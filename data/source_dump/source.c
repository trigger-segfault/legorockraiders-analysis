#include "datatypes.h"
#include "globals_unfiltered.h"
#include "source.h"



void __cdecl lego::front::Advisor_Initialise(char *rootPath,Camera *cameraMain,Viewport *viewMain)
{
	globs::advisorGlobs.positionName[0] = "Advisor_Objective";
	globs::advisorGlobs.positionName[1] = "Advisor_ObjectiveAcheived";
	globs::advisorGlobs.positionName[2] = "Advisor_ObjectiveFailed";
	globs::advisorGlobs.positionName[3] = "Advisor_IconPoint_Normal";
	globs::advisorGlobs.positionName[4] = "Advisor_IconPoint_BackButton";
	globs::advisorGlobs.positionName[5] = "Advisor_IconPoint_TopButtons";
	globs::advisorGlobs.positionName[6] = "Advisor_PanelPoint_RadarToggle";
	globs::advisorGlobs.positionName[7] = "Advisor_PanelPoint_RadarTaggedObjectView";
	globs::advisorGlobs.positionName[8] = "Advisor_PanelPoint_RadarZoomIn";
	globs::advisorGlobs.positionName[9] = "Advisor_PanelPoint_RadarZoomOut";
	globs::advisorGlobs.positionName[10] = "Advisor_PanelPoint_RadarMapView";
	globs::advisorGlobs.positionName[11] = "Advisor_PanelPoint_InfoDockGoto";
	globs::advisorGlobs.positionName[12] = "Advisor_PanelPoint_InfoDockClose";
	globs::advisorGlobs.positionName[13] = "Advisor_PanelPoint_TopPanelInfo";
	globs::advisorGlobs.positionName[14] = "Advisor_PanelPoint_TopPanelOptions";
	globs::advisorGlobs.positionName[15] = "Advisor_PanelPoint_TopPanelPriorities";
	globs::advisorGlobs.positionName[16] = "Advisor_PanelPoint_TopPanelCallToArms";
	globs::advisorGlobs.positionName[17] = "Advisor_PanelPoint_TopPanelGoBack";
	globs::advisorGlobs.positionName[18] = "Advisor_PanelPoint_ControlZoomIn";
	globs::advisorGlobs.positionName[19] = "Advisor_PanelPoint_ControlZoomOut";
	globs::advisorGlobs.positionName[20] = "Advisor_TalkInGame";
	globs::advisorGlobs.animName[0] = "Advisor_Anim_PointToMap";
	globs::advisorGlobs.animName[1] = "Advisor_Anim_Point_N";
	globs::advisorGlobs.animName[2] = "Advisor_Anim_Point_NE";
	globs::advisorGlobs.animName[3] = "Advisor_Anim_Point_E";
	globs::advisorGlobs.animName[4] = "Advisor_Anim_Point_SE";
	globs::advisorGlobs.animName[5] = "Advisor_Anim_Point_S";
	globs::advisorGlobs.animName[6] = "Advisor_Anim_Point_SW";
	globs::advisorGlobs.animName[7] = "Advisor_Anim_Point_W";
	globs::advisorGlobs.animName[8] = "Advisor_Anim_Point_NW";
	globs::advisorGlobs.animName[9] = "Advisor_Anim_Point_Up";
	globs::advisorGlobs.animName[10] = "Advisor_Anim_Talk_Top";
	globs::advisorGlobs.cameraCont = cameraMain->contCam;
	globs::advisorGlobs.viewMain = viewMain;
	globs::advisorGlobs.lightCont =
			 res::Container_MakeLight(cameraMain->contCam,D3DRMLIGHT_DIRECTIONAL,1.0,1.0,1.0);
	res::Container_SetOrientation
						(globs::advisorGlobs.lightCont,cameraMain->contCam,0.0,0.0,-1.0,0.0,1.0,0.0);
	res::Container_Hide(globs::advisorGlobs.lightCont,TRUE);
	globs::advisorGlobs.flags = ADVISORSTATE_NONE;
	return;
}



void __cdecl lego::front::Advisor_Cleanup(void)
{
	Container *cont;
	
	cont = globs::advisorGlobs.advisorAnims
				 [globs::advisorGlobs.advisorPositions[globs::advisorGlobs.currentType].animType].resData;
	if (cont != NULL) {
		res::Container_Hide(cont,1);
	}
	globs::advisorGlobs.flags &= ~ADVISORSTATE_UNK_1;
	res::Container_Hide(globs::advisorGlobs.lightCont,1);
	return;
}



void __cdecl lego::front::Advisor_InitViewport(float param_unused)
{
	lego::view::Viewport_GetBackClip(globs::advisorGlobs.viewMain);
	lego::view::Viewport_GetFrontClip(globs::advisorGlobs.viewMain);
	globs::advisorGlobs.position_Z = 0.96;
	return;
}



// sqrt(((a.x - b.x)*(a.x - b.x)) + ((a.y - b.y)*(a.y - b.y)))

float10 __cdecl lego::math::Maths_Vector2DDistance(Point2F *a,Point2F *b)
{
	float10 fVar1;
	float10 fVar2;
	
	fVar1 = (float10)a->y - (float10)b->y;
	fVar2 = (float10)a->x - (float10)b->x;
	return SQRT(fVar2 * fVar2 + fVar1 * (float10)(float)fVar1);
}



// <advisorType><animFileName>,<loopStart(seconds)>,<loopEnd(seconds)>
// NOTE last two parameters can be set to any value if the anim is not made to loop e.g. 0,0
// 
// Advisor_Anim_Point_Up  Mini-Figures\Captain\NEW_Captain_Point_CALL_T_ARMS,1.04,4.0
// Advisor_Anim_Talk_Top  Mini-Figures\Captain\NEW_Captain_Point_QTalk,1.04,2.4

void __cdecl lego::front::Advisor_LoadAdvisorAnims(CFGProperty *root,char *keyRoot)
{
	char *pcVar1;
	Container *cont;
	char **ppcVar2;
	AdvisorAnimData *pAVar3;
	float10 fVar4;
	char *stringParts [3];
	char buffer [64];
	
	pAVar3 = globs::advisorGlobs.advisorAnims;
	ppcVar2 = globs::advisorGlobs.animName;
	do {
		pcVar1 = cfg::CFG_JoinPath(keyRoot,"Advisor",*ppcVar2,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == NULL) {
			if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
				std::sprintf(buffer,"!%s",*ppcVar2);
				pcVar1 = cfg::CFG_JoinPath(keyRoot,"Advisor",*ppcVar2,0);
				pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			}
			if (pcVar1 != NULL) goto LAB_004012f0;
		}
		else {
LAB_004012f0:
			util::Util_Tokenise(pcVar1,stringParts,",");
			cont = res::Container_Load(globs::advisorGlobs.cameraCont,stringParts[0],"LWS",1);
			pAVar3->resData = cont;
			if (cont != NULL) {
				res::Container_SetOrientation(cont,globs::advisorGlobs.cameraCont,0.0,0.0,1.0,0.0,1.0,0.0);
				res::Container_Hide(pAVar3->resData,1);
			}
			fVar4 = std::atof(stringParts[1]);
			pAVar3->loopStartTime = (float)(fVar4 * (float10)25.0);
			fVar4 = std::atof(stringParts[2]);
			pAVar3->loopEndTime = (float)(fVar4 * (float10)25.0);
		}
		ppcVar2 = ppcVar2 + 1;
		pAVar3 = pAVar3 + 1;
		if ((char **)((int)globs::advisorGlobs.animName + 0x2b) < ppcVar2) {
			return;
		}
	} while( true );
}



BOOL __cdecl lego::front::Advisor_GetAdvisorType(char *advisorName,AdvisorType *out_advisorType)
{
	int iVar1;
	Advisor_Globs *pAVar2;
	int index;
	
	index = 0;
	pAVar2 = &globs::advisorGlobs;
	do {
		iVar1 = std::_stricmp(pAVar2->positionName[0],advisorName);
		if (iVar1 == 0) {
			*out_advisorType = index;
			return 1;
		}
		pAVar2 = (Advisor_Globs *)(pAVar2->positionName + 1);
						// index++
		index += ADVISOR_OBJECTIVEACHIEVED;
						// index < ADVISOR__COUNT (21)
	} while (pAVar2 < (Advisor_Globs *)globs::advisorGlobs.advisorPositions);
	return 0;
}



// out_vector = { (a.y * b.z) - (a.z * b.y),
//                (a.z * b.x) - (a.x * b.z),
//                (a.x * b.y) - (a.y * b.x) }

Vector3F * __cdecl
lego::math::Maths_Vector3DCrossProduct(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = b->z * a->y - a->z * b->y;
	out_vector->y = a->z * b->x - b->z * a->x;
	out_vector->z = b->y * a->x - a->y * b->x;
	return out_vector;
}



BOOL __cdecl lego::front::Advisor_GetAnimType(char *animName,AdvisorAnimType *out_animType)
{
	int iVar1;
	AdvisorAnimData *pAVar2;
	int index;
	
	index = 0;
	pAVar2 = (AdvisorAnimData *)globs::advisorGlobs.animName;
	do {
		iVar1 = std::_stricmp((char *)pAVar2->resData,animName);
		if (iVar1 == 0) {
			*out_animType = index;
			return 1;
		}
		pAVar2 = (AdvisorAnimData *)&pAVar2->loopStartTime;
						// index++
		index += ADVISORANIM_POINT_N;
						// index < ADVISORANIM__COUNT (11)
	} while (pAVar2 < globs::advisorGlobs.advisorAnims);
	return 0;
}



// out_vector = a + b

Vector3F * __cdecl lego::math::Maths_Vector3DAdd(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = b->x + a->x;
	out_vector->y = a->y + b->y;
	out_vector->z = a->z + b->z;
	return out_vector;
}



// <positionType><animName>,<textName|NULL>,<sfxName|SFX_NULL>,<x(float)>,<y(float)>,<panelName|NULL>
// 
// Advisor_IconPoint_TopButtons    Advisor_Anim_Point_NE,NULL,SFX_NULL,-25,25,NULL
// Advisor_PanelPoint_RadarToggle  Advisor_Anim_Point_N,NULL,SFX_NULL,220,65,Panel_Radar

void __cdecl
lego::front::Advisor_LoadAdvisorPositions
					(CFGProperty *root,char *keyRoot,int screenWidth,int screenHeight)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	int iVar2;
	float10 fVar3;
	PanelType panelType;
	TextType textType;
	AdvisorAnimType animType;
	float x;
	float y;
	int sfxIndex;
	AdvisorType advisorIndex;
	char *stringParts [6];
	char advisorKeyPath [128];
	
	std::sprintf(advisorKeyPath,"AdvisorPositions%ix%i",screenWidth,screenHeight);
	keyPath = cfg::CFG_JoinPath(keyRoot,advisorKeyPath,0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
						// TEXT__COUNT (26)  treated as NULL
		textType = TEXT__COUNT;
						// PANEL__COUNT (12)  treated as NULL
		panelType = PANEL__COUNT;
		BVar1 = Advisor_GetAdvisorType(prop->key,&advisorIndex);
		if (BVar1 != 0) {
			util::Util_Tokenise(prop->value,stringParts,",");
			BVar1 = Advisor_GetAnimType(stringParts[0],&animType);
			if ((BVar1 != 0) &&
				 (((iVar2 = std::_stricmp("NULL",stringParts[1]), iVar2 == 0 ||
					 (BVar1 = Text_GetTextType(stringParts[1],&textType), BVar1 != 0)) &&
					(BVar1 = snd::SFX_GetType(stringParts[2],(SFXType *)&sfxIndex), BVar1 != 0)))) {
				fVar3 = std::atof(stringParts[3]);
				x = (float)fVar3;
				fVar3 = std::atof(stringParts[4]);
				y = (float)fVar3;
				iVar2 = std::_stricmp("NULL",stringParts[5]);
				if ((iVar2 == 0) || (BVar1 = Panel_GetPanelType(stringParts[5],&panelType), BVar1 != 0)) {
					Advisor_AddAdvisorPosition(advisorIndex,animType,textType,sfxIndex,panelType,x,y);
				}
			}
		}
	}
	return;
}



// out_vector = a - b

Vector3F * __cdecl lego::math::Maths_Vector3DSubtract(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = a->x - b->x;
	out_vector->y = a->y - b->y;
	out_vector->z = a->z - b->z;
	return out_vector;
}



// out_vector = a * scalar

Vector3F * __cdecl lego::math::Maths_Vector3DScale(Vector3F *out_vector,Vector3F *a,float scalar)
{
	out_vector->x = scalar * a->x;
	out_vector->y = a->y * scalar;
	out_vector->z = a->z * scalar;
	return out_vector;
}



// ref_vector = ref_vector * (1.0 / modulus(ref_vector))
// REFERENCE: modulus(ref_vector) -> sqrt(dot_product(ref_vector, ref_vector))

Vector3F * __cdecl lego::math::Maths_Vector3DNormalize(Vector3F *ref_vector)
{
	float fVar1;
	
						// Vector3_Modulus (without 1.0 / _)
	fVar1 = 1.0 / SQRT(ref_vector->x * ref_vector->x +
										 ref_vector->z * ref_vector->z + ref_vector->y * ref_vector->y);
	ref_vector->x = fVar1 * ref_vector->x;
	ref_vector->y = fVar1 * ref_vector->y;
	ref_vector->z = fVar1 * ref_vector->z;
	return ref_vector;
}



void __cdecl
lego::front::Advisor_AddAdvisorPosition
					(AdvisorType advisorType,AdvisorAnimType animType,TextType textType,int sfxIndex,
					PanelType panelType,float x,float y)
{
	AdvisorPositionFlags *pAVar1;
	
	globs::advisorGlobs.advisorPositions[advisorType].flags = ADVISORPOS_DEFAULT;
	globs::advisorGlobs.advisorPositions[advisorType].animType = animType;
	globs::advisorGlobs.advisorPositions[advisorType].textType = textType;
	globs::advisorGlobs.advisorPositions[advisorType].sfxIndex = sfxIndex;
	globs::advisorGlobs.advisorPositions[advisorType].point1.x = x;
	globs::advisorGlobs.advisorPositions[advisorType].point1.y = y;
	globs::advisorGlobs.advisorPositions[advisorType].point2.x = x;
	globs::advisorGlobs.advisorPositions[advisorType].point2.y = y;
	globs::advisorGlobs.advisorPositions[advisorType].panelType = panelType;
						// NULL panel
	if (panelType == PANEL__COUNT) {
		pAVar1 = &globs::advisorGlobs.advisorPositions[advisorType].flags;
		*pAVar1 = *pAVar1 | ADVISORPOS_NOPANEL;
	}
						// non-NULL text
	if (textType != TEXT__COUNT) {
		pAVar1 = &globs::advisorGlobs.advisorPositions[advisorType].flags;
		*pAVar1 = *pAVar1 | ADVISORPOS_HASTEXT;
	}
	return;
}



void __cdecl
lego::front::Advisor_SetParameters(AdvisorType advisorType,PanelType panelType,float x1,float y1)
{
	AdvisorPositionFlags AVar1;
	
	globs::advisorGlobs.advisorPositions[advisorType].point1.x = x1;
	globs::advisorGlobs.advisorPositions[advisorType].point1.y = y1;
	globs::advisorGlobs.advisorPositions[advisorType].panelType = panelType;
	AVar1 = globs::advisorGlobs.advisorPositions[advisorType].flags;
						// NULL panel
	if (panelType == PANEL__COUNT) {
		globs::advisorGlobs.advisorPositions[advisorType].flags = AVar1 | ADVISORPOS_NOPANEL;
		return;
	}
	globs::advisorGlobs.advisorPositions[advisorType].flags = AVar1 & ~ADVISORPOS_NOPANEL;
	return;
}



void __cdecl lego::front::Advisor_GetPoint2(AdvisorType advisorType,float *out_x2,float *out_y2)
{
	*out_x2 = globs::advisorGlobs.advisorPositions[advisorType].point2.x;
	*out_y2 = globs::advisorGlobs.advisorPositions[advisorType].point2.y;
	return;
}



BOOL __cdecl lego::front::Advisor_SetCurrentAdvisor(AdvisorType advisorType,BOOL setFlag2)
{
	if ((((globs::advisorGlobs.advisorPositions[advisorType].flags & ADVISORPOS_DEFAULT) !=
				ADVISORPOS_NONE) && (globs::legoGlobs.viewMode != VIEW_FIRSTPERSON)) &&
		 ((globs::advisorGlobs.flags & ADVISORSTATE_UNK_1) == ADVISORSTATE_NONE)) {
		globs::advisorGlobs.currentType = advisorType;
		Advisor_SetCurrentSound(advisorType);
		if (setFlag2 != 0) {
			globs::advisorGlobs.flags =
					 globs::advisorGlobs.flags | (ADVISORSTATE_UNK_1|ADVISORSTATE_UNK_2);
			return 1;
		}
		globs::advisorGlobs.flags = globs::advisorGlobs.flags & ~ADVISORSTATE_UNK_2 | ADVISORSTATE_UNK_1
		;
		return 1;
	}
	return 0;
}



void __cdecl lego::front::Advisor_SetCurrentSound(AdvisorType advisorType)
{
	Container *cont;
	
	cont = globs::advisorGlobs.advisorAnims
				 [globs::advisorGlobs.advisorPositions[advisorType].animType].resData;
	if (cont != NULL) {
		res::Container_Hide(cont,0);
		res::Container_SetAnimationTime(cont,0.0);
		snd::SFX_Sample_Random_Play_OrAddToQueue
							(globs::advisorGlobs.advisorPositions[advisorType].sfxIndex,0);
		snd::SFX_Sample_AddToQueue(SFX_CAPTAINSLIDE,SOUND_ONCE);
	}
	return;
}



void __cdecl lego::front::Advisor_Update(float elapsed)
{
	Container *cont;
	BOOL BVar1;
	AdvisorType advisorType;
	
	advisorType = globs::advisorGlobs.currentType;
	cont = globs::advisorGlobs.advisorAnims
				 [globs::advisorGlobs.advisorPositions[globs::advisorGlobs.currentType].animType].resData;
	if (cont != NULL) {
		if (((globs::advisorGlobs.flags & ADVISORSTATE_UNK_1) != ADVISORSTATE_NONE) &&
			 (globs::legoGlobs.viewMode != VIEW_FIRSTPERSON)) {
			if ((globs::advisorGlobs.advisorPositions[globs::advisorGlobs.currentType].flags &
					ADVISORPOS_HASTEXT) != ADVISORPOS_NONE) {
				Text_DisplayMessage(globs::advisorGlobs.advisorPositions[globs::advisorGlobs.currentType].
														textType,TRUE,FALSE);
			}
			res::Container_Hide(cont,FALSE);
			res::Container_Hide(globs::advisorGlobs.lightCont,FALSE);
			res::Container_Light_SetEnableContainer(globs::advisorGlobs.lightCont,cont);
			Advisor_ViewportTransform(advisorType);
			BVar1 = Advisor_UpdateAnimation
												(globs::advisorGlobs.advisorPositions[advisorType].animType,elapsed);
			if (BVar1 != 0) {
				return;
			}
			globs::advisorGlobs.flags &= ~ADVISORSTATE_UNK_1;
		}
		res::Container_Hide(cont,TRUE);
	}
	res::Container_Hide(globs::advisorGlobs.lightCont,TRUE);
	return;
}



BOOL __cdecl lego::front::Advisor_UpdateAnimation(AdvisorAnimType animType,float elapsed)
{
	Container *cont;
	float10 fVar1;
	
	cont = globs::advisorGlobs.advisorAnims[animType].resData;
	fVar1 = res::Container_MoveAnimation(cont,elapsed);
	if (((byte)globs::advisorGlobs.flags & ADVISORSTATE_UNK_2) == 0) {
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) == 0)
		{
			return 0;
		}
	}
	else {
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) == 0)
		{
			res::Container_SetAnimationTime
								(cont,(float)((float10)globs::advisorGlobs.advisorAnims[animType].loopStartTime +
														 fVar1));
			return TRUE;
		}
		fVar1 = res::Container_GetAnimationTime(cont);
		if ((float10)globs::advisorGlobs.advisorAnims[animType].loopEndTime <= fVar1) {
			res::Container_SetAnimationTime
								(cont,(float)((fVar1 - (float10)globs::advisorGlobs.advisorAnims[animType].
																								loopEndTime) +
														 (float10)globs::advisorGlobs.advisorAnims[animType].loopStartTime));
			return TRUE;
		}
	}
	return TRUE;
}



void __cdecl lego::front::Advisor_ClearFlag2(void)
{
	globs::advisorGlobs.flags = globs::advisorGlobs.flags & ~ADVISORSTATE_UNK_2;
	return;
}



void __cdecl lego::front::Advisor_ViewportTransform(AdvisorType advisorType)
{
	Container *cont;
	AdvisorType AVar1;
	float y;
	Vector3F vector;
	Vector4F transform4d;
	
	AVar1 = advisorType;
	cont = globs::advisorGlobs.advisorAnims
				 [globs::advisorGlobs.advisorPositions[advisorType].animType].resData;
	if ((globs::advisorGlobs.advisorPositions[advisorType].flags & ADVISORPOS_NOPANEL) ==
			ADVISORPOS_NONE) {
						// output -> x, y (get panel position?)
		Panel_GetXYField3(globs::advisorGlobs.advisorPositions[advisorType].panelType,
											(float *)&advisorType,&y);
	}
	else {
		advisorType = ADVISOR_OBJECTIVE;
		y = 0.0;
	}
	transform4d.x = globs::advisorGlobs.advisorPositions[AVar1].point1.x + (float)advisorType;
	transform4d.z = globs::advisorGlobs.position_Z;
	transform4d.y = globs::advisorGlobs.advisorPositions[AVar1].point1.y + y;
	transform4d.w = 1.0;
	lego::view::Viewport_InverseTransform(globs::advisorGlobs.viewMain,&vector,&transform4d);
	res::Container_SetPosition(cont,NULL,vector.x,vector.y,vector.z);
	return;
}



ProgrammerMode __cdecl lego::main::Main_ProgrammerMode(void)
{
	return globs::mainGlobs.programmerLevel;
}



char * __cdecl lego::main::Main_GetStartLevel(void)
{
	return (char *)(-(uint)((globs::mainGlobs.flags & CMD_STARTLEVEL) != CMD_NONE) & 0x506f8c);
}



BOOL __cdecl lego::front::Advisor_GetFlag1(void)
{
	return globs::advisorGlobs.flags & ADVISORSTATE_UNK_1;
}



int __cdecl lego::main::appWidth(void)
{
	return globs::mainGlobs.appWidth;
}



int __cdecl lego::main::appHeight(void)
{
	return globs::mainGlobs.appHeight;
}



uint __cdecl lego::image::Font_GetStringWidth(Font *font,char *msg,...)
{
	Font_VGetStringInfo(font,(uint *)&font,NULL,msg,&stack0x0000000c);
	return (uint)font;
}



void __cdecl
lego::image::Font_GetStringInfo(Font *font,uint *out_width,uint *out_lineCount,char *msg,...)
{
	Font_VGetStringInfo(font,out_width,out_lineCount,msg,&stack0x00000014);
	return;
}



BOOL __cdecl lego::ai::AIPriority_GetType(char *aiPriorityName,AIPriorityType *out_priorityType)
{
	int iVar1;
	char **ppcVar2;
	AIPriorityType AVar3;
	
	AVar3 = AI_PRIORITY_CRYSTAL;
	ppcVar2 = globs::aiGlobs.priorityName;
	do {
		iVar1 = std::_stricmp(aiPriorityName,*ppcVar2);
		if (iVar1 == 0) {
			*out_priorityType = AVar3;
			return TRUE;
		}
		ppcVar2 = ppcVar2 + 1;
		AVar3 += AI_PRIORITY_ORE;
	} while (ppcVar2 < globs::aiGlobs.priorityValues);
	return 0;
}



void __cdecl lego::ai::AITask_Initialise(void)
{
	int iVar1;
	AI_Globs *pAVar2;
	uint *puVar3;
	
	pAVar2 = &globs::aiGlobs;
	for (iVar1 = 0xc; iVar1 != 0; iVar1 += -1) {
		pAVar2->listSet[0] = NULL;
		pAVar2 = (AI_Globs *)(pAVar2->listSet + 1);
	}
	globs::aiGlobs.aitaskName[0] = "AITask_Type_Goto";
	globs::aiGlobs.aitaskName[1] = "AITask_Type_Follow";
	globs::aiGlobs.aitaskName[2] = "AITask_Type_FollowAttack";
	globs::aiGlobs.aitaskName[3] = "AITask_Type_Collect";
	globs::aiGlobs.aitaskName[4] = "AITask_Type_Gather";
	globs::aiGlobs.aitaskName[12] = "AITask_Type_Clear";
	globs::aiGlobs.aitaskName[5] = "AITask_Type_Deposit";
	globs::aiGlobs.aitaskName[6] = "AITask_Type_Dump";
	globs::aiGlobs.aitaskName[7] = "AITask_Type_Request";
	globs::aiGlobs.aitaskName[10] = "AITask_Type_Repair";
	globs::aiGlobs.aitaskName[8] = "AITask_Type_Dig";
	globs::aiGlobs.aitaskName[9] = "AITask_Type_Dynamite";
	globs::aiGlobs.aitaskName[11] = "AITask_Type_Reinforce";
	globs::aiGlobs.aitaskName[13] = "AITask_Type_Wait";
	globs::aiGlobs.aitaskName[14] = "AITask_Type_AnimationWait";
	globs::aiGlobs.aitaskName[15] = "AITask_Type_ElecFence";
	globs::aiGlobs.aitaskName[16] = "AITask_Type_Eat";
	globs::aiGlobs.aitaskName[17] = "AITask_Type_GotoEat";
	globs::aiGlobs.aitaskName[18] = "AITask_Type_FindDriver";
	globs::aiGlobs.aitaskName[19] = "AITask_Type_GetTool";
	globs::aiGlobs.aitaskName[20] = "AITask_Type_BirdScarer";
	globs::aiGlobs.aitaskName[21] = "AITask_Type_Upgrade";
	globs::aiGlobs.aitaskName[22] = "AITask_Type_BuildPath";
	globs::aiGlobs.aitaskName[23] = "AITask_Type_Train";
	globs::aiGlobs.aitaskName[24] = "AITask_Type_Depart";
	globs::aiGlobs.aitaskName[25] = "AITask_Type_AttackPath";
	globs::aiGlobs.aitaskName[26] = "AITask_Type_AttackRockMonster";
	globs::aiGlobs.aitaskName[27] = "AITask_Type_Recharge";
	globs::aiGlobs.aitaskName[28] = "AITask_Type_Dock";
	globs::aiGlobs.aitaskName[29] = "AITask_Type_AttackObject";
	globs::aiGlobs.aitaskName[30] = "AITask_Type_FindLoad";
	globs::aiGlobs.priorityName[0] = "AI_Priority_Crystal";
	globs::aiGlobs.priorityName[1] = "AI_Priority_Ore";
	globs::aiGlobs.priorityName[2] = "AI_Priority_DefaultCollect";
	globs::aiGlobs.priorityName[3] = "AI_Priority_Destruction";
	globs::aiGlobs.priorityName[4] = "AI_Priority_Construction";
	globs::aiGlobs.priorityName[5] = "AI_Priority_Request";
	globs::aiGlobs.priorityName[6] = "AI_Priority_Reinforce";
	globs::aiGlobs.priorityName[7] = "AI_Priority_Repair";
	globs::aiGlobs.priorityName[8] = "AI_Priority_Clearing";
	globs::aiGlobs.priorityName[9] = "AI_Priority_Storage";
	globs::aiGlobs.priorityName[10] = "AI_Priority_Refining";
	globs::aiGlobs.priorityName[11] = "AI_Priority_HealthLow";
	globs::aiGlobs.priorityName[12] = "AI_Priority_GetIn";
	globs::aiGlobs.priorityName[13] = "AI_Priority_Upgrade";
	globs::aiGlobs.priorityName[14] = "AI_Priority_BuildPath";
	globs::aiGlobs.priorityName[15] = "AI_Priority_AttackRockMonster";
	globs::aiGlobs.priorityName[16] = "AI_Priority_Barrier";
	globs::aiGlobs.priorityName[17] = "AI_Priority_FindLoad";
	globs::aiGlobs.priorityName[18] = "AI_Priority_Recharge";
	globs::aiGlobs.priorityName[19] = "AI_Priority_UpgradeBuilding";
	globs::aiGlobs.priorityName[20] = "AI_Priority_Gather";
	globs::aiGlobs.priorityName[21] = "AI_Priority_Steal";
	globs::aiGlobs.priorityName[22] = "AI_Priority_Punch";
	globs::aiGlobs.priorityName[23] = "AI_Priority_Depart";
	globs::aiGlobs.priorityName[24] = "AI_Priority_AttackPath";
	globs::aiGlobs.priorityName[26] = "AI_Priority_Congregate";
	globs::aiGlobs.priorityName[25] = "AI_Priority_AttackObject";
	puVar3 = globs::aiGlobs.priorityValues;
	for (iVar1 = 0x1b; iVar1 != 0; iVar1 += -1) {
		*puVar3 = 0x31;
		puVar3 = puVar3 + 1;
	}
	globs::aiGlobs.freeList = NULL;
	globs::aiGlobs.listCount = 0;
	globs::aiGlobs.priorityValues[0] = 0x37;
	globs::aiGlobs.priorityValues[3] = 0x28;
	globs::aiGlobs.priorityValues[4] = 0x3c;
	globs::aiGlobs.priorityValues[5] = 0x14;
	globs::aiGlobs.priorityValues[6] = 0x46;
	globs::aiGlobs.priorityValues[8] = 0x14;
	globs::aiGlobs.priorityValues[9] = 5;
	globs::aiGlobs.priorityValues[10] = 0xf;
	globs::aiGlobs.priorityValues[15] = 0x38;
	globs::aiGlobs.priorityValues[19] = 99;
	globs::aiGlobs.priorityValues[20] = 0x31;
	globs::aiGlobs.priorityValues[21] = 0x5a;
	globs::aiGlobs.priorityValues[22] = 0x31;
	globs::aiGlobs.priorityValues[23] = 0;
	globs::aiGlobs.priorityValues[24] = 0x14;
	globs::aiGlobs.priorityValues[25] = 0x1e;
	globs::aiGlobs.priorityValues[26] = 99;
	globs::aiGlobs.flags = 1;
	return;
}



void __cdecl
lego::ai::AITask_FUN_00401f40(AITaskType taskType,LiveObject *liveObj,Point2I *opt_position)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globs::aiGlobs.AITaskUnkPtr;
	if (globs::aiGlobs.AITaskUnkPtr != NULL) {
		do {
			if (pAVar2->taskType == taskType) {
				if ((liveObj != NULL) && (liveObj == pAVar2->object_10)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x10000;
				}
				if (((opt_position != NULL) && (opt_position->x == (pAVar2->blockPos).x)) &&
					 (opt_position->y == (pAVar2->blockPos).y)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x10000;
				}
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != NULL);
	}
	return;
}



void __cdecl lego::ai::AITask_SetPriorityType(AITaskData *aiTask,AIPriorityType priorityType)
{
	uint uVar1;
	
	if ((aiTask->flags_5c & 0x30000) == 0) {
		uVar1 = globs::aiGlobs.priorityValues[priorityType];
		aiTask->priorityType = priorityType;
		aiTask->priorityValue = uVar1;
		return;
	}
	aiTask->priorityValue = 99;
	aiTask->priorityType = priorityType;
	return;
}



void __cdecl lego::ai::AITask_Game_SetAITaskValue2(int index,uint aiTaskValue)
{
	globs::aiGlobs.priorityValues[index] = aiTaskValue;
	return;
}



void __cdecl lego::ai::AITask_Game_SetIsPriorityDisabled(int priorityIndex,BOOL isDisabled)
{
	globs::aiGlobs.disabledPriorities[priorityIndex] = isDisabled;
	return;
}



BOOL __cdecl lego::ai::AITask_Game_IsPriorityDisabled(int priorityIndex)
{
	return globs::aiGlobs.disabledPriorities[priorityIndex];
}



void __cdecl lego::ai::AITask_Shutdown(void)
{
	AI_Globs *pAVar1;
	
	pAVar1 = &globs::aiGlobs;
	do {
		if (pAVar1->listSet[0] != NULL) {
			std::free(pAVar1->listSet[0]);
		}
		pAVar1 = (AI_Globs *)(pAVar1->listSet + 1);
	} while (pAVar1 < (AI_Globs *)&globs::aiGlobs.freeList);
	globs::aiGlobs.freeList = NULL;
	globs::aiGlobs.flags = 0;
	return;
}



void __cdecl lego::ai::AITask_Reset_Or_ClearFlag2(BOOL unsetFlag2)
{
	int iVar1;
	uint (*paauVar2) [15] [16];
	BOOL *pBVar3;
	
	if (unsetFlag2 != 0) {
		globs::aiGlobs.flags = globs::aiGlobs.flags & 0xfffffffd;
		return;
	}
	AITask_DoUnkCallbacks(AITask_RemoveCallback,NULL);
	globs::aiGlobs.flags |= 2;
	globs::aiGlobs.AITaskUnkPtr = NULL;
	globs::aiGlobs.AITaskDataNext = NULL;
	paauVar2 = globs::aiGlobs.requestObjCounts;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 += -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	pBVar3 = globs::aiGlobs.disabledPriorities;
	for (iVar1 = 0x1b; iVar1 != 0; iVar1 += -1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	return;
}



void __cdecl lego::ai::AITask_Game_SetNoGather(BOOL noGather)
{
	AITaskData *pAVar1;
	
	if (noGather == 0) {
		AITask_DoGather_Count(0);
	}
	pAVar1 = AITask_Create(AITASK_DEPART);
	AITask_SetPriorityType(pAVar1,AI_PRIORITY_DEPART);
	pAVar1->flags_5c = pAVar1->flags_5c | 0x40;
	pAVar1->next = globs::aiGlobs.AITaskDataNext;
	globs::aiGlobs.AITaskDataNext = pAVar1;
	pAVar1 = AITask_Create(AITASK_RECHARGE);
	AITask_InitTask_1(pAVar1,AI_PRIORITY_CRYSTAL);
	pAVar1->flags_5c = pAVar1->flags_5c & 0xffffffef | 0x440;
	return;
}



BOOL __cdecl lego::ai::AITask_RemoveCallback(AITaskData *aiTask)
{
	AITask_Remove(aiTask,TRUE);
	return 0;
}



void __cdecl lego::util::free2(undefined *param_1)
{
	std::free(param_1);
	return;
}



void __cdecl lego::ai::AITask_Update(float elapsedGame)
{
	float fVar1;
	AITaskData *pAVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = globs::aiGlobs.priorityValues[1];
	if ((int)globs::aiGlobs.priorityValues[1] <= (int)globs::aiGlobs.priorityValues[0]) {
		uVar4 = globs::aiGlobs.priorityValues[0];
	}
	uVar3 = globs::aiGlobs.priorityValues[4];
	if (((int)globs::aiGlobs.priorityValues[4] < (int)uVar4) &&
		 (uVar3 = globs::aiGlobs.priorityValues[0],
		 (int)globs::aiGlobs.priorityValues[0] < (int)globs::aiGlobs.priorityValues[1])) {
		uVar3 = globs::aiGlobs.priorityValues[1];
	}
	globs::aiGlobs.priorityValues[16] = uVar3 + 1;
	if ((globs::aiGlobs.flags & 0x80000000) == 0) {
		AITask_DoUnkCallbacks(AITask_Callback_FUN_00404180,(LiveObject *)&elapsedGame);
		for (pAVar2 = globs::aiGlobs.AITaskUnkPtr; pAVar2 != NULL; pAVar2 = pAVar2->next) {
			if (((pAVar2->taskType == AITASK_REPAIR) && ((pAVar2->flags_5c & 0x200000) == 0)) &&
				 ((fVar1 = pAVar2->object_10->health,
					(ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0 ||
					(100.0 <= pAVar2->object_10->health)))) {
				pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
			}
		}
		AITask_FUN_00402240(&globs::aiGlobs.AITaskUnkPtr);
		AITask_FUN_00402240(&globs::aiGlobs.AITaskDataNext);
		globs::aiGlobs.liveObjsCount_1 = 0;
		globs::aiGlobs.liveObjsCount_2 = 0;
		game::Search_LiveObjects_SkipIgnoreMes(AITask_LiveObject_Callback_DoAITask,&elapsedGame);
		AITask_FUN_00405b40();
		AITask_FUN_00405880();
	}
	return;
}



void __cdecl lego::ai::AITask_FUN_00402240(AITaskData **ref_aiTask)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	uint uVar4;
	bool bVar5;
	AITaskData **ppAVar6;
	BOOL BVar7;
	int iVar8;
	int iVar9;
	int iVar10;
	AITaskData *pAVar11;
	uint number;
	int *piVar12;
	AITaskData *local_4dc;
	int local_4d0 [5];
	undefined4 local_4bc;
	undefined4 local_4b8;
	undefined4 local_4b4;
	AITaskData *local_4b0 [300];
	
	local_4dc = NULL;
	pAVar2 = *ref_aiTask;
	pAVar11 = NULL;
	while (pAVar3 = pAVar11, pAVar11 = pAVar2, pAVar11 != NULL) {
		pAVar2 = pAVar11->next;
		if ((*(byte *)&pAVar11->flags_5c & 0x20) != 0) {
			if (pAVar3 == NULL) {
				*ref_aiTask = pAVar2;
				AITask_Remove(pAVar11,0);
				pAVar11 = pAVar3;
			}
			else {
				pAVar3->next = pAVar2;
				AITask_Remove(pAVar11,0);
				pAVar11 = pAVar3;
			}
		}
	}
	number = 0;
	pAVar2 = local_4dc;
	if (*ref_aiTask != NULL) {
		ppAVar6 = local_4b0;
		pAVar11 = *ref_aiTask;
		do {
			pAVar3 = pAVar11->next;
			pAVar2 = pAVar11;
			if (number == 300) break;
			*ppAVar6 = pAVar11;
			ppAVar6 = ppAVar6 + 1;
			number += 1;
			if ((globs::aiGlobs.disabledPriorities[pAVar11->priorityType] == 0) ||
				 ((pAVar11->flags_5c & 0x10000) != 0)) {
				uVar4 = pAVar11->flags_5c;
				pAVar11->flags_5c = uVar4 & 0xfff7ffff;
				if ((uVar4 & 0x30000) == 0) {
					pAVar11->priorityValue = globs::aiGlobs.priorityValues[pAVar11->priorityType];
				}
				else {
					pAVar11->priorityValue = 99;
				}
			}
			else {
				pAVar11->flags_5c = pAVar11->flags_5c | 0x80000;
			}
			if (pAVar11->taskType == AITASK_DIG) {
				if ((*(byte *)&pAVar11->flags_5c & 8) == 0) {
					BVar7 = game::Level_Block_IsNotWallOrGround((pAVar11->blockPos).x,(pAVar11->blockPos).y);
					if (BVar7 != 0) {
						pAVar11->priorityValue = 0;
					}
				}
				else {
					local_4d0[0] = 0;
					local_4d0[1] = 0;
					local_4d0[2] = 0;
					local_4b4 = 0;
					local_4d0[3] = 0xffffffff;
					local_4d0[4] = 0xffffffff;
					local_4bc = 0xffffffff;
					local_4b8 = 0xffffffff;
					bVar5 = false;
					piVar12 = local_4d0;
					iVar10 = 4;
					do {
						BVar7 = game::Level_Block_IsWall
															(*piVar12 + (pAVar11->blockPos).x,piVar12[1] + (pAVar11->blockPos).y);
						if (BVar7 != 0) {
							bVar5 = true;
						}
						piVar12 = piVar12 + 2;
						iVar10 += -1;
					} while (iVar10 != 0);
					if (bVar5) {
						if (pAVar11->priorityValue == 0) {
							pAVar11->float_18 = (float)&DAT_42c80000;
						}
					}
					else {
						pAVar11->priorityValue = 0;
					}
				}
			}
			pAVar11 = pAVar3;
			pAVar2 = local_4dc;
		} while (pAVar3 != NULL);
	}
	local_4dc = pAVar2;
	if (number != 0) {
		std::qsort(local_4b0,number,4,AITask_QSortCompare);
		iVar10 = number - 1;
		iVar9 = 0;
		if (iVar10 != 0) {
			ppAVar6 = local_4b0;
			iVar8 = iVar10;
			do {
				pAVar2 = *ppAVar6;
				ppAVar1 = ppAVar6 + 1;
				ppAVar6 = ppAVar6 + 1;
				iVar8 += -1;
				pAVar2->next = *ppAVar1;
				iVar9 = iVar10;
			} while (iVar8 != 0);
		}
		local_4b0[iVar9]->next = local_4dc;
		*ref_aiTask = local_4b0[0];
	}
	return;
}



void __cdecl lego::ai::AITask_DoDig_AtBlockPos(Point2I *blockPos,BOOL param_2,BOOL param_3)
{
	uint uVar1;
	LevelData *pLVar2;
	BOOL BVar3;
	AITaskData *aiTask;
	int iVar4;
	
	pLVar2 = lrr::Lego_GetLevel();
	BVar3 = game::Level_Block_IsImmovable(blockPos);
	if (BVar3 == 0) {
		BVar3 = game::Level_Block_IsLava(blockPos);
		if (BVar3 == 0) {
			BVar3 = game::Level_Block_IsSurveyed(blockPos->x,blockPos->y);
			if (BVar3 != 0) {
				aiTask = AITask_Create(AITASK_DIG);
				(aiTask->blockPos).x = blockPos->x;
				(aiTask->blockPos).y = blockPos->y;
				if (param_2 != 0) {
					aiTask->flags_5c = aiTask->flags_5c | 8;
				}
				AITask_UnkInitRouting_FUN_00402530(aiTask,1);
				AITask_InitTask_1(aiTask,AI_PRIORITY_DESTRUCTION);
				uVar1 = aiTask->flags_5c;
				aiTask->flags_5c = uVar1 | 0x80;
				if (param_3 != 0) {
					aiTask->flags_5c = uVar1 | 0x20080;
				}
				if (param_2 == 0) {
					game::Map3D_Block_SetHighlightType
										(pLVar2->surfaceMap,blockPos->x,blockPos->y,WALLHIGHLIGHT_DIG);
					iVar4 = (pLVar2->dimensions).width * blockPos->y + blockPos->x;
					pLVar2->blocks[iVar4].flags1 = pLVar2->blocks[iVar4].flags1 | BLOCK1_UNK_800000;
				}
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_UnkInitRouting_FUN_00402530(AITaskData *aiTask,BOOL param_2)
{
	uint *out_unitsCount;
	LiveObject **out_unitsTable;
	BOOL BVar1;
	uint uVar2;
	
	BVar1 = game::Message_IsAnyUnitsSelected();
	if (BVar1 != 0) {
		out_unitsCount = &aiTask->field_44;
		out_unitsTable = (LiveObject **)&aiTask->ptr_40;
		aiTask->flags_5c = aiTask->flags_5c | 0x140;
		game::Message_CopySelectedUnits(out_unitsTable,out_unitsCount);
		uVar2 = 0;
		if (*out_unitsCount != 0) {
			do {
				game::LiveObject_UnkDoRouting_FUN_00441c00
									(*(LiveObject **)((int)(*out_unitsTable)->routing_points_4 + uVar2 * 4 + -0x34),0)
				;
				if (param_2 != 0) {
					game::LiveObject_DropCarriedObject_FUN_0043a130
										(*(LiveObject **)((int)(*out_unitsTable)->routing_points_4 + uVar2 * 4 + -0x34),
										 0);
				}
				uVar2 += 1;
			} while (uVar2 < *out_unitsCount);
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoAttackRockMonster_Target(LiveObject *targetObj)
{
	BOOL BVar1;
	AITaskData *aiTask;
	
	lrr::Lego_GetLevel();
	if (targetObj != NULL) {
		BVar1 = game::LiveObject_CanShootObject(targetObj);
		if (BVar1 != 0) {
			aiTask = AITask_Create(AITASK_ATTACKROCKMONSTER);
			AITask_InitTask_1(aiTask,AI_PRIORITY_ATTACKROCKMONSTER);
			aiTask->object_10 = targetObj;
			aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0x40040;
		}
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_004025f0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->carryingThisObject == NULL) && ((liveObj->flags4 & 0x100) == LIVEOBJ4_NONE)) {
		BVar1 = AITask_DoUnkCallbacks(AITask_IsCollectAndSameTarget,liveObj);
		if (BVar1 == 0) {
			AITask_DoCollect(liveObj,0.0);
		}
	}
	return;
}



BOOL __cdecl lego::ai::AITask_IsCollectAndSameTarget(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_COLLECT) && (aiTask->object_10 == liveObj)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoCollect(LiveObject *liveObj,float param_2)
{
	ObjectType OVar1;
	AITaskData *aiTask;
	AIPriorityType priorityType;
	
	priorityType = AI_PRIORITY_DEFAULTCOLLECT;
	aiTask = AITask_Create(AITASK_COLLECT);
	aiTask->object_10 = liveObj;
	aiTask->float_18 = param_2;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_POWERCRYSTAL) {
		priorityType = -(uint)((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE) & 0x12;
	}
	else {
		if (OVar1 == OBJECT_ORE) {
			priorityType = AI_PRIORITY_ORE;
		}
		else {
			if (OVar1 == OBJECT_BARRIER) {
				priorityType = AI_PRIORITY_BARRIER;
			}
			else {
				if (OVar1 == OBJECT_DYNAMITE) {
					aiTask->mode_3c = 8;
					priorityType = AI_PRIORITY_DESTRUCTION;
				}
			}
		}
	}
	AITask_InitTask_1(aiTask,priorityType);
	AITask_DoCollect_Target(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoBuildPath_AtPosition(Point2I *position)
{
	BOOL BVar1;
	uint uVar2;
	AITaskData *aiTask;
	
	BVar1 = game::Level_Block_IsPath(position);
	if (BVar1 == 0) {
		uVar2 = game::Level_Block_GetRubbleLayers(position);
		if (uVar2 == 0) {
			BVar1 = game::Dependencies_Object_FUN_0040add0(OBJECT_PATH,0,0);
			if (BVar1 != 0) {
				aiTask = AITask_Create(AITASK_BUILDPATH);
				(aiTask->blockPos).x = position->x;
				(aiTask->blockPos).y = position->y;
				AITask_InitTask_1(aiTask,AI_PRIORITY_BUILDPATH);
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoGather_Count(int count)
{
	AITaskData *aiTask;
	bool bVar1;
	
	bVar1 = count == 0;
	if (bVar1) {
		count = 1;
	}
	if (true) {
		do {
			aiTask = AITask_Create(AITASK_GATHER);
			AITask_SetPriorityType(aiTask,AI_PRIORITY_GATHER);
			if (bVar1) {
				aiTask->flags_5c = aiTask->flags_5c | 0x40;
			}
			AITask_Init_2_NoPriority(aiTask);
			count += -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoCollect_Target(LiveObject *targetObj)
{
	AITaskData *aiTask;
	
	if (targetObj->objType == OBJECT_POWERCRYSTAL) {
		aiTask = AITask_Create(AITASK_COLLECT);
		aiTask->object_10 = targetObj;
		AITask_SetPriorityType(aiTask,AI_PRIORITY_STEAL);
		AITask_Init_2_NoPriority(aiTask);
		aiTask->flags_5c = aiTask->flags_5c | 0x2000;
	}
	return;
}



void __cdecl
lego::ai::AITask_DoTrain_Target(LiveObject *targetObj,TrainedFlags training,BOOL param_3)
{
	BOOL BVar1;
	AITaskData *aiTask;
	AIPriorityType priorityType;
	
	BVar1 = game::LiveObject_HasTraining(targetObj,training);
	if (BVar1 == 0) {
		return;
	}
	aiTask = AITask_Create(AITASK_TRAIN);
	aiTask->object_10 = targetObj;
	aiTask->mode_3c = training;
	if (false) {
switchD_004027fb_caseD_3:
		priorityType = AI_PRIORITY_UPGRADE;
	}
	else {
		switch(training) {
		case TRAINED_PILOT:
		case TRAINED_SAILOR:
		case TRAINED_DRIVER:
			priorityType = AI_PRIORITY_GETIN;
			break;
		default:
			goto switchD_004027fb_caseD_3;
		case TRAINED_DYNAMITE:
			priorityType = AI_PRIORITY_DESTRUCTION;
			break;
		case TRAINED_REPAIR:
			priorityType = AI_PRIORITY_REPAIR;
			break;
		case TRAINED_SCANNER:
			priorityType = AI_PRIORITY_CONSTRUCTION;
		}
	}
	if (param_3 != 0) {
		AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	}
	AITask_InitTask_1(aiTask,priorityType);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf;
	return;
}



void __cdecl lego::ai::AITask_DoFindDriver_Target(LiveObject *targetObj)
{
	AITaskData *aiTask;
	ObjectStatsFlags3 OVar1;
	ObjectStatsFlags1 OVar2;
	
	if ((*(byte *)&targetObj->flags2 & LIVEOBJ2_UNK_10) == 0) {
		aiTask = AITask_Create(AITASK_FINDDRIVER);
		aiTask->object_10 = targetObj;
		targetObj->flags2 = targetObj->flags2 | LIVEOBJ2_UNK_10;
		OVar1 = stats::StatsObject_GetStatsFlags3(targetObj);
		if ((OVar1 & STATS3_NEEDSPILOT) == STATS3_NONE) {
			OVar2 = stats::StatsObject_GetStatsFlags1(targetObj);
			if ((OVar2 & STATS1_CROSSLAND) == STATS1_NONE) {
				OVar2 = stats::StatsObject_GetStatsFlags1(targetObj);
				if ((OVar2 & STATS1_CROSSWATER) != STATS1_NONE) {
					aiTask->mode_3c = 2;
				}
			}
			else {
				OVar2 = stats::StatsObject_GetStatsFlags1(targetObj);
				if ((OVar2 & STATS1_CROSSWATER) == STATS1_NONE) {
					aiTask->mode_3c = 4;
				}
				else {
					aiTask->mode_3c = 1;
				}
			}
		}
		else {
			aiTask->mode_3c = 1;
		}
		OVar1 = stats::StatsObject_GetStatsFlags3(targetObj);
		if (((OVar1 & STATS3_TAKECARRYINGDRIVERS) != STATS3_NONE) &&
			 ((targetObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
			aiTask->flags_5c = aiTask->flags_5c | 0x100000;
		}
		AITask_UnkInitRouting_FUN_00402530(aiTask,~aiTask->flags_5c >> 0x14 & 1);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf;
		AITask_InitTask_1(aiTask,AI_PRIORITY_GETIN);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(Point2I *blockPos)
{
	BOOL BVar1;
	Point2I *local_8;
	int local_4;
	
	local_8 = blockPos;
	local_4 = 0;
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_IfAttackPath_FUN_004029a0,(LiveObject *)&local_8);
	return BVar1;
}



BOOL __cdecl
lego::ai::AITask_Callback_IfAttackPath_FUN_004029a0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_ATTACKPATH) && ((*param_2)->x == (aiTask->blockPos).x)) &&
		 ((*param_2)->y == (aiTask->blockPos).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_LiveObject_DoCallbacks_FUN_004029d0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_004029f0,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_004029f0(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_ATTACKROCKMONSTER) && (aiTask->object_10 == liveObj)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_Block_FUN_00402a10(Point2I *blockPos,int param_2)
{
	LevelData *level;
	Point2I *local_8;
	int local_4;
	
	level = lrr::Lego_GetLevel();
	local_8 = blockPos;
	local_4 = param_2;
	AITask_DoUnkCallbacks(AITask_Callback_FUN_00402ae0,(LiveObject *)&local_8);
	game::Map3D_Block_ClearHighlight(level->surfaceMap,blockPos->x,blockPos->y);
	return;
}



BOOL __cdecl lego::ai::AITask_Block_FUN_00402a60(Point2I *blockPos)
{
	BOOL BVar1;
	Point2I *local_8;
	int local_4;
	
	local_8 = blockPos;
	local_4 = 0;
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00402b50,(LiveObject *)&local_8);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_DoCallbacks_Block_FUN_00402a90(Point2I *blockPos,BOOL param_2)
{
	BOOL BVar1;
	Point2I *local_8;
	int local_4;
	
	local_4 = 0;
	local_8 = blockPos;
	if (param_2 != 0) {
		BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00402bd0,(LiveObject *)&local_8);
		return BVar1;
	}
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00402ba0,(LiveObject *)&local_8);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402ae0(AITaskData *aiTask,Point2I **pBlockPos)
{
	AITaskType AVar1;
	bool bVar2;
	
	bVar2 = false;
	AVar1 = aiTask->taskType;
	if (AVar1 == AITASK_DIG) {
		if (pBlockPos[1] != NULL) {
			if ((*(byte *)&aiTask->flags_5c & 8) != 0) goto LAB_00402b16;
			if (pBlockPos[1] != NULL) goto LAB_00402b1b;
		}
		if ((*(byte *)&aiTask->flags_5c & 8) != 0) goto LAB_00402b1b;
	}
	else {
		if ((AVar1 != AITASK_DYNAMITE) && (AVar1 != AITASK_REINFORCE)) goto LAB_00402b1b;
	}
LAB_00402b16:
	bVar2 = true;
LAB_00402b1b:
	if (((bVar2) && ((*pBlockPos)->x == (aiTask->blockPos).x)) &&
		 ((*pBlockPos)->y == (aiTask->blockPos).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
		game::Level_Block_SetBusy(*pBlockPos,FALSE);
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402b50(AITaskData *aiTask,Point2I **param_2)
{
	SurfaceMap *surfMap;
	int bx;
	int by;
	
	if (((aiTask->taskType == AITASK_REINFORCE) && ((*param_2)->x == (aiTask->blockPos).x)) &&
		 ((*param_2)->y == (aiTask->blockPos).y)) {
		by = (aiTask->blockPos).y;
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
		bx = (aiTask->blockPos).x;
		surfMap = lrr::Lego_GetMap();
		game::Map3D_Block_ClearHighlight(surfMap,bx,by);
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402ba0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_CLEAR) && ((*param_2)->x == (aiTask->blockPos).x)) &&
		 ((*param_2)->y == (aiTask->blockPos).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402bd0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_CLEAR) && ((*param_2)->x == (aiTask->blockPos).x)) &&
		 ((*param_2)->y == (aiTask->blockPos).y)) {
		aiTask->float_18 = 500.0;
	}
	return 0;
}



void __cdecl lego::ai::AITask_Release_2(AITaskData *aiTask)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	if (aiTask->taskType == AITASK_GETTOOL) {
		if (aiTask->aiTask_58 != NULL) {
			AITask_DoUnkCallbacks(AITask_Callback_IsSameTaskAsField58,(LiveObject *)&aiTask);
			return;
		}
	}
	else {
		if ((aiTask->aiTask_58 != NULL) &&
			 (pAVar2 = globs::aiGlobs.AITaskUnkPtr, globs::aiGlobs.AITaskUnkPtr != NULL)) {
			do {
				if ((pAVar2->taskType == AITASK_GETTOOL) && (aiTask->aiTask_58 == pAVar2)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
				}
				ppAVar1 = &pAVar2->next;
				pAVar2 = *ppAVar1;
			} while (*ppAVar1 != NULL);
		}
	}
	return;
}



BOOL __cdecl lego::ai::AITask_Callback_IsSameTaskAsField58(AITaskData *aiTask,AITaskData *otherTask)
{
	return (uint)(aiTask->aiTask_58 == otherTask);
}



BOOL __cdecl lego::ai::AITask_DoDynamite_AtBlockPos(Point2I *blockPos,BOOL noRoutingUnk)
{
	uint uVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	SurfaceMap *surfMap;
	int bx;
	int by;
	WallHighlightType highlightType;
	
	if ((globs::legoGlobs.level)->blocks
			[((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].terrain !=
			TERRAIN_IMMOVABLE) {
		BVar2 = game::Level_Block_IsWall(blockPos->x,blockPos->y);
		if (BVar2 != 0) {
			BVar2 = game::Level_Block_IsBusy(blockPos);
			if (BVar2 == 0) {
				aiTask = AITask_Create(AITASK_DYNAMITE);
				(aiTask->blockPos).x = blockPos->x;
				uVar1 = aiTask->flags_5c;
				(aiTask->blockPos).y = blockPos->y;
				aiTask->objType = OBJECT_DYNAMITE;
				aiTask->objIndex = -1;
				aiTask->objLevel = 0;
				aiTask->flags_5c = uVar1 | 0x400;
				if (noRoutingUnk == 0) {
					AITask_UnkInitRouting_FUN_00402530(aiTask,TRUE);
				}
				AITask_InitTask_1(aiTask,AI_PRIORITY_DESTRUCTION);
				AITask_PlaceRequestObject(blockPos,OBJECT_DYNAMITE,0,0);
				game::Level_Block_SetBusy(blockPos,TRUE);
				by = blockPos->y;
				bx = blockPos->x;
				highlightType = WALLHIGHLIGHT_DYNAMITE;
				surfMap = lrr::Lego_GetMap();
				game::Map3D_Block_SetHighlightType(surfMap,bx,by,highlightType);
				return TRUE;
			}
		}
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoBirdScarer_AtPosition(Point2I *blockPos)
{
	uint uVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	
	BVar2 = game::Level_Block_IsGround(blockPos->x,blockPos->y);
	if (BVar2 != 0) {
		aiTask = AITask_Create(AITASK_BIRDSCARER);
		uVar1 = aiTask->flags_5c;
		(aiTask->blockPos).x = blockPos->x;
		(aiTask->blockPos).y = blockPos->y;
		aiTask->objType = OBJECT_OOHSCARY;
		aiTask->objIndex = -1;
		aiTask->objLevel = 0;
		aiTask->flags_5c = uVar1 | 0x400;
		AITask_UnkInitRouting_FUN_00402530(aiTask,TRUE);
		AITask_InitTask_1(aiTask,AI_PRIORITY_DESTRUCTION);
		AITask_PlaceRequestObject(blockPos,OBJECT_OOHSCARY,0,0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoFindLoad(LiveObject *targetObj)
{
	ObjectStatsFlags3 OVar1;
	AITaskData *aiTask;
	
	OVar1 = stats::StatsObject_GetStatsFlags3(targetObj);
	if ((((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			((targetObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) &&
		 ((targetObj->flags4 & LIVEOBJ4_UNK_10000) == LIVEOBJ4_NONE)) {
		aiTask = AITask_Create(AITASK_FINDLOAD);
		aiTask->object_10 = targetObj;
		targetObj->flags4 = targetObj->flags4 | LIVEOBJ4_UNK_10000;
		AITask_InitTask_1(aiTask,AI_PRIORITY_FINDLOAD);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf | 0x100010;
	}
	return;
}



void __cdecl lego::ai::AITask_DoRepair_Target(LiveObject *targetObj,BOOL condition)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_REPAIR);
	aiTask->object_10 = targetObj;
	aiTask->mode_3c = 0x10;
	if (condition != 0) {
		aiTask->flags_5c = aiTask->flags_5c | 0x200000;
	}
	AITask_InitTask_1(aiTask,(-(uint)(condition != 0) & 0xc) + AI_PRIORITY_REPAIR);
	return;
}



void __cdecl lego::ai::AITask_DoGotoEat_Target(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_GOTOEAT);
	pAVar1->object_10 = targetObj;
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_DoElecFence(Point2I *position)
{
	uint uVar1;
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_ELECFENCE);
	uVar1 = aiTask->flags_5c;
	(aiTask->blockPos).x = position->x;
	(aiTask->blockPos).y = position->y;
	aiTask->objType = OBJECT_ELECTRICFENCE;
	aiTask->objIndex = -1;
	aiTask->objLevel = 0;
	aiTask->flags_5c = uVar1 | 0x400;
	AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	AITask_InitTask_1(aiTask,AI_PRIORITY_CONSTRUCTION);
	AITask_PlaceRequestObject(position,OBJECT_ELECTRICFENCE,0,0);
	game::Level_Block_SetFenceRequest(position->x,position->y,TRUE);
	return;
}



void __cdecl lego::ai::AITask_DoReinforce_AtBlockPos(Point2I *blockPos)
{
	BOOL BVar1;
	AITaskData *aiTask;
	SurfaceMap *surfMap;
	int bx;
	int by;
	WallHighlightType highlightType;
	
	BVar1 = game::Level_Block_IsWall(blockPos->x,blockPos->y);
	if (BVar1 != 0) {
		BVar1 = game::Level_Block_IsReinforced(blockPos->x,blockPos->y);
		if (BVar1 == 0) {
			aiTask = AITask_Create(AITASK_REINFORCE);
			(aiTask->blockPos).x = blockPos->x;
			(aiTask->blockPos).y = blockPos->y;
			AITask_UnkInitRouting_FUN_00402530(aiTask,TRUE);
			AITask_InitTask_1(aiTask,AI_PRIORITY_REINFORCE);
			by = blockPos->y;
			bx = blockPos->x;
			highlightType = WALLHIGHLIGHT_REINFORCE;
			surfMap = lrr::Lego_GetMap();
			game::Map3D_Block_SetHighlightType(surfMap,bx,by,highlightType);
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoClear_AtPosition(Point2I *position,MessageType completeAction)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_CLEAR);
	(aiTask->blockPos).x = position->x;
	(aiTask->blockPos).y = position->y;
	aiTask->completeAction = completeAction;
	AITask_InitTask_1(aiTask,AI_PRIORITY_CLEARING);
	return;
}



void __cdecl lego::ai::AITask_DoGetTool_FromTask(AITaskData *in_aiTask)
{
	AITaskData *pAVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	undefined4 *puVar3;
	uint uVar4;
	int iVar5;
	undefined4 *puVar6;
	
	pAVar1 = in_aiTask;
	BVar2 = stats::Stats_FindToolFromTaskType(in_aiTask->taskType,(ToolType *)&in_aiTask);
	if (BVar2 != 0) {
		pAVar1->flags_5c = pAVar1->flags_5c | 0x1000;
		aiTask = AITask_Create(AITASK_GETTOOL);
		if ((pAVar1->flags_5c & 0x100) != 0) {
			puVar3 = (undefined4 *)std::malloc(pAVar1->field_44 << 2);
			aiTask->ptr_40 = puVar3;
			puVar6 = (undefined4 *)pAVar1->ptr_40;
			for (uVar4 = pAVar1->field_44 & 0x3fffffff; uVar4 != 0; uVar4 -= 1) {
				*puVar3 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar3 = puVar3 + 1;
			}
			for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
				*(undefined *)puVar3 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			aiTask->field_44 = pAVar1->field_44;
			aiTask->flags_5c = aiTask->flags_5c | 0x100;
		}
		aiTask->flags_5c = aiTask->flags_5c | 0x10;
		aiTask->toolType = (ToolType)in_aiTask;
		aiTask->aiTask_58 = pAVar1;
		pAVar1->aiTask_58 = aiTask;
		AITask_InitTask_1(aiTask,pAVar1->priorityType);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoGetTool(ToolType toolType)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_GETTOOL);
	aiTask->toolType = toolType;
	aiTask->aiTask_58 = NULL;
	AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf | 0x10;
	AITask_InitTask_1(aiTask,AI_PRIORITY_DEFAULTCOLLECT);
	return 1;
}



BOOL __cdecl lego::ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(ToolType toolType)
{
	BOOL BVar1;
	uint uVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	
	BVar1 = game::Message_IsAnyUnitsSelected();
	if (BVar1 == 0) {
		uVar2 = 0;
		if (globs::aiGlobs.liveObjsCount_1 != 0) {
			ppLVar3 = globs::aiGlobs.liveObjsTable_1;
			while ((*ppLVar3 == NULL ||
						 (BVar1 = game::LiveObject_HasToolEquipped(*ppLVar3,toolType), BVar1 == 0))) {
				uVar2 += 1;
				ppLVar3 = ppLVar3 + 1;
				if (globs::aiGlobs.liveObjsCount_1 <= uVar2) {
					return 0;
				}
			}
			return 1;
		}
	}
	else {
		uVar2 = game::Message_GetNumSelectedUnits();
		ppLVar3 = game::Message_GetSelectedUnits();
		uVar4 = 0;
		if (uVar2 != 0) {
			do {
				BVar1 = game::LiveObject_HasToolEquipped(*ppLVar3,toolType);
				if (BVar1 != 0) {
					return 1;
				}
				uVar4 += 1;
				ppLVar3 = ppLVar3 + 1;
			} while (uVar4 < uVar2);
			return 0;
		}
	}
	return 0;
}



void __cdecl
lego::ai::AITask_Game_PTL_UserGoto
					(LiveObject **liveObjsTable,int count,Point2I *position,BOOL param_4)
{
	LiveObject *liveObj;
	AITaskData *pAVar1;
	ObjectStatsFlags1 OVar2;
	AITaskData *pAVar3;
	
	if ((count != 0) && (count != 0)) {
		do {
			pAVar1 = AITask_Create(AITASK_GOTO);
			(pAVar1->blockPos).x = position->x;
			(pAVar1->blockPos).y = position->y;
			pAVar1->flags_5c = 4;
			liveObj = *liveObjsTable;
			OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
			if ((((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) &&
				 ((liveObj->carryingThisObject == NULL &&
					((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_80) != 0)))) {
				if (param_4 != 0) {
					AITask_LiveObject_FUN_00404030(liveObj);
				}
				pAVar3 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
				if (pAVar3 == NULL) {
					liveObj->aitask_2f0 = pAVar1;
				}
				else {
					pAVar3->next = pAVar1;
				}
			}
			liveObjsTable = liveObjsTable + 1;
			count += -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoUpgrade(LiveObject *liveObj,int newObjLevel)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	Point2F local_8;
	
	pLVar3 = NULL;
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
		game::LiveObject_GetPosition(liveObj,&local_8.x,&local_8.y);
		pLVar3 = game::Level_GetBuildingAtPosition(&local_8);
	}
	else {
		if (liveObj->objType == OBJECT_VEHICLE) {
			pLVar3 = (LiveObject *)FUN_00438eb0(liveObj);
		}
	}
	if (pLVar3 != NULL) {
		pAVar1 = AITask_Create(AITASK_UPGRADE);
		pAVar1->object_10 = pLVar3;
		pAVar1->objLevel = newObjLevel;
		AITask_LiveObject_FUN_00404030(liveObj);
		pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
		if (pAVar2 != NULL) {
			pAVar2->next = pAVar1;
			return;
		}
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl lego::ai::AITask_DoDock(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_DOCK);
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_DoGoto_Congregate(Point2I *blockPos)
{
	uint uVar1;
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_GOTO);
	(aiTask->blockPos).x = blockPos->x;
	uVar1 = aiTask->flags_5c;
	(aiTask->blockPos).y = blockPos->y;
	aiTask->flags_5c = uVar1 & 0xffffffef | 0x40;
	AITask_SetPriorityType(aiTask,AI_PRIORITY_CONGREGATE);
	AITask_Init_2_NoPriority(aiTask);
	return;
}



void __cdecl lego::ai::AITask_StopGoto_Congregate(Point2I *blockPos)
{
	AITaskData *pAVar1;
	AITaskData *aiTask;
	AITaskData *pAVar2;
	
	pAVar1 = globs::aiGlobs.AITaskDataNext;
	pAVar2 = NULL;
	if (globs::aiGlobs.AITaskDataNext != NULL) {
		do {
			aiTask = pAVar1;
			pAVar1 = aiTask->next;
			if (((aiTask->taskType == AITASK_GOTO) && ((aiTask->blockPos).x == blockPos->x)) &&
				 ((aiTask->blockPos).y == blockPos->y)) {
				if (pAVar2 == NULL) {
					globs::aiGlobs.AITaskDataNext = pAVar1;
					AITask_Remove(aiTask,FALSE);
					return;
				}
				pAVar2->next = pAVar1;
				AITask_Remove(aiTask,FALSE);
				return;
			}
			pAVar2 = aiTask;
		} while (pAVar1 != NULL);
	}
	return;
}



void __cdecl lego::ai::AITask_DoAttackObject(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_ATTACKOBJECT);
	aiTask->object_10 = liveObj;
	AITask_SetPriorityType(aiTask,AI_PRIORITY_ATTACKOBJECT);
	AITask_Init_2_NoPriority(aiTask);
	aiTask->flags_5c = aiTask->flags_5c | 0x40;
	return;
}



void __cdecl lego::ai::AITask_DoAttackPath(Point2I *position)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_ATTACKPATH);
	(aiTask->blockPos).x = position->x;
	(aiTask->blockPos).y = position->y;
	AITask_SetPriorityType(aiTask,AI_PRIORITY_ATTACKPATH);
	AITask_Init_2_NoPriority(aiTask);
	return;
}



void __cdecl lego::ai::AITask_DoRepair(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_REPAIR);
	aiTask->object_10 = liveObj;
	AITask_SetPriorityType(aiTask,AI_PRIORITY_PUNCH);
	AITask_Init_2_NoPriority(aiTask);
	aiTask->flags_5c = aiTask->flags_5c | 0x40;
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403490(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *aiTask;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	
	pAVar2 = NULL;
	aiTask = globs::aiGlobs.AITaskDataNext;
	if (globs::aiGlobs.AITaskDataNext != NULL) {
		do {
			pAVar1 = aiTask->next;
			pAVar3 = aiTask;
			if ((aiTask->taskType == AITASK_REPAIR) && (liveObj == aiTask->object_10)) {
				pAVar3 = pAVar2;
				if (pAVar2 == NULL) {
					globs::aiGlobs.AITaskDataNext = pAVar1;
					AITask_Remove(aiTask,0);
				}
				else {
					pAVar2->next = pAVar1;
					AITask_Remove(aiTask,0);
				}
			}
			aiTask = pAVar1;
			pAVar2 = pAVar3;
		} while (pAVar1 != NULL);
	}
	return;
}



void __cdecl
lego::ai::AITask_Game_PTL_GotoOrRMGoto(LiveObject *liveObj,Point2I *position,undefined4 param_3)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_GOTO);
	(pAVar1->blockPos).x = position->x;
	(pAVar1->blockPos).y = position->y;
	pAVar1->field_4 = param_3;
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	front::Bubble_LiveObject_MiniFigure_FUN_00407380(liveObj);
	return;
}



void __cdecl lego::ai::AITask_Game_PTL_CrystalToRefinery(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		pAVar1 = AITask_Create(AITASK_DEPOSITE);
		pAVar1->object_10 = targetObj;
		pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
		if (pAVar2 != NULL) {
			pAVar2->next = pAVar1;
			return;
		}
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl
lego::ai::AITask_DoFollow_Group(LiveObject **liveObjsTable,int count,LiveObject *targetObj)
{
	LiveObject *liveObj;
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	if ((count != 0) && (count != 0)) {
		do {
			pAVar1 = AITask_Create(AITASK_FOLLOW);
			pAVar1->object_10 = targetObj;
			pAVar1->unkExpiryTime = 0.0;
			liveObj = *liveObjsTable;
			AITask_LiveObject_FUN_00404030(liveObj);
			pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
			if (pAVar2 == NULL) {
				liveObj->aitask_2f0 = pAVar1;
			}
			else {
				pAVar2->next = pAVar1;
			}
			liveObjsTable = liveObjsTable + 1;
			count += -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_Game_PTL_FollowAttack(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_FOLLOWATTACK);
	pAVar1->object_10 = targetObj;
	pAVar1->unkExpiryTime = 0.0;
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_FUN_00403630(int param_1,int param_2,int param_3,int param_4)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globs::aiGlobs.AITaskUnkPtr;
	if (globs::aiGlobs.AITaskUnkPtr != NULL) {
		do {
			if (((pAVar2->taskType == AITASK_REQUEST) && (pAVar2->field_2c == param_1)) &&
				 ((param_2 == 0 || ((param_3 == pAVar2->objType && (param_4 == pAVar2->objIndex)))))) {
				pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != NULL);
	}
	return;
}



void __cdecl
lego::ai::AITask_DoRequest_ObjectType
					(ObjectType objType,int objLevel,int objIndex,Point2I *blockPos,undefined4 param_5,
					Point2F *pointFloat,BOOL param_7)
{
	int iVar1;
	AITaskData *aiTask;
	float10 fVar2;
	
	aiTask = AITask_Create(AITASK_REQUEST);
	aiTask->objType = objType;
	aiTask->objIndex = objLevel;
	aiTask->objLevel = objIndex;
	(aiTask->blockPos).x = blockPos->x;
	iVar1 = blockPos->y;
	aiTask->field_2c = param_5;
	(aiTask->blockPos).y = iVar1;
	if (pointFloat == NULL) {
		fVar2 = math::Maths_RandRange(0.4,0.6);
		(aiTask->pointf_30).x = (float)fVar2;
		fVar2 = math::Maths_RandRange(0.4,0.6);
		(aiTask->pointf_30).y = (float)fVar2;
	}
	else {
		(aiTask->pointf_30).x = pointFloat->x;
		(aiTask->pointf_30).y = pointFloat->y;
	}
	if (param_7 != 0) {
		aiTask->flags_5c = aiTask->flags_5c | 0x800;
	}
	aiTask->object_10 = NULL;
	aiTask->unkExpiryTime = 0.0;
	AITask_InitTask_1(aiTask,AI_PRIORITY_REQUEST);
	aiTask->flags_5c = aiTask->flags_5c | 0x400;
	AITask_PlaceRequestObject(blockPos,objType,objLevel,objIndex);
	return;
}



void __cdecl
lego::ai::AITask_PlaceRequestObject(Point2I *blockPos,ObjectType objType,int objIndex,int objLevel)
{
	LiveObject *pLVar1;
	LiveObject *liveObj;
	int iVar2;
	
	pLVar1 = FUN_00438d20(blockPos,objType,objIndex,objLevel);
	if (pLVar1 == NULL) {
		if (((objIndex != 0) && (objType == OBJECT_ORE)) &&
			 (pLVar1 = FUN_00438d20(blockPos,OBJECT_ORE,0,objLevel), pLVar1 != NULL)) {
			liveObj = game::LiveObject_FUN_00438da0(NULL,blockPos,OBJECT_ORE,0);
			iVar2 = stats::StatsObject_GetMaxCarry(liveObj);
			if (iVar2 == 0) {
				return;
			}
			do {
				game::LiveObject_FUN_0043a910(pLVar1,OBJECT_ORE,0,objLevel);
				iVar2 += -1;
			} while (iVar2 != 0);
			return;
		}
	}
	else {
		pLVar1 = game::LiveObject_FUN_0043a910(pLVar1,objType,objIndex,objLevel);
		if (pLVar1 != NULL) {
			return;
		}
	}
	globs::aiGlobs.requestObjCounts[objType][objIndex][objLevel] =
			 globs::aiGlobs.requestObjCounts[objType][objIndex][objLevel] + 1;
	return;
}



AITaskData * __cdecl
lego::ai::AITask_DoDeposit_ObjectType
					(LiveObject *liveObj,ObjectType objType,int objIndex,int objLevel)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_DEPOSITE);
	aiTask->object_10 = liveObj;
	aiTask->unkExpiryTime = 0.0;
	aiTask->objType = objType;
	aiTask->objIndex = objIndex;
	aiTask->objLevel = objLevel;
	AITask_InitTask_1(aiTask,AI_PRIORITY_REFINING);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0x4c0;
	return aiTask;
}



void __cdecl lego::ai::AITask_DoRequestObjectCallbacks(LiveObject *liveObj)
{
	BOOL BVar1;
	LiveObject *pLVar2;
	uint objIndex;
	ObjectType objType;
	uint objLevel;
	uint (*paauVar3) [15] [16];
	int local_8;
	uint local_4;
	
	objType = OBJECT_NONE;
	paauVar3 = globs::aiGlobs.requestObjCounts;
	do {
		objIndex = 0;
		do {
			objLevel = 0;
			do {
				local_8 = 0;
				local_4 = 0;
				if ((*paauVar3)[0] != 0) {
					do {
						BVar1 = AITask_FUN_00404e40(objType,objIndex,objLevel);
						if ((BVar1 == 0) ||
							 (pLVar2 = game::LiveObject_FUN_0043a910(liveObj,objType,objIndex,objLevel),
							 pLVar2 != NULL)) {
							local_8 += 1;
						}
						local_4 += 1;
					} while (local_4 < (*paauVar3)[0]);
				}
				objLevel += 1;
				(*paauVar3)[0] = (*paauVar3)[0] - local_8;
				paauVar3 = (uint (*) [15] [16])(*paauVar3 + 1);
			} while (objLevel < 0x10);
			objIndex += 1;
		} while (objIndex < 0xf);
		objType += OBJECT_VEHICLE;
	} while (paauVar3 <= (uint (*) [15] [16])((int)globs::aiGlobs.requestObjCounts[0x13][0xe] + 0x3f))
	;
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_004038d0(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_DoDeposit_ObjectType(liveObj,OBJECT_NONE,-1,0);
	AITask_SetPriorityType(aiTask,AI_PRIORITY_STORAGE);
	AITask_DoRequestObjectCallbacks(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoGotoEat(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_GOTOEAT);
	aiTask->object_10 = liveObj;
	aiTask->unkExpiryTime = 0.0;
	AITask_InitTask_1(aiTask,AI_PRIORITY_CRYSTAL);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0xc0;
	return;
}



BOOL __cdecl lego::ai::AITask_LiveObject_FUN_00403940(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00403960,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00403960(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_DEPOSITE) && (liveObj == aiTask->object_10)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403980(LiveObject *liveObj)
{
	uint uVar1;
	AITaskData *pAVar2;
	AITaskData *aiTask;
	
	if (((byte)globs::aiGlobs.flags & 2) == 0) {
		aiTask = liveObj->aitask_2f0;
		while (aiTask != NULL) {
			uVar1 = aiTask->flags_5c;
			pAVar2 = aiTask->next;
			if (((uVar1 & 0x10) == 0) || ((uVar1 & 0x20) != 0)) {
				if (((uVar1 & 0x2000) == 0) || ((uVar1 & 0x20) != 0)) {
					AITask_Remove(aiTask,0);
					aiTask = pAVar2;
				}
				else {
					AITask_Init_2_NoPriority(aiTask);
					aiTask = pAVar2;
				}
			}
			else {
				AITask_InitTask_1(aiTask,aiTask->priorityType);
				aiTask = pAVar2;
			}
		}
		liveObj->aitask_2f0 = NULL;
		AITask_DoUnkCallbacks(AITask_Callback_FUN_00403a00,liveObj);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00403a00(AITaskData *aiTask,LiveObject *liveObj)
{
	if (liveObj == aiTask->object_10) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403a20(LiveObject *liveObj,BOOL param_2)
{
	AITaskData *pAVar1;
	
	pAVar1 = liveObj->aitask_2f0;
	if (pAVar1 != NULL) {
		if (param_2 == 0) {
			pAVar1->flags_5c = pAVar1->flags_5c & 0xfffffffe;
		}
		else {
			if (pAVar1->taskType == AITASK_GOTO) {
				AITask_LiveObject_FUN_00404110(liveObj);
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					game::Message_AddMessageAction(MESSAGE_ROCKMONSTERGOTO_COMPLETE,liveObj,0,NULL);
					return;
				}
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403a70(LiveObject *liveObj)
{
	uint *puVar1;
	
	if (liveObj->aitask_2f0 != NULL) {
		puVar1 = &liveObj->aitask_2f0->flags_5c;
		*puVar1 = *puVar1 & 0xfffffffe;
	}
	return;
}



void __cdecl lego::ai::AITask_VariousGatherTasks_FUN_00403a90(LiveObject *liveObj)
{
	LiveObject *carriedObj;
	uint uVar1;
	LiveObject **ppLVar2;
	
	if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			((liveObj->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) &&
		 (uVar1 = 0, liveObj->numCarriedObjects != 0)) {
		ppLVar2 = liveObj->carriedObjects;
		do {
			carriedObj = *ppLVar2;
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DEPOSITE,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DUMP,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DYNAMITE,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_ELECFENCE,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_REQUEST,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_GATHER,NULL);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_BIRDSCARER,carriedObj);
			uVar1 += 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar1 < liveObj->numCarriedObjects);
	}
	return;
}



void __cdecl
lego::ai::AITask_LiveObject_FUN_00403b30
					(LiveObject *holderObj,AITaskType taskType,LiveObject *carriedObj)
{
	AITaskData **ppAVar1;
	AITaskType AVar2;
	SurfaceMap *surfMap;
	AITaskData *pAVar3;
	AITaskData *aiTask;
	int bx;
	int by;
	
	if (((byte)globs::aiGlobs.flags & 2) != 0) {
		return;
	}
	pAVar3 = NULL;
	aiTask = holderObj->aitask_2f0;
	if (aiTask == NULL) {
		return;
	}
	while (taskType != aiTask->taskType) {
		ppAVar1 = &aiTask->next;
		pAVar3 = aiTask;
		aiTask = *ppAVar1;
		if (*ppAVar1 == NULL) {
			return;
		}
	}
	AVar2 = aiTask->taskType;
	if (AVar2 == AITASK_DEPOSITE) {
LAB_00403b90:
		if (AVar2 == AITASK_REQUEST) goto LAB_00403b95;
	}
	else {
		if (AVar2 != AITASK_REQUEST) {
			if ((((AVar2 != AITASK_DUMP) && (AVar2 != AITASK_COLLECT)) && (AVar2 != AITASK_DYNAMITE)) &&
				 ((AVar2 != AITASK_ELECFENCE && (AVar2 != AITASK_BIRDSCARER)))) goto LAB_00403c01;
			goto LAB_00403b90;
		}
LAB_00403b95:
		AITask_DoRequest_ObjectType
							(aiTask->objType,aiTask->objIndex,aiTask->objLevel,&aiTask->blockPos,aiTask->field_2c,
							 &aiTask->pointf_30,aiTask->flags_5c & 0x800);
	}
	if (aiTask->taskType == AITASK_DYNAMITE) {
		game::Level_Block_SetBusy(&aiTask->blockPos,FALSE);
		by = (aiTask->blockPos).y;
		bx = (aiTask->blockPos).x;
		surfMap = lrr::Lego_GetMap();
		game::Map3D_Block_ClearHighlight(surfMap,bx,by);
	}
	AITask_DoCollect(carriedObj,150.0);
	AITask_DoCollect_Target(carriedObj);
LAB_00403c01:
	if (pAVar3 == NULL) {
		holderObj->aitask_2f0 = aiTask->next;
		AITask_Remove(aiTask,0);
		return;
	}
	pAVar3->next = aiTask->next;
	AITask_Remove(aiTask,0);
	return;
}



void __cdecl
lego::ai::AITask_LiveObject_SetAITaskUnk
					(LiveObject *liveObj1,AITaskType taskType,LiveObject *liveObj2,BOOL param_4)
{
	Point2I *blockPos;
	bool bVar1;
	LiveObject *liveObj;
	AITaskData *pAVar2;
	LiveObject *argument2;
	BOOL BVar3;
	LevelBlockFlags1 LVar4;
	AITaskData *aiTask;
	AITaskData *pAVar5;
	AITaskType AVar6;
	
	liveObj = liveObj1;
	if (((byte)globs::aiGlobs.flags & 2) == 0) {
		if ((taskType == AITASK_COLLECT) &&
			 (argument2 = game::LiveObject_FUN_00438da0
															(liveObj1,NULL,liveObj2->objType,liveObj2->objLevel),
			 argument2 != NULL)) {
			game::Message_AddMessageAction(MESSAGE_COLLECTCRYSTAL_COMPLETE,liveObj1,argument2,NULL);
		}
		pAVar2 = liveObj1->aitask_2f0;
		pAVar5 = NULL;
		if (liveObj1->aitask_2f0 != NULL) {
LAB_00403c9a:
			aiTask = pAVar2;
			if (taskType != aiTask->taskType) goto code_r0x00403ca4;
			liveObj1 = NULL;
			bVar1 = false;
			if (param_4 != 0) {
				if (pAVar5 == NULL) {
					liveObj->aitask_2f0 = aiTask->next;
				}
				else {
					pAVar5->next = aiTask->next;
				}
			}
			if (aiTask->taskType == AITASK_REQUEST) {
				AVar6 = aiTask->field_2c;
				bVar1 = true;
				liveObj1 = liveObj2;
				BVar3 = game::Construction_FUN_00408ca0(AVar6,liveObj2->objType,liveObj2->objIndex);
				if (BVar3 == 0) {
					AITask_FUN_00403630(AVar6,1,liveObj2->objType,liveObj2->objIndex);
					bVar1 = false;
				}
			}
			else {
				AVar6 = taskType;
				if (aiTask->taskType == AITASK_CLEAR) {
					if (liveObj->objType == OBJECT_VEHICLE) {
						for (LVar4 = (globs::legoGlobs.level)->blocks
												 [(aiTask->blockPos).y * ((globs::legoGlobs.level)->dimensions).width +
													(aiTask->blockPos).x].flags1 & BLOCK1_RUBBLE_FULL; LVar4 != BLOCK1_NONE;
								LVar4 += ~BLOCK1_NONE) {
							game::Level_Block_ClearRubbleLayer(&aiTask->blockPos);
							game::Message_AddMessageAction(aiTask->completeAction,0,0,&aiTask->blockPos);
						}
					}
					blockPos = &aiTask->blockPos;
					game::Level_Block_ClearRubbleLayer(blockPos);
					game::Message_AddMessageAction(aiTask->completeAction,0,0,blockPos);
					game::Level_Block_SetFlags1_80000(blockPos,FALSE);
					game::Level_Block_SetFlags1_10000000(blockPos,FALSE);
				}
				else {
					if (taskType == AITASK_TRAIN) {
						game::LiveObject_TrainMiniFigure_instantunk(liveObj,aiTask->mode_3c);
						front::Text_DisplayMessage(TEXT_MANTRAINED,1,0);
					}
				}
			}
			if (param_4 != 0) {
				AITask_Remove(aiTask,FALSE);
			}
			if (bVar1) {
				game::Construction_FUN_00408c10(AVar6,liveObj1);
			}
		}
LAB_00403dfc:
		if (taskType == AITASK_COLLECT) {
			AITask_LiveObject_FUN_00403e20(liveObj2);
		}
	}
	return;
code_r0x00403ca4:
	pAVar2 = aiTask->next;
	pAVar5 = aiTask;
	if (aiTask->next == NULL) goto LAB_00403dfc;
	goto LAB_00403c9a;
}



BOOL __cdecl lego::ai::AITask_LiveObject_FUN_00403e20(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00403e40,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00403e40(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_COLLECT) && (aiTask->object_10 == liveObj)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoAnimationWait(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	
	if ((liveObj->aitask_2f0 == NULL) || (liveObj->aitask_2f0->taskType != AITASK_ANIMATIONWAIT)) {
		pAVar1 = AITask_Create(AITASK_ANIMATIONWAIT);
		pAVar1->next = liveObj->aitask_2f0;
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(LiveObject *liveObj)
{
	if ((liveObj->aitask_2f0 != NULL) && (liveObj->aitask_2f0->taskType == AITASK_ANIMATIONWAIT)) {
		AITask_LiveObject_FUN_00404110(liveObj);
	}
	return;
}



int __cdecl lego::ai::AITask_QSortCompare(AITaskData **task_a,AITaskData **task_b)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	uint uVar3;
	uint uVar4;
	
	pAVar1 = *task_a;
	pAVar2 = *task_b;
	uVar3 = pAVar1->flags_5c & 0x100;
	if ((uVar3 != 0) && ((pAVar2->flags_5c & 0x100) == 0)) {
		return 0xffffffff;
	}
	uVar4 = pAVar2->flags_5c & 0x100;
	if (uVar4 == 0) {
		if (uVar3 == 0) goto LAB_00403f0c;
	}
	else {
		if (uVar3 == 0) {
			return 1;
		}
	}
	if (uVar4 != 0) {
		if (pAVar2->taskStartTime < pAVar1->taskStartTime) {
			return 0xffffffff;
		}
		if (pAVar1->taskStartTime < pAVar2->taskStartTime) {
			return 1;
		}
	}
LAB_00403f0c:
	if ((int)pAVar1->priorityValue < 0) {
		pAVar1->priorityValue = 0;
	}
	if ((int)pAVar2->priorityValue < 0) {
		pAVar2->priorityValue = 0;
	}
	if (99 < (int)pAVar1->priorityValue) {
		pAVar1->priorityValue = 99;
	}
	if (99 < (int)pAVar2->priorityValue) {
		pAVar2->priorityValue = 99;
	}
	if ((int)pAVar2->priorityValue < (int)pAVar1->priorityValue) {
		return 0xffffffff;
	}
	return (uint)((int)pAVar1->priorityValue < (int)pAVar2->priorityValue);
}



AITaskData * __cdecl lego::ai::AITask_InitTask_1(AITaskData *aiTask,AIPriorityType priorityType)
{
	aiTask->next = globs::aiGlobs.AITaskUnkPtr;
	globs::aiGlobs.AITaskUnkPtr = aiTask;
	aiTask->unkExpiryTime = 1500.0;
	aiTask->flags_5c = aiTask->flags_5c & 0xfffffffe | 0x10;
	aiTask->priorityValue = globs::aiGlobs.priorityValues[priorityType];
	aiTask->priorityType = priorityType;
	return aiTask;
}



void __cdecl lego::ai::AITask_Init_2_NoPriority(AITaskData *aiTask)
{
	aiTask->next = globs::aiGlobs.AITaskDataNext;
	globs::aiGlobs.AITaskDataNext = aiTask;
	aiTask->unkExpiryTime = 1500.0;
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffee;
	return;
}



void __cdecl lego::ai::AITask_Game_UnkLiveObjectHandleDynamite(LiveObject *liveObj)
{
	if (((byte)globs::aiGlobs.flags & 6) == 0) {
		AITask_LiveObject_FUN_00403b30(liveObj,AITASK_GOTO,NULL);
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0]->objType == OBJECT_DYNAMITE)) {
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DYNAMITE,liveObj->carriedObjects[0]);
		}
		AITask_LiveObject_FUN_00404030(liveObj);
		AITask_LiveObject_ReleaseTaskReferences(liveObj);
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00404030(LiveObject *liveObj)
{
	uint uVar1;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	AITaskData *aiTask;
	
	pAVar3 = NULL;
	pAVar2 = liveObj->aitask_2f0;
	while (aiTask = pAVar2, aiTask != NULL) {
		uVar1 = aiTask->flags_5c;
		pAVar2 = aiTask->next;
		if ((uVar1 & 4) == 0) {
			if (((uVar1 & 0x10) == 0) || ((uVar1 & 0x20) != 0)) {
				if (((uVar1 & 0x2000) == 0) || ((uVar1 & 0x20) != 0)) {
					if (pAVar3 == NULL) {
						aiTask->next = NULL;
						pAVar3 = aiTask;
					}
					else {
						pAVar3->next = aiTask;
						aiTask->next = NULL;
					}
				}
				else {
					aiTask->next = globs::aiGlobs.AITaskDataNext;
					globs::aiGlobs.AITaskDataNext = aiTask;
				}
			}
			else {
				aiTask->next = globs::aiGlobs.AITaskUnkPtr;
				globs::aiGlobs.AITaskUnkPtr = aiTask;
			}
		}
		else {
			AITask_Remove(aiTask,0);
		}
	}
	liveObj->aitask_2f0 = pAVar3;
	return;
}



AITaskData * __cdecl lego::ai::AITask_LiveObject_AITask2F0_GetLast(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = liveObj->aitask_2f0;
	if (pAVar2 != NULL) {
		for (pAVar1 = pAVar2->next; pAVar1 != NULL; pAVar1 = pAVar1->next) {
			pAVar2 = pAVar1;
		}
	}
	return pAVar2;
}



BOOL __cdecl lego::ai::AITask_LiveObject_IsCurrentTaskType(LiveObject *liveObj,AITaskType taskType)
{
	AITaskData *pAVar1;
	
	pAVar1 = liveObj->aitask_2f0;
	if (pAVar1 == NULL) {
		return (BOOL)NULL;
	}
	do {
		if (taskType == pAVar1->taskType) {
			return (BOOL)(AITaskData *)0x1;
		}
		pAVar1 = pAVar1->next;
	} while (pAVar1 != NULL);
	return (BOOL)pAVar1;
}



AITaskData * __cdecl lego::ai::AITask_LiveObject_FUN_00404110(LiveObject *liveObj)
{
	AITaskData *aiTask;
	uint uVar1;
	
	aiTask = liveObj->aitask_2f0;
	if (aiTask != NULL) {
		liveObj->aitask_2f0 = aiTask->next;
		uVar1 = aiTask->flags_5c;
		if (((uVar1 & 0x10) != 0) && ((uVar1 & 0x20) == 0)) {
			aiTask->next = globs::aiGlobs.AITaskUnkPtr;
			globs::aiGlobs.AITaskUnkPtr = aiTask;
			return liveObj->aitask_2f0;
		}
		if (((uVar1 & 0x2000) != 0) && ((uVar1 & 0x20) == 0)) {
			aiTask->next = globs::aiGlobs.AITaskDataNext;
			globs::aiGlobs.AITaskDataNext = aiTask;
			return liveObj->aitask_2f0;
		}
		AITask_Remove(aiTask,FALSE);
	}
	return liveObj->aitask_2f0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00404180(AITaskData *aiTask,float *param_2)
{
	if ((*(byte *)&aiTask->flags_5c & 0x80) == 0) {
		aiTask->unkExpiryTime = aiTask->unkExpiryTime - *param_2;
	}
	aiTask->float_18 = aiTask->float_18 - *param_2;
	return 0;
}



BOOL __cdecl lego::ai::AITask_LiveObject_Callback_DoAITask(LiveObject *liveObj,float *param_2)
{
	float fVar1;
	AITaskType AVar2;
	LiveObject *pLVar3;
	ObjectType OVar4;
	LiveObject *pLVar5;
	bool bVar6;
	bool bVar7;
	float *pfVar8;
	BOOL BVar9;
	TutorialFlags TVar10;
	ObjectStatsFlags1 OVar11;
	SurfaceMap *surfMap;
	AITaskData *pAVar12;
	float fVar13;
	uint uVar14;
	LiveObject *aiTask;
	float10 fVar15;
	uint bx;
	Vector3F *out_vertPoses;
	void *local_6c;
	void *local_68;
	undefined local_64 [4];
	Point2I local_60;
	float local_58;
	VehicleData *local_54;
	float local_50;
	VehicleData *local_4c;
	Point2I local_48;
	float local_40;
	float local_3c;
	Point2I local_38;
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	pLVar3 = liveObj;
	globs::aiGlobs.flags |= 4;
	if (((((((liveObj->flags3 & LIVEOBJ3_UNK_400000) == LIVEOBJ3_NONE) ||
				 ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe)
					!= 0)) ||
				(BVar9 = game::LiveObject_Check_FUN_004294f0(liveObj), pfVar8 = param_2, BVar9 != 0)) ||
			 ((liveObj->drivenObject != NULL && (liveObj->objType == OBJECT_MINIFIGURE)))) ||
			(liveObj->carryingThisObject != NULL)) ||
		 (((liveObj->flags2 & (LIVEOBJ2_UNK_4000|LIVEOBJ2_UNK_8000000)) != LIVEOBJ2_NONE ||
			((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE)))) goto LAB_00404c90;
	pAVar12 = liveObj->aitask_2f0;
	local_6c = NULL;
	if (pAVar12 == NULL) {
		local_60.x = 0;
		local_60.y = 0;
		liveObj->float_338 = *param_2 + liveObj->float_338;
		game::LiveObject_GetBlockPos(liveObj,&local_38.x,&local_38.y);
		if (((liveObj->float_338 == *pfVar8) || ((*(byte *)&liveObj->flags4 & 0xc0) != 0)) ||
			 (BVar9 = game::LiveObject_FUN_004439d0(liveObj,&local_38,&local_60,0), BVar9 == 0)) {
			if ((ushort)((ushort)(liveObj->float_338 < 250.0) << 8 |
									(ushort)(liveObj->float_338 == 250.0) << 0xe) == 0) {
				if ((liveObj->objType == OBJECT_MINIFIGURE) &&
					 (BVar9 = game::LiveObject_Check_FUN_004294f0(liveObj), BVar9 == 0)) {
					game::LiveObject_FUN_00443930(liveObj);
				}
				liveObj->float_338 = 0.0;
			}
			else {
				liveObj = NULL;
				aiTask = (LiveObject *)globs::aiGlobs.AITaskUnkPtr;
				pLVar5 = (LiveObject *)globs::aiGlobs.AITaskUnkPtr;
				if (globs::aiGlobs.AITaskUnkPtr == NULL) {
LAB_00404c21:
					if (aiTask != NULL) {
						AITask_FUN_00406290((AITaskData *)aiTask,(AITaskData *)liveObj,pLVar3);
						goto LAB_00404c90;
					}
				}
				else {
					do {
						aiTask = pLVar5;
						fVar13 = aiTask->routing_points_4[5].x;
						if ((((((uint)fVar13 & 0x80000) == 0) &&
								 ((((uint)fVar13 & 0x100000) != 0 ||
									((BVar9 = game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(pLVar3),
									 BVar9 == 0 &&
									 (fVar13 = aiTask->routing_points_4[5].x, ((uint)fVar13 & 0x400) == 0)))))) &&
								((((uint)fVar13 & 0x100) != 0 ||
								 (BVar9 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar3,NULL),
								 BVar9 == 0)))) &&
							 ((((uint)aiTask->routing_points_4[5].x & 0x100) == 0 ||
								(BVar9 = game::LiveObject_FindIndexOfInTable
																	 ((LiveObject **)aiTask->routing_points_4[1].y,
																		(uint)aiTask->routing_points_4[2].x,pLVar3,NULL), BVar9 != 0))))
						{
							local_58 = (float)((Point2I *)&aiTask->customName)->x;
							local_54 = aiTask->vehicle;
							BVar9 = AITask_FUN_00404ef0((AITaskData *)aiTask,pLVar3,NULL,&local_58,&param_2,1,1);
							if ((BVar9 != 0) && (param_2 == NULL)) {
								if (((uint)aiTask->routing_points_4[5].x & 0x100000) != 0) goto LAB_00404c21;
								game::LiveObject_GetBlockPos(pLVar3,(int *)&local_50,(int *)&local_4c);
								OVar4 = aiTask->objType;
								if ((((OVar4 == OBJECT_UPGRADEPART) || (OVar4 == OBJECT_ELECTRICFENCE)) ||
										(OVar4 == 0x17)) ||
									 ((OVar4 == 0x15 ||
										((OVar4 == OBJECT_DYNAMITE &&
										 ((*(byte *)&aiTask->routing_points_4[5].x & 8) == 0)))))) {
									if (((local_58 == local_50) &&
											(uVar14 = (int)local_54 - (int)local_4c >> 0x1f,
											((int)local_54 - (int)local_4c ^ uVar14) - uVar14 == 1)) ||
										 ((local_54 == local_4c &&
											(uVar14 = (int)local_58 - (int)local_50 >> 0x1f,
											((int)local_58 - (int)local_50 ^ uVar14) - uVar14 == 1)))) goto LAB_00404c21;
								}
								else {
									if ((local_58 == local_50) && (local_54 == local_4c)) goto LAB_00404c21;
								}
							}
						}
						if ((((((uint)aiTask->routing_points_4[5].x & 0x400) != 0) &&
								 (BVar9 = game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(pLVar3),
								 BVar9 != 0)) && ((pLVar3->flags3 & LIVEOBJ3_UNK_200000) == LIVEOBJ3_NONE)) &&
							 (pLVar3->objType != OBJECT_ROCKMONSTER)) {
							pLVar5 = pLVar3->carriedObjects[0];
							if ((pLVar5->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
								if ((aiTask->upgrade == NULL) ||
									 (((pLVar5->objLevel == aiTask->routingBlocksTotal &&
										 ((aiTask->routeptr_24 == (RoutingBlock *)0xffffffff ||
											((RoutingBlock *)pLVar5->objIndex == aiTask->routeptr_24)))) &&
										((UpgradeData *)pLVar5->objType == aiTask->upgrade)))) {
									OVar4 = aiTask->objType;
									bVar6 = false;
									bVar7 = false;
									if (((OVar4 == OBJECT_ORE) || (OVar4 == OBJECT_BARRIER)) ||
										 ((OVar4 == OBJECT_PATH || (OVar4 == 0x14)))) {
LAB_00404b3f:
										bVar6 = true;
									}
									else {
										if (OVar4 == OBJECT_BOULDER) {
											if ((LiveObject *)aiTask->miniFigure == NULL) goto LAB_00404b3f;
											BVar9 = game::LiveObject_CheckCondition_AndIsPowered
																				((LiveObject *)aiTask->miniFigure,0);
											if (BVar9 != 0) {
												BVar9 = game::LiveObject_TryDeposit_FUN_0043a5c0
																					(pLVar3,(LiveObject *)aiTask->miniFigure);
												if (BVar9 != 0) goto LAB_00404c21;
												bVar7 = true;
											}
										}
									}
									if (bVar6) {
										if (aiTask->objType == OBJECT_BARRIER) {
											BVar9 = game::LiveObject_FUN_00431ba0
																				(pLVar3,(Point2I *)&aiTask->customName,&local_48,1);
											if (BVar9 == 0) {
												bVar7 = true;
											}
										}
										else {
											local_48.x = ((Point2I *)&aiTask->customName)->x;
											local_48.y = (int)aiTask->vehicle;
										}
										if (!bVar7) {
											game::LiveObject_GetBlockPos(pLVar3,(int *)&local_40,(int *)&local_3c);
											BVar9 = game::LiveObject_FUN_00440ef0
																				(pLVar3,local_40,local_3c,local_48.x,local_48.y,&local_6c,
																				 &local_68,local_64);
											if (BVar9 == 0) {
												bVar7 = true;
												goto LAB_00404bc6;
											}
											std::free(local_6c);
											std::free(local_68);
											goto LAB_00404c21;
										}
									}
									else {
LAB_00404bc6:
										if (!bVar7) goto LAB_00404bd1;
									}
									aiTask->building = (BuildingData *)0x42960000;
								}
							}
							else {
								if (aiTask->objType == 0x1b) goto LAB_00404c21;
							}
						}
LAB_00404bd1:
						if ((((uint)aiTask->routing_points_4[5].x & 0x100) != 0) &&
							 (BVar9 = game::LiveObject_FindIndexOfInTable
																	((LiveObject **)aiTask->routing_points_4[1].y,
																	 (uint)aiTask->routing_points_4[2].x,pLVar3,NULL), BVar9 != 0)) {
							aiTask = NULL;
							goto LAB_00404c21;
						}
						pLVar5 = (LiveObject *)aiTask->routing_points_4[5].y;
						liveObj = aiTask;
					} while (pLVar5 != NULL);
				}
				BVar9 = game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(pLVar3);
				if (BVar9 == 0) {
					if (globs::aiGlobs.liveObjsCount_1 < 0x32) {
						globs::aiGlobs.liveObjsTable_1[globs::aiGlobs.liveObjsCount_1] = pLVar3;
						globs::aiGlobs.liveObjsCount_1 += 1;
					}
					if (((globs::aiGlobs.liveObjsCount_2 < 0x32) && (pLVar3->objType == OBJECT_ROCKMONSTER))
						 && ((pLVar3->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)) {
						globs::aiGlobs.liveObjsTable_2[globs::aiGlobs.liveObjsCount_2] = pLVar3;
						globs::aiGlobs.liveObjsCount_2 += 1;
					}
				}
			}
		}
		else {
			if ((local_60.x != 0) && (local_60.y != 0)) {
				pAVar12 = AITask_Create(AITASK_GOTO);
				liveObj->aitask_2f0 = pAVar12;
				(pAVar12->blockPos).x = local_60.x;
				(pAVar12->blockPos).y = local_60.y;
			}
		}
		goto LAB_00404c90;
	}
	liveObj->float_338 = 0.0;
	uVar14 = pAVar12->flags_5c;
	if ((uVar14 & 0x20) != 0) {
		AITask_LiveObject_FUN_00404110(liveObj);
		game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
		goto LAB_00404c90;
	}
	AVar2 = pAVar12->taskType;
	if ((AVar2 == AITASK_WAIT) &&
		 ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
							(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0)) {
		AITask_LiveObject_FUN_00404110(liveObj);
	}
	else {
		if (AVar2 == AITASK_FOLLOW) {
			if ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
									(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0) {
				game::LiveObject_GetBlockPos(liveObj,&local_48.x,&local_48.y);
				game::LiveObject_GetBlockPos(pAVar12->object_10,(int *)&local_50,(int *)&local_4c);
				if (((float)local_48.x == local_50) && ((VehicleData *)local_48.y == local_4c))
				goto LAB_0040441c;
LAB_004043f4:
				AITask_LiveObject_FUN_00404d30(liveObj,&local_50,NULL);
				pAVar12->unkExpiryTime = 50.0;
			}
		}
		else {
			if (AVar2 == AITASK_FOLLOWATTACK) {
				if ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
										(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0) {
					fVar13 = pAVar12->object_10->health;
					fVar1 = pAVar12->object_10->stats->PainThreshold;
					if ((ushort)((ushort)(fVar13 < fVar1) << 8 | (ushort)(fVar13 == fVar1) << 0xe) == 0) {
						game::LiveObject_GetPosition(liveObj,(float *)&local_48,(float *)&local_48.y);
						game::LiveObject_GetPosition(pAVar12->object_10,&local_58,(float *)&local_54);
						fVar13 = SQRT(((float)local_48.y - (float)local_54) *
													((float)local_48.y - (float)local_54) +
													((float)local_48.x - local_58) * ((float)local_48.x - local_58));
						if ((ushort)((ushort)(fVar13 < 130.0) << 8 | (ushort)(fVar13 == 130.0) << 0xe) == 0) {
							game::LiveObject_GetBlockPos(liveObj,&local_60.x,&local_60.y);
							game::LiveObject_GetBlockPos(pAVar12->object_10,(int *)&local_50,(int *)&local_4c);
							if (((float)local_60.x != local_50) || ((VehicleData *)local_60.y != local_4c))
							goto LAB_004043f4;
						}
						else {
							BVar9 = game::LiveObject_Proc_FUN_00442190(liveObj,pAVar12->object_10,2);
							if (BVar9 == 0) {
								pAVar12->unkExpiryTime = 25.0;
								goto LAB_004047ed;
							}
						}
LAB_0040441c:
						pAVar12->unkExpiryTime = 50.0;
					}
					else {
						pAVar12->flags_5c = uVar14 | 0x20;
					}
				}
			}
			else {
				if (((uVar14 & 1) == 0) && ((liveObj->flags3 & LIVEOBJ3_UNK_200000) == LIVEOBJ3_NONE)) {
					BVar9 = 1;
					if (true) {
						switch(AVar2) {
						case AITASK_GOTO:
							game::LiveObject_GetBlockPos(liveObj,&local_48.x,&local_48.y);
							if ((local_48.x == (pAVar12->blockPos).x) &&
								 ((VehicleData *)local_48.y == (VehicleData *)(pAVar12->blockPos).y)) {
								BVar9 = 1;
								AITask_LiveObject_FUN_00404110(liveObj);
							}
							else {
								uVar14 = (pAVar12->blockPos).y;
								bx = (pAVar12->blockPos).x;
								out_vertPoses = local_30;
								surfMap = lrr::Lego_GetMap();
								game::Map3D_GetBlockVertexPositions2(surfMap,bx,uVar14,out_vertPoses);
								fVar15 = math::Maths_RandRange(local_30[0].x - -6.0,local_18 - 6.0);
								local_40 = (float)fVar15;
								fVar15 = math::Maths_RandRange(local_14 - -6.0,local_30[0].y - 6.0);
								local_3c = (float)fVar15;
								OVar11 = stats::StatsObject_GetStatsFlags1(liveObj);
								BVar9 = AITask_LiveObject_FUN_00404d30
																	(liveObj,(float *)&pAVar12->blockPos,
																	 (float *)(-(uint)((OVar11 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE
																										) & (uint)&local_40));
							}
							break;
						case AITASK_COLLECT:
							BVar9 = game::LiveObject_TryCollect_FUN_00439ce0(liveObj,pAVar12->object_10);
							break;
						case AITASK_GATHER:
							BVar9 = game::Game_PTL_GatherRock(liveObj);
							break;
						case AITASK_DEPOSITE:
							BVar9 = game::LiveObject_TryDeposit_FUN_0043a5c0(liveObj,pAVar12->object_10);
							break;
						case AITASK_DUMP:
							BVar9 = game::LiveObject_TryRequestOrDump_FUN_0043a3e0
																(liveObj,&pAVar12->blockPos,&pAVar12->pointf_30,1,uVar14 & 0x800);
							break;
						case AITASK_REQUEST:
							BVar9 = game::LiveObject_TryRequestOrDump_FUN_0043a3e0
																(liveObj,&pAVar12->blockPos,&pAVar12->pointf_30,1,uVar14 & 0x800);
							break;
						case AITASK_DIG:
							if ((((uVar14 & 8) != 0) &&
									(OVar11 = stats::StatsObject_GetStatsFlags1(liveObj),
									(OVar11 & STATS1_SINGLEWIDTHDIG) != STATS1_NONE)) ||
								 ((*(byte *)&pAVar12->flags_5c & 8) == 0)) {
								BVar9 = game::LiveObject_RouteToDig_FUN_00447100
																	(liveObj,(pAVar12->blockPos).x,(pAVar12->blockPos).y,
																	 pAVar12->flags_5c & 8);
							}
							break;
						case AITASK_DYNAMITE:
							BVar9 = game::LiveObject_TryDynamite_FUN_00448ac0(liveObj,&pAVar12->blockPos);
							break;
						case AITASK_REPAIR:
							BVar9 = game::LiveObject_TryRepair_FUN_00449360
																(liveObj,pAVar12->object_10,TRUE,uVar14 & 0x200000);
							break;
						case AITASK_REINFORCE:
							BVar9 = game::LiveObject_TryReinforce_FUN_00449500(liveObj,&pAVar12->blockPos);
							break;
						case AITASK_CLEAR:
							BVar9 = game::LiveObject_TryClear_FUN_00449570(liveObj,&pAVar12->blockPos);
							break;
						case AITASK_ELECFENCE:
							BVar9 = game::LiveObject_TryElecFence_FUN_00448d20(liveObj,&pAVar12->blockPos);
							break;
						case AITASK_EAT:
							BVar9 = game::LiveObject_TryGoEat_FUN_00449d80(liveObj,pAVar12->object_10);
							break;
						case AITASK_GOTOEAT:
							BVar9 = game::LiveObject_TryGoEat_FUN_00449d80(liveObj,pAVar12->object_10);
							break;
						case AITASK_FINDDRIVER:
							BVar9 = game::LiveObject_TryFindDriver_FUN_00440690(liveObj,pAVar12->object_10);
							break;
						case AITASK_GETTOOL:
							BVar9 = game::LiveObject_DoGetTool(liveObj,pAVar12->toolType);
							front::Bubble_LiveObject_UpdateBubbleImage(liveObj);
							break;
						case AITASK_BIRDSCARER:
							BVar9 = game::LiveObject_PlaceCarriedBirdScarerAt(liveObj,&pAVar12->blockPos);
							break;
						case AITASK_UPGRADE:
							BVar9 = game::LiveObject_TryUpgrade_FUN_00448f50
																(liveObj,pAVar12->object_10,pAVar12->objLevel);
							break;
						case AITASK_BUILDPATH:
							BVar9 = game::LiveObject_TryBuildPath_FUN_00448f10(liveObj);
							break;
						case AITASK_TRAIN:
							BVar9 = game::LiveObject_TryTrain_FUN_00449170(liveObj,pAVar12->object_10,0);
							break;
						case AITASK_DEPART:
							BVar9 = game::LiveObject_TryDepart_FUN_004499c0(liveObj);
							break;
						case AITASK_ATTACKPATH:
							BVar9 = game::LiveObject_TryAttackPath_FUN_004498d0(liveObj,&pAVar12->blockPos);
							break;
						case AITASK_ATTACKROCKMONSTER:
							pLVar3 = pAVar12->object_10;
							if ((pLVar3 == NULL) || (pLVar3->object_364 == NULL)) {
LAB_0040469f:
								BVar9 = game::LiveObject_TryAttackRockMonster_FUN_004496f0
																	(liveObj,pAVar12->object_10);
							}
							else {
								if ((pLVar3->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE) {
									TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
									if ((TVar10 == TUTORIAL_NONE) ||
										 (pAVar12->object_10->stats->PainThreshold <= pAVar12->object_10->health))
									goto LAB_0040469f;
									BVar9 = 0;
								}
								else {
									BVar9 = 0;
								}
							}
							break;
						case AITASK_RECHARGE:
							BVar9 = game::LiveObject_TryRecharge_FUN_004492d0(liveObj);
							break;
						case AITASK_DOCK:
							BVar9 = game::LiveObject_TryDock_FUN_004402b0(liveObj);
							break;
						case AITASK_ATTACKOBJECT:
							BVar9 = game::LiveObject_TryAttackObject_FUN_004497e0(liveObj,pAVar12->object_10);
							break;
						case AITASK_FINDLOAD:
							BVar9 = game::LiveObject_TryFindLoad_FUN_00440130(liveObj,pAVar12->object_10);
						}
					}
					if (BVar9 == 0) {
						local_6c = (void *)0x1;
					}
					else {
						pAVar12->flags_5c = pAVar12->flags_5c | 1;
					}
				}
			}
		}
	}
LAB_004047ed:
	if (local_6c != NULL) {
		if ((pAVar12->taskType == AITASK_DIG) && ((*(byte *)&pAVar12->flags_5c & 8) != 0)) {
			pAVar12->float_18 = (float)&DAT_42c80000;
		}
		if (((*(byte *)&pAVar12->flags_5c & 0x10) != 0) && (pAVar12->unkExpiryTime < 0.0)) {
			pAVar12->unkExpiryTime = 1500.0;
		}
		AITask_LiveObject_FUN_00404110(liveObj);
	}
LAB_00404c90:
	globs::aiGlobs.flags = globs::aiGlobs.flags & 0xfffffffb;
	return 0;
}



BOOL __cdecl
lego::ai::AITask_LiveObject_FUN_00404d30(LiveObject *in_liveObj,float *param_2,float *param_3)
{
	LiveObject *liveObj;
	BOOL BVar1;
	float *local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	game::LiveObject_GetBlockPos(in_liveObj,(int *)&local_8,(int *)&local_4);
	if ((local_8 == *param_2) && (local_4 == param_2[1])) {
		in_liveObj = (LiveObject *)&local_8;
		local_10 = &local_4;
		local_c = 1;
	}
	else {
		BVar1 = game::LiveObject_FUN_00440ef0
											(liveObj,local_8,local_4,*param_2,param_2[1],&in_liveObj,&local_10,&local_c);
		if (BVar1 == 0) {
			return 0;
		}
	}
	game::LiveObject_RoutingPtr_Alloc_FUN_004419c0
						(liveObj,local_c,(float *)in_liveObj,local_10,param_3);
	if (in_liveObj != (LiveObject *)&local_8) {
		std::free(in_liveObj);
		std::free(local_10);
	}
	return TRUE;
}



BOOL __cdecl lego::ai::AITask_LiveObject_FUN_00404e00(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->objType == OBJECT_POWERCRYSTAL) &&
		 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) {
		BVar1 = game::LiveObject_FindRechargeSeam_FUN_0044a690(liveObj,NULL);
		return BVar1;
	}
	BVar1 = AITask_FUN_00404e40(liveObj->objType,liveObj->objIndex,liveObj->objLevel);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_FUN_00404e40(ObjectType objType,int objIndex,int objLevel)
{
	BOOL BVar1;
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	local_c = objType;
	local_8 = objIndex;
	local_4 = (char *)objLevel;
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00404e80,(LiveObject *)&local_c);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00404e80(AITaskData *aiTask,int *param_2)
{
	AITaskType AVar1;
	BOOL BVar2;
	
	AVar1 = aiTask->taskType;
	if (AVar1 != AITASK_DEPOSITE) {
		if (((AVar1 != AITASK_REQUEST) && (AVar1 != AITASK_DYNAMITE)) && (AVar1 != AITASK_ELECFENCE)) {
			return 0;
		}
		if (((AVar1 != AITASK_DEPOSITE) && (aiTask->object_10 != NULL)) &&
			 (BVar2 = game::LiveObject_CheckCondition_AndIsPowered(aiTask->object_10,0), BVar2 == 0)) {
			return 0;
		}
	}
	if ((aiTask->objType != OBJECT_NONE) &&
		 (((*param_2 != aiTask->objType ||
			 ((aiTask->objIndex != -1 && (param_2[1] != aiTask->objIndex)))) ||
			(param_2[2] != aiTask->objLevel)))) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl
lego::ai::AITask_FUN_00404ef0
					(AITaskData *aiTask,LiveObject *liveObj_2,float *param_3,float *param_4,
					undefined4 *param_5,int param_6,int param_7)
{
	Point2I *blockPos;
	AITaskType AVar1;
	ObjectType OVar2;
	LiveFlags5 LVar3;
	ObjectStatsFlags1 OVar4;
	BOOL BVar5;
	Container *pCVar6;
	ObjectStatsFlags3 OVar7;
	SurfaceMap *pSVar8;
	int iVar9;
	LiveObject *pLVar10;
	BOOL BVar11;
	float10 fVar12;
	float fVar13;
	uint uVar14;
	float by;
	uint uVar15;
	float *pfVar16;
	Vector3F local_18;
	Vector3F local_c;
	
	if (param_5 != NULL) {
		*param_5 = 0;
	}
	if (((aiTask->taskType != AITASK_COLLECT) || (aiTask->object_10->objType != OBJECT_DYNAMITE)) &&
		 ((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe) ==
			0)) {
		return 0;
	}
	OVar4 = stats::StatsObject_GetStatsFlags1(liveObj_2);
	if (((OVar4 & STATS1_CANBEDRIVEN) != STATS1_NONE) && (liveObj_2->drivenObject == NULL)) {
		return 0;
	}
	if ((liveObj_2->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) {
		return 0;
	}
	if ((liveObj_2->flags4 & 0x400) != LIVEOBJ4_NONE) {
		return 0;
	}
	if (((((byte)globs::legoGlobs.flags2 & 1) != 0) &&
			(BVar5 = game::LiveObject_MiniFigureHasBeamEquipped2(liveObj_2), BVar5 != 0)) &&
		 (aiTask->taskType != AITASK_ATTACKROCKMONSTER)) {
		return 0;
	}
	AVar1 = aiTask->taskType;
	if (AVar1 == AITASK_ATTACKROCKMONSTER) {
		BVar5 = game::LiveObject_MiniFigureHasBeamEquipped(liveObj_2);
		if (BVar5 == 0) {
			return 0;
		}
		BVar5 = game::LiveObject_FUN_004723f0(liveObj_2,&aiTask->object_10->objType);
		if (BVar5 == 0) {
			return 0;
		}
		BVar5 = game::LiveObject_SeeThroughWalls_FUN_00471c20(liveObj_2,aiTask->object_10);
		if (BVar5 != 0) {
			return 0;
		}
		BVar5 = game::LiveObject_CheckCondition_AndIsPowered(aiTask->object_10,1);
		if (BVar5 == 0) {
			return 0;
		}
		if (((byte)globs::legoGlobs.flags2 & GAME2_CALLTOARMS) == 0) {
			return 0;
		}
		if (param_3 != NULL) {
			game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
		}
		if (param_4 != NULL) {
			game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
			return 1;
		}
	}
	else {
		if (AVar1 == AITASK_FINDLOAD) {
			pCVar6 = game::LiveObject_GetDepositNull(aiTask->object_10);
			if ((pCVar6 == NULL) ||
				 (OVar7 = stats::StatsObject_GetStatsFlags3(liveObj_2),
				 (OVar7 & STATS3_VEHICLECANBECARRIED) == STATS3_NONE)) {
				return 0;
			}
			res::Container_GetPosition(pCVar6,NULL,&local_18);
			if (param_3 != NULL) {
				*param_3 = local_18.x;
				param_3[1] = local_18.y;
			}
			if (param_4 != NULL) {
				pfVar16 = param_4 + 1;
				pSVar8 = lrr::Lego_GetMap();
				game::Map3D_WorldToBlockPos_NoZ(pSVar8,local_18.x,local_18.y,(int *)param_4,(int *)pfVar16);
				return 1;
			}
		}
		else {
			if (AVar1 == AITASK_COLLECT) {
				if ((*(byte *)&liveObj_2->flags3 & 0x40) == 0) {
					return 0;
				}
				BVar5 = game::LiveObject_FUN_00439e90(liveObj_2,aiTask->object_10,1);
				if (BVar5 == 0) {
					return 0;
				}
				if ((liveObj_2->objType == OBJECT_VEHICLE) &&
					 (iVar9 = stats::StatsObject_GetMaxCarry(liveObj_2), iVar9 == 0)) {
					return 0;
				}
				pLVar10 = aiTask->object_10;
				OVar2 = pLVar10->objType;
				if (((OVar2 == OBJECT_DYNAMITE) && ((*(byte *)&liveObj_2->flags5 & 8) == 0)) &&
					 (param_7 != 0)) {
					return 0;
				}
				if ((liveObj_2->objType == OBJECT_ROCKMONSTER) && (OVar2 != OBJECT_POWERCRYSTAL)) {
					return 0;
				}
				if (liveObj_2->objType == OBJECT_VEHICLE) {
					if (OVar2 == OBJECT_BARRIER) {
						return 0;
					}
					if (true) {
						if ((OVar2 == OBJECT_POWERCRYSTAL) &&
							 ((pLVar10->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) {
							return 0;
						}
						if (((true) && ((liveObj_2->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
							 (liveObj_2->carriedObjects[0]->objType == OBJECT_ELECTRICFENCE)) {
							return 0;
						}
					}
				}
				BVar5 = AITask_LiveObject_FUN_00404e00(pLVar10);
				if (BVar5 == 0) {
					return 0;
				}
				BVar5 = game::LiveObject_FUN_00439e40(liveObj_2,aiTask->object_10);
				if (BVar5 == 0) {
					return 0;
				}
				if (param_3 != NULL) {
					game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
				}
				if (param_4 != NULL) {
					game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
					return 1;
				}
			}
			else {
				if (((AVar1 == AITASK_DIG) || (AVar1 == AITASK_GOTO)) ||
					 ((AVar1 == AITASK_REINFORCE || (AVar1 == AITASK_CLEAR)))) {
					BVar5 = 1;
					if (AVar1 == AITASK_DIG) {
						BVar5 = game::LiveObject_BlockCheck_FUN_004326a0
															(liveObj_2,(aiTask->blockPos).x,(aiTask->blockPos).y,
															 aiTask->flags_5c & 8,1);
					}
					if (((param_6 != 0) && (AVar1 = aiTask->taskType, AVar1 != AITASK_GOTO)) &&
						 ((AVar1 != AITASK_DYNAMITE &&
							(BVar11 = game::LiveObject_TaskHasTool_FUN_0044b780(liveObj_2,AVar1), BVar11 == 0))))
					{
						return 0;
					}
					if ((aiTask->taskType == AITASK_REINFORCE) && (liveObj_2->objType != OBJECT_MINIFIGURE)) {
						return 0;
					}
					if ((aiTask->taskType == AITASK_CLEAR) &&
						 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj_2),
						 (OVar4 & STATS1_CANCLEARRUBBLE) == STATS1_NONE)) {
						return 0;
					}
					if (aiTask->taskType == AITASK_DIG) {
						if ((*(byte *)&liveObj_2->flags3 & 2) == 0) {
							return 0;
						}
						if (BVar5 == 0) {
							return 0;
						}
						if (((*(byte *)&aiTask->flags_5c & 8) != 0) &&
							 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj_2),
							 (OVar4 & STATS1_SINGLEWIDTHDIG) == STATS1_NONE)) {
							return 0;
						}
					}
					if (param_3 != NULL) {
						uVar15 = (aiTask->blockPos).y;
						pfVar16 = param_3 + 1;
						uVar14 = (aiTask->blockPos).x;
						pSVar8 = lrr::Lego_GetMap();
						game::Map3D_BlockToWorldPos(pSVar8,uVar14,uVar15,param_3,pfVar16);
					}
					if (param_4 != NULL) {
						*param_4 = (float)(aiTask->blockPos).x;
						param_4[1] = (float)(aiTask->blockPos).y;
					}
				}
				else {
					if (AVar1 == AITASK_REPAIR) {
						if ((param_6 != 0) &&
							 (BVar5 = game::LiveObject_TaskHasTool_FUN_0044b780(liveObj_2,AITASK_REPAIR),
							 BVar5 == 0)) {
							return 0;
						}
						if (((param_7 != 0) && ((*(byte *)&liveObj_2->flags5 & 0x10) == 0)) &&
							 ((aiTask->flags_5c & 0x200000) == 0)) {
							return 0;
						}
						if (liveObj_2->objType != OBJECT_MINIFIGURE) {
							return 0;
						}
						if (param_3 != NULL) {
							game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
							if (param_4 == NULL) {
								return 1;
							}
							game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
							return 1;
						}
					}
					else {
						if (AVar1 == AITASK_GOTOEAT) {
							BVar5 = game::LiveObject_CheckCondition_AndIsPowered(aiTask->object_10,0);
							if (BVar5 == 0) {
								return 0;
							}
							if (((liveObj_2->objType == OBJECT_MINIFIGURE) &&
									((liveObj_2->flags2 & LIVEOBJ2_UNK_800) == LIVEOBJ2_NONE)) &&
								 (fVar13 = liveObj_2->health * 0.01 * globs::legoGlobs.MinEnergyForEat,
								 (ushort)((ushort)(liveObj_2->energy < fVar13) << 8 |
												 (ushort)(liveObj_2->energy == fVar13) << 0xe) != 0)) {
								if ((liveObj_2->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
									return 1;
								}
								return 0;
							}
							return 0;
						}
						if (AVar1 == AITASK_FINDDRIVER) {
							if ((((liveObj_2->objType != OBJECT_MINIFIGURE) || (liveObj_2->aitask_2f0 != NULL)) ||
									(liveObj_2->drivenObject != NULL)) ||
								 (((aiTask->mode_3c & liveObj_2->flags5) == LIVEOBJ5_NONE && (param_7 != 0)))) {
								return 0;
							}
							OVar4 = stats::StatsObject_GetStatsFlags1(aiTask->object_10);
							if ((OVar4 & STATS1_CROSSLAND) == STATS1_NONE) {
								if ((((*(byte *)&aiTask->object_10->flags4 & 0x40) != 0) &&
										(pLVar10 = aiTask->object_10->object_2fc, pLVar10 != NULL)) &&
									 ((pLVar10->objType == OBJECT_BUILDING &&
										(pCVar6 = res::Building_GetEntranceNull(pLVar10->building), pCVar6 != NULL)))) {
									res::Container_GetPosition(pCVar6,NULL,&local_c);
									if (param_3 != NULL) {
										*param_3 = local_c.x;
										param_3[1] = local_c.y;
									}
									if (param_4 == NULL) {
										return 1;
									}
									pfVar16 = param_4 + 1;
									pSVar8 = lrr::Lego_GetMap();
									game::Map3D_WorldToBlockPos_NoZ
														(pSVar8,local_c.x,local_c.y,(int *)param_4,(int *)pfVar16);
									return 1;
								}
								BVar5 = game::LiveObject_CheckUnkGetInAtLand_FUN_0043a100
																	(aiTask->object_10,(Point2I *)&local_18);
								if (BVar5 == 0) {
									return 0;
								}
								if (param_3 != NULL) {
									pfVar16 = param_3 + 1;
									fVar13 = local_18.x;
									by = local_18.y;
									pSVar8 = lrr::Lego_GetMap();
									game::Map3D_BlockToWorldPos(pSVar8,(uint)fVar13,(uint)by,param_3,pfVar16);
								}
								if (param_4 == NULL) {
									return 1;
								}
								*param_4 = local_18.x;
								param_4[1] = local_18.y;
								return 1;
							}
							if (param_3 != NULL) {
								game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
								if (param_4 == NULL) {
									return 1;
								}
								game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
								return 1;
							}
						}
						else {
							if (AVar1 == AITASK_UPGRADE) {
								if (liveObj_2->objType != OBJECT_VEHICLE) {
									return 0;
								}
								if (liveObj_2->drivenObject != NULL) {
									pCVar6 = game::LiveObject_GetDepositNull(aiTask->object_10);
									res::Container_GetPosition(pCVar6,NULL,&local_c);
									if (param_3 != NULL) {
										*param_3 = local_c.x;
										param_3[1] = local_c.y;
									}
									if (param_4 == NULL) {
										return 1;
									}
									pfVar16 = param_4 + 1;
									pSVar8 = lrr::Lego_GetMap();
									game::Map3D_WorldToBlockPos_NoZ
														(pSVar8,local_c.x,local_c.y,(int *)param_4,(int *)pfVar16);
									return 1;
								}
								return 0;
							}
							if (AVar1 != AITASK_TRAIN) {
								if (AVar1 != AITASK_BUILDPATH) {
									if (AVar1 == AITASK_GETTOOL) {
										if (((liveObj_2->objType == OBJECT_MINIFIGURE) &&
												(iVar9 = stats::StatsObject_GetNumOfToolsCanCarry(liveObj_2), iVar9 != 0))
											 && (BVar5 = game::LiveObject_HasToolEquipped(liveObj_2,aiTask->toolType),
													BVar5 == 0)) {
											game::LiveObject_GetPosition(liveObj_2,&local_18.x,&local_18.y);
											pLVar10 = game::Level_GetBuildingAtPosition((Point2F *)&local_18);
											if (pLVar10 != NULL) {
												if (param_3 == NULL) {
													return 1;
												}
												game::LiveObject_GetPosition(pLVar10,param_3,param_3 + 1);
												return 1;
											}
										}
										return 0;
									}
									if (param_5 == NULL) {
										return 1;
									}
									*param_5 = 1;
									return 1;
								}
								if (liveObj_2->objType != OBJECT_MINIFIGURE) {
									return 0;
								}
								blockPos = &aiTask->blockPos;
								BVar5 = game::Level_IsBuildPathBoolUnk_true(blockPos);
								if (BVar5 != 0) {
									if (param_3 != NULL) {
										uVar15 = (aiTask->blockPos).y;
										pfVar16 = param_3 + 1;
										uVar14 = blockPos->x;
										pSVar8 = lrr::Lego_GetMap();
										game::Map3D_BlockToWorldPos(pSVar8,uVar14,uVar15,param_3,pfVar16);
									}
									if (param_4 == NULL) {
										return 1;
									}
									*param_4 = (float)blockPos->x;
									param_4[1] = (float)(aiTask->blockPos).y;
									return 1;
								}
								return 0;
							}
							if (liveObj_2->objType != OBJECT_MINIFIGURE) {
								return 0;
							}
							LVar3 = liveObj_2->flags5;
							if (((LVar3 & LIVEOBJ5_ABILITY_PILOT) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 1)) {
								return 0;
							}
							if (((LVar3 & LIVEOBJ5_ABILITY_SAILOR) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 2)) {
								return 0;
							}
							if (((LVar3 & LIVEOBJ5_ABILITY_DRIVER) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 4)) {
								return 0;
							}
							if (((LVar3 & LIVEOBJ5_ABILITY_DYNAMITE) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 8))
							{
								return 0;
							}
							if (((LVar3 & LIVEOBJ5_ABILITY_REPAIR) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 0x10))
							{
								return 0;
							}
							if (((LVar3 & LIVEOBJ5_ABILITY_SCANNER) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 0x20)
								 ) {
								return 0;
							}
							fVar12 = lrr::Lego_GetTrainTime();
							if ((ushort)((ushort)(fVar12 < (float10)liveObj_2->elapsedTime1) << 8 |
													(ushort)(fVar12 == (float10)liveObj_2->elapsedTime1) << 0xe) == 0) {
								return 0;
							}
							if (param_3 != NULL) {
								game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
							}
						}
					}
					if (param_4 != NULL) {
						game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
						return 1;
					}
				}
			}
		}
	}
	return 1;
}



void __cdecl lego::ai::AITask_FUN_00405880(void)
{
	LiveObject *liveObj;
	AITaskType AVar1;
	float fVar2;
	float fVar3;
	bool bVar4;
	BOOL BVar5;
	int iVar6;
	ObjectStatsFlags2 OVar7;
	AITaskData *pAVar8;
	uint uVar9;
	AITaskData *aiTask;
	float10 fVar10;
	LiveObject **local_24;
	AITaskData *local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	int local_8;
	int local_4;
	
	local_1c = NULL;
	pAVar8 = globs::aiGlobs.AITaskDataNext;
	if (globs::aiGlobs.AITaskDataNext != NULL) {
		do {
			aiTask = pAVar8;
			if ((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe)
					!= 0) {
				bVar4 = false;
				uVar9 = 0;
				if (globs::aiGlobs.liveObjsCount_2 != 0) {
					local_24 = globs::aiGlobs.liveObjsTable_2;
					do {
						liveObj = *local_24;
						game::LiveObject_GetPosition(liveObj,&local_18,&local_14);
						game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
						fVar10 = stats::StatsObject_GetPainThreshold(liveObj);
						if (fVar10 < (float10)liveObj->health) {
							AVar1 = aiTask->taskType;
							if (AVar1 == AITASK_GATHER) {
								BVar5 = game::LiveObject_IsRockMonsterCanGather(liveObj);
								if ((BVar5 != 0) &&
									 (iVar6 = game::LiveManager_FUN_004373c0(OBJECT_BUILDING,0), iVar6 != 0)) {
									bVar4 = true;
								}
							}
							else {
								if (AVar1 == AITASK_REPAIR) {
									OVar7 = stats::StatsObject_GetStatsFlags2(liveObj);
									if (((OVar7 & STATS2_DRAINPOWER) == STATS2_NONE) ||
										 ((BVar5 = game::LiveObject_CheckCondition_AndIsPowered(aiTask->object_10,0),
											BVar5 != 0 &&
											(OVar7 = stats::StatsObject_GetStatsFlags2(aiTask->object_10),
											(OVar7 & STATS2_SELFPOWERED) == STATS2_NONE)))) {
										game::LiveObject_GetPosition(aiTask->object_10,&local_10,&local_c);
										fVar3 = local_18 - local_10;
										fVar2 = local_14 - local_c;
										fVar10 = stats::StatsObject_GetAttackRadius(liveObj);
										if ((float10)SQRT(fVar2 * fVar2 + fVar3 * fVar3) < fVar10) {
											bVar4 = true;
											OVar7 = stats::StatsObject_GetStatsFlags2(liveObj);
											if ((OVar7 & STATS2_DRAINPOWER) == STATS2_NONE) {
												aiTask->float_18 = 750.0;
											}
										}
									}
								}
								else {
									if (AVar1 == AITASK_COLLECT) {
										iVar6 = game::LiveObject_CheckCanSteal(liveObj);
joined_r0x00405a76:
										if (iVar6 != 0) {
											bVar4 = true;
											aiTask->float_18 = 250.0;
										}
									}
									else {
										if (AVar1 == AITASK_ATTACKPATH) {
											OVar7 = stats::StatsObject_GetStatsFlags2(liveObj);
											if ((OVar7 & STATS2_ATTACKPATHS) != STATS2_NONE) {
												bVar4 = true;
											}
										}
										else {
											if (AVar1 == AITASK_GOTO) {
												BVar5 = game::LiveObject_IsRockMonsterCanGather(liveObj);
												if ((BVar5 != 0) &&
													 (((aiTask->blockPos).x != local_8 || ((aiTask->blockPos).y != local_4))))
												{
													bVar4 = true;
												}
											}
											else {
												if (AVar1 == AITASK_ATTACKOBJECT) {
													iVar6 = game::LiveObject_IsRockMonsterCanGather(liveObj);
													goto joined_r0x00405a76;
												}
											}
										}
									}
								}
							}
						}
						if ((aiTask->taskType == AITASK_DEPART) &&
							 ((BVar5 = game::LiveObject_IsRockMonsterCanGather(liveObj), BVar5 != 0 ||
								(OVar7 = stats::StatsObject_GetStatsFlags2(liveObj),
								(OVar7 & STATS2_USEHOLES) != STATS2_NONE)))) {
							bVar4 = true;
						}
						if (bVar4) {
							iVar6 = globs::aiGlobs.liveObjsCount_2 - 1;
							globs::aiGlobs.liveObjsCount_2 = globs::aiGlobs.liveObjsCount_2 - 1;
							globs::aiGlobs.liveObjsTable_2[uVar9] = globs::aiGlobs.liveObjsTable_2[iVar6];
							if ((*(byte *)&aiTask->flags_5c & 0x40) == 0) {
								if (local_1c == NULL) {
									globs::aiGlobs.AITaskDataNext = aiTask->next;
								}
								else {
									local_1c->next = aiTask->next;
								}
								aiTask->next = NULL;
								liveObj->aitask_2f0 = aiTask;
							}
							else {
								pAVar8 = AITask_FUN_00406330(aiTask);
								liveObj->aitask_2f0 = pAVar8;
							}
							break;
						}
						uVar9 += 1;
						local_24 = local_24 + 1;
					} while (uVar9 < globs::aiGlobs.liveObjsCount_2);
				}
			}
			pAVar8 = aiTask->next;
			local_1c = aiTask;
		} while (aiTask->next != NULL);
	}
	return;
}



void __cdecl lego::ai::AITask_FUN_00405b40(void)
{
	AITaskType AVar1;
	bool bVar2;
	int iVar3;
	AITaskData *pAVar4;
	BOOL BVar5;
	SurfaceMap *pSVar6;
	BOOL BVar7;
	uint uVar8;
	LiveObject *pLVar9;
	LiveObject *pLVar10;
	LiveObject **ppLVar11;
	AITaskData *aiTask;
	float fVar12;
	float fVar13;
	Point2I *pPVar14;
	int *out_bx;
	int *piVar15;
	LiveObject *local_94;
	LiveObject *local_90;
	LiveObject **local_8c;
	MessageType local_88;
	uint local_84;
	Point2I local_80;
	MessageType local_78;
	float local_74;
	float local_70;
	Point2I local_6c;
	int local_64;
	int local_60;
	uint local_5c;
	int local_58;
	int local_54;
	AITaskData *local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	void *local_38;
	int local_34;
	void *local_30;
	Point2F local_2c;
	Point2I local_24;
	float local_18;
	undefined local_14 [4];
	Point2I local_10;
	Point2F local_8;
	
	local_50 = NULL;
	local_44 = 99999.0;
	pAVar4 = globs::aiGlobs.AITaskUnkPtr;
	if (globs::aiGlobs.AITaskUnkPtr != NULL) {
		do {
			aiTask = pAVar4;
			if (((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe
									 ) != 0) && ((aiTask->flags_5c & 0x80400) == 0)) {
				pLVar9 = NULL;
				local_90 = NULL;
				local_84 = 0;
				if (globs::aiGlobs.liveObjsCount_1 != 0) {
					local_8c = globs::aiGlobs.liveObjsTable_1;
					pLVar10 = pLVar9;
					do {
						pLVar9 = *local_8c;
						if (pLVar9 != NULL) {
							if ((aiTask->flags_5c & 0x100) == 0) {
								BVar5 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar9,NULL);
								pLVar10 = local_90;
								if (BVar5 == 0) {
									if ((aiTask->flags_5c & 0x100) != 0) goto LAB_00405bda;
									goto LAB_00405bf5;
								}
							}
							else {
LAB_00405bda:
								BVar5 = game::LiveObject_FindIndexOfInTable
																	((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar9,NULL);
								pLVar10 = local_90;
								if (BVar5 != 0) {
LAB_00405bf5:
									game::LiveObject_GetPosition(pLVar9,&local_4c,&local_48);
									BVar5 = AITask_FUN_00404ef0(aiTask,pLVar9,&local_74,NULL,&local_34,1,1);
									if (BVar5 != 0) {
										piVar15 = &local_6c.y;
										pPVar14 = &local_6c;
										fVar12 = local_74;
										fVar13 = local_70;
										pSVar6 = lrr::Lego_GetMap();
										BVar7 = game::Map3D_WorldToBlockPos_NoZ
																			(pSVar6,fVar12,fVar13,&pPVar14->x,piVar15);
										if (BVar7 != 0) {
											piVar15 = &local_60;
											out_bx = &local_64;
											fVar12 = local_4c;
											fVar13 = local_48;
											pSVar6 = lrr::Lego_GetMap();
											BVar7 = game::Map3D_WorldToBlockPos_NoZ(pSVar6,fVar12,fVar13,out_bx,piVar15);
											if (BVar7 != 0) {
												AVar1 = aiTask->taskType;
												local_94 = (LiveObject *)0x1;
												if ((((((AVar1 == AITASK_DIG) && ((*(byte *)&aiTask->flags_5c & 8) == 0)) ||
															(AVar1 == AITASK_REPAIR)) ||
														 ((AVar1 == AITASK_REINFORCE || (AVar1 == AITASK_TRAIN)))) ||
														(AVar1 == AITASK_GETTOOL)) &&
													 (((local_64 != local_6c.x ||
														 (uVar8 = local_60 - local_6c.y >> 0x1f,
														 (local_60 - local_6c.y ^ uVar8) - uVar8 != 1)) &&
														((local_60 != local_6c.y ||
														 (uVar8 = local_64 - local_6c.x >> 0x1f,
														 (local_64 - local_6c.x ^ uVar8) - uVar8 != 1)))))) {
													local_24.x = local_6c.x;
													local_24.y = local_6c.y;
													BVar7 = game::LiveObject_FUN_00431ba0(local_90,&local_24,&local_6c,1);
													if (BVar7 == 0) {
														local_94 = (LiveObject *)BVar7;
													}
												}
												if (local_94 != NULL) {
													BVar5 = game::LiveObject_FUN_00440ef0
																						(pLVar9,local_64,local_60,local_6c.x,local_6c.y,
																						 &local_30,&local_38,local_14);
													if (BVar5 == 0) {
														aiTask->float_18 = 75.0;
													}
													else {
														std::free(local_30);
														std::free(local_38);
													}
												}
											}
										}
									}
									if (local_34 != 0) {
										local_5c = local_84;
										local_40 = local_74;
										local_3c = local_70;
										break;
									}
									pLVar10 = local_90;
									if (BVar5 != 0) {
										local_18 = local_70 - local_48;
										fVar12 = SQRT(local_18 * local_18 +
																	(local_74 - local_4c) * (local_74 - local_4c));
										game::LiveObject_GetFaceDirection(pLVar9,&local_8);
										if ((local_90 == NULL) || (fVar12 < local_44)) {
											local_5c = local_84;
											local_40 = local_74;
											local_3c = local_70;
											pLVar10 = pLVar9;
											local_90 = pLVar9;
											local_44 = fVar12;
										}
									}
								}
							}
						}
						pLVar9 = pLVar10;
						local_84 += 1;
						local_8c = local_8c + 1;
						pLVar10 = pLVar9;
					} while (local_84 < globs::aiGlobs.liveObjsCount_1);
				}
				if (pLVar9 == NULL) {
					if (((aiTask->flags_5c & 0x1000) == 0) && (uVar8 = 0, globs::aiGlobs.liveObjsCount_1 != 0)
						 ) {
						ppLVar11 = globs::aiGlobs.liveObjsTable_1;
						do {
							pLVar9 = *ppLVar11;
							if (pLVar9 != NULL) {
								if ((aiTask->flags_5c & 0x100) == 0) {
									BVar5 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar9,NULL);
									if (BVar5 == 0) {
										if ((aiTask->flags_5c & 0x100) != 0) goto LAB_004060b6;
										goto LAB_004060cd;
									}
								}
								else {
LAB_004060b6:
									BVar5 = game::LiveObject_FindIndexOfInTable
																		((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar9,NULL);
									if (BVar5 != 0) {
LAB_004060cd:
										BVar5 = AITask_FUN_00404ef0(aiTask,pLVar9,NULL,NULL,NULL,0,1);
										if (BVar5 != 0) {
											AITask_DoGetTool_FromTask(aiTask);
											break;
										}
									}
								}
							}
							uVar8 += 1;
							ppLVar11 = ppLVar11 + 1;
						} while (uVar8 < globs::aiGlobs.liveObjsCount_1);
					}
					if (((aiTask->taskType != AITASK_TRAIN) && (aiTask->mode_3c != 0)) &&
						 ((aiTask->flags_5c & 0x8000) == 0)) {
						uVar8 = 0;
						local_94 = NULL;
						bVar2 = false;
						if (globs::aiGlobs.liveObjsCount_1 != 0) {
							ppLVar11 = globs::aiGlobs.liveObjsTable_1;
							do {
								pLVar9 = *ppLVar11;
								if (pLVar9 != NULL) {
									if ((aiTask->flags_5c & 0x100) == 0) {
										BVar5 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar9,NULL);
										if (BVar5 == 0) {
											if ((aiTask->flags_5c & 0x100) != 0) goto LAB_0040615f;
											goto LAB_00406176;
										}
									}
									else {
LAB_0040615f:
										BVar5 = game::LiveObject_FindIndexOfInTable
																			((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar9,NULL);
										if (BVar5 != 0) {
LAB_00406176:
											BVar5 = AITask_FUN_00404ef0(aiTask,pLVar9,&local_2c.x,NULL,NULL,0,0);
											if ((BVar5 != 0) &&
												 (BVar5 = AITask_FUN_00404ef0(aiTask,pLVar9,&local_2c.x,NULL,NULL,0,1),
												 local_94 = pLVar9, BVar5 != 0)) {
												bVar2 = true;
												break;
											}
										}
									}
								}
								uVar8 += 1;
								ppLVar11 = ppLVar11 + 1;
							} while (uVar8 < globs::aiGlobs.liveObjsCount_1);
						}
						if (((local_94 != NULL) && (!bVar2)) &&
							 (pLVar9 = (LiveObject *)FUN_00439110(NULL,&local_2c,aiTask->mode_3c), pLVar9 != NULL)
							 ) {
							AITask_DoTrain_Target
												(pLVar9,aiTask->mode_3c,(uint)(aiTask->mode_3c != TRAINED_REPAIR));
							aiTask->flags_5c = aiTask->flags_5c | 0x8000;
						}
					}
				}
				else {
					bVar2 = true;
					game::LiveObject_GetBlockPos(pLVar9,&local_58,&local_54);
					piVar15 = &local_80.y;
					pPVar14 = &local_80;
					fVar12 = local_40;
					fVar13 = local_3c;
					pSVar6 = lrr::Lego_GetMap();
					game::Map3D_WorldToBlockPos_NoZ(pSVar6,fVar12,fVar13,&pPVar14->x,piVar15);
					AVar1 = aiTask->taskType;
					if (((((AVar1 == AITASK_CLEAR) || (AVar1 == AITASK_COLLECT)) ||
							 (AVar1 == AITASK_BUILDPATH)) || (AVar1 == AITASK_UPGRADE)) &&
						 ((local_58 != local_80.x || (local_54 != local_80.y)))) {
						if (aiTask->object_48 == NULL) {
							if (true) {
								switch(AVar1) {
								case AITASK_COLLECT:
									local_78 = MESSAGE_COLLECTCRYSTAL;
									break;
								case AITASK_CLEAR:
									local_78 = MESSAGE_CLEAR;
									break;
								case AITASK_UPGRADE:
									local_78 = MESSAGE_UPGRADE;
									break;
								case AITASK_BUILDPATH:
									local_78 = MESSAGE_BUILDPATH;
								}
							}
							game::Message_AddMessageAction(local_78,pLVar9,aiTask,&local_80);
							if ((aiTask->flags_5c & 0x100) == 0) {
								aiTask->object_48 = pLVar9;
							}
							if ((aiTask->taskType == AITASK_CLEAR) && (pLVar9->objType == OBJECT_VEHICLE)) {
								AITask_DoCallbacks_Block_FUN_00402a90(&aiTask->blockPos,TRUE);
								aiTask->float_18 = 0.0;
							}
						}
LAB_00406042:
						bVar2 = false;
					}
					else {
						if ((((AVar1 == AITASK_DIG) && ((*(byte *)&aiTask->flags_5c & 8) == 0)) ||
								(((AVar1 == AITASK_REPAIR || (AVar1 == AITASK_REINFORCE)) ||
								 ((AVar1 == AITASK_TRAIN || (AVar1 == AITASK_GETTOOL)))))) &&
							 (((local_58 != local_80.x ||
								 (uVar8 = local_54 - local_80.y >> 0x1f,
								 (local_54 - local_80.y ^ uVar8) - uVar8 != 1)) &&
								((local_54 != local_80.y ||
								 (uVar8 = local_58 - local_80.x >> 0x1f,
								 (local_58 - local_80.x ^ uVar8) - uVar8 != 1)))))) {
							if (aiTask->object_48 == NULL) {
								if (true) {
									switch(AVar1) {
									case AITASK_DIG:
										local_88 = MESSAGE_DIG;
										break;
									case AITASK_REPAIR:
										local_88 = MESSAGE_REPAIR;
										break;
									case AITASK_REINFORCE:
										local_88 = MESSAGE_REINFORCE;
										break;
									case AITASK_GETTOOL:
										local_88 = MESSAGE_COLLECTTOOL;
										break;
									case AITASK_TRAIN:
										local_88 = MESSAGE_TRAIN;
									}
								}
								BVar5 = game::LiveObject_FUN_00431ba0(pLVar9,&local_80,&local_10,1);
								if (BVar5 == 0) {
									aiTask->priorityValue = aiTask->priorityValue - 1;
								}
								else {
									game::Message_AddMessageAction(local_88,pLVar9,aiTask,&local_10);
									if ((aiTask->flags_5c & 0x100) == 0) {
										aiTask->object_48 = pLVar9;
									}
								}
							}
							goto LAB_00406042;
						}
					}
					if (bVar2) {
						AITask_FUN_00406290(aiTask,local_50,pLVar9);
					}
					iVar3 = globs::aiGlobs.liveObjsCount_1 - 1;
					globs::aiGlobs.liveObjsCount_1 = globs::aiGlobs.liveObjsCount_1 - 1;
					globs::aiGlobs.liveObjsTable_1[local_5c] = globs::aiGlobs.liveObjsTable_1[iVar3];
				}
			}
			pAVar4 = aiTask->next;
			local_50 = aiTask;
		} while (aiTask->next != NULL);
	}
	return;
}



void __cdecl
lego::ai::AITask_FUN_00406290(AITaskData *aiTask1,AITaskData *aiTask2,LiveObject *liveObj)
{
	AITaskData *pAVar1;
	
	if ((*(byte *)&aiTask1->flags_5c & 0x40) == 0) {
		if (aiTask2 == NULL) {
			globs::aiGlobs.AITaskUnkPtr = aiTask1->next;
		}
		else {
			aiTask2->next = aiTask1->next;
		}
		aiTask1->next = NULL;
		liveObj->aitask_2f0 = aiTask1;
	}
	else {
		pAVar1 = AITask_FUN_00406330(aiTask1);
		liveObj->aitask_2f0 = pAVar1;
		if ((aiTask1->flags_5c & 0x40000) != 0) {
			aiTask1->float_18 = 25.0;
		}
	}
	AITask_LiveObject_ReleaseTaskReferences(liveObj);
	front::Bubble_LiveObject_MiniFigure_FUN_00407380(liveObj);
	return;
}



void __cdecl lego::ai::AITask_LiveObject_ReleaseTaskReferences(LiveObject *liveObj)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globs::aiGlobs.AITaskUnkPtr;
	if (globs::aiGlobs.AITaskUnkPtr != NULL) {
		do {
			if (pAVar2->object_48 == liveObj) {
				pAVar2->object_48 = NULL;
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != NULL);
	}
	return;
}



AITaskData * __cdecl lego::ai::AITask_FUN_00406330(AITaskData *aiTask)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	int iVar3;
	AITaskData *pAVar4;
	
	pAVar2 = AITask_Create(aiTask->taskType);
	pAVar1 = pAVar2->nextFree;
	pAVar4 = pAVar2;
	for (iVar3 = 0x1a; iVar3 != 0; iVar3 += -1) {
		pAVar4->taskType = aiTask->taskType;
		aiTask = (AITaskData *)&aiTask->field_4;
		pAVar4 = (AITaskData *)&pAVar4->field_4;
	}
	pAVar2->nextFree = pAVar1;
	pAVar2->flags_5c = pAVar2->flags_5c | 0x200;
	pAVar2->next = NULL;
	return pAVar2;
}



AITaskData * __cdecl lego::ai::AITask_Create(AITaskType taskType)
{
	AITaskData *pAVar1;
	uint uVar2;
	int iVar3;
	AITaskData *pAVar4;
	
	if (globs::aiGlobs.freeList == NULL) {
		AITask_AddList();
	}
	pAVar1 = globs::aiGlobs.freeList;
	pAVar4 = globs::aiGlobs.freeList;
	globs::aiGlobs.freeList = (globs::aiGlobs.freeList)->nextFree;
	for (iVar3 = 0x1a; iVar3 != 0; iVar3 += -1) {
		pAVar4->taskType = AITASK_GOTO;
		pAVar4 = (AITaskData *)&pAVar4->field_4;
	}
	pAVar1->nextFree = pAVar1;
	uVar2 = main::Main_GetTime();
	pAVar1->taskStartTime = uVar2;
	pAVar1->taskType = taskType;
	return pAVar1;
}



void __cdecl lego::ai::AITask_Remove(AITaskData *aiTask,BOOL noRelease2)
{
	if (noRelease2 == 0) {
		AITask_Release_2(aiTask);
	}
	if ((aiTask->ptr_40 != NULL) && ((aiTask->flags_5c & 0x200) == 0)) {
		std::free(aiTask->ptr_40);
	}
	aiTask->nextFree = globs::aiGlobs.freeList;
	globs::aiGlobs.freeList = aiTask;
	return;
}



void __cdecl lego::ai::AITask_AddList(void)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::aiGlobs.listCount & 0x1f);
	pAVar2 = (AITaskData *)std::malloc(uVar4 * 0x68);
	globs::aiGlobs.listSet[globs::aiGlobs.listCount] = pAVar2;
	pAVar2 = globs::aiGlobs.listSet[globs::aiGlobs.listCount];
	if (pAVar2 != NULL) {
		globs::aiGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pAVar1 = pAVar2;
			do {
				pAVar1->nextFree = pAVar1 + 1;
				iVar3 += -1;
				pAVar1 = pAVar1 + 1;
			} while (iVar3 != 0);
		}
		pAVar2[uVar4 - 1].nextFree = globs::aiGlobs.freeList;
		globs::aiGlobs.freeList = pAVar2;
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoUnkCallbacks(undefined *taskFunction,LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	AI_Globs *pAVar3;
	uint uVar4;
	uint uVar5;
	uint local_4;
	
	local_4 = 0;
	if (globs::aiGlobs.listCount == 0) {
		return 0;
	}
	pAVar3 = &globs::aiGlobs;
	do {
		if (pAVar3->listSet[0] != NULL) {
			uVar5 = 0;
			uVar4 = 1 << ((byte)local_4 & 0x1f);
			if (uVar4 != 0) {
				iVar2 = 0;
				do {
					iVar1 = (int)&pAVar3->listSet[0]->taskType + iVar2;
					if (((iVar1 != 0) && (*(int *)(iVar1 + 100) == iVar1)) &&
						 (iVar1 = (*(code *)taskFunction)(iVar1,liveObj), iVar1 != 0)) {
						return TRUE;
					}
					uVar5 += 1;
					iVar2 += 0x68;
				} while (uVar5 < uVar4);
			}
		}
		local_4 += 1;
		pAVar3 = (AI_Globs *)(pAVar3->listSet + 1);
		if (globs::aiGlobs.listCount <= local_4) {
			return 0;
		}
	} while( true );
}



IDirectDraw4 * __cdecl lego::ddraw::DirectDraw(void)
{
	return globs::directDrawGlobs.lpDirectDraw;
}



IDirectDrawSurface4 * __cdecl lego::ddraw::DirectDraw_bSurf(void)
{
	return globs::directDrawGlobs.bSurf;
}



void __cdecl
lego::math::Routing_Maths_Vector2D_FUN_00406520
					(Point2F *out_point,Point2F *param_2,Point2F *param_3,Point2F *param_4,Point2F *param_5,
					float scalar)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	
	fVar1 = param_3->x * 3.0 + param_2->x;
	fVar5 = scalar * scalar;
	fVar4 = (fVar1 - param_2->x) * 3.0;
	fVar3 = ((param_4->x - param_5->x * 3.0) - fVar1) * 3.0 - fVar4;
	fVar1 = param_5->y;
	fVar6 = param_3->y * 3.0 + param_2->y;
	fVar2 = param_4->y;
	out_point->x = fVar4 * scalar +
								 fVar3 * fVar5 + (((param_4->x - param_2->x) - fVar4) - fVar3) * fVar5 * scalar +
								 param_2->x;
	fVar3 = (fVar6 - param_2->y) * 3.0;
	fVar1 = ((fVar2 - fVar1 * 3.0) - fVar6) * 3.0 - fVar3;
	out_point->y = fVar1 * fVar5 +
								 fVar3 * scalar + (((param_4->y - param_2->y) - fVar3) - fVar1) * fVar5 * scalar +
								 param_2->y;
	return;
}



// sqrt(((a.x-b.x)*(a.x-b.x)) + ((a.y-b.y)*(a.y-b.y)))

float10 __cdecl lego::math::Routing_Maths_Vector2DDistance(Point2F *a,Point2F *b)
{
	float10 diff_x;
	float10 diff_y;
	
	diff_x = (float10)a->x - (float10)b->x;
	diff_y = (float10)a->y - (float10)b->y;
	return SQRT(diff_y * diff_y + diff_x * (float10)(float)diff_x);
}



// ref_point = norm(ref_point) * newLength
// NOTE: Unlike `Maths_Vector2DSetLength`, this function modifies the input point.

Point2F * __cdecl lego::math::Routing_Maths_Vector2DChangeLength(Point2F *ref_point,float newLength)
{
	float fVar1;
	
	fVar1 = SQRT(ref_point->x * ref_point->x + ref_point->y * ref_point->y) / newLength;
	ref_point->x = ref_point->x / fVar1;
	ref_point->y = ref_point->y / fVar1;
	return ref_point;
}



float10 __cdecl lego::game::Routing_UpdateDistances_RetTotal(RoutingData *route)
{
	RoutingData *pRVar1;
	uint index;
	float *curValue;
	float10 fVar2;
	float totalDist;
	
	index = 1;
	totalDist = 0.0;
	route->distances[0] = 0.0;
	if (1 < route->count) {
		curValue = route->distances;
		pRVar1 = route;
		do {
			curValue = curValue + 1;
			fVar2 = math::Routing_Maths_Vector2DDistance(pRVar1->points,pRVar1->points + 1);
			*curValue = (float)fVar2;
			index += 1;
			totalDist = (float)(fVar2 + (float10)totalDist);
			pRVar1 = (RoutingData *)&pRVar1->points[0].y;
		} while (index < route->count);
	}
	return (float10)totalDist;
}



void __cdecl
lego::game::Routing_DoMath_FUN_00406750
					(RoutingData *route,Point2F *a,Point2F *b,Point2F *c,Point2F *d,uint count)
{
	uint index;
	Point2F *curPoint;
	
	if (49 < count) {
		count = 50;
	}
	index = 1;
	route->count = count;
	route->points[0].x = a->x;
	route->points[0].y = a->y;
	if (1 < count) {
		curPoint = route->points;
		do {
			curPoint = curPoint + 1;
			math::Routing_Maths_Vector2D_FUN_00406520
								(curPoint,a,b,c,d,(float)(ulonglong)index * (1.0 / (float)(ulonglong)(count - 1)));
			index += 1;
		} while (index < count);
	}
	return;
}



uint __cdecl
lego::game::Routing_Calculate_FUN_004067f0(RoutingData *route,float scalar,Point2F *out_point)
{
	float fVar1;
	float fVar2;
	float fVar3;
	uint index;
	float *pfVar4;
	uint count;
	
	fVar3 = 0.0;
	count = route->count;
	index = 1;
	if (1 < count) {
		pfVar4 = route->distances;
		do {
			pfVar4 = pfVar4 + 1;
			fVar3 = fVar3 + *pfVar4;
			if (scalar < fVar3) break;
			index += 1;
		} while (index < count);
	}
	if (index < count) {
		out_point->x = route->points[index - 1].x;
		out_point->y = route->points[index - 1].y;
		fVar1 = route->points[index].y;
		fVar2 = route->points[index - 1].y;
		fVar3 = (scalar - (fVar3 - route->distances[index])) / route->distances[index];
		out_point->x = (route->points[index].x - route->points[index - 1].x) * fVar3 +
									 route->points[index - 1].x;
		out_point->y = (fVar1 - fVar2) * fVar3 + route->points[index - 1].y;
		return index;
	}
	out_point->x = route->points[index - 1].x;
	out_point->y = route->points[index - 1].y;
	return index;
}



BOOL __cdecl lego::res::Creature_IsCameraFlipDir(CreatureData *creature)
{
	return (uint)(creature->CameraFlipDir == BOOL3_TRUE);
}



BOOL __cdecl
lego::res::Creature_LoadActivityFile
					(CreatureData *creature,int objIndex,Container *resRoot,char *aeFilename,char *rootName)
{
	char cVar1;
	CFGProperty *prop;
	Container *pCVar2;
	char *pcVar3;
	BoolTri BVar4;
	PolyMeshData *pPVar5;
	uint uVar6;
	uint uVar7;
	char **ppcVar8;
	int iVar9;
	undefined4 *puVar10;
	char *pcVar11;
	undefined4 *puVar12;
	BOOL result;
	char *stringParts [100];
	char buffName [1024];
	char buffPath [1024];
	
	uVar6 = 0xffffffff;
	pcVar3 = aeFilename;
	do {
		pcVar11 = pcVar3;
		if (uVar6 == 0) break;
		uVar6 -= 1;
		pcVar11 = pcVar3 + 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar11;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	puVar10 = (undefined4 *)(pcVar11 + -uVar6);
	puVar12 = (undefined4 *)buffName;
	for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
		*puVar12 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar12 = puVar12 + 1;
	}
	result = 0;
	for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	uVar6 = util::Util_Tokenise(buffName,stringParts,"\\");
	if (1 < uVar6) {
		ppcVar8 = stringParts;
		iVar9 = uVar6 - 1;
		do {
			ppcVar8 = ppcVar8 + 1;
			iVar9 += -1;
			(*ppcVar8)[-1] = '\\';
		} while (iVar9 != 0);
	}
	std::sprintf(buffPath,"%s\\%s.%s",buffName,stringParts[uVar6 - 1],"ae");
	prop = cfg::CFG_Open(buffPath);
	if (prop != NULL) {
		pCVar2 = Container_Load(resRoot,aeFilename,"ACT",TRUE);
		creature->contAct = pCVar2;
		if (pCVar2 != NULL) {
			pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->CameraNullName = pcVar3;
			if (pcVar3 == NULL) {
				creature->CameraNullFrames = 0;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				if (pcVar3 == NULL) {
					pcVar3 = ____EMPTYSTR__;
				}
				else {
					pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
					pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				}
				uVar6 = std::atoi(pcVar3);
				creature->CameraNullFrames = uVar6;
				pcVar3 = cfg::CFG_JoinPath(rootName,"CameraFlipDir",0);
				BVar4 = cfg::CFG_ReadBool(prop,pcVar3);
				creature->CameraFlipDir = BVar4;
			}
			pcVar3 = cfg::CFG_JoinPath(rootName,"DrillNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->DrillNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"FootStepNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->FootStepNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->CarryNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"ThrowNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->ThrowNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->DepositNullName = pcVar3;
			creature->objIndex = objIndex;
			pPVar5 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_MEDIUM,1);
			creature->polyMedium = pPVar5;
			pPVar5 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_HIGH,1);
			creature->polyHigh = pPVar5;
			pPVar5 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_FP,creature->CameraNullFrames);
			creature->polyFP = pPVar5;
			creature->flags = 1;
			result = 1;
		}
		cfg::CFG_Close(prop);
	}
	return result;
}



void __cdecl lego::res::Creature_SwapPolyMedium(CreatureData *creature,BOOL swap)
{
	MeshPoly_Container_SwapFrame(creature->polyMedium,creature->contAct,(uint)(swap == 0),0);
	return;
}



void __cdecl lego::res::Creature_SwapPolyHigh(CreatureData *creature,BOOL swap)
{
	MeshPoly_Container_SwapFrame(creature->polyHigh,creature->contAct,(uint)(swap == 0),0);
	return;
}



void __cdecl lego::res::Creature_SwapPolyFP(CreatureData *creature,BOOL swap,int cameraFrameIndex)
{
	MeshPoly_Container_SwapFrame
						(creature->polyFP,creature->contAct,(uint)(swap == 0),cameraFrameIndex);
	return;
}



void __cdecl lego::res::Object_HideAll(BasicObjectData *basicObjData,BOOL hide)
{
	Container_Hide(basicObjData->aeResData,hide);
	return;
}



void __cdecl lego::res::Creature_Duplicate(CreatureData *in_creature,CreatureData *out_creature)
{
	PolyMeshData *pPVar1;
	Container *pCVar2;
	int iVar3;
	CreatureData *pCVar4;
	CreatureData *pCVar5;
	
	pCVar4 = in_creature;
	pCVar5 = out_creature;
	for (iVar3 = 0x1d; iVar3 != 0; iVar3 += -1) {
		pCVar5->objIndex = pCVar4->objIndex;
		pCVar4 = (CreatureData *)&pCVar4->contAct;
		pCVar5 = (CreatureData *)&pCVar5->contAct;
	}
	out_creature->flags = out_creature->flags & 0xfffffffe;
	pPVar1 = MeshPoly_Duplicate(in_creature->polyMedium);
	out_creature->polyMedium = pPVar1;
	pPVar1 = MeshPoly_Duplicate(in_creature->polyHigh);
	out_creature->polyHigh = pPVar1;
	pPVar1 = MeshPoly_Duplicate(in_creature->polyFP);
	out_creature->polyFP = pPVar1;
	pCVar2 = Container_Clone(in_creature->contAct);
	out_creature->contAct = pCVar2;
	return;
}



void __cdecl lego::res::Creature_DoCallbacks(CreatureData *creature,float elapsed)
{
	Container_SetAnimationTime(creature->contAct,elapsed);
	return;
}



float10 __cdecl lego::res::Creature_FUN_00406c60(CreatureData *creature,float elapsed,uint param_3)
{
	float fVar1;
	uint uVar2;
	float10 fVar3;
	
	fVar3 = Container_MoveAnimation(creature->contAct,elapsed);
	fVar1 = (float)fVar3;
	if ((1 < param_3) && (fVar1 != 0.0)) {
		uVar2 = Container_GetAnimationFrames(creature->contAct);
		return (float10)fVar1 - (float10)(ulonglong)(uVar2 * (param_3 - 1));
	}
	return (float10)fVar1;
}



float10 __cdecl lego::res::Creature_GetAnimFloat10(CreatureData *creature)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(creature->contAct);
	return fVar1;
}



void __cdecl lego::res::Creature_SetOrientation(CreatureData *creature,float x,float y)
{
	Container_SetOrientation(creature->contAct,NULL,x,y,0.0,0.0,0.0,-1.0);
	return;
}



void __cdecl
lego::res::Creature_SetPosition
					(CreatureData *creature,float x,float y,GetSurfaceZFunc getSurfaceZFunc,
					SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = (*getSurfaceZFunc)(x,y,surfMap);
	Container_SetPosition(creature->contAct,NULL,x,y,(float)fVar1);
	return;
}



Container * __cdecl lego::res::Object_GetActivityContainer(BasicObjectData *basicObjData)
{
	return basicObjData->aeResData;
}



BOOL __cdecl
lego::res::Creature_SetActivity_AndRemoveCarryCameraFrames
					(CreatureData *creature,char *activityName,float elapsed)
{
	uint uVar1;
	BOOL BVar2;
	Container **ppCVar3;
	
	MeshPoly_RemoveTarget(creature->polyMedium);
	MeshPoly_RemoveTarget(creature->polyHigh);
	MeshPoly_RemoveTarget(creature->polyFP);
	uVar1 = 0;
	creature->field_40 = 0;
	creature->field_44 = 0;
	creature->cont_48 = NULL;
	creature->cont_4c = NULL;
	creature->field_50 = 0;
	if (creature->CameraNullFrames != 0) {
		ppCVar3 = creature->cameraFramesTable_54;
		do {
			*ppCVar3 = NULL;
			uVar1 += 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar1 < creature->CameraNullFrames);
	}
	BVar2 = Container_SetActivity(creature->contAct,activityName);
	Container_SetAnimationTime(creature->contAct,elapsed);
	return BVar2;
}



void __cdecl lego::res::Creature_Destroy(CreatureData *creature)
{
	MeshPoly_Destroy(creature->polyMedium);
	MeshPoly_Destroy(creature->polyHigh);
	MeshPoly_Destroy(creature->polyFP);
	if ((*(byte *)&creature->flags & 1) != 0) {
		if (creature->DrillNullName != NULL) {
			std::free(creature->DrillNullName);
		}
		if (creature->FootStepNullName != NULL) {
			std::free(creature->FootStepNullName);
		}
		if (creature->CameraNullName != NULL) {
			std::free(creature->CameraNullName);
		}
		if (creature->CarryNullName != NULL) {
			std::free(creature->CarryNullName);
		}
		if (creature->ThrowNullName != NULL) {
			std::free(creature->ThrowNullName);
		}
	}
	Container_Remove(creature->contAct);
	return;
}



Container * __cdecl
lego::res::Object_SearchForPartName(BasicObjectData *basicObjData,char *name,int instance)
{
	char *name_00;
	Container *pCVar1;
	
	name_00 = Container_FormatPartName(basicObjData->aeResData,name,&instance);
	pCVar1 = Container_SearchTree
										 (basicObjData->aeResData,name_00,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetCameraNull(CreatureData *creature,int cameraIndex)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)creature->CameraNullName;
	if (pCVar1 != NULL) {
		if (creature->cameraFramesTable_54[cameraIndex] == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,pCVar1,cameraIndex);
			creature->cameraFramesTable_54[cameraIndex] = pCVar1;
		}
		pCVar1 = creature->cameraFramesTable_54[cameraIndex];
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetDrillNull(CreatureData *creature)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)creature->field_40;
	if (pCVar1 == NULL) {
		if (creature->DrillNullName != NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,creature->DrillNullName,0);
			creature->field_40 = pCVar1;
			return pCVar1;
		}
		pCVar1 = NULL;
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetCarryNull(CreatureData *creature)
{
	Container *pCVar1;
	
	if (creature->CarryNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = creature->cont_48;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,creature->CarryNullName,0);
			creature->cont_48 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetDepositNull(CreatureData *creature)
{
	Container *pCVar1;
	
	if (creature->DepositNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)creature->field_50;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,creature->DepositNullName,0);
			creature->field_50 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



BOOL __cdecl lego::res::Creature_GetThrowNull(CreatureData *creature)
{
	Container *contNull;
	float10 fVar1;
	
	if ((creature->cont_4c == NULL) && (creature->ThrowNullName != NULL)) {
		contNull = Object_SearchForPartName((BasicObjectData *)creature,creature->ThrowNullName,0);
		creature->cont_4c = contNull;
	}
	if (creature->cont_4c != NULL) {
		fVar1 = Container_GetZXRatio(creature->cont_4c);
		if (fVar1 != (float10)1.0) {
			return TRUE;
		}
	}
	return 0;
}



float10 __cdecl lego::res::Creature_GetTransCoef(CreatureData *creature)
{
	float10 fVar1;
	
	fVar1 = Container_GetTransCoef(creature->contAct);
	return fVar1;
}



void __cdecl lego::front::Bubble_Initialise(void)
{
	globs::bubbleGlobs.bubbleName[0] = "Bubble_CantDo";
	globs::bubbleGlobs.bubbleName[1] = "Bubble_Idle";
	globs::bubbleGlobs.bubbleName[2] = "Bubble_CollectCrystal";
	globs::bubbleGlobs.bubbleName[3] = "Bubble_CollectOre";
	globs::bubbleGlobs.bubbleName[4] = "Bubble_CollectStud";
	globs::bubbleGlobs.bubbleName[5] = "Bubble_CollectDynamite";
	globs::bubbleGlobs.bubbleName[6] = "Bubble_CollectBarrier";
	globs::bubbleGlobs.bubbleName[7] = "Bubble_CollectElecFence";
	globs::bubbleGlobs.bubbleName[8] = "Bubble_CollectDrill";
	globs::bubbleGlobs.bubbleName[9] = "Bubble_CollectSpade";
	globs::bubbleGlobs.bubbleName[10] = "Bubble_CollectHammer";
	globs::bubbleGlobs.bubbleName[11] = "Bubble_CollectSpanner";
	globs::bubbleGlobs.bubbleName[12] = "Bubble_CollectLaser";
	globs::bubbleGlobs.bubbleName[13] = "Bubble_CollectPusher";
	globs::bubbleGlobs.bubbleName[14] = "Bubble_CollectFreezer";
	globs::bubbleGlobs.bubbleName[15] = "Bubble_CollectBirdScarer";
	globs::bubbleGlobs.bubbleName[16] = "Bubble_CarryCrystal";
	globs::bubbleGlobs.bubbleName[17] = "Bubble_CarryOre";
	globs::bubbleGlobs.bubbleName[18] = "Bubble_CarryStud";
	globs::bubbleGlobs.bubbleName[19] = "Bubble_CarryDynamite";
	globs::bubbleGlobs.bubbleName[20] = "Bubble_CarryBarrier";
	globs::bubbleGlobs.bubbleName[21] = "Bubble_CarryElecFence";
	globs::bubbleGlobs.bubbleName[22] = "Bubble_Goto";
	globs::bubbleGlobs.bubbleName[23] = "Bubble_Dynamite";
	globs::bubbleGlobs.bubbleName[24] = "Bubble_Reinforce";
	globs::bubbleGlobs.bubbleName[25] = "Bubble_Drill";
	globs::bubbleGlobs.bubbleName[26] = "Bubble_Repair";
	globs::bubbleGlobs.bubbleName[27] = "Bubble_Dig";
	globs::bubbleGlobs.bubbleName[28] = "Bubble_Flee";
	globs::bubbleGlobs.bubbleName[29] = "Bubble_PowerOff";
	globs::bubbleGlobs.bubbleName[30] = "Bubble_CallToArms";
	globs::bubbleGlobs.bubbleName[31] = "Bubble_ElecFence";
	globs::bubbleGlobs.bubbleName[32] = "Bubble_Eat";
	globs::bubbleGlobs.bubbleName[33] = "Bubble_Drive";
	globs::bubbleGlobs.bubbleName[34] = "Bubble_Upgrade";
	globs::bubbleGlobs.bubbleName[35] = "Bubble_BuildPath";
	globs::bubbleGlobs.bubbleName[36] = "Bubble_Train";
	globs::bubbleGlobs.bubbleName[37] = "Bubble_Recharge";
	globs::bubbleGlobs.bubbleName[38] = "Bubble_Request";
	return;
}



void __cdecl lego::front::Bubble_LoadCFG(CFGProperty *root)
{
	char cVar1;
	bool bVar2;
	char *pcVar3;
	CFGProperty *prop;
	BubbleType BVar4;
	Image *image;
	int iVar5;
	char *pcVar6;
	
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Bubbles",0);
	prop = cfg::CFG_GetChildren(root,pcVar3);
	do {
		if (prop == NULL) {
			return;
		}
		pcVar3 = prop->key;
		bVar2 = true;
		if (pcVar3 != NULL) {
			iVar5 = -1;
			pcVar6 = pcVar3;
			do {
				if (iVar5 == 0) break;
				iVar5 += -1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			if ((iVar5 != -2) && (*pcVar3 == '!')) {
				if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
					pcVar3 = pcVar3 + 1;
				}
				else {
					bVar2 = false;
				}
			}
		}
		if (bVar2) {
			BVar4 = Bubble_GetBubbleType(pcVar3);
			image = lego::image::Image_LoadBMPScaled(prop->value,0,0);
			globs::bubbleGlobs.bubbleImages[BVar4] = image;
			if (image != NULL) {
				lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



BubbleType __cdecl lego::front::Bubble_GetBubbleType(char *bubbleName)
{
	BubbleType BVar1;
	char **ppcVar2;
	BubbleType BVar3;
	
	BVar3 = BUBBLE_CANTDO;
	ppcVar2 = globs::bubbleGlobs.bubbleName;
	do {
		BVar1 = std::_stricmp(*ppcVar2,bubbleName);
		if (BVar1 == BUBBLE_CANTDO) {
			return BVar3;
		}
		ppcVar2 = ppcVar2 + 1;
		BVar3 += BUBBLE_IDLE;
	} while ((int)ppcVar2 < 0x55899c);
	return BVar1;
}



void __cdecl lego::front::Bubble_ToggleObjectUIsAlwaysVisible(void)
{
	globs::bubbleGlobs.ObjectUIsAlwaysVisible = (uint)(globs::bubbleGlobs.ObjectUIsAlwaysVisible == 0)
	;
	return;
}



BOOL __cdecl lego::front::Bubble_GetObjectUIsAlwaysVisible(void)
{
	return globs::bubbleGlobs.ObjectUIsAlwaysVisible;
}



void __cdecl lego::front::Bubble_LiveObject_UpdateBubbleImage(LiveObject *liveObj)
{
	if (globs::bubbleGlobs.ObjectUIsAlwaysVisible != 0) {
		liveObj->field_388 = 0;
		Bubble_LiveObject_GetCurrentBubbleImage(liveObj,&liveObj->bubbleImage_38c);
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_FUN_004072d0(LiveObject *liveObj)
{
	BubbleData *pBVar1;
	
	pBVar1 = globs::bubbleGlobs.table1;
	do {
		if (liveObj == pBVar1->object_0) {
			pBVar1->object_0 = NULL;
		}
		pBVar1 = pBVar1 + 1;
	} while (pBVar1 < globs::bubbleGlobs.table2);
	pBVar1 = globs::bubbleGlobs.table2;
	do {
		if (liveObj == pBVar1->object_0) {
			pBVar1->object_0 = NULL;
		}
		pBVar1 = pBVar1 + 1;
	} while (pBVar1 < globs::bubbleGlobs.table3);
	pBVar1 = globs::bubbleGlobs.table3;
	do {
		if (liveObj == pBVar1->object_0) {
			pBVar1->object_0 = NULL;
		}
		pBVar1 = pBVar1 + 1;
	} while (pBVar1 < globs::bubbleGlobs.bigTable);
	pBVar1 = globs::bubbleGlobs.bigTable;
	do {
		if (liveObj == pBVar1->object_0) {
			pBVar1->object_0 = NULL;
		}
		pBVar1 = pBVar1 + 1;
	} while (pBVar1 < (BubbleData *)&DAT_00558d54);
	return;
}



void __cdecl lego::front::Bubble_LiveObject_FUN_00407340(LiveObject *liveObj)
{
	BubbleData *pBVar1;
	int iVar2;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		iVar2 = 0;
		pBVar1 = globs::bubbleGlobs.table3;
		do {
			if (liveObj == pBVar1->object_0) break;
			pBVar1 = pBVar1 + 1;
			iVar2 += 1;
		} while (pBVar1 < globs::bubbleGlobs.bigTable);
		if (iVar2 == 0x14) {
			pBVar1 = globs::bubbleGlobs.table3;
			while (pBVar1->object_0 != NULL) {
				pBVar1 = pBVar1 + 1;
				if ((BubbleData *)((int)&globs::bubbleGlobs.table3[0x13].float_4 + 3) < pBVar1) {
					return;
				}
			}
			pBVar1->object_0 = liveObj;
		}
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_MiniFigure_FUN_00407380(LiveObject *liveObj)
{
	BubbleData *pBVar1;
	int iVar2;
	BubbleData *pBVar3;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		iVar2 = 0;
		pBVar1 = globs::bubbleGlobs.table2;
		do {
			pBVar3 = pBVar1;
			if (liveObj == pBVar3->object_0) break;
			iVar2 += 1;
			pBVar1 = pBVar3 + 1;
		} while (pBVar3 + 1 < globs::bubbleGlobs.table3);
		if (iVar2 == 0x14) {
			iVar2 = 0;
			pBVar1 = globs::bubbleGlobs.table2;
			do {
				pBVar3 = pBVar1;
				if (pBVar3->object_0 == NULL) {
					pBVar3->object_0 = liveObj;
					break;
				}
				iVar2 += 1;
				pBVar1 = pBVar3 + 1;
			} while (pBVar3 + 1 < globs::bubbleGlobs.table3);
			if (iVar2 == 0x14) {
				return;
			}
		}
		pBVar3->float_4 = 12.5;
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_MiniFIgure_FUN_004073e0(LiveObject *liveObj)
{
	BubbleData *pBVar1;
	int iVar2;
	BubbleData *pBVar3;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		iVar2 = 0;
		pBVar1 = globs::bubbleGlobs.bigTable;
		do {
			pBVar3 = pBVar1;
			if (liveObj == pBVar3->object_0) break;
			iVar2 += 1;
			pBVar1 = pBVar3 + 1;
		} while (pBVar3 + 1 < (BubbleData *)&DAT_00558d54);
		if (iVar2 == 50) {
			iVar2 = 0;
			pBVar1 = globs::bubbleGlobs.bigTable;
			do {
				pBVar3 = pBVar1;
				if (pBVar3->object_0 == NULL) {
					pBVar3->object_0 = liveObj;
					break;
				}
				iVar2 += 1;
				pBVar1 = pBVar3 + 1;
			} while (pBVar3 + 1 < (BubbleData *)&DAT_00558d54);
			if (iVar2 == 50) {
				return;
			}
		}
		pBVar3->float_4 = 2250000.0;
	}
	return;
}



void __cdecl
lego::front::Bubble_LiveObject_MiniFigure_FUN_00407440(LiveObject *liveObj,float param_2)
{
	float *pfVar1;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		pfVar1 = &globs::bubbleGlobs.bigTable[0].float_4;
		do {
			if (pfVar1[-1] != 0.0) {
				*pfVar1 = param_2;
			}
			pfVar1 = pfVar1 + 2;
		} while (pfVar1 < null_ARRAY_00558d58);
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_FUN_00407470(LiveObject *liveObj)
{
	BubbleData *pBVar1;
	ObjectStatsFlags3 OVar2;
	int iVar3;
	BubbleData *pBVar4;
	
	OVar2 = stats::StatsObject_GetStatsFlags3(liveObj);
	if ((OVar2 & STATS3_SHOWHEALTHBAR) != STATS3_NONE) {
		iVar3 = 0;
		pBVar1 = globs::bubbleGlobs.table1;
		do {
			pBVar4 = pBVar1;
			if (liveObj == pBVar4->object_0) break;
			iVar3 += 1;
			pBVar1 = pBVar4 + 1;
		} while (pBVar4 + 1 < globs::bubbleGlobs.table2);
		if (iVar3 == 0x14) {
			iVar3 = 0;
			pBVar1 = globs::bubbleGlobs.table1;
			do {
				pBVar4 = pBVar1;
				if (pBVar4->object_0 == NULL) {
					pBVar4->object_0 = liveObj;
					break;
				}
				iVar3 += 1;
				pBVar1 = pBVar4 + 1;
			} while (pBVar4 + 1 < globs::bubbleGlobs.table2);
			if (iVar3 == 0x14) {
				return;
			}
		}
		pBVar4->float_4 = 37.5;
	}
	return;
}



void __cdecl lego::front::Bubble_Unk_DrawObjectUIs_FUN_004074d0(float elapsedAbs)
{
	LiveObject *pLVar1;
	float fVar2;
	Image *pIVar3;
	BOOL BVar4;
	Container *pCVar5;
	int iVar6;
	BubbleData *pBVar7;
	float10 fVar8;
	longlong lVar9;
	Container *pCVar10;
	Vector3F *pVVar11;
	Point2F local_14;
	Vector3F local_c;
	
	if ((globs::bubbleGlobs.ObjectUIsAlwaysVisible != 0) &&
		 (BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)) {
		game::Search_LiveObjects_SkipIgnoreMes(Bubble_LiveObject_CallbackDraw_FUN_00407890,&elapsedAbs);
	}
	pBVar7 = globs::bubbleGlobs.table1;
	do {
		pLVar1 = pBVar7->object_0;
		if (pLVar1 != NULL) {
			if ((((pLVar1->objType != OBJECT_MINIFIGURE) ||
					 (globs::bubbleGlobs.ObjectUIsAlwaysVisible == 0)) &&
					(BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)) &&
				 ((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) {
				pVVar11 = &local_c;
				pCVar10 = NULL;
				pCVar5 = game::LiveObject_GetContainer(pLVar1);
				res::Container_GetPosition(pCVar5,pCVar10,pVVar11);
				fVar8 = stats::StatsObject_GetCollHeight(pLVar1);
				local_c.z = (float)((float10)local_c.z - fVar8);
				lego::view::Viewport_WorldToScreen(globs::legoGlobs.viewMain,&local_14,&local_c);
				lVar9 = __ftol((float10)local_14.y);
				iVar6 = (int)lVar9;
				lVar9 = __ftol((float10)local_14.x);
				ObjInfo_DrawHealthBar(pLVar1,(int)lVar9,iVar6);
			}
			fVar2 = pBVar7->float_4 - elapsedAbs;
			pBVar7->float_4 = fVar2;
			if (fVar2 < 0.0) {
				pBVar7->object_0 = NULL;
			}
		}
		pBVar7 = pBVar7 + 1;
	} while (pBVar7 < globs::bubbleGlobs.table2);
	BVar4 = game::Game_IsFirstPersonView();
	if (BVar4 == 0) {
		if (12.5 <= globs::s_Bubble_ElapsedTimer) {
			if (25.0 <= globs::s_Bubble_ElapsedTimer) {
				globs::s_Bubble_ElapsedTimer = globs::s_Bubble_ElapsedTimer - 25.0;
			}
		}
		else {
			pBVar7 = globs::bubbleGlobs.table3;
			do {
				pIVar3 = globs::bubbleGlobs.bubbleImages[29];
				pLVar1 = pBVar7->object_0;
				if (pLVar1 != NULL) {
					if ((pLVar1->flags3 & LIVEOBJ3_HASPOWER) == LIVEOBJ3_NONE) {
						pVVar11 = &local_c;
						pCVar10 = NULL;
						pCVar5 = game::LiveObject_GetContainer(pLVar1);
						res::Container_GetPosition(pCVar5,pCVar10,pVVar11);
						fVar8 = stats::StatsObject_GetCollHeight(pLVar1);
						local_c.z = (float)((float10)local_c.z - fVar8);
						lego::view::Viewport_WorldToScreen(globs::legoGlobs.viewMain,&local_14,&local_c);
						local_14.y = local_14.y - (float)pIVar3->height;
						local_14.x = local_14.x - (float)pIVar3->width * 0.5;
						lego::image::Image_DisplayScaled(pIVar3,NULL,&local_14,NULL);
					}
					else {
						pBVar7->object_0 = NULL;
					}
				}
				pBVar7 = pBVar7 + 1;
			} while (pBVar7 < globs::bubbleGlobs.bigTable);
		}
		globs::s_Bubble_ElapsedTimer = globs::s_Bubble_ElapsedTimer + elapsedAbs;
	}
	pBVar7 = globs::bubbleGlobs.table2;
	do {
		pLVar1 = pBVar7->object_0;
		if (pLVar1 != NULL) {
			if (((pLVar1->objType != OBJECT_MINIFIGURE) ||
					(globs::bubbleGlobs.ObjectUIsAlwaysVisible == 0)) &&
				 (((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
					(BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)))) {
				local_14.x = 0.0;
				Bubble_LiveObject_GetBubbleImage_FUN_004077f0
									(pLVar1,elapsedAbs,(Image **)&local_14,&local_c);
				pIVar3 = (Image *)local_14.x;
				if (((Image *)local_14.x != NULL) &&
					 ((Image *)local_14.x != globs::bubbleGlobs.bubbleImages[1])) {
					lVar9 = __ftol((float10)local_c.y);
					iVar6 = (int)lVar9;
					lVar9 = __ftol((float10)local_c.x);
					ObjInfo_DrawBubbleImage(pIVar3,(int)lVar9,iVar6);
				}
			}
			fVar2 = pBVar7->float_4 - elapsedAbs;
			pBVar7->float_4 = fVar2;
			if (fVar2 < 0.0) {
				pBVar7->object_0 = NULL;
			}
		}
		pBVar7 = pBVar7 + 1;
	} while (pBVar7 < globs::bubbleGlobs.table3);
	pBVar7 = globs::bubbleGlobs.bigTable;
	do {
		pLVar1 = pBVar7->object_0;
		if (pLVar1 != NULL) {
			if (((globs::bubbleGlobs.ObjectUIsAlwaysVisible == 0) &&
					((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) &&
				 (BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)) {
				local_14.x = 0.0;
				Bubble_LiveObject_GetBubbleImage_FUN_004077f0
									(pLVar1,elapsedAbs,(Image **)&local_14,&local_c);
				pIVar3 = (Image *)local_14.x;
				if ((Image *)local_14.x != NULL) {
					lVar9 = __ftol((float10)local_c.y);
					iVar6 = (int)lVar9;
					lVar9 = __ftol((float10)local_c.x);
					ObjInfo_DrawBubbleImage(pIVar3,(int)lVar9,iVar6);
				}
			}
			if ((ushort)((ushort)(pBVar7->float_4 < 0.0) << 8 | (ushort)(pBVar7->float_4 == 0.0) << 0xe)
					!= 0) {
				pBVar7->object_0 = NULL;
			}
		}
		pBVar7 = pBVar7 + 1;
	} while (pBVar7 < (BubbleData *)&DAT_00558d54);
	return;
}



void __cdecl
lego::front::Bubble_LiveObject_GetBubbleImage_FUN_004077f0
					(LiveObject *liveObj,float param_2,Image **out_bubbleImage,Point2F *param_4)
{
	float fVar1;
	Container *cont;
	float10 fVar2;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_c;
	
	out_pos = &local_c;
	opt_ref = NULL;
	cont = game::LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,opt_ref,out_pos);
	fVar2 = stats::StatsObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)local_c.z - fVar2);
	lego::view::Viewport_WorldToScreen(globs::legoGlobs.viewMain,param_4,&local_c);
	fVar1 = (float)liveObj->field_388 - param_2;
	liveObj->field_388 = fVar1;
	if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
		*out_bubbleImage = liveObj->bubbleImage_38c;
	}
	else {
		Bubble_LiveObject_GetCurrentBubbleImage(liveObj,out_bubbleImage);
	}
	if (*out_bubbleImage == NULL) {
		*out_bubbleImage = globs::bubbleGlobs.bubbleImages[1];
	}
	return;
}



BOOL __cdecl
lego::front::Bubble_LiveObject_CallbackDraw_FUN_00407890(LiveObject *liveObj,float *param_2)
{
	float *image;
	int iVar1;
	longlong lVar2;
	float local_8;
	float local_4;
	
	local_8 = *param_2;
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 ((liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) {
		param_2 = NULL;
		Bubble_LiveObject_GetBubbleImage_FUN_004077f0(liveObj,local_8,(Image **)&param_2,&local_8);
		lVar2 = __ftol((float10)local_4);
		iVar1 = (int)lVar2;
		lVar2 = __ftol((float10)local_8);
		ObjInfo_DrawHealthBar(liveObj,(int)lVar2,iVar1);
		lVar2 = __ftol((float10)local_4);
		iVar1 = (int)lVar2;
		lVar2 = __ftol((float10)local_8);
		ObjInfo_DrawHungerImage(liveObj,(int)lVar2,iVar1);
		image = param_2;
		if ((Image *)param_2 != NULL) {
			lVar2 = __ftol((float10)local_4);
			iVar1 = (int)lVar2;
			lVar2 = __ftol((float10)local_8);
			ObjInfo_DrawBubbleImage((Image *)image,(int)lVar2,iVar1);
		}
	}
	return 0;
}



void __cdecl
lego::front::Bubble_LiveObject_GetCurrentBubbleImage(LiveObject *liveObj,Image **out_bubbleImage)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	ObjectType OVar4;
	ToolType TVar5;
	AITaskType AVar6;
	
	pAVar1 = liveObj->aitask_2f0;
	if ((*(byte *)&liveObj->flags4 & 0x20) != 0) {
		*out_bubbleImage = globs::bubbleGlobs.bubbleImages[30];
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) {
		*out_bubbleImage = globs::bubbleGlobs.bubbleImages[28];
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
		*out_bubbleImage = globs::bubbleGlobs.bubbleImages[0];
		return;
	}
	if (pAVar1 != NULL) {
		AVar6 = pAVar1->taskType;
		while ((AVar6 == AITASK_ANIMATIONWAIT && (pAVar2 = pAVar1->next, pAVar2 != NULL))) {
			AVar6 = pAVar2->taskType;
			pAVar1 = pAVar2;
		}
		if (true) {
			switch(pAVar1->taskType) {
			case AITASK_GOTO:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[22];
				return;
			case AITASK_COLLECT:
				OVar4 = pAVar1->object_10->objType;
				if (OVar4 == OBJECT_POWERCRYSTAL) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[2];
					return;
				}
				if (OVar4 == OBJECT_ORE) {
					if (pAVar1->object_10->objIndex == 0) {
						*out_bubbleImage = globs::bubbleGlobs.bubbleImages[3];
						return;
					}
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[4];
					return;
				}
				if (OVar4 == OBJECT_DYNAMITE) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[5];
					return;
				}
				if (OVar4 == OBJECT_BARRIER) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[6];
					return;
				}
				if (OVar4 == OBJECT_ELECTRICFENCE) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[7];
					return;
				}
				break;
			case AITASK_DEPOSITE:
				pLVar3 = liveObj->carriedObjects[0];
				if (pLVar3 != NULL) {
					OVar4 = pLVar3->objType;
					if (OVar4 == OBJECT_POWERCRYSTAL) {
						*out_bubbleImage = globs::bubbleGlobs.bubbleImages[16];
						return;
					}
					if (OVar4 == OBJECT_ORE) {
						if (pLVar3->objIndex == 0) {
							*out_bubbleImage = globs::bubbleGlobs.bubbleImages[17];
							return;
						}
						*out_bubbleImage = globs::bubbleGlobs.bubbleImages[18];
						return;
					}
					if (OVar4 == OBJECT_DYNAMITE) {
						*out_bubbleImage = globs::bubbleGlobs.bubbleImages[19];
						return;
					}
					if (OVar4 == OBJECT_BARRIER) {
						*out_bubbleImage = globs::bubbleGlobs.bubbleImages[20];
						return;
					}
					if (OVar4 == OBJECT_ELECTRICFENCE) {
						*out_bubbleImage = globs::bubbleGlobs.bubbleImages[21];
						return;
					}
				}
				break;
			case AITASK_REQUEST:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[38];
				break;
			case AITASK_DIG:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[25];
				return;
			case AITASK_DYNAMITE:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[23];
				return;
			case AITASK_REPAIR:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[26];
				return;
			case AITASK_REINFORCE:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[24];
				return;
			case AITASK_CLEAR:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[27];
				return;
			case AITASK_ELECFENCE:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[31];
				return;
			case AITASK_EAT:
			case AITASK_GOTOEAT:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[32];
				return;
			case AITASK_FINDDRIVER:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[33];
				return;
			case AITASK_GETTOOL:
				TVar5 = pAVar1->toolType;
				if (TVar5 == TOOL_DRILL) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[8];
					return;
				}
				if (TVar5 == TOOL_SPADE) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[9];
					return;
				}
				if (TVar5 == TOOL_HAMMER) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[10];
					return;
				}
				if (TVar5 == TOOL_SPANNER) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[11];
					return;
				}
				if (TVar5 == TOOL_LASER) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[12];
					return;
				}
				if (TVar5 == TOOL_PUSHERGUN) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[13];
					return;
				}
				if (TVar5 == TOOL_FREEZERGUN) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[14];
					return;
				}
				if (TVar5 == TOOL_BIRDSCARER) {
					*out_bubbleImage = globs::bubbleGlobs.bubbleImages[15];
					return;
				}
				break;
			case AITASK_UPGRADE:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[34];
				return;
			case AITASK_BUILDPATH:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[35];
				return;
			case AITASK_TRAIN:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[36];
				return;
			case AITASK_RECHARGE:
				*out_bubbleImage = globs::bubbleGlobs.bubbleImages[37];
				return;
			}
		}
	}
	return;
}



BOOL __cdecl
lego::res::Building_LoadActivityFile
					(BuildingData *building,int objIndex,Container *resData,char *filename,char *rootName)
{
	char cVar1;
	Container *pCVar2;
	CFGProperty *prop;
	char *pcVar3;
	Point2I *pPVar4;
	char *pcVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	char **ppcVar9;
	undefined4 *puVar10;
	BuildingData *pBVar11;
	undefined4 *puVar12;
	float10 fVar13;
	char **local_99c;
	int local_998;
	char *stringParts [100];
	char buffName [1024];
	char buffPath [1024];
	
	pBVar11 = building;
	for (iVar6 = 0x53; iVar6 != 0; iVar6 += -1) {
		pBVar11->objIndex = 0;
		pBVar11 = (BuildingData *)&pBVar11->contAct;
	}
	pCVar2 = Container_Load(resData,filename,"ACT",TRUE);
	building->contAct = pCVar2;
	if (pCVar2 == NULL) {
		return 0;
	}
	uVar7 = 0xffffffff;
	do {
		pcVar3 = filename;
		if (uVar7 == 0) break;
		uVar7 -= 1;
		pcVar3 = filename + 1;
		cVar1 = *filename;
		filename = pcVar3;
	} while (cVar1 != '\0');
	uVar7 = ~uVar7;
	puVar10 = (undefined4 *)(pcVar3 + -uVar7);
	puVar12 = (undefined4 *)buffName;
	for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
		*puVar12 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	uVar7 = util::Util_Tokenise(buffName,stringParts,"\\");
	if (1 < uVar7) {
		ppcVar9 = stringParts;
		iVar6 = uVar7 - 1;
		do {
			ppcVar9 = ppcVar9 + 1;
			iVar6 += -1;
			(*ppcVar9)[-1] = '\\';
		} while (iVar6 != 0);
	}
	std::sprintf(buffPath,"%s\\%s.%s",buffName,stringParts[uVar7 - 1],"ae");
	prop = cfg::CFG_Open(buffPath);
	if (prop != NULL) {
		pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->CarryNullName = pcVar3;
		if (pcVar3 == NULL) {
			building->CarryNullFrames = 0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->CarryNullFrames = uVar7;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				uVar7 = std::atoi(pcVar3);
				building->CarryNullFrames = uVar7;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->CameraNullName = pcVar3;
		if (pcVar3 == NULL) {
			building->CameraNullFrames = 0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->CameraNullFrames = uVar7;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				uVar7 = std::atoi(pcVar3);
				building->CameraNullFrames = uVar7;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"ToolNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->ToolNullName = pcVar3;
		if (pcVar3 == NULL) {
			building->ToolNullFrames = 0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"ToolNullFrames",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->ToolNullFrames = uVar7;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"ToolNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				uVar7 = std::atoi(pcVar3);
				building->ToolNullFrames = uVar7;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->DepositNullName = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"FireNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->FireNullName = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"EntranceNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->EntranceNullName = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"yPivot",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->yPivot = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"xPivot",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->xPivot = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
		pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
		if (pcVar3 == NULL) {
			building->PivotMaxZ = 1.0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				fVar13 = std::atof(____EMPTYSTR__);
				building->PivotMaxZ = (float)fVar13;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				fVar13 = std::atof(pcVar3);
				building->PivotMaxZ = (float)fVar13;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
		pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
		if (pcVar3 == NULL) {
			building->PivotMinZ = -1.0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				fVar13 = std::atof(____EMPTYSTR__);
				building->PivotMinZ = (float)fVar13;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				fVar13 = std::atof(pcVar3);
				building->PivotMinZ = (float)fVar13;
			}
		}
		Upgrade_LoadUpgradeLevels(&building->upgrades,prop,rootName);
		pPVar4 = (Point2I *)std::malloc(0x50);
		building->shapePoints = pPVar4;
		building->shapeCount = 1;
		pPVar4->y = 0;
		building->shapePoints->x = 0;
		pcVar3 = cfg::CFG_JoinPath(rootName,"Shape",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		if (pcVar3 != NULL) {
			local_998 = util::Util_Tokenise(pcVar3,stringParts,":");
			if (local_998 != 0) {
				local_99c = stringParts;
				do {
					uVar7 = building->shapeCount;
					pPVar4 = building->shapePoints;
					pcVar5 = *local_99c;
					building->shapeCount = uVar7 + 1;
					iVar6 = std::atoi(pcVar5);
					pPVar4[uVar7].x = iVar6;
					pcVar5 = std::strstr(pcVar5,",");
					iVar6 = std::atoi(pcVar5 + 1);
					pPVar4[uVar7].y = iVar6;
					local_99c = local_99c + 1;
					local_998 += -1;
				} while (local_998 != 0);
			}
			std::free(pcVar3);
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"PowerLevelScene",0);
		pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
		if (pcVar3 != NULL) {
			std::sprintf(buffPath,"%s\\%s",buffName,pcVar3);
			pCVar2 = Container_Load(resData,buffPath,"LWS",TRUE);
			building->contPowerLevelScene = pCVar2;
		}
		cfg::CFG_Close(prop);
	}
	Container_Hide(building->contAct,TRUE);
	building->objIndex = objIndex;
	building->flags = 0;
	return TRUE;
}



void __cdecl lego::res::Building_FUN_00408210(BuildingData *building,BOOL unkAddSubInverse)
{
	float fVar1;
	
	if (unkAddSubInverse == 0) {
		fVar1 = ((float)building->field_80 - 0.1) * 10.0 * 0.1111111;
	}
	else {
		fVar1 = (float)building->field_80 - (1.0 - (float)building->field_80) * -0.1;
	}
	building->field_80 = fVar1;
	if ((float)building->field_80 < 0.0) {
		building->field_80 = 0;
	}
	building->flags = building->flags | 2;
	return;
}



Point2I * __cdecl lego::res::Building_GetShapePoints(BuildingData *building,uint *out_shapeCount)
{
	if (out_shapeCount != NULL) {
		*out_shapeCount = building->shapeCount;
	}
	return building->shapePoints;
}



void __cdecl lego::res::Object_SetOwnerObject(BasicObjectData *basicObjData,LiveObject *liveObj)
{
	Container_SetUserData(basicObjData->aeResData,liveObj);
	return;
}



void __cdecl lego::res::Building_SetUpgradeActivity(BuildingData *building,char *activityName)
{
	int *opt_instance;
	LiveObject *pLVar1;
	uint uVar2;
	BuildingData *basicObjData;
	undefined4 *puVar3;
	Container *pCVar4;
	Container *child;
	char *pcVar5;
	undefined4 *puVar6;
	int iVar7;
	UpgradeData *upgrade;
	uint local_14;
	int local_10;
	uint local_c;
	int local_8;
	UpgradeData *local_4;
	
	basicObjData = building;
	iVar7 = 3;
	pLVar1 = (LiveObject *)(building->upgrades).upgradeObjs;
	puVar3 = (undefined4 *)&building->field_0xc4;
	puVar6 = (undefined4 *)&building->field_0xa0;
	do {
		puVar3[0x1a] = 0;
		*puVar3 = 0;
		puVar3[-3] = 0;
		*puVar6 = 0;
		puVar3 = puVar3 + 1;
		iVar7 += -1;
		puVar6[1] = 0;
		puVar6 = puVar6 + 2;
	} while (iVar7 != 0);
	building->count_144 = 0;
	do {
		if (pLVar1 == NULL) {
			return;
		}
		upgrade = pLVar1->upgrade;
		iVar7 = upgrade->field_c;
		local_8 = iVar7;
		local_4 = upgrade;
		pCVar4 = Object_SearchForPartName
											 ((BasicObjectData *)basicObjData,*(undefined4 *)(iVar7 + 8),
												*(undefined4 *)(iVar7 + 4));
		child = Object_GetActivityContainer((BasicObjectData *)upgrade);
		Container_SetParent(child,pCVar4);
		Container_ClearTransform(child);
		if (activityName == NULL) {
			Container_SetActivity(upgrade->aeResData,globs::liveGlobs.Activities_TABLE[0]);
		}
		else {
			Upgrade_SetActivity(upgrade,activityName);
		}
		if (*(int *)(iVar7 + 0xc) != 0) {
			uVar2 = basicObjData->count_144;
			local_10 = 0;
			*(undefined4 *)(&basicObjData->field_0xd8 + uVar2 * 4) = 0;
			local_14 = 0;
			opt_instance = (int *)(&basicObjData->field_0xd8 + uVar2 * 4);
			building = (BuildingData *)(basicObjData->cameraFramesTable_40 + uVar2 * 2 + 0x18);
			local_c = uVar2;
			do {
				building->objIndex = 0;
				pcVar5 = Container_FormatPartName
													 (basicObjData->contAct,basicObjData->FireNullName,opt_instance);
				pCVar4 = Container_SearchTree(child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
				basicObjData->cameraFramesTable_40[*opt_instance + uVar2 * 2 + 0x18] = pCVar4;
				pCVar4 = basicObjData->cameraFramesTable_40[uVar2 * 2 + *opt_instance + 0x18];
				*opt_instance = *opt_instance + 1;
				if (pCVar4 == NULL) break;
				local_14 += 1;
				building = (BuildingData *)&building->contAct;
			} while (local_14 < 2);
			pcVar5 = Container_FormatPartName(basicObjData->contAct,basicObjData->xPivot,&local_10);
			pCVar4 = Container_SearchTree(child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			uVar2 = local_c;
			basicObjData->cameraFramesTable_40[local_c + 0x1e] = pCVar4;
			pcVar5 = Container_FormatPartName(basicObjData->contAct,basicObjData->yPivot,&local_10);
			pCVar4 = Container_SearchTree(child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			*(Container **)(&basicObjData->field_0xc4 + uVar2 * 4) = pCVar4;
			*(int *)(&basicObjData->field_0x12c + uVar2 * 4) = local_8;
			basicObjData->count_144 = basicObjData->count_144 + 1;
			upgrade = local_4;
		}
		pLVar1 = upgrade->object_8;
	} while( true );
}



BOOL __cdecl
lego::res::Building_SetActivity_AndRemoveCarryCameraFrames
					(BuildingData *building,char *activityName,float elapsed)
{
	uint uVar1;
	BOOL BVar2;
	Container **ppCVar3;
	
	uVar1 = 0;
	if (building->CarryNullFrames != 0) {
		ppCVar3 = building->carryFramesTable_28;
		do {
			*ppCVar3 = NULL;
			uVar1 += 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar1 < building->CarryNullFrames);
	}
	uVar1 = 0;
	if (building->CameraNullFrames != 0) {
		ppCVar3 = building->cameraFramesTable_40;
		do {
			*ppCVar3 = NULL;
			uVar1 += 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar1 < building->CameraNullFrames);
	}
	building->field_68 = 0;
	building->field_6c = 0;
	BVar2 = Container_SetActivity(building->contAct,activityName);
	Container_SetAnimationTime(building->contAct,elapsed);
	Building_SetUpgradeActivity(building,activityName);
	return BVar2;
}



Container * __cdecl lego::res::Building_GetCameraNull(BuildingData *building,int cameraIndex)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)building->CameraNullName;
	if (pCVar1 != NULL) {
		if (building->cameraFramesTable_40[cameraIndex] == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)building,pCVar1,cameraIndex);
			building->cameraFramesTable_40[cameraIndex] = pCVar1;
		}
		pCVar1 = building->cameraFramesTable_40[cameraIndex];
	}
	return pCVar1;
}



void __cdecl lego::res::Building_Duplicate(BuildingData *in_building,BuildingData *out_building)
{
	Container *pCVar1;
	int iVar2;
	BuildingData *pBVar3;
	BuildingData *pBVar4;
	
	pBVar3 = in_building;
	pBVar4 = out_building;
	for (iVar2 = 0x53; iVar2 != 0; iVar2 += -1) {
		pBVar4->objIndex = pBVar3->objIndex;
		pBVar3 = (BuildingData *)&pBVar3->contAct;
		pBVar4 = (BuildingData *)&pBVar4->contAct;
	}
	out_building->flags = out_building->flags & 0xfffffffe;
	pCVar1 = Container_Clone(in_building->contAct);
	out_building->contAct = pCVar1;
	if (in_building->contPowerLevelScene != NULL) {
		pCVar1 = Container_Clone(in_building->contPowerLevelScene);
		out_building->contPowerLevelScene = pCVar1;
	}
	return;
}



void __cdecl lego::res::Building_HideAll(BuildingData *building,BOOL hide)
{
	Container_Hide(building->contAct,hide);
	if (building->contPowerLevelScene != NULL) {
		Container_Hide(building->contPowerLevelScene,hide);
	}
	return;
}



BOOL __cdecl lego::res::Object_IsHidden(BasicObjectData *basicObjData)
{
	BOOL BVar1;
	
	BVar1 = Container_IsHidden(basicObjData->aeResData);
	return BVar1;
}



void __cdecl lego::res::Building_SetOrientation(BuildingData *building,float x,float y)
{
	Container_SetOrientation(building->contAct,NULL,x,y,0.0,0.0,0.0,-1.0);
	if (building->contPowerLevelScene != NULL) {
		Container_SetOrientation(building->contPowerLevelScene,NULL,x,y,0.0,0.0,0.0,-1.0);
	}
	return;
}



void __cdecl
lego::res::Building_SetPosition
					(BuildingData *building,float x,float y,undefined *getZcallback,SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = (float10)(*(code *)getZcallback)(x,y,surfMap);
	Container_SetPosition(building->contAct,NULL,x,y,(float)fVar1);
	if (building->contPowerLevelScene != NULL) {
		Container_SetPosition(building->contPowerLevelScene,NULL,x,y,(float)fVar1);
	}
	return;
}



Container * __cdecl lego::res::Building_GetCarryNull(BuildingData *building,int carryIndex)
{
	Container *pCVar1;
	
	if (building->CarryNullName == NULL) {
		return NULL;
	}
	if (building->carryFramesTable_28[carryIndex] != NULL) {
		return building->carryFramesTable_28[carryIndex];
	}
	pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->CarryNullName,carryIndex);
	building->carryFramesTable_28[carryIndex] = pCVar1;
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetDepositNull(BuildingData *building)
{
	Container *pCVar1;
	
	if (building->DepositNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)building->field_68;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->DepositNullName,0);
			building->field_68 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetEntranceNull(BuildingData *building)
{
	Container *pCVar1;
	
	if (building->EntranceNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)building->field_6c;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->EntranceNullName,0);
			building->field_6c = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetToolNull(BuildingData *building,int toolIndex)
{
	Container *pCVar1;
	
	if (building->ToolNullName == NULL) {
		return NULL;
	}
	if (building->cameraFramesTable_40[toolIndex + 4] != NULL) {
		return building->cameraFramesTable_40[toolIndex + 4];
	}
	pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->ToolNullName,toolIndex);
	building->cameraFramesTable_40[toolIndex + 4] = pCVar1;
	return pCVar1;
}



int __cdecl lego::res::Building_GetCarryNullFrames(BuildingData *building)
{
	return building->CarryNullFrames;
}



float10 __cdecl lego::res::Building_FUN_00408790(BuildingData *building,float elapsed,uint param_3)
{
	BuildingData *pBVar1;
	BuildingData *pBVar2;
	uint uVar3;
	float10 fVar4;
	
	pBVar2 = building;
	fVar4 = Container_MoveAnimation(building->contAct,elapsed);
	pBVar1 = (BuildingData *)(float)fVar4;
	if ((1 < param_3) && ((float)pBVar1 != 0.0)) {
		uVar3 = Container_GetAnimationFrames(building->contAct);
		pBVar1 = (BuildingData *)((float)pBVar1 - (float)(ulonglong)(uVar3 * (param_3 - 1)));
	}
	building = pBVar1;
	if ((*(byte *)&pBVar2->flags & 2) != 0) {
		if (pBVar2->contPowerLevelScene != NULL) {
			uVar3 = Container_GetAnimationFrames(pBVar2->contPowerLevelScene);
			Container_SetAnimationTime
								(pBVar2->contPowerLevelScene,(float)(ulonglong)uVar3 * (float)pBVar2->field_80);
		}
		pBVar2->flags = pBVar2->flags & 0xfffffffd;
	}
	return (float10)(float)building;
}



float10 __cdecl lego::res::Building_GetAnimFloat14_zero(BuildingData *building)
{
	return (float10)0.0;
}



void __cdecl lego::res::Building_Destroy(BuildingData *building)
{
	Building_ChangeUpgradeParts(building,-1);
	if (building->contPowerLevelScene != NULL) {
		Container_Remove(building->contPowerLevelScene);
	}
	Container_Remove(building->contAct);
	return;
}



BOOL __cdecl
lego::res::Object_Debug_ChangeUpgradeModel(BuildingData *building,int levelBit,BOOL condition)
{
	uint uVar1;
	
	uVar1 = 1 << ((byte)levelBit & 0x1f);
	if ((condition != 0) && (((building->upgrades).levelsMask & uVar1) != 0)) {
		return 0;
	}
	return (building->upgrades).levelsMask & uVar1;
}



void __cdecl lego::res::Building_ChangeUpgradeParts(BuildingData *building,int objLevel)
{
	Upgrade_ChangeUpgradeParts(&building->upgrades,objLevel);
	Building_SetUpgradeActivity(building,NULL);
	return;
}



float10 __cdecl
lego::math::Collision_Maths_Sub_FUN_00408900(Point2F *param_1,Point2F *param_2,Point2F *param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float10 fVar6;
	float10 fVar7;
	
	fVar3 = param_3->x - param_2->x;
	fVar5 = param_3->y - param_2->y;
	fVar6 = (float10)param_1->x - (float10)param_3->x;
	fVar7 = (float10)param_1->y - (float10)param_3->y;
	fVar1 = (float)fVar6;
	fVar2 = (float)fVar7;
	fVar6 = SQRT(fVar7 * (float10)fVar2 + fVar6 * (float10)fVar1);
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar3 * fVar3);
	fVar3 = fVar4 * fVar3;
	fVar4 = fVar4 * fVar5;
	if ((float10)(float)((float10)1.0 / fVar6) * (float10)fVar2 * (float10)fVar4 +
			((float10)1.0 / fVar6) * (float10)fVar1 * (float10)fVar3 < (float10)0.0) {
		fVar5 = param_1->x - param_2->x;
		fVar1 = param_1->y - param_2->y;
		fVar2 = SQRT(fVar1 * fVar1 + fVar5 * fVar5);
		fVar1 = (1.0 / fVar2) * fVar1 * fVar4 + (1.0 / fVar2) * fVar5 * fVar3;
		if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) {
			return (float10)fVar2;
		}
		fVar6 = std::acos((float10)fVar1);
		fVar6 = (float10)fsin(fVar6);
		fVar6 = fVar6 * (float10)fVar2;
	}
	return fVar6;
}



float10 __cdecl
lego::math::Collision_Maths_FUN_00408a30
					(Point2F *point,Point2F *fromList,Point2F *toList,uint count)
{
	Point2F *pPVar1;
	int iVar2;
	int iVar3;
	float10 fVar4;
	
	fVar4 = Collision_Maths_Sub_FUN_00408900(point,fromList,toList);
	pPVar1 = (Point2F *)(float)fVar4;
	if (1 < count) {
		iVar3 = (int)toList - (int)fromList;
		iVar2 = count - 1;
		toList = (Point2F *)(float)fVar4;
		do {
			fromList = fromList + 1;
			fVar4 = Collision_Maths_Sub_FUN_00408900(point,fromList,(Point2F *)(iVar3 + (int)fromList));
			if (fVar4 < (float10)(float)toList) {
				toList = (Point2F *)(float)fVar4;
			}
			iVar2 += -1;
			pPVar1 = toList;
		} while (iVar2 != 0);
	}
	toList = pPVar1;
	return (float10)(float)toList;
}



Point2F * __cdecl
lego::math::Collision_Maths_FUN_00408a90
					(Point2F *param_1,Point2F *param_2,Point2F *position,Point2F *out_point)
{
	float fVar1;
	float fVar2;
	float fVar3;
	
	fVar3 = param_2->x - param_1->x;
	fVar1 = param_2->y - param_1->y;
	fVar2 = 1.0 / SQRT(fVar1 * fVar1 + fVar3 * fVar3);
	fVar3 = fVar2 * fVar3;
	fVar2 = fVar2 * fVar1;
	fVar1 = (position->y - param_1->y) * fVar2 + (position->x - param_1->x) * fVar3;
	out_point->x = fVar1 * fVar3 + param_1->x;
	out_point->y = fVar1 * fVar2 + param_1->y;
	return out_point;
}



Point2F * __cdecl
lego::math::Collision_MathUnk_Vector2D_FUN_00408b20
					(Point2F *param_1,Point2F *param_2,Point2F *position,Point2F *out_point)
{
	float fVar1;
	float fVar2;
	float fVar3;
	
	fVar1 = param_2->y;
	fVar2 = param_2->x;
	fVar3 = 1.0 / SQRT(fVar1 * fVar1 + fVar2 * fVar2);
	fVar2 = fVar3 * fVar2;
	fVar3 = fVar3 * fVar1;
	fVar1 = (position->y - param_1->y) * fVar3 + (position->x - param_1->x) * fVar2;
	out_point->x = fVar1 * fVar2 + param_1->x;
	out_point->y = fVar1 * fVar3 + param_1->y;
	return out_point;
}



uint __cdecl lego::game::Construction_GetBuildingBase(char *name)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	byte **ppbVar6;
	bool bVar7;
	
	uVar4 = 0;
	if (globs::constructionGlobs.buildingBaseCount == 0) {
		return 0;
	}
	ppbVar6 = (byte **)globs::constructionGlobs.buildingBaseTable;
	do {
		pbVar2 = *ppbVar6;
		pbVar5 = (byte *)name;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00408bee:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00408bf3;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00408bee;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00408bf3:
		if (iVar3 == 0) {
			return uVar4;
		}
		uVar4 += 1;
		ppbVar6 = ppbVar6 + 1;
		if (globs::constructionGlobs.buildingBaseCount <= uVar4) {
			return globs::constructionGlobs.buildingBaseCount;
		}
	} while( true );
}



void __cdecl lego::game::Construction_FUN_00408c10(int param_1,LiveObject *liveObj)
{
	BlockConstruction *pBVar1;
	
	pBVar1 = Construction_BlockCheck_FUN_00408ff0(NULL,&param_1);
	if (pBVar1 == NULL) {
		if (liveObj->objType == OBJECT_POWERCRYSTAL) {
			Message_AddMessageAction(MESSAGE_GENERATECRYSTAL_COMPLETE,liveObj,0,NULL);
			return;
		}
		Message_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,liveObj,0,NULL);
	}
	else {
		if (liveObj != NULL) {
			liveObj->flags4 = liveObj->flags4 | 0x100;
			pBVar1->liveObjs_2c[pBVar1->liveObjsCount_cc] = liveObj;
			pBVar1->liveObjsCount_cc = pBVar1->liveObjsCount_cc + 1;
			*(int *)&pBVar1->field_0x20 = *(int *)&pBVar1->field_0x20 + 1;
		}
		if (*(int *)&pBVar1->field_0x1c == *(int *)&pBVar1->field_0x20) {
			*(undefined4 *)&pBVar1->field_0x28 = 0x42fa0000;
			pBVar1->flags = pBVar1->flags | 1;
			return;
		}
	}
	return;
}



BOOL __cdecl lego::game::Construction_FUN_00408ca0(int param_1,int param_2,int param_3)
{
	int iVar1;
	int iVar2;
	BlockConstruction *pBVar3;
	uint uVar4;
	ObjectType objType;
	uint uVar5;
	
	pBVar3 = Construction_BlockCheck_FUN_00408ff0(NULL,&param_1);
	iVar2 = param_3;
	iVar1 = param_2;
	if (pBVar3 != NULL) {
		uVar4 = Construction_FUN_00408d40(pBVar3,param_2,param_3);
		objType = (-(uint)((pBVar3->flags & 2) != 0) & 0xb) + OBJECT_BUILDING;
		if (iVar1 == 6) {
			uVar5 = stats::Stats_GetCostCrystal(objType,pBVar3->objIndex,0);
		}
		else {
			if (iVar1 != 7) {
				return 1;
			}
			if (iVar2 == 0) {
				uVar5 = stats::Stats_GetCostOre(objType,pBVar3->objIndex,0);
			}
			else {
				uVar5 = stats::Stats_GetCostRefinedOre(objType,pBVar3->objIndex,0);
			}
		}
		if (uVar4 < uVar5) {
			return TRUE;
		}
	}
	return 0;
}



int __cdecl
lego::game::Construction_FUN_00408d40(BlockConstruction *param_1,ObjectType objType,int objIndex)
{
	int iVar1;
	LiveObject **ppLVar2;
	int iVar3;
	
	iVar1 = 0;
						// count of the list field
	iVar3 = *(int *)&param_1->field_0x20;
	if (iVar3 != 0) {
						// a ptr list field
		ppLVar2 = param_1->liveObjs_2c;
		do {
			if ((objType == (*ppLVar2)->objType) && (objIndex == (*ppLVar2)->objIndex)) {
				iVar1 += 1;
			}
			ppLVar2 = ppLVar2 + 1;
			iVar3 += -1;
		} while (iVar3 != 0);
	}
	return iVar1;
}



void __cdecl
lego::game::Construction_SpawnCarryableObject
					(Point2I *blockPos,ObjectType objType,int objIndex,int objLevel,uint count)
{
	BlockConstruction *pBVar1;
	
	pBVar1 = Construction_BlockCheck_FUN_00408ff0(blockPos,NULL);
	if ((objType == OBJECT_ORE) && (objIndex == ORE_PROCESSED)) {
		pBVar1->flags = pBVar1->flags | 8;
	}
	if (count != 0) {
		do {
			*(int *)&pBVar1->field_0x1c = *(int *)&pBVar1->field_0x1c + 1;
			ai::AITask_DoRequest_ObjectType(objType,objIndex,objLevel,blockPos,pBVar1->int_8,NULL,0);
			count -= 1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::game::Construction_FUN_00408df0(Point2I *blockPos,uint *param_2,uint param_3)
{
	uint *puVar1;
	bool bVar2;
	BlockConstruction *pBVar3;
	SurfaceMap *surfMap;
	uint *puVar4;
	uint uVar5;
	uint *puVar6;
	uint *puVar7;
	Point2I *blockPos_00;
	uint *puVar8;
	float10 fVar9;
	uint local_4c;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	Point2F local_20;
	float local_18;
	undefined4 local_14;
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	pBVar3 = Construction_BlockCheck_FUN_00408ff0(blockPos,NULL);
	surfMap = lrr::Lego_GetMap();
	fVar9 = Map3D_GetBlockSize(surfMap);
	local_40[2] = 1;
	local_2c = 1;
	local_40[1] = -1;
	local_28 = 0xffffffff;
	local_40[0] = 0;
	local_40[3] = 0;
	local_40[4] = 0;
	local_24 = 0;
	local_4c = 0;
	local_20.x = 0.5;
	local_14 = 0x3f000000;
	local_10 = 0x3f000000;
	local_4 = 0x3f000000;
	local_c = (float)((float10)8.8 / fVar9);
	local_20.y = 1.0 - local_c;
	if (param_3 != 0) {
		puVar6 = param_2 + 1;
		puVar8 = param_2 + 2;
		blockPos_00 = (Point2I *)param_2;
		local_18 = local_20.y;
		local_8 = local_c;
		do {
			if (((local_4c == param_3 - 1) || (blockPos_00->x != *puVar8)) || (*puVar6 != puVar8[1])) {
				blockPos = NULL;
				do {
					bVar2 = false;
					uVar5 = 0;
					puVar4 = param_2;
					puVar1 = param_2;
					do {
						puVar7 = puVar1 + 2;
						if (((uVar5 == param_3 - 1) || (*puVar4 != *puVar7)) || (puVar4[1] != puVar1[3])) {
							if ((*puVar4 ==
									 *(int *)((int)((int)register0x00000010 + -0x40) + (int)blockPos) + blockPos_00->x
									) && (puVar4[1] ==
												*puVar6 + *(int *)((int)((int)register0x00000010 + -0x3c) + (int)blockPos)))
							{
								bVar2 = true;
							}
						}
						else {
							uVar5 += 1;
							puVar7 = puVar1 + 4;
							puVar4 = puVar4 + 2;
						}
						uVar5 += 1;
						puVar4 = puVar4 + 2;
						puVar1 = puVar7;
					} while (uVar5 < param_3);
					if (!bVar2) {
						ai::AITask_DoRequest_ObjectType
											(OBJECT_BARRIER,0,0,blockPos_00,pBVar3->int_8,
											 (Point2F *)((int)&blockPos->x + (int)&local_20.x),1);
						*(int *)&pBVar3->field_0x1c = *(int *)&pBVar3->field_0x1c + 1;
					}
					blockPos = blockPos + 1;
				} while (blockPos < (Point2I *)&DAT_00000020);
			}
			else {
				local_4c += 1;
				puVar8 = puVar8 + 2;
				blockPos_00 = blockPos_00 + 1;
				puVar6 = puVar6 + 2;
			}
			local_4c += 1;
			puVar8 = puVar8 + 2;
			blockPos_00 = blockPos_00 + 1;
			puVar6 = puVar6 + 2;
		} while (local_4c < param_3);
	}
	return;
}



BOOL __cdecl lego::game::Construction_BlockCheck_FUN_00408fd0(Point2I *blockPos)
{
	BlockConstruction *pBVar1;
	
	pBVar1 = Construction_BlockCheck_FUN_00408ff0(blockPos,NULL);
	return (uint)(pBVar1 != NULL);
}



BlockConstruction * __cdecl
lego::game::Construction_BlockCheck_FUN_00408ff0(Point2I *blockPos,int *opt_param_2)
{
	BlockConstruction **ppBVar1;
	BlockConstruction *pBVar2;
	
	pBVar2 = globs::constructionGlobs.construct_4;
	if (globs::constructionGlobs.construct_4 != NULL) {
		do {
			if (blockPos == NULL) {
				if ((opt_param_2 != NULL) && (*opt_param_2 == pBVar2->int_8)) {
					return pBVar2;
				}
			}
			else {
				if ((blockPos->x == (pBVar2->pointi_c).x) && (blockPos->y == (pBVar2->pointi_c).y)) {
					return pBVar2;
				}
			}
			ppBVar1 = &pBVar2->next_24;
			pBVar2 = *ppBVar1;
		} while (*ppBVar1 != NULL);
	}
	return NULL;
}



void __cdecl lego::game::Construction_Block_FUN_00409040(Point2I *blockPos)
{
	BlockConstruction *pBVar1;
	
	pBVar1 = Construction_BlockCheck_FUN_00408ff0(blockPos,NULL);
	if (pBVar1 != NULL) {
		front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(blockPos);
		Construction_FUN_00409970(pBVar1);
		Construction_Free(pBVar1);
	}
	return;
}



void __cdecl lego::game::Construction_Cancel2(Point2I *blockPos)
{
	LiveFlags4 *pLVar1;
	LiveObject *liveObj;
	BlockConstruction *pBVar2;
	uint uVar3;
	LiveObject **ppLVar4;
	
	pBVar2 = Construction_BlockCheck_FUN_00408ff0(blockPos,NULL);
	Level_Block_SetLayedPath(blockPos,FALSE);
	uVar3 = 0;
	if (pBVar2->liveObjsCount_cc != 0) {
		ppLVar4 = pBVar2->liveObjs_2c;
		do {
			liveObj = *ppLVar4;
			pLVar1 = &liveObj->flags4;
			*pLVar1 = *pLVar1 & 0xfffffeff;
			ai::AITask_DoCollect(liveObj,0.0);
			uVar3 += 1;
			ppLVar4 = ppLVar4 + 1;
		} while (uVar3 < pBVar2->liveObjsCount_cc);
	}
	front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(blockPos);
	ai::AITask_FUN_00403630(pBVar2->int_8,0,0,0);
	Construction_Free(pBVar2);
	return;
}



void __cdecl lego::game::Construction_Update(float elapsedGame)
{
	uint uVar1;
	BlockConstruction *pBVar2;
	BOOL BVar3;
	BlockConstruction *construct;
	
	construct = globs::constructionGlobs.construct_4;
	if (globs::constructionGlobs.construct_4 != NULL) {
		do {
			uVar1 = construct->flags;
			pBVar2 = construct->next_24;
			if (((uVar1 & 2) == 0) || ((uVar1 & 4) != 0)) {
				if ((uVar1 & 1) != 0) {
					if ((uVar1 & 2) == 0) {
						BVar3 = Construction_LiveObject_DoBlockStructD4_Callbacks_FUN_004091a0(construct);
						if (BVar3 != 0) {
							Construction_FUN_00409970(construct);
							Construction_Complete(construct,TRUE);
							Construction_Free(construct);
						}
					}
					else {
						ai::AITask_DoBuildPath_AtPosition(&construct->pointi_c);
						construct->flags = construct->flags & 0xfffffffe;
					}
				}
			}
			else {
				Construction_FUN_00409480(construct);
			}
			construct = pBVar2;
		} while (pBVar2 != NULL);
	}
	return;
}



BOOL __cdecl
lego::game::Construction_LiveObject_DoBlockStructD4_Callbacks_FUN_004091a0
					(BlockConstruction *param_1)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes
										(Construction_LiveObject_Callback_FindIn_BlockStructD4Table,param_1);
	return (uint)(BVar1 == 0);
}



BOOL __cdecl
lego::game::Construction_LiveObject_Callback_FindIn_BlockStructD4Table
					(LiveObject *liveObj,BlockConstruction *data)
{
	uint index;
	LiveObject **ppLVar1;
	Point2I local_8;
	uint count;
	
	LiveObject_GetBlockPos(liveObj,&local_8.x,&local_8.y);
	if (((data->pointi_c).x == local_8.x) && ((data->pointi_c).y == local_8.y)) {
		count = data->liveObjsCount_cc;
		index = 0;
		if (count != 0) {
			ppLVar1 = data->liveObjs_2c;
			do {
				if (liveObj == *ppLVar1) break;
				index += 1;
				ppLVar1 = ppLVar1 + 1;
			} while (index < count);
		}
		if (index == count) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Construction_LayPath(Point2I *blockPos)
{
	BOOL isPath;
	BlockConstruction *construct;
	
	isPath = Level_Block_IsPath(blockPos);
	if (isPath == 0) {
		construct = Construction_CreateBlock(blockPos);
		Level_Block_SetLayedPath(blockPos,TRUE);
		construct->flags = construct->flags | 2;
		front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(blockPos);
		return TRUE;
	}
	return 0;
}



BlockConstruction * __cdecl lego::game::Construction_CreateBlock(Point2I *blockPos)
{
	BlockConstruction *pBVar1;
	int iVar2;
	BlockConstruction *pBVar3;
	
	pBVar1 = (BlockConstruction *)std::malloc(0xd4);
	pBVar3 = pBVar1;
	for (iVar2 = 0x35; iVar2 != 0; iVar2 += -1) {
		pBVar3->objIndex = 0;
		pBVar3 = (BlockConstruction *)&pBVar3->direction;
	}
	*(undefined4 *)&pBVar1->field_0x20 = 0;
	*(undefined4 *)&pBVar1->field_0x1c = 0;
	pBVar1->int_8 = globs::constructionGlobs.uint_0;
	globs::constructionGlobs.uint_0 += 1;
	(pBVar1->pointi_c).x = blockPos->x;
	(pBVar1->pointi_c).y = blockPos->y;
	pBVar1->next_24 = globs::constructionGlobs.construct_4;
	globs::constructionGlobs.construct_4 = pBVar1;
	return pBVar1;
}



void __cdecl lego::game::Construction_Level_Block_FUN_004092e0(Point2I *blockPos)
{
	Point2I *pPVar1;
	BOOL BVar2;
	Point2I *blockPos_00;
	int iVar3;
	uint local_20 [8];
	
	iVar3 = 4;
	pPVar1 = (Point2I *)&stack0xffffffd8;
	do {
		blockPos_00 = pPVar1 + 1;
		blockPos_00->x = blockPos_00->x + blockPos->x;
		pPVar1[1].y = pPVar1[1].y + blockPos->y;
		BVar2 = Level_Block_IsPath(blockPos_00);
		if (BVar2 == 0) {
			BVar2 = Level_Block_IsSolidBuilding(blockPos_00->x,pPVar1[1].y,TRUE);
			if (BVar2 != 0) goto LAB_00409350;
		}
		else {
LAB_00409350:
			BVar2 = Level_Block_IsPowered(blockPos_00);
			if (BVar2 == 0) {
				Level_Block_SetPowered_AddToTable(blockPos_00);
				Construction_Level_Block_FUN_004092e0(blockPos_00);
			}
		}
		iVar3 += -1;
		pPVar1 = blockPos_00;
		if (iVar3 == 0) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Construction_Level_Blocks_UnkPowerCrystalProc_FUN_00409380
					(Point2I *blockPos,int crystalCount)
{
	BOOL BVar1;
	
	BVar1 = Construction_Level_Block_UnkDrainedPower_FUN_004093a0(blockPos,crystalCount);
	Game_UnkProcessBlockPtsTable_UnsetsFlag2_2();
	return BVar1;
}



BOOL __cdecl
lego::game::Construction_Level_Block_UnkDrainedPower_FUN_004093a0
					(Point2I *blockPos,int crystalCount)
{
	BOOL BVar1;
	LiveObject *liveObj;
	Point2I *blockPos_00;
	uint i;
	Point2I DIRECTIONS [4];
	
	i = 0;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[3].y = 0;
	blockPos_00 = DIRECTIONS;
	do {
		blockPos_00->x = blockPos_00->x + blockPos->x;
		blockPos_00->y = blockPos_00->y + blockPos->y;
		BVar1 = Level_Block_IsGeneratePower(blockPos_00);
		if (((BVar1 != 0) && (liveObj = Game_Unk_DoSearchCallbacks_Unique(blockPos_00), liveObj != NULL)
				) && (BVar1 = LiveObject_AddThisDrainedCrystals(liveObj,crystalCount), BVar1 != 0)) {
			return 1;
		}
		BVar1 = Level_Block_IsPath(blockPos_00);
		if (((BVar1 != 0) ||
				(BVar1 = Level_Block_IsSolidBuilding(blockPos_00->x,blockPos_00->y,TRUE), BVar1 != 0)) &&
			 (BVar1 = Level_Block_IsPowerPathDrainTemp_Unk(blockPos_00), BVar1 == 0)) {
			Level_Block_AddPowerPathDrainTemp_ToTable_Unk(blockPos_00);
			BVar1 = Construction_Level_Block_UnkDrainedPower_FUN_004093a0(blockPos_00,crystalCount);
			if (BVar1 != 0) {
				return TRUE;
			}
		}
		i += 1;
		blockPos_00 = blockPos_00 + 1;
	} while (i < 4);
	return 0;
}



void __cdecl lego::game::Construction_FUN_00409480(BlockConstruction *construct)
{
	Point2I *blockPos;
	BOOL BVar1;
	LiveObject *pLVar2;
	uint count;
	uint count_00;
	uint uVar3;
	int objIndex;
	
	blockPos = &construct->pointi_c;
	BVar1 = Level_IsBuildPathBoolUnk_true(blockPos);
	if (BVar1 != 0) {
		pLVar2 = LiveObject_FUN_00438da0(NULL,blockPos,OBJECT_ORE,0);
		count = stats::Stats_GetCostCrystal(OBJECT_PATH,0,0);
		count_00 = stats::Stats_GetCostOre(OBJECT_PATH,0,0);
		uVar3 = stats::Stats_GetCostRefinedOre(OBJECT_PATH,0,0);
		Construction_SpawnCarryableObject(blockPos,OBJECT_POWERCRYSTAL,0,0,count);
		if ((pLVar2 == NULL) || (uVar3 == 0)) {
			objIndex = 0;
		}
		else {
			objIndex = 1;
			count_00 = uVar3;
		}
		Construction_SpawnCarryableObject(blockPos,OBJECT_ORE,objIndex,0,count_00);
		construct->flags = construct->flags | 4;
	}
	return;
}



void __cdecl lego::game::Construction_Cancel(Point2I *blockPos)
{
	Point2I *pPVar1;
	LiveObject *pLVar2;
	LevelData *level;
	BlockConstruction *pBVar3;
	int iVar4;
	uint uVar5;
	LiveObject **ppLVar6;
	uint uVar7;
	
	level = globs::legoGlobs.level;
	pBVar3 = Construction_BlockCheck_FUN_00408ff0(blockPos,NULL);
	if ((pBVar3 != NULL) && (*(int *)&pBVar3->field_0x1c != *(int *)&pBVar3->field_0x20)) {
		uVar7 = pBVar3->shapeCount;
		uVar5 = 0;
		if (uVar7 != 0) {
			do {
				if (((uVar5 != uVar7 - 1) &&
						(pPVar1 = pBVar3->shapePoints, pPVar1[uVar5].x == pPVar1[uVar5 + 1].x)) &&
					 (pPVar1[uVar5].y == pPVar1[uVar5 + 1].y)) {
					iVar4 = pPVar1[uVar5].y * (level->dimensions).width + pPVar1[uVar5].x;
					level->blocks[iVar4].flags1 = level->blocks[iVar4].flags1 & ~BLOCK1_BUILDINGPATH;
				}
				iVar4 = pBVar3->shapePoints[uVar5].y * (level->dimensions).width +
								pBVar3->shapePoints[uVar5].x;
				level->blocks[iVar4].flags1 = level->blocks[iVar4].flags1 & ~BLOCK1_FOUNDATION;
				level->blocks
				[pBVar3->shapePoints[uVar5].y * (level->dimensions).width + pBVar3->shapePoints[uVar5].x].
				construct = NULL;
				Level_BlockUpdateSurface(level,pBVar3->shapePoints[uVar5].x,pBVar3->shapePoints[uVar5].y,0);
				front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos
									(pBVar3->shapePoints + uVar5);
				uVar7 = pBVar3->shapeCount;
				uVar5 += 1;
			} while (uVar5 < uVar7);
		}
		uVar7 = 0;
		if (pBVar3->liveObjsCount_cc != 0) {
			ppLVar6 = pBVar3->liveObjs_2c;
			do {
				pLVar2 = *ppLVar6;
				if (pLVar2->objType == OBJECT_BARRIER) {
					pLVar2->flags3 = pLVar2->flags3 | LIVEOBJ3_UNK_800000;
					(*ppLVar6)->health = -1.0;
				}
				else {
					pLVar2->flags4 = pLVar2->flags4 & 0xfffffeff;
					ai::AITask_DoCollect(*ppLVar6,0.0);
				}
				uVar7 += 1;
				ppLVar6 = ppLVar6 + 1;
			} while (uVar7 < pBVar3->liveObjsCount_cc);
		}
		ai::AITask_FUN_00403630(pBVar3->int_8,0,0,0);
		Construction_Free(pBVar3);
	}
	return;
}



int __cdecl
lego::game::Construction_Start
					(int objIndex,Point2I *blockPos,Direction direction,Point2I *shapePoints,uint count)
{
	LevelBlockFlags1 *pLVar1;
	bool bVar2;
	LevelData *level;
	BlockConstruction *construct;
	Point2I *pPVar3;
	SurfaceMap *surfMap;
	int idx;
	uint uVar4;
	Point2I *pPVar5;
	float fVar6;
	
	level = globs::legoGlobs.level;
	construct = Construction_CreateBlock(blockPos);
	construct->objIndex = objIndex;
	construct->direction = direction;
	pPVar3 = (Point2I *)std::malloc(count * 8);
	construct->shapePoints = pPVar3;
	pPVar5 = shapePoints;
	for (uVar4 = count * 8 >> 2; uVar4 != 0; uVar4 -= 1) {
		pPVar3->x = pPVar5->x;
		pPVar5 = (Point2I *)&pPVar5->y;
		pPVar3 = (Point2I *)&pPVar3->y;
	}
	fVar6 = 4.0;
	for (idx = 0; idx != 0; idx += -1) {
		*(undefined *)&pPVar3->x = *(undefined *)&pPVar5->x;
		pPVar5 = (Point2I *)((int)&pPVar5->x + 1);
		pPVar3 = (Point2I *)((int)&pPVar3->x + 1);
	}
	pPVar5 = construct->shapePoints;
	construct->shapeCount = count;
	uVar4 = count;
	surfMap = lrr::Lego_GetMap();
	Map3D_FUN_0044ed90(surfMap,pPVar5,uVar4,fVar6);
	blockPos = NULL;
	if (count != 0) {
		pPVar5 = shapePoints + 1;
		do {
			if (((blockPos == (Point2I *)(count - 1)) || (shapePoints->x != pPVar5->x)) ||
				 (shapePoints->y != pPVar5->y)) {
				bVar2 = false;
			}
			else {
				bVar2 = true;
				pLVar1 = &level->blocks[shapePoints->y * (level->dimensions).width + shapePoints->x].flags1;
				*pLVar1 = *pLVar1 | BLOCK1_BUILDINGPATH;
				level->blocks[shapePoints->y * (level->dimensions).width + shapePoints->x].construct =
						 construct;
			}
			idx = shapePoints->y * (level->dimensions).width + shapePoints->x;
			level->blocks[idx].flags1 = level->blocks[idx].flags1 | BLOCK1_FOUNDATION;
			level->blocks[shapePoints->y * (level->dimensions).width + shapePoints->x].construct =
					 construct;
			Level_BlockUpdateSurface(level,shapePoints->x,shapePoints->y,0);
			Construction_FlattenGround(shapePoints);
			front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(shapePoints);
			pPVar3 = shapePoints;
			if (bVar2) {
				blockPos = (Point2I *)((int)&blockPos->x + 1);
				pPVar3 = shapePoints + 1;
				pPVar5 = pPVar5 + 1;
			}
			shapePoints = pPVar5;
			blockPos = (Point2I *)((int)&blockPos->x + 1);
			pPVar5 = shapePoints + 1;
			shapePoints = pPVar3 + 1;
		} while (blockPos < count);
	}
	return construct->int_8;
}



void __cdecl lego::game::Construction_FlattenGround(Point2I *blockPos)
{
	int *piVar1;
	int iVar2;
	Point2I ANGLES [8];
	
						// for (int i = 0; i < 8; i++) {
						//   Level_Block_LowerDigVertices(globs::legoGlobs.level,
						//                                blockPos->x + ANGLES[i].x,
						//                                blockPos->y + ANGLES[i].y);
						// }
	iVar2 = 8;
	piVar1 = (int *)&stack0xffffffb8;
	do {
		Level_Block_LowerRoofVertices
							(globs::legoGlobs.level,blockPos->x + piVar1[2],piVar1[3] + blockPos->y);
		iVar2 += -1;
		piVar1 = piVar1 + 2;
	} while (iVar2 != 0);
	return;
}



void __cdecl lego::game::Construction_RemoveAll(void)
{
	BlockConstruction *pBVar1;
	BlockConstruction *pBVar2;
	
	pBVar2 = globs::constructionGlobs.construct_4;
	if (globs::constructionGlobs.construct_4 != NULL) {
		do {
			pBVar1 = pBVar2->next_24;
			Construction_Free(pBVar2);
			pBVar2 = pBVar1;
		} while (pBVar1 != NULL);
	}
	return;
}



void __cdecl lego::game::Construction_Free(BlockConstruction *param_1)
{
	BlockConstruction *pBVar1;
	BlockConstruction *pBVar2;
	BlockConstruction *pBVar3;
	
	pBVar1 = globs::constructionGlobs.construct_4;
	pBVar3 = NULL;
	if (globs::constructionGlobs.construct_4 != NULL) {
		do {
			pBVar2 = pBVar1;
			if (pBVar2 == param_1) {
				if (pBVar3 == NULL) {
					globs::constructionGlobs.construct_4 = pBVar2->next_24;
				}
				else {
					pBVar3->next_24 = pBVar2->next_24;
				}
				break;
			}
			pBVar1 = pBVar2->next_24;
			pBVar3 = pBVar2;
		} while (pBVar2->next_24 != NULL);
	}
	std::free(param_1->shapePoints);
	std::free(param_1);
	return;
}



void __cdecl lego::game::Construction_FUN_00409970(BlockConstruction *param_1)
{
	LiveObject *pLVar1;
	uint uVar2;
	LiveObject **ppLVar3;
	
	uVar2 = 0;
	if (param_1->liveObjsCount_cc != 0) {
		ppLVar3 = param_1->liveObjs_2c;
		do {
			pLVar1 = *ppLVar3;
			ppLVar3 = ppLVar3 + 1;
			pLVar1->health = -1.0;
			uVar2 += 1;
			pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_UNK_800000;
		} while (uVar2 < param_1->liveObjsCount_cc);
	}
	return;
}



LiveObject * __cdecl
lego::game::Construction_AddShape_FUN_004099c0
					(uint param_1,Point2I *blockPos,Direction param_3,Point2I *shapePoints,uint shapeCount,
					BOOL teleportDown)
{
	SurfaceMap *surfMap;
	LiveObject *pLVar1;
	int iVar2;
	BlockConstruction *pBVar3;
	float fVar4;
	BlockConstruction local_construct;
	
	pBVar3 = &local_construct;
	for (iVar2 = 0x35; iVar2 != 0; iVar2 += -1) {
		pBVar3->objIndex = 0;
		pBVar3 = (BlockConstruction *)&pBVar3->direction;
	}
	local_construct.pointi_c.x = blockPos->x;
	local_construct.pointi_c.y = blockPos->y;
	local_construct.objIndex = param_1;
	local_construct.direction = param_3;
	fVar4 = 4.0;
	local_construct.shapePoints = shapePoints;
	local_construct.shapeCount = shapeCount;
	surfMap = lrr::Lego_GetMap();
	Map3D_FUN_0044ed90(surfMap,shapePoints,shapeCount,fVar4);
	Construction_FlattenGround(blockPos);
	pLVar1 = Construction_Complete(&local_construct,teleportDown);
	return pLVar1;
}



LiveObject * __cdecl
lego::game::Construction_Complete(BlockConstruction *construct,BOOL teleportDown)
{
	ulonglong uVar1;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	uint count;
	ObjectStatsFlags1 OVar2;
	ObjectStatsFlags2 OVar3;
	uint i;
	float xPos;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float yPos;
	Point2I *pShape;
	
	i = 0;
	xPos = 0.0;
	out_y = &yPos;
	xPos = (float)construct->direction;
	out_x = &xPos;
	by = (construct->pointi_c).y;
	uVar1 = (ulonglong)(uint)xPos;
	bx = (construct->pointi_c).x;
	surfMap = lrr::Lego_GetMap();
	Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
	liveObj = LiveObject_CreateInWorld
											(globs::legoGlobs.BuildingData_TABLE + construct->objIndex,OBJECT_BUILDING,
											 construct->objIndex,0,xPos,yPos,(float)uVar1 * 1.570796);
	if (teleportDown != 0) {
		LiveObject_TeleportDownBuilding(liveObj);
		front::Info_Send(INFO_CONSTRUCTED,NULL,liveObj,NULL);
	}
	count = construct->shapeCount;
	if (count != 0) {
		do {
			count = count - 1;
			if (i == count) {
LAB_00409b4b:
				OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
				if ((OVar2 & STATS1_TOOLSTORE) == STATS1_NONE) {
					front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos
										(construct->shapePoints + i);
					Level_Block_SetSolidBuilding(construct->shapePoints[i].x,construct->shapePoints[i].y);
					OVar3 = stats::StatsObject_GetStatsFlags2(liveObj);
					if ((OVar3 & STATS2_GENERATEPOWER) != STATS2_NONE) {
						Level_Block_SetGeneratePower(construct->shapePoints + i);
					}
					Construction_Block_FUN_00409c00(construct->shapePoints + i);
				}
				else {
					Level_Block_SetToolStoreBuilding(construct->shapePoints + i);
				}
				ElectricFence_UpdateBlockConnections
									(construct->shapePoints[i].x,construct->shapePoints[i].y);
			}
			else {
				pShape = construct->shapePoints;
				if ((pShape[i].x != pShape[i + 1].x) || (pShape[i].y != pShape[i + 1].y)) goto LAB_00409b4b;
				Level_Block_SetPathBuilding(pShape[i].x,pShape[i].y);
				LiveObject_TryDock_AtBlockPos_FUN_004403f0(liveObj,construct->shapePoints + i);
				i += 1;
			}
			count = construct->shapeCount;
			i += 1;
		} while (i < count);
	}
	return liveObj;
}



void __cdecl lego::game::Construction_Block_FUN_00409c00(Point2I *blockPos)
{
	int iVar1;
	Point2I *blockOffPos;
	Point2I DIRECTIONS_I [4];
	
	DIRECTIONS_I[0].x = 0;
	DIRECTIONS_I[0].y = -1;
	DIRECTIONS_I[1].x = 1;
	DIRECTIONS_I[1].y = 0;
	DIRECTIONS_I[2].x = 0;
	DIRECTIONS_I[2].y = 1;
	DIRECTIONS_I[3].x = -1;
	DIRECTIONS_I[3].y = 0;
	blockOffPos = DIRECTIONS_I;
	iVar1 = 4;
	do {
		blockOffPos->x = blockOffPos->x + blockPos->x;
		blockOffPos->y = blockOffPos->y + blockPos->y;
		ai::AITask_Block_FUN_00402a10(blockOffPos,0);
		blockOffPos = blockOffPos + 1;
		iVar1 += -1;
	} while (iVar1 != 0);
	return;
}



void __cdecl lego::game::Game_DisableCryOreDrop(BOOL param_1)
{
	globs::constructionGlobs.disableCryOreDrop = param_1;
	return;
}



void __cdecl lego::game::LiveObject_Building_Remove_FUN_00409c80(LiveObject *liveObj)
{
	bool bVar1;
	Point2I *pPVar2;
	Point2I *blockPos;
	SurfaceMap *pSVar3;
	Point2I *pPVar4;
	Direction rotation;
	uint uVar5;
	float10 fVar6;
	uint bx;
	uint by;
	Vector3F *out_x;
	float x;
	float *out_y;
	float y;
	uint local_34;
	Point2F local_30;
	Point2I local_28;
	float local_20;
	float local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	LiveObject_GetFaceDirection(liveObj,&local_30);
	LiveObject_GetBlockPos(liveObj,&local_28.x,&local_28.y);
	LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	if (ABS(local_30.x) <= ABS(local_30.y)) {
		if ((ushort)((ushort)(local_30.y < 0.0) << 8 | (ushort)(local_30.y == 0.0) << 0xe) == 0) {
			rotation = DIRECTION_UP;
		}
		else {
			rotation = DIRECTION_DOWN;
		}
	}
	else {
		if ((ushort)((ushort)(local_30.x < 0.0) << 8 | (ushort)(local_30.x == 0.0) << 0xe) == 0) {
			rotation = DIRECTION_RIGHT;
		}
		else {
			rotation = DIRECTION_LEFT;
		}
	}
	pPVar2 = res::Building_GetShapePoints
										 (globs::legoGlobs.BuildingData_TABLE + liveObj->objIndex,&local_34);
	blockPos = res::SelectPlace_TransformShapePoints(&local_28,pPVar2,local_34,rotation);
	uVar5 = 0;
	pPVar2 = blockPos;
	if (local_34 != 0) {
		do {
			pPVar4 = pPVar2 + 1;
			if (((uVar5 == local_34 - 1) || (blockPos->x != pPVar4->x)) || (blockPos->y != pPVar2[1].y)) {
				bVar1 = false;
			}
			else {
				bVar1 = true;
			}
			Level_Block_UnsetFlags1_108400PwrPath_AndUnsetFlags2_4_UpdateSurface(blockPos);
			Level_Block_UnsetGeneratePower(blockPos);
			if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_8) == 0) {
				by = blockPos->y;
				out_y = &local_18.y;
				out_x = &local_18;
				bx = blockPos->x;
				pSVar3 = lrr::Lego_GetMap();
				Map3D_BlockToWorldPos(pSVar3,bx,by,&out_x->x,out_y);
				x = local_18.x;
				y = local_18.y;
				pSVar3 = lrr::Lego_GetMap();
				fVar6 = Map3D_GetWorldZ(pSVar3,x,y);
				local_18.z = (float)fVar6;
				math::Maths_Vector3DRandom(&local_c);
				local_c.z = 0.0;
				effect::Effect_Spawn_Particle(MISCOBJECT_PATHDUST,&local_18,&local_c);
				ai::AITask_DoClearTypeAction(blockPos,MESSAGE_CLEARBUILDING_COMPLETE);
			}
			ElectricFence_UpdateBlockConnections(blockPos->x,blockPos->y);
			if (bVar1) {
				uVar5 += 1;
				pPVar4 = pPVar2 + 2;
				blockPos = blockPos + 1;
			}
			uVar5 += 1;
			blockPos = blockPos + 1;
			pPVar2 = pPVar4;
		} while (uVar5 < local_34);
	}
	LiveObject_GenerateCryOre_FromCosts(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_GenerateCryOre_FromCosts(LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	Point2I local_8;
	
	if ((liveObj->flags4 & LIVEOBJ4_UNK_800) == LIVEOBJ4_NONE) {
		LiveObject_GetBlockPos(liveObj,&local_8.x,&local_8.y);
		iVar1 = stats::Stats_GetCostOre(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		iVar2 = stats::Stats_GetCostCrystal(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		stats::Stats_GetCostRefinedOre(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		if (globs::constructionGlobs.disableCryOreDrop == 0) {
			for (; iVar2 != 0; iVar2 += -1) {
				Level_GenerateCrystal(&local_8,0,NULL,FALSE);
			}
			for (; iVar1 != 0; iVar1 += -1) {
				Level_GenerateOre(&local_8,0,NULL,FALSE);
			}
		}
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_800;
	}
	return;
}



void __cdecl lego::game::LiveObject_BuildingDestroy(LiveObject *liveObj)
{
	bool bVar1;
	bool bVar2;
	bool bVar3;
	ObjectStatsFlags1 OVar4;
	Point2F local_8;
	
	bVar3 = false;
	bVar1 = false;
	bVar2 = false;
	LiveObject_GetPosition(liveObj,&local_8.x,&local_8.y);
	OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE) &&
		 (globs::legoGlobs.placeDestSmallTeleporter == liveObj)) {
		bVar1 = true;
	}
	OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE) &&
		 (globs::legoGlobs.placeDestBigTeleporter == liveObj)) {
		bVar2 = true;
	}
	OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE) &&
		 (globs::legoGlobs.placeDestWaterTeleporter == liveObj)) {
		bVar3 = true;
	}
	if (bVar1) {
		globs::legoGlobs.placeDestSmallTeleporter = Game_FindSmallTeleporter(&local_8);
	}
	if (bVar2) {
		globs::legoGlobs.placeDestBigTeleporter = Game_FindBigTeleporter(&local_8);
	}
	if (bVar3) {
		globs::legoGlobs.placeDestWaterTeleporter = Game_FindWaterTeleporter(&local_8);
	}
	LiveObject_Remove(liveObj);
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	return;
}



void __cdecl lego::front::Credits_Play(char *textFile,Font *font,char *aviFile)
{
	char *pcVar1;
	byte *memblock;
	Animation_t *anim;
	uint uVar2;
	uint uVar3;
	DWORD DVar4;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	int iVar8;
	char **ppcVar9;
	int iVar10;
	int iVar11;
	int local_444;
	uint local_440;
	uint local_43c;
	DWORD local_438;
	int local_434;
	uint local_430;
	char *local_42c;
	int local_428;
	int local_424;
	char **local_420;
	int local_41c;
	Animation_t *local_418;
	BOOL local_414;
	RECT local_410;
	char buff [1024];
	
	local_434 = 0;
	local_43c = 0;
	local_424 = 0;
	local_438 = timeGetTime();
	local_410.left = 0;
	local_410.top = 0;
	local_410.right = globs::mainGlobs.appWidth;
	local_410.bottom = globs::mainGlobs.appHeight;
	local_430 = lego::image::Font_GetHeight(font);
	iVar10 = globs::mainGlobs.appHeight / local_430 + 1;
	local_41c = (int)globs::mainGlobs.appWidth / 2;
	local_428 = iVar10;
	std::sprintf(buff,"%s.cconv",textFile);
	memblock = lego::file::File_LoadBinary(buff,&local_440);
	if ((memblock != NULL) ||
		 (memblock = lego::file::File_LoadBinary(textFile,&local_440), memblock != NULL)) {
		local_42c = (char *)std::realloc(memblock,local_440 + 4);
		local_42c[local_440] = '\0';
		anim = video::Animation_Load(aviFile);
		if (1 < (int)local_440) {
			iVar6 = local_440 - 1;
			pcVar1 = local_42c;
			do {
				if ((*pcVar1 == '\r') && (pcVar1[1] == '\n')) {
					local_434 += 1;
				}
				iVar6 += -1;
				pcVar1 = pcVar1 + 1;
			} while (iVar6 != 0);
		}
		local_434 += 1;
		local_418 = anim;
		local_420 = (char **)std::malloc(local_434 * 4);
		util::Util_Tokenise(local_42c,local_420,"\r\n");
		iVar6 = -iVar10;
		iVar7 = 0;
		local_444 = iVar6;
		do {
			uVar2 = input::Input_AnyKeyPressed();
			if ((uVar2 != 0) || ((globs::INPUT.mslb == 0 && (iVar7 != 0)))) {
				local_424 = 1;
			}
			local_414 = globs::INPUT.mslb;
			video::Animation_Update(anim);
			uVar2 = video::Animation_GetLength(anim);
			uVar3 = video::Animation_GetTime(anim);
			if (uVar2 <= uVar3) {
				video::Animation_SetTime(anim,0);
			}
			video::Animation_BlitToBackBuffer(anim,&local_410);
			DVar4 = timeGetTime();
			iVar7 = iVar6;
			if (0x21 < DVar4 - local_438) {
				local_43c += 1;
				if (local_43c == local_430) {
					iVar7 = iVar6 + 1;
					local_43c = 0;
					local_444 = iVar7;
					if (iVar6 == local_434) {
						iVar7 = -iVar10;
						local_444 = iVar7;
					}
				}
				uVar2 = local_438 + 0x21;
				local_438 = uVar2;
				DVar4 = timeGetTime();
				if (uVar2 < DVar4) {
					local_438 = timeGetTime();
				}
			}
			iVar6 = iVar7;
			if (iVar7 < local_434) {
				iVar8 = iVar7 * local_430;
				ppcVar9 = local_420 + iVar7;
				iVar11 = iVar8;
				do {
					iVar6 = local_444;
					anim = local_418;
					iVar10 = local_428;
					if (local_428 < iVar7 - local_444) break;
					if (-1 < iVar7) {
						uVar2 = lego::image::Font_GetStringWidth(font,"%s",*ppcVar9);
						lego::image::Font_PrintF
											(font,local_41c - (int)uVar2 / 2,(iVar11 - iVar8) - local_43c,"%s",*ppcVar9);
					}
					iVar7 += 1;
					iVar11 += local_430;
					ppcVar9 = ppcVar9 + 1;
					anim = local_418;
					iVar10 = local_428;
				} while (iVar7 < local_434);
			}
			snd::SFX_Update(1.0);
			BVar5 = video::Animation_IsOk(anim);
			if (BVar5 == 0) {
				main::Main_LoopUpdate(TRUE);
				Sleep(10);
			}
			else {
				main::Main_LoopUpdate(FALSE);
			}
			iVar7 = local_414;
		} while (local_424 == 0);
		if (anim != NULL) {
			video::Animation_Free(anim);
		}
		std::free(local_420);
		std::free(local_42c);
	}
	return;
}



void __cdecl lego::effect::DamageFont_Cleanup(void)
{
	uint *puVar1;
	
	puVar1 = &globs::dmgfontGlobs.instanceTable[0].flags;
	do {
		if ((*puVar1 & 1) != 0) {
			*puVar1 = *puVar1 & 0xfffffffe;
			res::Container_Hide((Container *)puVar1[-7],TRUE);
		}
		puVar1 = puVar1 + 8;
	} while (puVar1 < globs::dependencyGlobs.table[0].numRequirements + 6);
	return;
}



void __cdecl lego::effect::DamageFont_LoadFrames(char *dirName,char *fileBaseName)
{
	Container_Texture *pCVar1;
	uint uVar2;
	char filenameBuff [260];
	char baseDirBuff [260];
	
	uVar2 = 0;
	do {
		std::sprintf(baseDirBuff,"%s\\",dirName);
		if (fileBaseName == NULL) {
			std::sprintf(filenameBuff,"%i.bmp",uVar2);
		}
		else {
			std::sprintf(filenameBuff,"%s%i.bmp",fileBaseName);
		}
		if (uVar2 == 10) {
			globs::dmgfontGlobs.fontTextMinus = res::Mesh_LoadTexture(baseDirBuff,filenameBuff,0,0);
		}
		else {
			pCVar1 = res::Mesh_LoadTexture(baseDirBuff,filenameBuff,0,0);
			globs::dmgfontGlobs.fontTextDigitsTable[uVar2] = pCVar1;
		}
		uVar2 += 1;
	} while (uVar2 < 0xb);
	return;
}



void __cdecl
lego::effect::DamageFont_DisplayDamage_OverLiveObject(LiveObject *liveObj,uint displayNumber)
{
	BOOL BVar1;
	HealthFontData *healthFont;
	Container *pCVar2;
	Mesh *pMVar3;
	int iVar4;
	float10 fVar5;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_18 = 0;
	local_14 = 2;
	local_10 = 1;
	local_c = 0;
	local_8 = 3;
	local_4 = 2;
	BVar1 = front::DamageFont_LiveObject_CheckCanShowDamage_Unk(liveObj);
	if ((((BVar1 != 0) && (displayNumber != 0)) && (displayNumber < 999)) &&
		 (healthFont = DamageFont_GetNextFree(), healthFont != NULL)) {
		healthFont->timerUp = 0.0;
		healthFont->float_10 = 0.0;
		healthFont->float_c = 0.0;
		fVar5 = stats::StatsObject_GetCollHeight(liveObj);
		healthFont->timerDown = (float)-fVar5;
		if (healthFont->ownerCont == NULL) {
			pCVar2 = game::LiveObject_GetContainer(liveObj);
			pCVar2 = res::Container_Create(pCVar2);
			healthFont->ownerCont = pCVar2;
			pMVar3 = res::Mesh_CreateOnFrame
												 (pCVar2->activityFrame,DamageFont_MeshRenderCallback,0x3000,healthFont,
													MESH_TYPE_NORM);
			healthFont->mesh = pMVar3;
			iVar4 = 4;
			do {
				res::Mesh_AddGroup(healthFont->mesh,4,2,3,&local_18);
				iVar4 += -1;
			} while (iVar4 != 0);
		}
		else {
			pCVar2 = game::LiveObject_GetContainer(liveObj);
			res::Container_SetParent(healthFont->ownerCont,pCVar2);
			res::Container_Hide(healthFont->ownerCont,0);
		}
		DamageFont_SetDisplayNumber(healthFont,displayNumber);
	}
	return;
}



HealthFontData * __cdecl lego::effect::DamageFont_GetNextFree(void)
{
	HealthFontData *pHVar1;
	
	pHVar1 = globs::dmgfontGlobs.instanceTable;
	do {
		if ((*(byte *)&pHVar1->flags & 1) == 0) {
			pHVar1->flags = pHVar1->flags | 1;
			return pHVar1;
		}
		pHVar1 = pHVar1 + 1;
	} while (pHVar1 < (HealthFontData *)&DAT_004b9bc4);
	return NULL;
}



void __cdecl
lego::effect::DamageFont_SetDisplayNumber(HealthFontData *healthFont,uint displayNumber)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	D3DRMGroupIndex groupID;
	Mesh *mesh;
	float r;
	float g;
	D3DRMGroupIndex local_4;
	
	DVar2 = D3DRMGROUP_0;
	local_4 = D3DRMGROUP_0;
	groupID = D3DRMGROUP_0;
	do {
		if (displayNumber < 5) {
			res::Mesh_SetGroupColour(healthFont->mesh,groupID,0.0,1.0,0.0,MATERIAL_DIFFUSE);
			mesh = healthFont->mesh;
			g = 1.0;
			r = 0.0;
		}
		else {
			if (displayNumber < 10) {
				res::Mesh_SetGroupColour(healthFont->mesh,groupID,1.0,1.0,0.0,MATERIAL_DIFFUSE);
				mesh = healthFont->mesh;
				g = 1.0;
				r = 1.0;
			}
			else {
				res::Mesh_SetGroupColour(healthFont->mesh,groupID,1.0,0.25,0.0,MATERIAL_DIFFUSE);
				mesh = healthFont->mesh;
				g = 0.25;
				r = 1.0;
			}
		}
		res::Mesh_SetGroupColour(mesh,groupID,r,g,0.0,MATERIAL_EMISSIVE);
		groupID += 1;
	} while (groupID < 4);
	uVar1 = 1;
	if (displayNumber != 0) {
		do {
			DVar2 += 1;
			uVar1 *= 10;
			local_4 = DVar2;
		} while (uVar1 <= displayNumber);
	}
	DVar2 = D3DRMGROUP_0;
	if (local_4 != D3DRMGROUP_0) {
		do {
			res::Mesh_SetGroupTexture
								(healthFont->mesh,DVar2,globs::dmgfontGlobs.fontTextDigitsTable[displayNumber % 10])
			;
			res::Mesh_HideGroup(healthFont->mesh,DVar2,FALSE);
			displayNumber = (displayNumber - displayNumber % 10) / 10;
			DVar2 += 1;
		} while (DVar2 < local_4);
	}
	res::Mesh_SetGroupTexture(healthFont->mesh,DVar2,globs::dmgfontGlobs.fontTextMinus);
	for (DVar2 = local_4 + 1; DVar2 < 4; DVar2 += 1) {
		res::Mesh_HideGroup(healthFont->mesh,DVar2,TRUE);
	}
	healthFont->groupCount = local_4 + 1;
	return;
}



void __cdecl
lego::effect::DamageFont_MeshRenderCallback(Mesh *mesh,HealthFontData *healthFont,Viewport *view)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Container *cont;
	Container *cont_00;
	D3DRMGroupIndex groupID;
	float local_88;
	Vector3F local_80;
	float local_74;
	float local_70;
	float local_6c;
	Vector3F local_68;
	Vector3F local_5c;
	float local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	Point2F local_2c;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	Vector3F local_c;
	
	local_2c.x = 0.0;
	local_2c.y = 0.0;
	local_24 = 0x3f800000;
	local_20 = 0;
	local_1c = 0x3f800000;
	local_18 = 0x3f800000;
	local_14 = 0;
	local_10 = 0x3f800000;
	cont = lrr::Lego_GetCurrentViewLight();
	fVar1 = healthFont->timerUp * 0.06666667;
	res::Container_SetOrientation(healthFont->ownerCont,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
	cont_00 = lego::view::Viewport_GetCamera(view);
	res::Container_GetOrientation(cont_00,NULL,&local_68,&local_80);
	res::Container_GetPosition(cont,NULL,&local_c);
	fVar2 = local_80.y * local_68.z;
	fVar3 = local_80.z * local_68.y;
	fVar4 = local_80.z * local_68.x;
	local_68.z = local_80.x * local_68.z;
	local_68.y = local_80.x * local_68.y;
	local_68.x = local_80.y * local_68.x;
	local_6c = ((fVar1 + fVar1) - -1.0) * 3.0;
	local_80.x = local_6c * local_80.x;
	local_80.y = local_6c * local_80.y;
	local_88 = 1.0 - (float)(ulonglong)healthFont->groupCount * 0.5;
	local_80.z = local_6c * local_80.z;
	local_74 = local_6c * (fVar2 - fVar3);
	groupID = D3DRMGROUP_0;
	local_70 = local_6c * (fVar4 - local_68.z);
	local_6c = local_6c * (local_68.y - local_68.x);
	if (healthFont->groupCount != 0) {
		do {
			local_5c.x = healthFont->float_c - local_88 * local_74;
			local_5c.y = healthFont->float_10 - local_88 * local_70;
			local_5c.z = healthFont->timerDown - local_88 * local_6c;
			local_50 = local_74 + local_5c.x;
			local_4c = local_70 + local_5c.y;
			local_48 = local_6c + local_5c.z;
			local_38 = local_80.x + local_5c.x;
			local_34 = local_80.y + local_5c.y;
			local_44 = local_80.x + local_50;
			local_30 = local_80.z + local_5c.z;
			local_40 = local_80.y + local_4c;
			local_3c = local_80.z + local_48;
			res::Mesh_SetVertices_PointNormalAt(healthFont->mesh,groupID,0,4,&local_5c,&local_c,&local_2c)
			;
			local_88 = local_88 - -1.0;
			groupID += 1;
		} while (groupID < healthFont->groupCount);
	}
	return;
}



void __cdecl lego::effect::DamageFont_UpdateAll(float elapsedAbs)
{
	HealthFontData *healthFont;
	
	healthFont = globs::dmgfontGlobs.instanceTable;
	do {
		if ((*(byte *)&healthFont->flags & 1) != 0) {
			DamageFont_UpdateSingle(healthFont,elapsedAbs);
		}
		healthFont = healthFont + 1;
	} while (healthFont < (HealthFontData *)&DAT_004b9bc4);
	return;
}



void __cdecl lego::effect::DamageFont_UpdateSingle(HealthFontData *healthFont,float elapsedAbs)
{
	float fVar1;
	D3DRMGroupIndex groupID;
	
	if (healthFont->timerUp < 15.0) {
		healthFont->float_c = healthFont->float_c + 0.0;
		groupID = D3DRMGROUP_0;
		healthFont->float_10 = healthFont->float_10 + 0.0;
		healthFont->timerDown = elapsedAbs * -1.0 + healthFont->timerDown;
		fVar1 = healthFont->timerUp;
		if (healthFont->groupCount != 0) {
			do {
				res::Mesh_SetGroupMaterialValues
									(healthFont->mesh,groupID,1.0 - fVar1 * 0.06666667,MATERIAL_ALPHA);
				groupID += 1;
			} while (groupID < healthFont->groupCount);
		}
		healthFont->timerUp = elapsedAbs + healthFont->timerUp;
		return;
	}
	healthFont->flags = healthFont->flags & 0xfffffffe;
	res::Container_Hide(healthFont->ownerCont,TRUE);
	return;
}



BOOL __cdecl lego::front::DamageFont_LiveObject_CheckCanShowDamage_Unk(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
	if ((((OVar1 & STATS2_DONTSHOWDAMAGE) == STATS2_NONE) && (liveObj->objType != OBJECT_DYNAMITE)) &&
		 (liveObj->objType != OBJECT_OOHSCARY)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::debug::Dependencies_Debug_SetBuildingPrerequisits(BOOL on)
{
	globs::dependencyGlobs.disabled = (uint)(on == 0);
	return;
}



void __cdecl lego::game::Dependencies_Reset_ClearAllLevelFlags_10c(void)
{
	DependencyFlags *pFlags;
	int objLevel;
	DependencyFlags *pDVar1;
	int objIndex;
	
	pDVar1 = globs::dependencyGlobs.table[0].levelFlags;
	do {
		objIndex = 0xf;
		do {
			objLevel = 0x10;
			pFlags = pDVar1;
			do {
				objLevel += -1;
				*pFlags = *pFlags & ~(DEPENDENCY_UNK_4|DEPENDENCY_UNK_8|DEPENDENCY_UNK_100);
				pFlags = pFlags + 1;
			} while (objLevel != 0);
			pDVar1 = pDVar1 + 0x31;
			objIndex += -1;
		} while (objIndex != 0);
	} while (pDVar1 < globs::effectGlobs.rockFallEffects[0].xBlockPosTable + 2);
	return;
}



void __cdecl lego::game::Dependencies_Initialise(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	CFGProperty *prop;
	int numParts;
	BOOL BVar2;
	int cmp;
	int objLevel;
	DependencyFlags *pFlags;
	uint uVar3;
	DependencyRequirement *pDVar4;
	int requireObjLevel;
	char **pRequirePart;
	uint size;
	int objIndex;
	int requireObjIndex;
	ObjectType requireObjType;
	uint numRequired;
	char *targetParts [3];
	char *requireObjParts [2];
	char *requireParts [10];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Dependencies",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar1); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		numParts = util::Util_Tokenise(prop->key,targetParts,":");
		BVar2 = Object_GetObjectByName(targetParts[1],(ObjectType *)&rootPath,&objIndex,NULL);
		if (BVar2 != 0) {
			cmp = std::_stricmp(targetParts[0],"HitOnceStay");
			if (numParts == 3) {
				objLevel = std::atoi(targetParts[2]);
				stats::Stats_GetLevels((ObjectType)rootPath,objIndex);
				if (cmp == 0) {
					globs::dependencyGlobs.table[(int)rootPath][objIndex].levelFlags[objLevel] =
							 globs::dependencyGlobs.table[(int)rootPath][objIndex].levelFlags[objLevel] |
							 DEPENDENCY_HITONCESTAY;
				}
				globs::dependencyGlobs.table[(int)rootPath][objIndex].manualLevel = TRUE;
			}
			else {
				objLevel = 0;
				if (cmp == 0) {
					numParts = 0x10;
					pFlags = globs::dependencyGlobs.table[(int)rootPath][objIndex].levelFlags;
					do {
						numParts += -1;
						*pFlags = *pFlags | DEPENDENCY_HITONCESTAY;
						pFlags = pFlags + 1;
					} while (numParts != 0);
				}
				globs::dependencyGlobs.table[(int)rootPath][objIndex].manualLevel = FALSE;
			}
			uVar3 = util::Util_Tokenise(prop->value,requireParts,",");
			numParts = objIndex;
			pcVar1 = rootPath;
			size = uVar3 << 4;
			pDVar4 = (DependencyRequirement *)std::malloc(size);
			globs::dependencyGlobs.table[(int)pcVar1][numParts].requirements[objLevel] = pDVar4;
			globs::dependencyGlobs.table[(int)pcVar1][numParts].numRequirements[objLevel] = uVar3;
			if (uVar3 != 0) {
				pRequirePart = requireParts;
				numRequired = uVar3;
				do {
					numParts = util::Util_Tokenise(*pRequirePart,requireObjParts,":");
					BVar2 = Object_GetObjectByName(requireObjParts[0],&requireObjType,&requireObjIndex,NULL);
					if (BVar2 != 0) {
						// [objType][objIndex].requirements[objLevel][i].objType  = requireObjType;
						// [objType][objIndex].requirements[objLevel][i].objIndex = requireObjIndex;
						*(ObjectType *)
						 ((int)&globs::dependencyGlobs.table[(int)rootPath][objIndex].requirements[objLevel][-1]
										.objType + size) = requireObjType;
						*(int *)((int)globs::dependencyGlobs.table[(int)rootPath][objIndex].requirements
													[objLevel] + (size - 0xc)) = requireObjIndex;
						if (numParts == 2) {
							requireObjLevel = std::atoi(requireObjParts[1]);
							stats::Stats_GetLevels(requireObjType,requireObjIndex);
						// [objType][objIndex].requirements[objLevel][i].objLevel = requireObjlevel;
						// [objType][objIndex].requirements[objLevel][i].hasLevel = TRUE;
							*(int *)((int)globs::dependencyGlobs.table[(int)rootPath][objIndex].requirements
														[objLevel] + (size - 8)) = requireObjLevel;
							*(undefined4 *)
							 ((int)globs::dependencyGlobs.table[(int)rootPath][objIndex].requirements[objLevel] +
							 (size - 4)) = TRUE;
						}
						else {
						// [objType][objIndex].requirements[objLevel][i].hasLevel = FALSE;
							*(undefined4 *)
							 ((int)globs::dependencyGlobs.table[(int)rootPath][objIndex].requirements[objLevel] +
							 (size - 4)) = FALSE;
						}
					}
					pRequirePart = pRequirePart + 1;
					size -= 0x10;
					numRequired -= 1;
				} while (numRequired != 0);
			}
		}
	}
	Dependencies_Prepare_Unk();
	return;
}



BOOL __cdecl
lego::game::Dependencies_Object_FUN_0040add0(ObjectType objType,int objIndex,int objLevel)
{
	DependencyFlags *pDVar1;
	DependencyFlags DVar2;
	BOOL BVar3;
	int iVar4;
	ObjectType OVar5;
	
	if (globs::dependencyGlobs.disabled == 0) {
		pDVar1 = globs::dependencyGlobs.table[objType][objIndex].levelFlags + objLevel;
		if ((*(byte *)(globs::dependencyGlobs.table[objType][objIndex].levelFlags + objLevel) &
				DEPENDENCY_UNK_2) == 0) {
			Dependencies_Object_GetRequirements
								(objType,objIndex,objLevel,(DependencyRequirement **)&objIndex,&objType);
			OVar5 = OBJECT_NONE;
			if (objType != OBJECT_NONE) {
				iVar4 = 0;
				do {
					BVar3 = Search_LiveObjects_SkipIgnoreMes
														(Dependencies_LiveObject_CallbackCheck_FUN_0040ae70,
														 (void *)(objIndex + iVar4));
					if (BVar3 == 0) {
						return 0;
					}
					OVar5 += OBJECT_VEHICLE;
					iVar4 += 0x10;
				} while (OVar5 < objType);
			}
			DVar2 = *pDVar1;
			if ((DVar2 & DEPENDENCY_HITONCESTAY) != DEPENDENCY_NONE) {
				*pDVar1 = DVar2 | DEPENDENCY_UNK_2;
			}
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::Dependencies_LiveObject_CallbackCheck_FUN_0040ae70
					(LiveObject *liveObj,LiveObject *otherObj)
{
	BOOL BVar1;
	
	BVar1 = Game_CanStoredObjectTypeBeSpawned(otherObj->objType);
	if (BVar1 == 0) {
		if (otherObj->objType != liveObj->objType) {
			return 0;
		}
		if (otherObj->objIndex != liveObj->objIndex) {
			return 0;
		}
		if ((otherObj->vehicle != NULL) && ((char *)liveObj->objLevel < otherObj->customName)) {
			return 0;
		}
	}
	return TRUE;
}



void __cdecl
lego::game::Dependencies_Object_GetRequirements
					(ObjectType objType,int objIndex,int objLevel,DependencyRequirement **out_requirements,
					uint *out_count)
{
	if (globs::dependencyGlobs.table[objType][objIndex].manualLevel != 0) {
		*out_requirements = globs::dependencyGlobs.table[objType][objIndex].requirements[objLevel];
		*out_count = globs::dependencyGlobs.table[objType][objIndex].numRequirements[objLevel];
		return;
	}
	*out_requirements = globs::dependencyGlobs.table[objType][objIndex].requirements[0];
	*out_count = globs::dependencyGlobs.table[objType][objIndex].numRequirements[0];
	return;
}



void __cdecl
lego::game::Dependencies_Object_Unlock
					(ObjectType objType,int objIndex,int objLevel,DependencyUnlocks *unlocks)
{
	DependencyUnlocks *pDVar1;
	int objIndexOff;
	uint reqIdx;
	uint objIndex_00;
	ObjectType objType_00;
	uint numRequirements;
	uint *local_8;
	uint local_4;
	
	pDVar1 = unlocks;
	local_8 = (uint *)&globs::dependencyGlobs.table[0].manualLevel;
	objType_00 = OBJECT_NONE;
	unlocks->count = 0;
	do {
		objIndex_00 = 0;
		do {
			if (*local_8 == 0) {
				Dependencies_Object_GetRequirements
									(objType_00,objIndex_00,0,(DependencyRequirement **)&unlocks,&numRequirements);
				reqIdx = 0;
				if (numRequirements != 0) {
					objIndexOff = 0;
					do {
						if (((*(ObjectType *)((int)unlocks->objTypes + objIndexOff) == objType) &&
								(*(int *)((int)unlocks->objTypes + objIndexOff + 4) == objIndex)) &&
							 ((*(int *)((int)unlocks->objTypes + objIndexOff + 0xc) == 0 ||
								(*(int *)((int)unlocks->objTypes + objIndexOff + 8) == objLevel)))) {
							pDVar1->objTypes[pDVar1->count] = objType_00;
							pDVar1->objIndexes[pDVar1->count] = objIndex_00;
							pDVar1->objHasLevels[pDVar1->count] = FALSE;
							pDVar1->count = pDVar1->count + 1;
						}
						reqIdx += 1;
						objIndexOff += 0x10;
					} while (reqIdx < numRequirements);
				}
			}
			else {
				reqIdx = 0;
				do {
					Dependencies_Object_GetRequirements
										(objType_00,objIndex_00,reqIdx,(DependencyRequirement **)&unlocks,
										 &numRequirements);
					objIndexOff = 0;
					local_4 = 0;
					if (numRequirements != 0) {
						do {
							if (((*(ObjectType *)((int)unlocks->objTypes + objIndexOff) == objType) &&
									(*(int *)((int)unlocks->objTypes + objIndexOff + 4) == objIndex)) &&
								 ((*(int *)((int)unlocks->objTypes + objIndexOff + 0xc) == 0 ||
									(*(int *)((int)unlocks->objTypes + objIndexOff + 8) == objLevel)))) {
								pDVar1->objTypes[pDVar1->count] = objType_00;
								pDVar1->objIndexes[pDVar1->count] = objIndex_00;
								pDVar1->objLevels[pDVar1->count] = reqIdx;
								pDVar1->objHasLevels[pDVar1->count] = TRUE;
								pDVar1->count = pDVar1->count + 1;
							}
							objIndexOff += 0x10;
							local_4 += 1;
						} while (local_4 < numRequirements);
					}
					reqIdx += 1;
				} while (reqIdx < 0x10);
			}
			objIndex_00 += 1;
			local_8 = local_8 + 0x31;
		} while (objIndex_00 < 0xf);
		objType_00 += OBJECT_VEHICLE;
	} while (local_8 < globs::effectGlobs.rockFallEffects[0].xBlockPosTable + 1);
	return;
}



void __cdecl lego::game::Dependencies_Prepare_Unk(void)
{
	BOOL BVar1;
	DependencyFlags flags;
	uint objIndex;
	uint objTypeOff;
	uint objLevel;
	ObjectType objType;
	DependencyFlags *pFlags;
	
	objTypeOff = 0;
	objType = OBJECT_NONE;
	do {
		objIndex = 0;
		do {
			objLevel = 0;
			do {
				if ((objLevel == 1) &&
					 (globs::dependencyGlobs.table[objIndex + objTypeOff].manualLevel != 0)) break;
				pFlags = globs::dependencyGlobs.table[objIndex + objTypeOff].levelFlags + objLevel;
				if ((*(byte *)(globs::dependencyGlobs.table[objIndex + objTypeOff].levelFlags + objLevel) &
						DEPENDENCY_UNK_8) == 0) {
					BVar1 = Dependencies_Object_FUN_0040add0(objType,objIndex,objLevel);
					flags = *pFlags;
					if (BVar1 == 0) {
						if ((flags & DEPENDENCY_UNK_4) != DEPENDENCY_NONE) goto LAB_0040b14c;
					}
					else {
						if ((flags & DEPENDENCY_UNK_4) == DEPENDENCY_NONE) {
							flags |= DEPENDENCY_UNK_4;
						}
						else {
LAB_0040b14c:
							flags = flags & ~DEPENDENCY_UNK_4 | DEPENDENCY_UNK_8;
						}
						*pFlags = flags;
					}
				}
				objLevel += 1;
			} while (objLevel < 0x10);
			objIndex += 1;
		} while (objIndex < 0xf);
		objTypeOff += 0xf;
		objType += OBJECT_VEHICLE;
		if (299 < objTypeOff) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Dependencies_Object_IsLevelFlag4(ObjectType objType,int objIndex,int objLevel)
{
	if (globs::dependencyGlobs.table[objType][objIndex].manualLevel != 0) {
		return globs::dependencyGlobs.table[objType][objIndex].levelFlags[objLevel] & DEPENDENCY_UNK_4;
	}
	return globs::dependencyGlobs.table[objType][objIndex].levelFlags[0] & DEPENDENCY_UNK_4;
}



void __cdecl
lego::game::Dependencies_Object_AddLevelFlag_100(ObjectType objType,int objIndex,int objLevel)
{
	globs::dependencyGlobs.table[objType][objIndex].levelFlags[objLevel] =
			 globs::dependencyGlobs.table[objType][objIndex].levelFlags[objLevel] | DEPENDENCY_UNK_100;
	return;
}



BOOL __cdecl
lego::game::Dependencies_Object_GetLevelFlag_100(ObjectType objType,int objIndex,int objLevel)
{
	return globs::dependencyGlobs.table[objType][objIndex].levelFlags[objLevel] & DEPENDENCY_UNK_100;
}



SurfaceTextureGrid * __cdecl
lego::res::DynamicPM_LoadTextureBaseName(char *textureBaseName,uint width,uint height)
{
	SurfaceTextureGrid *buffer;
	Container_Texture **ppCVar1;
	Container_Texture *pCVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	int local_404;
	char buff [1024];
	
	buffer = (SurfaceTextureGrid *)std::malloc(0xc);
	uVar3 = 0;
	if (buffer != NULL) {
		ppCVar1 = (Container_Texture **)std::malloc(height * width * 4);
		buffer->gridSurfaces = ppCVar1;
		if (ppCVar1 == NULL) {
			std::free(buffer);
			buffer = NULL;
		}
		else {
			(buffer->gridSize).width = width;
			(buffer->gridSize).height = height;
			if (height != 0) {
				local_404 = 0;
				do {
					uVar4 = 0;
					iVar5 = local_404;
					if (width != 0) {
						do {
							std::sprintf(buff,"%s%0.1x%0.1x.bmp",textureBaseName,uVar4,uVar3);
							pCVar2 = Container_LoadTexture2(buff,TRUE,NULL,NULL);
							uVar4 += 1;
							*(Container_Texture **)((int)buffer->gridSurfaces + iVar5) = pCVar2;
							iVar5 = iVar5 + 4;
						} while (uVar4 < width);
					}
					uVar3 += 1;
					local_404 += width * 4;
				} while (uVar3 < height);
				return buffer;
			}
		}
	}
	return buffer;
}



void __cdecl lego::res::DynamicPM_Free_SurfaceTextureGrid(SurfaceTextureGrid *surfTextGrid)
{
	uint width;
	uint y;
	uint x;
	
	y = 0;
	if ((surfTextGrid->gridSize).height != 0) {
		do {
			width = (surfTextGrid->gridSize).width;
			x = 0;
			if (width != 0) {
				do {
					Container_FreeTexture(surfTextGrid->gridSurfaces[y * width + x]);
					width = (surfTextGrid->gridSize).width;
					x += 1;
				} while (x < width);
			}
			y += 1;
		} while (y < (uint)(surfTextGrid->gridSize).height);
	}
	std::free(surfTextGrid->gridSurfaces);
	std::free(surfTextGrid);
	return;
}



float10 __cdecl
lego::res::DynamicPM_FUN_0040b3a0(int param_1,Viewport *view,Point2F *param_3,BOOL param_4)
{
	float *pfVar1;
	float *pfVar2;
	int iVar3;
	Vector4F *out_transform4d;
	Vector3F *pVVar4;
	float10 fVar5;
	float10 fVar6;
	float local_78;
	Vector3F local_70;
	Vector3F local_64;
	Vector3F local_58;
	Vector3F local_4c;
	Vector4F local_40 [4];
	
	local_78 = 1.0;
	iVar3 = 4;
	out_transform4d = local_40;
	pVVar4 = &local_70;
	do {
		lego::view::Viewport_Transform
							(view,out_transform4d,(Vector3F *)((param_1 - (int)&local_70) + (int)pVVar4));
		iVar3 += -1;
		pVVar4->x = out_transform4d->x / out_transform4d->w;
		pVVar4->y = out_transform4d->y / out_transform4d->w;
		out_transform4d = out_transform4d + 1;
		pVVar4 = pVVar4 + 1;
	} while (iVar3 != 0);
	if (param_4 == 0) {
		pfVar2 = &local_40[0].z;
		pfVar1 = &local_70.y;
		iVar3 = 4;
		do {
			if (0.0 <= pfVar1[-1]) {
				if (0.0 <= *pfVar1) {
					if ((ushort)((ushort)(pfVar1[-1] < param_3->x) << 8 |
											(ushort)(pfVar1[-1] == param_3->x) << 0xe) == 0) {
						local_78 = local_78 - 0.25;
					}
					else {
						if ((ushort)((ushort)(*pfVar1 < param_3->y) << 8 |
												(ushort)(*pfVar1 == param_3->y) << 0xe) == 0) {
							local_78 = local_78 - 0.25;
						}
						else {
							if (((ushort)((ushort)(*pfVar2 < pfVar2[1]) << 8 |
													 (ushort)(*pfVar2 == pfVar2[1]) << 0xe) == 0) || (*pfVar2 < 0.0)) {
								local_78 = local_78 - 0.25;
							}
						}
					}
				}
				else {
					local_78 = local_78 - 0.25;
				}
			}
			else {
				local_78 = local_78 - 0.25;
			}
			pfVar1 = pfVar1 + 3;
			pfVar2 = pfVar2 + 4;
			iVar3 += -1;
		} while (iVar3 != 0);
	}
	if ((ushort)((ushort)(local_78 < 0.0) << 8 | (ushort)(local_78 == 0.0) << 0xe) != 0) {
		return (float10)0.0;
	}
	fVar5 = math::Maths_TriangleAreaZ(&local_58,&local_64,&local_70,0);
	fVar6 = math::Maths_TriangleAreaZ(&local_70,&local_4c,&local_58,0);
	return (fVar6 + (float10)(float)fVar5) * (float10)local_78;
}



ProMeshData * __cdecl
lego::res::DynamicPM_LoadPromesh_AB
					(Container *resData,char *meshName_a,char *meshName_b,float blockSize,
					SurfaceTextureGrid *surfTextGrid)
{
	ProMeshData *promesh;
	Container *pCVar1;
	D3DRMVertex *out_retArray;
	float *pfVar2;
	int iVar3;
	float fVar4;
	undefined4 (*pauVar5) [100];
	ProMeshData *pPVar6;
	uint uVar7;
	undefined4 (*pauVar8) [100];
	
	if (meshName_b == NULL) {
		meshName_b = meshName_a;
	}
	promesh = (ProMeshData *)std::malloc(0x340);
	if (promesh != NULL) {
		pCVar1 = Container_Load(resData,meshName_a,"LWO:NOTEXTURE",TRUE);
		promesh->promesh_ab[0] = pCVar1;
		if (pCVar1 != NULL) {
			pCVar1 = Container_Load(resData,meshName_b,"LWO:NOTEXTURE",TRUE);
			promesh->promesh_ab[1] = pCVar1;
			if (pCVar1 == NULL) {
				pCVar1 = Container_Load(resData,meshName_a,"LWO:NOTEXTURE",TRUE);
				promesh->promesh_ab[1] = pCVar1;
			}
			fVar4 = blockSize * 0.01;
			promesh->field_32c = 0;
			promesh->BlockSize = blockSize;
			promesh->surfTextGrid = surfTextGrid;
			pauVar5 = promesh->table_ab;
						// = 2
			blockSize = 2.802597e-45;
			pPVar6 = promesh;
			do {
				Container_Mesh_Scale(pPVar6->promesh_ab[0],fVar4,fVar4,fVar4);
				Container_Mesh_SetPerspectiveCorrection(pPVar6->promesh_ab[0],D3DRMGROUP_0,TRUE);
				Container_Hide(pPVar6->promesh_ab[0],TRUE);
				pauVar8 = pauVar5;
				for (iVar3 = 100; iVar3 != 0; iVar3 += -1) {
					(*pauVar8)[0] = 0;
					pauVar8 = (undefined4 (*) [100])(*pauVar8 + 1);
				}
				pPVar6 = (ProMeshData *)(pPVar6->promesh_ab + 1);
				pauVar5 = pauVar5[1];
				blockSize = (float)((int)blockSize + -1);
			} while (blockSize != 0.0);
			uVar7 = 0;
			do {
				Container_Mesh_GetGroup
									(promesh->promesh_ab[uVar7],D3DRMGROUP_0,(uint *)&blockSize,NULL,NULL,NULL,NULL);
				out_retArray = (D3DRMVertex *)std::malloc((int)blockSize * 0x24);
				Container_Mesh_GetVertices
									(promesh->promesh_ab[uVar7],D3DRMGROUP_0,0,(uint)blockSize,out_retArray);
				fVar4 = 0.0;
				if (blockSize != 0.0) {
					pfVar2 = &out_retArray->tv;
					do {
						if (uVar7 != 0) {
							pfVar2[-1] = 1.0 - pfVar2[-1];
							*pfVar2 = 1.0 - *pfVar2;
						}
						fVar4 = (float)((int)fVar4 + 1);
						pfVar2 = pfVar2 + 9;
					} while ((uint)fVar4 < (uint)blockSize);
				}
				Container_Mesh_SetVertices
									(promesh->promesh_ab[uVar7],D3DRMGROUP_0,0,(uint)blockSize,out_retArray);
				std::free(out_retArray);
				uVar7 += 1;
			} while (uVar7 < 2);
			return promesh;
		}
		std::free(promesh);
	}
	return NULL;
}



void __cdecl lego::res::DynamicPM_Free(ProMeshData *promesh)
{
	ProMeshData *pPVar1;
	int i;
	
	if (promesh != NULL) {
		DynamicPM_Remove_FUN_0040b740(promesh);
		i = 2;
		pPVar1 = promesh;
		do {
			Container_Remove(pPVar1->promesh_ab[0]);
			pPVar1 = (ProMeshData *)(pPVar1->promesh_ab + 1);
			i += -1;
		} while (i != 0);
		std::free(promesh);
	}
	return;
}



void __cdecl lego::res::DynamicPM_Remove_FUN_0040b740(ProMeshData *promesh)
{
	int iVar1;
	undefined4 (*pauVar2) [100];
	int iVar3;
	
	promesh->field_32c = 0;
	pauVar2 = promesh->table_ab;
	iVar1 = 2;
	do {
		iVar3 = 100;
		do {
			if ((Container *)(*pauVar2)[0] != NULL) {
				Container_Remove((Container *)(*pauVar2)[0]);
				(*pauVar2)[0] = 0;
			}
			pauVar2 = (undefined4 (*) [100])(*pauVar2 + 1);
			iVar3 += -1;
		} while (iVar3 != 0);
		iVar1 += -1;
	} while (iVar1 != 0);
	return;
}



Container_Texture * __cdecl
lego::res::DynamicPM_SurfaceTextureGrid_GetTexture
					(SurfaceTextureGrid *param_1,SurfaceTexture coord_4X_0Y)
{
	if (param_1 != NULL) {
		return param_1->gridSurfaces
					 [(coord_4X_0Y & 0xf) * (param_1->gridSize).width + (uint)(coord_4X_0Y >> 4)];
	}
	return NULL;
}



void __cdecl
lego::res::DynamicPM_FUN_0040b7b0
					(ProMeshData *promesh,Vector3F *vectPoses4,SurfaceTexture texture,byte param_4,
					undefined4 param_5,undefined4 param_6)
{
	float fVar1;
	Container_Texture *contTexture;
	Container *pCVar2;
	uint uVar3;
	Container **ppCVar4;
	uint uVar5;
	Container *local_38 [2];
	int local_30 [4];
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (promesh != NULL) {
		fVar1 = promesh->BlockSize;
		local_30[2] = 2;
		local_14 = 2;
		local_c = 2;
		local_30[0] = 3;
		local_1c = 3;
		local_8 = 3;
		local_30[1] = 0;
		local_30[3] = 0;
		local_20 = 1;
		local_18 = 1;
		local_10 = 0;
		local_4 = 1;
		contTexture = DynamicPM_SurfaceTextureGrid_GetTexture(promesh->surfTextGrid,texture);
		ppCVar4 = local_38;
		uVar3 = 0;
		do {
			pCVar2 = Container_Clone(*(Container **)(((int)promesh - (int)local_38) + (int)ppCVar4));
			promesh->table_ab[uVar3 + promesh->field_32c] = pCVar2;
			uVar5 = uVar3 + 100;
			*ppCVar4 = (Container *)promesh->table_ab[uVar3 + promesh->field_32c];
			ppCVar4 = ppCVar4 + 1;
			uVar3 = uVar5;
		} while (uVar5 < 200);
		uVar3 = (uint)param_4;
		DynamicPM_Sub1_FUN_0040b930
							(local_38[0],fVar1,vectPoses4 + local_30[uVar3 * 3],
							 vectPoses4 + local_30[uVar3 * 3 + 1],vectPoses4 + local_30[uVar3 * 3 + 2],param_5,
							 param_6,contTexture,0);
		uVar3 = uVar3 + 2 & 3;
		DynamicPM_Sub1_FUN_0040b930
							(local_38[1],fVar1,vectPoses4 + local_30[uVar3 * 3],
							 vectPoses4 + local_30[uVar3 * 3 + 1],vectPoses4 + local_30[uVar3 * 3 + 2],param_5,
							 param_6,contTexture,0);
		promesh->field_32c = promesh->field_32c + 1;
	}
	return;
}



void __cdecl
lego::res::DynamicPM_Sub1_FUN_0040b930
					(Container *cont,float param_2,Vector3F *position,Vector3F *dir,Vector3F *up,float scaleZ,
					float brightness,Container_Texture *contTexture,byte unkFlags1to80)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	D3DRMGroupIndex groupID;
	
	DynamicPM_Sub2_FUN_0040bac0(cont,param_2,position,dir,up);
	Container_Hide(cont,FALSE);
	groupID = D3DRMGROUP_0;
	uVar1 = Container_Mesh_GetGroupCount(cont);
	if (uVar1 != 0) {
		do {
			Container_Mesh_SetTexture(cont,groupID,contTexture);
			groupID += 1;
			DVar2 = Container_Mesh_GetGroupCount(cont);
		} while (groupID < DVar2);
	}
	Container_AddTranslation(cont,D3DRMCOMBINE_BEFORE,-0.02,-0.02,0.0);
	Container_AddScale(cont,D3DRMCOMBINE_BEFORE,1.015,1.015,scaleZ);
	Container_SetColourAlpha(cont,brightness,brightness,brightness,1.0);
	if ((unkFlags1to80 & 1) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,1.570796);
	}
	if ((unkFlags1to80 & 2) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,-1.570796);
	}
	if ((unkFlags1to80 & 4) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,1.570796);
	}
	if ((unkFlags1to80 & 8) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,-1.570796);
	}
	if ((unkFlags1to80 & 0x10) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,1.570796);
	}
	if ((unkFlags1to80 & 0x20) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,-1.570796);
	}
	if ((unkFlags1to80 & 0x80) != 0) {
		Container_AddTranslation(cont,D3DRMCOMBINE_AFTER,0.0,-10.0,0.0);
	}
	if ((unkFlags1to80 & 0x40) != 0) {
		Container_AddTranslation(cont,D3DRMCOMBINE_AFTER,0.0,10.0,0.0);
	}
	return;
}



void __cdecl
lego::res::DynamicPM_Sub2_FUN_0040bac0
					(Container *cont,float param_2,Vector3F *position,Vector3F *dir,Vector3F *up)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F local_58;
	Vector3F local_4c;
	Matrix4F matrix;
	
	fVar1 = dir->x - position->x;
	local_58.y = dir->y - position->y;
	local_58.z = dir->z - position->z;
	fVar4 = up->x - dir->x;
	fVar2 = up->y - dir->y;
	fVar3 = up->z - dir->z;
	local_4c.x = fVar3 * local_58.y - fVar2 * local_58.z;
	local_4c.y = fVar4 * local_58.z - fVar3 * fVar1;
	local_4c.z = fVar2 * fVar1 - fVar4 * local_58.y;
	fVar3 = 1.0 / SQRT(local_58.z * local_58.z + local_58.y * local_58.y + fVar1 * fVar1);
	fVar2 = 1.0 / SQRT(local_4c.z * local_4c.z + local_4c.y * local_4c.y + local_4c.x * local_4c.x);
	Container_SetOrientation
						(cont,NULL,-(fVar2 * local_4c.x),-(fVar2 * local_4c.y),-(fVar2 * local_4c.z),
						 fVar3 * fVar1,fVar3 * local_58.y,fVar3 * local_58.z);
	Container_SetPosition(cont,NULL,position->x,position->y,position->z);
	Container_InverseTransform(cont,&local_58,dir);
	Container_InverseTransform(cont,&local_4c,up);
	math::DynamicPM_Matrix_FUN_0040bc90(&matrix,param_2,param_2,local_58.y,local_4c.x,local_4c.y);
	Container_AddTransform(cont,D3DRMCOMBINE_BEFORE,&matrix);
	return;
}



void __cdecl
lego::math::DynamicPM_Matrix_FUN_0040bc90
					(Matrix4F *out_matrix,float param_2,float param_3,float param_4,float param_5,
					float param_6)
{
	out_matrix->values[3] = 0.0;
	out_matrix->values[2] = 0.0;
	out_matrix->values[1][3] = 0.0;
	out_matrix->values[1][2] = 0.0;
	out_matrix->values[1][0] = 0.0;
	out_matrix->values[2][3] = 0.0;
	out_matrix->values[2][1] = 0.0;
	out_matrix->values[2][0] = 0.0;
	out_matrix->values[3][2] = 0.0;
	out_matrix->values[3][1] = 0.0;
	out_matrix->values[3][0] = 0.0;
	out_matrix->values[3][3] = 1.0;
	out_matrix->values[2][2] = 1.0;
	out_matrix->values[0] = param_5 / param_2;
	out_matrix->values[1][1] = param_4 / param_3;
	out_matrix->values[1] = (param_6 / param_5) * (param_5 / param_2);
	return;
}



void __cdecl lego::effect::Effect_StopAll(void)
{
	uint *dummy;
	
						// This is an ungodly-lazy method that just sets an arbitrarily
						//  large amount of passed time, thus forcing any sane animation
						//  to finish.
	Effect_UpdateAll(10000.0,&dummy,&dummy);
	return;
}



// This CAN ONLY be used with a non-activity-based object type:
//  I.E. anything but Vehicles, MiniFigures, RockMonsters, Vehicles, or Upgrades.

void __cdecl lego::effect::Effect_Spawn_BoulderExplode_AtObjectOther(LiveObject *liveObj)
{
	Vector3F objPosition;
	
	res::Container_GetPosition(liveObj->other,NULL,&objPosition);
	Effect_Spawn_BoulderExplode(&objPosition);
	return;
}



void __cdecl lego::effect::Effect_Spawn_BoulderExplode(Vector3F *position)
{
	Container **pCont;
	LevelData *level;
	int i;
	Container *cont;
	
	i = 0;
	pCont = globs::effectGlobs.boulderExplodeContTable;
	do {
		if (*pCont == NULL) {
			level = lrr::Lego_GetLevel();
			cont = globs::legoGlobs.contBoulderExplode;
						// Hardcoded Ice boulder explode effect
			if (level->BoulderAnimation == TEXTURES_ICE) {
				cont = globs::legoGlobs.contBoulderExplodeIce;
			}
			cont = res::Container_Clone(cont);
			globs::effectGlobs.boulderExplodeContTable[i] = cont;
			res::Container_SetAnimationTime(cont,0.0);
			res::Container_SetPosition
								(globs::effectGlobs.boulderExplodeContTable[i],NULL,position->x,position->y,
								 position->z);
			res::Container_SetOrientation
								(globs::effectGlobs.boulderExplodeContTable[i],NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
			return;
		}
		pCont = pCont + 1;
		i += 1;
	} while (pCont < globs::effectGlobs.smashPathContTable);
	return;
}



// Must pass in non-null LiveObject* -OR- Vector3F* 
//  in order to get a position. (LiveObject* has precedence)

void __cdecl
lego::effect::Effect_Spawn_SmashPath(LiveObject *optor_liveObj,Vector3F *optor_position)
{
	Container *pCVar1;
	EffectElectricFenceBeam *pEVar2;
	Vector3F local_c;
	
	if (optor_liveObj == NULL) {
		local_c.x = optor_position->x;
		local_c.y = optor_position->y;
		local_c.z = optor_position->z;
	}
	else {
		pCVar1 = game::LiveObject_GetContainer(optor_liveObj);
		res::Container_GetPosition(pCVar1,NULL,&local_c);
	}
	pEVar2 = (EffectElectricFenceBeam *)globs::effectGlobs.smashPathContTable;
	do {
		if (pEVar2->cont == NULL) {
			pCVar1 = res::Container_Clone(globs::legoGlobs.contSmashPath);
			pEVar2->cont = pCVar1;
			res::Container_SetAnimationTime(pCVar1,0.0);
			res::Container_SetPosition(pEVar2->cont,NULL,local_c.x,local_c.y,local_c.z);
			res::Container_SetOrientation(pEVar2->cont,NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
		}
		pEVar2 = (EffectElectricFenceBeam *)pEVar2->contTable;
	} while (pEVar2 < globs::effectGlobs.efenceEffects);
	return;
}



BOOL __cdecl lego::effect::Effect_GetRockFallStyle(char *name,uint *out_index)
{
	int cmp;
	uint i;
	char **pName;
	
	i = 0;
	if (globs::effectGlobs.rockFallStyleCount == 0) {
		return 0;
	}
	pName = globs::effectGlobs.rockFallStyleName;
	do {
		cmp = std::_stricmp(*pName,name);
		if (cmp == 0) {
			*out_index = i;
			return TRUE;
		}
		i += 1;
		pName = pName + 1;
	} while (i < globs::effectGlobs.rockFallStyleCount);
	return 0;
}



void __cdecl lego::effect::Effect_SetRockFallStyle(int rockFallStyleIndex)
{
	globs::effectGlobs.rockFallStyleIndex = rockFallStyleIndex;
	return;
}



void __cdecl
lego::effect::Effect_Load_RockFallStylesAll(CFGProperty *root,char *rootPath,Container *contRoot)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	uint numParts;
	uint rockFallTypeIdx;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	char *stringParts [10];
	char buff [1024];
	
	pcVar2 = cfg::CFG_JoinPath(rootPath,"RockFallStyles",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		pcVar2 = util::_strdup(prop->key);
		globs::effectGlobs.rockFallStyleName[globs::effectGlobs.rockFallStyleCount] = pcVar2;
						// std::strcpy(buff, prop->value);
		uVar3 = 0xffffffff;
		pcVar2 = prop->value;
		do {
			pcVar6 = pcVar2;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar6 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar6;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar6 + -uVar3);
		puVar7 = (undefined4 *)buff;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
						// This right here is where they fucked up...
						//  We're passing stringParts[0] into Effect_Load_RockFallStyle,
						//  And THAT string is being stored in a struct for later used.
						//  AND THIS string is from a temporary buffer.... SO BAD!
		numParts = util::Util_Tokenise(buff,stringParts,",");
		uVar3 = 1;
		if (1 < numParts) {
			rockFallTypeIdx = 1;
			do {
				Effect_Load_RockFallStyle
									(contRoot,stringParts[rockFallTypeIdx],globs::effectGlobs.rockFallStyleCount,
									 rockFallTypeIdx - 1,stringParts[0]);
				uVar3 += 1;
				rockFallTypeIdx = uVar3 & 0xffff;
			} while (rockFallTypeIdx < numParts);
		}
		globs::effectGlobs.rockFallStyleCount += 1;
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



BOOL __cdecl
lego::effect::Effect_Load_RockFallStyle
					(Container *contRoot,char *filename,int rockFallStyle,int rockFallType,char *itemName)
{
	int iVar1;
	EffectRockFall *pEVar2;
	char *pcVar3;
	Container *pCVar4;
	char *name;
	int iVar5;
	Container **ppCVar6;
	
	iVar1 = rockFallType + rockFallStyle * 3;
	pEVar2 = globs::effectGlobs.rockFallEffects + iVar1;
	pCVar4 = res::Container_Load(contRoot,filename,"LWS",TRUE);
	pEVar2->cont = pCVar4;
	if (pCVar4 == NULL) {
		pCVar4 = res::Container_Load(contRoot,filename,"ANIM",TRUE);
		pEVar2->cont = pCVar4;
	}
	if (pEVar2->cont != NULL) {
		res::Container_Hide(pEVar2->cont,TRUE);
		ppCVar6 = globs::effectGlobs.rockFallEffects[iVar1].contTable;
		iVar5 = 4;
		do {
			pCVar4 = res::Container_Clone(pEVar2->cont);
			*ppCVar6 = pCVar4;
			ppCVar6[0xc] = (Container *)TRUE;
			ppCVar6[0x24] = NULL;
			res::Container_Hide(*ppCVar6,TRUE);
			pcVar3 = itemName;
			ppCVar6 = ppCVar6 + 1;
			iVar5 += -1;
		} while (iVar5 != 0);
		name = res::Container_FormatPartName(pEVar2->cont,itemName,NULL);
		res::Container_SearchTree
							(pEVar2->cont,name,CONTAINER_SEARCHMODE_MATCHCOUNT,(uint *)&rockFallStyle);
		globs::effectGlobs.rockFallEffects[iVar1].itemFrameCount = rockFallStyle;
						// itemName is a temporary buffer on the stack!
						//  WTF ARE YOU DOING STORING HERE!??
		globs::effectGlobs.rockFallEffects[iVar1].itemName = pcVar3;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::effect::Effect_Load_ElectricFenceBeam(Container *resRoot,char *filename,BOOL isLongBeam)
{
	Container *cont;
	int i;
	Container **ppCVar1;
	
	cont = res::Container_Load(resRoot,filename,"LWS",TRUE);
	globs::effectGlobs.efenceEffects[isLongBeam].cont = cont;
	if (cont != NULL) {
		res::Container_Hide(cont,TRUE);
		ppCVar1 = globs::effectGlobs.efenceEffects[isLongBeam].contTable;
		i = 30;
		do {
			cont = res::Container_Clone(globs::effectGlobs.efenceEffects[isLongBeam].cont);
						// efenceEffects[isLongBeam].contTable[i] = TRUE;
			*ppCVar1 = cont;
						// efenceEffects[isLongBeam].finishedTable[i] = TRUE;
			ppCVar1[0x1e] = (Container *)TRUE;
			res::Container_Hide(*ppCVar1,TRUE);
			ppCVar1 = ppCVar1 + 1;
			i += -1;
		} while (i != 0);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::effect::Effect_Spawn_RockFall
					(RockFallType rockFallType,int bx,int by,float x,float y,float z,float dirX,float dirY)
{
	int iVar1;
	int *piVar2;
	uint j;
	int i;
	
	i = rockFallType + globs::effectGlobs.rockFallStyleIndex * 3;
	j = 0;
	iVar1 = i * 0xa4;
	piVar2 = globs::effectGlobs.rockFallEffects[i].finishedTable;
	do {
						// if (rockFallEffects[i].finishedTable[j] != false) break;
		if (*piVar2 != 0) break;
		j += 1;
		piVar2 = piVar2 + 1;
	} while (j < 4);
	if (j < 4) {
						// Container_Hide(rockFallEffects[i].contTable[j], false);
		res::Container_Hide(*(Container **)(iVar1 + 0x4c81e4 + j * 4),FALSE);
						// Container_SetAnimationTime(rockFallEffects[i].contTable[j], 0.0f);
		res::Container_SetAnimationTime(*(Container **)(iVar1 + 0x4c81e4 + j * 4),0.0);
						// Container_SetPosition(rockFallEffects[i].contTable[j], NULL, x, y, z);
		res::Container_SetPosition(*(Container **)(iVar1 + 0x4c81e4 + j * 4),NULL,x,y,z);
						// Container_SetOrientation(rockFallEffects[i].contTable[j], NULL, dirX, dirY, 0.0f,
						// 0.0f, 0.0f, -1.0f);
		res::Container_SetOrientation
							(*(Container **)(iVar1 + 0x4c81e4 + j * 4),NULL,dirX,dirY,0.0,0.0,0.0,-1.0);
						// rockFallEffects[i].xBlockTable[j] = bx;
						// rockFallEffects[i].yBlockTable[j] = by;
		*(int *)(iVar1 + 0x4c81f4 + j * 4) = bx;
		*(int *)(iVar1 + 0x4c8204 + j * 4) = by;
						// rockFallEffects[i].finishedTable[j] = false;
		*(undefined4 *)(iVar1 + 0x4c8214 + j * 4) = 0;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::effect::Effect_ElectricFenceBeam_Spawn
					(BOOL longBeam,float xPos,float yPos,float zPos,float xDir,float yDir,float zDir)
{
	int iVar1;
	int *piVar2;
	uint i;
	
	i = 0;
	iVar1 = longBeam * 0xf4;
	piVar2 = globs::effectGlobs.efenceEffects[longBeam].finishedTable;
	do {
						// if (efenceEffects[longBeam].finishedTable != false) break;
		if (*piVar2 != 0) break;
		i += 1;
		piVar2 = piVar2 + 1;
	} while (i < 30);
	if (i < 30) {
						// Container_Hide(efenceEffects[longBeam].contTable[i], false);
		res::Container_Hide(*(Container **)(iVar1 + 0x4c8bfc + i * 4),FALSE);
						// Container_SetAnimationTime(efenceEffects[longBeam].contTable[i], 0.0f);
		res::Container_SetAnimationTime(*(Container **)(iVar1 + 0x4c8bfc + i * 4),0.0);
						// Container_SetPosition(efenceEffects[longBeam].contTable[i], NULL, xPos, yPos, zPos);
		res::Container_SetPosition(*(Container **)(iVar1 + 0x4c8bfc + i * 4),NULL,xPos,yPos,zPos);
						// Container_SetOrientation(efenceEffects[longBeam].contTable[i], NULL, xDir, yDir,
						// zDir, 0.0f, 0.0f, -1.0f);
		res::Container_SetOrientation
							(*(Container **)(iVar1 + 0x4c8bfc + i * 4),NULL,xDir,yDir,zDir,0.0,0.0,-1.0);
						// efenceEffects[longBeam].finishedTable[i] = false;
		*(undefined4 *)(iVar1 + 0x4c8c74 + i * 4) = 0;
		return TRUE;
	}
	return 0;
}



// Returns number of finisher rockFall effects.

uint __cdecl
lego::effect::Effect_UpdateAll
					(float elapsedGame,uint **out_rockFallTypes,uint **out_rockFallSubtypes)
{
	uint rockFallsFinished;
	uint rfType;
	int j;
	int *piVar1;
	BlockElectricFence **ppBVar2;
	uint rfIndex;
	BlockElectricFence **ppBVar3;
	float10 animTime;
	int idx;
	
	rockFallsFinished = 0;
	Effect_Update_Explosion(elapsedGame);
	Effect_Update_BoulderExplode(elapsedGame);
	Effect_Update_SmashPath(elapsedGame);
	Effect_Update_MiscEffectsAll(elapsedGame);
	rfType = 0;
	do {
		idx = rfType + globs::effectGlobs.rockFallStyleIndex * 3;
		if (globs::effectGlobs.rockFallEffects[idx].cont != NULL) {
			rfIndex = 0;
			piVar1 = globs::effectGlobs.rockFallEffects[idx].finishedTable;
			do {
						// if (rockFallEffects[idx].finishedTable[rfIndex] == false)
				if (*piVar1 == 0) {
						// Container_MoveAnimation(rockFallEffects[idx].contTable[rfIndex], elapsedGame);
					animTime = res::Container_MoveAnimation((Container *)piVar1[-0xc],elapsedGame);
						// if (animTime > 0.0f)
					if ((ushort)((ushort)(animTime < (float10)0.0) << 8 |
											(ushort)(animTime == (float10)0.0) << 0xe) == 0) {
						// Container_Hide(rockFallEffects[idx].contTable[rfIndex], true);
						res::Container_Hide((Container *)piVar1[-0xc],TRUE);
						// rockFallEffects[idx].finishedTable[rfIndex] = true;
						*piVar1 = 1;
						// rockFallEffects[idx].bitfieldTable_94[rfIndex] = 0;
						piVar1[0x18] = 0;
						globs::effectGlobs.rockFallCompletedTypes[rockFallsFinished] = rfType;
						globs::effectGlobs.rockFallCompletedIndexes[rockFallsFinished] = rfIndex;
						rockFallsFinished += 1;
					}
				}
				rfIndex += 1;
				piVar1 = piVar1 + 1;
			} while (rfIndex < 4);
		}
		rfType += 1;
	} while (rfType < 3);
						// i = 0;
	ppBVar3 = (BlockElectricFence **)globs::effectGlobs.efenceEffects[0].finishedTable;
	*out_rockFallTypes = globs::effectGlobs.rockFallCompletedTypes;
	*out_rockFallSubtypes = globs::effectGlobs.rockFallCompletedIndexes;
	do {
		j = 30;
		ppBVar2 = ppBVar3;
		do {
						// if (efenceEffects[i].finishedTable[j] == false)
			if (*ppBVar2 == NULL) {
						// Container_MoveAnimation(efenceEffects[i].contTable[j], elapsedGame);
				animTime = res::Container_MoveAnimation((Container *)ppBVar2[-0x1e],elapsedGame);
						// if (animTime > 0.0f)
				if ((ushort)((ushort)(animTime < (float10)0.0) << 8 |
										(ushort)(animTime == (float10)0.0) << 0xe) == 0) {
						// Container_Hide(efenceEffects[i].contTable[j], true);
					res::Container_Hide((Container *)ppBVar2[-0x1e],TRUE);
						// efenceEffects[i].finishedTable[j] = true;
					*ppBVar2 = (BlockElectricFence *)0x1;
				}
			}
			ppBVar2 = ppBVar2 + 1;
			j += -1;
		} while (j != 0);
						// i++;
		ppBVar3 = ppBVar3 + 0x3d;
						// while (i < 2);
	} while (ppBVar3 < globs::efenceGlobs.listSet + 0x17);
	return rockFallsFinished;
}



void __cdecl lego::effect::Effect_Update_BoulderExplode(float elapsedGame)
{
	Container **pCont;
	float10 animTime;
	
						// i = 0;
	pCont = globs::effectGlobs.boulderExplodeContTable;
	do {
		if (*pCont != NULL) {
			animTime = res::Container_MoveAnimation(*pCont,elapsedGame);
						// if (animTime > 0.0f)
			if ((ushort)((ushort)(animTime < (float10)0.0) << 8 |
									(ushort)(animTime == (float10)0.0) << 0xe) == 0) {
				res::Container_Remove(*pCont);
				*pCont = NULL;
			}
		}
		pCont = pCont + 1;
						// while (i < 4);
	} while (pCont < globs::effectGlobs.smashPathContTable);
	return;
}



void __cdecl lego::effect::Effect_Update_SmashPath(float elapsedGame)
{
	Container **pCont;
	float10 animTime;
	
						// i = 0;
	pCont = globs::effectGlobs.smashPathContTable;
	do {
		if (*pCont != NULL) {
			animTime = res::Container_MoveAnimation(*pCont,elapsedGame);
						// if (animTime > 0.0f)
			if ((ushort)((ushort)(animTime < (float10)0.0) << 8 |
									(ushort)(animTime == (float10)0.0) << 0xe) == 0) {
				res::Container_Remove(*pCont);
				*pCont = NULL;
			}
		}
		pCont = pCont + 1;
						// while (i < 4);
	} while (pCont < globs::effectGlobs.efenceEffects);
	return;
}



void __cdecl
lego::effect::Effect_GetBlockPos_RockFall
					(RockFallType rockFallType,int index,uint *out_bx,uint *out_by)
{
	int iVar1;
	
	iVar1 = (rockFallType + globs::effectGlobs.rockFallStyleIndex * 3) * 0xa4;
	*out_bx = *(uint *)(iVar1 + 0x4c81f4 + index * 4);
	*out_by = *(uint *)(iVar1 + 0x4c8204 + index * 4);
	return;
}



Container * __cdecl lego::effect::Effect_Unk_RockFall_FUN_0040c4e0(uint bx,uint by)
{
	uint *puVar1;
	char *name;
	Container *pCVar2;
	uint uVar3;
	uint uVar4;
	EffectRockFall *pEVar5;
	
	uVar3 = 0;
	pEVar5 = globs::effectGlobs.rockFallEffects + globs::effectGlobs.rockFallStyleIndex * 3;
	do {
		if (pEVar5->cont != NULL) {
			uVar4 = 0;
			puVar1 = pEVar5->xBlockPosTable;
			do {
				if (((puVar1[8] == 0) && (bx == *puVar1)) && (by == puVar1[4])) {
					by = 0;
					if (pEVar5->itemFrameCount != 0) goto LAB_0040c546;
					goto LAB_0040c564;
				}
				uVar4 += 1;
				puVar1 = puVar1 + 1;
			} while (uVar4 < 4);
		}
		uVar3 += 1;
		pEVar5 = pEVar5 + 1;
		if (2 < uVar3) {
			return NULL;
		}
	} while( true );
	while( true ) {
		by += 1;
		if ((uint)pEVar5->itemFrameCount <= by) break;
LAB_0040c546:
		if ((pEVar5->bitfieldTable_94[uVar4] & 1 << ((byte)by & 0x1f)) == 0) break;
	}
LAB_0040c564:
	if (by != pEVar5->itemFrameCount) {
		pEVar5->bitfieldTable_94[uVar4] = pEVar5->bitfieldTable_94[uVar4] | 1 << ((byte)by & 0x1f);
		name = res::Container_FormatPartName(pEVar5->contTable[uVar4],pEVar5->itemName,(int *)&by);
		pCVar2 = res::Container_SearchTree
											 (pEVar5->contTable[uVar4],name,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
		return pCVar2;
	}
	return NULL;
}



void __cdecl lego::effect::Effect_RemoveAll_BoulderExplode(void)
{
	Container **ppCVar1;
	
	ppCVar1 = globs::effectGlobs.boulderExplodeContTable;
	do {
		if (*ppCVar1 != NULL) {
			res::Container_Remove(*ppCVar1);
			*ppCVar1 = NULL;
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < globs::effectGlobs.smashPathContTable);
	return;
}



void __cdecl lego::effect::Effect_RemoveAll_RockFall(void)
{
	int iVar1;
	uint uVar2;
	Container **ppCVar3;
	int iVar4;
	
	uVar2 = 0;
	iVar1 = globs::effectGlobs.rockFallStyleIndex;
	do {
		iVar4 = uVar2 + iVar1 * 3;
		if (globs::effectGlobs.rockFallEffects[iVar4].cont != NULL) {
			ppCVar3 = globs::effectGlobs.rockFallEffects[iVar4].contTable;
			iVar4 = 4;
			do {
				res::Container_Remove(*ppCVar3);
				*ppCVar3 = NULL;
				ppCVar3 = ppCVar3 + 1;
				iVar4 += -1;
				iVar1 = globs::effectGlobs.rockFallStyleIndex;
			} while (iVar4 != 0);
		}
		uVar2 += 1;
	} while (uVar2 < 3);
	return;
}



void __cdecl lego::effect::Effect_Load_Explosion(Container *contRoot,char *filename)
{
	globs::effectGlobs.explosionCont = res::Container_Load(contRoot,filename,"LWS",TRUE);
	res::Container_Hide(globs::effectGlobs.explosionCont,TRUE);
	return;
}



void __cdecl lego::effect::Effect_Spawn_Explosion(LiveObject *optor_liveObj,Point2F *optor_position)
{
	SurfaceMap *surfMap;
	Container *pCVar1;
	float10 fVar2;
	float x;
	float y;
	Vector3F position;
	
	if (optor_liveObj == NULL) {
		position.x = optor_position->x;
		position.y = optor_position->y;
	}
	else {
		game::LiveObject_GetPosition(optor_liveObj,&position.x,&position.y);
	}
	x = position.x;
	y = position.y;
	surfMap = lrr::Lego_GetMap();
	fVar2 = game::Map3D_GetWorldZ(surfMap,x,y);
	position.z = (float)(fVar2 - (float10)1.0);
	if (globs::effectGlobs.explosionCount < 4) {
		pCVar1 = res::Container_Clone(globs::effectGlobs.explosionCont);
		globs::effectGlobs.explosionContTable[globs::effectGlobs.explosionCount] = pCVar1;
		pCVar1 = globs::effectGlobs.explosionContTable[globs::effectGlobs.explosionCount];
		globs::effectGlobs.explosionCount += 1;
		res::Container_Hide(pCVar1,FALSE);
		res::Container_SetPosition(pCVar1,NULL,position.x,position.y,position.z);
		res::Container_SetOrientation(pCVar1,NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
		res::Container_SetAnimationTime(pCVar1,0.0);
	}
	return;
}



void __cdecl lego::effect::Effect_Update_Explosion(float elapsedGame)
{
	Container *cont;
	int iVar1;
	int iVar2;
	Container **ppCVar3;
	Container **ppCVar4;
	float10 fVar5;
	
	iVar2 = 0;
	if (0 < (int)globs::effectGlobs.explosionCount) {
		ppCVar3 = globs::effectGlobs.explosionContTable;
		do {
			cont = *ppCVar3;
			fVar5 = res::Container_MoveAnimation(cont,elapsedGame);
			ppCVar4 = ppCVar3;
			if (fVar5 != (float10)0.0) {
				res::Container_Remove(cont);
				iVar2 += -1;
				ppCVar4 = ppCVar3 + -1;
				iVar1 = globs::effectGlobs.explosionCount - 1;
				globs::effectGlobs.explosionCount = globs::effectGlobs.explosionCount - 1;
				*ppCVar3 = globs::effectGlobs.explosionContTable[iVar1];
			}
			iVar2 += 1;
			ppCVar3 = ppCVar4 + 1;
		} while (iVar2 < (int)globs::effectGlobs.explosionCount);
	}
	return;
}



EffectMisc * __cdecl lego::effect::Effect_GetMiscEffectData(MiscEffectType miscEffectType)
{
	switch(miscEffectType) {
	case MISCOBJECT_LAZERHIT:
		return &globs::effectGlobs.lazerHitEffect;
	case MISCOBJECT_PUSHERHIT:
		return &globs::effectGlobs.pusherHitEffect;
	case MISCOBJECT_FREEZERHIT:
		return &globs::effectGlobs.freezerHitEffect;
	case MISCOBJECT_PATHDUST:
		return &globs::effectGlobs.pathDustEffect;
	case MISCOBJECT_LAVAEROSIONSMOKE1:
		return globs::effectGlobs.lavaErosionSmokeEffects;
	case MISCOBJECT_LAVAEROSIONSMOKE2:
		return globs::effectGlobs.lavaErosionSmokeEffects + 1;
	case MISCOBJECT_LAVAEROSIONSMOKE3:
		return globs::effectGlobs.lavaErosionSmokeEffects + 2;
	case MISCOBJECT_LAVAEROSIONSMOKE4:
		return globs::effectGlobs.lavaErosionSmokeEffects + 3;
	case MISCOBJECT_BIRDSCARER:
		return &globs::effectGlobs.birdScarerEffect;
	case MISCOBJECT_UPGRADEEFFECT:
		return &globs::effectGlobs.upgradeEffect;
	default:
		return NULL;
	}
}



BOOL __cdecl
lego::effect::Effect_Load_Misc(EffectMisc *effectMisc,Container *contRoot,char *filename)
{
	Container *pCVar1;
	
	if (filename == NULL) {
		return 0;
	}
	pCVar1 = res::Container_Load(contRoot,filename,"LWS",TRUE);
	effectMisc->cont = pCVar1;
	if (pCVar1 == NULL) {
		pCVar1 = res::Container_Load(contRoot,filename,"LWO",TRUE);
		effectMisc->cont = pCVar1;
		if (pCVar1 == NULL) {
			return 0;
		}
	}
	res::Container_Hide(effectMisc->cont,TRUE);
	return TRUE;
}



void __cdecl lego::effect::Effect_Initialise(CFGProperty *root,char *rootPath,Container *cont)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LazerHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(&globs::effectGlobs.lazerHitEffect,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","PusherHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(&globs::effectGlobs.pusherHitEffect,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","FreezerHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(&globs::effectGlobs.freezerHitEffect,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","PathDust",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(&globs::effectGlobs.pathDustEffect,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke1",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(globs::effectGlobs.lavaErosionSmokeEffects,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke2",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(globs::effectGlobs.lavaErosionSmokeEffects + 1,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke3",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(globs::effectGlobs.lavaErosionSmokeEffects + 2,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke4",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(globs::effectGlobs.lavaErosionSmokeEffects + 3,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","BirdScarer",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(&globs::effectGlobs.birdScarerEffect,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","UpgradeEffect",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_Load_Misc(&globs::effectGlobs.upgradeEffect,cont,pcVar1);
	return;
}



void __cdecl lego::effect::Effect_Update_MiscEffect(EffectMisc *miscEffect,float elapsedGame)
{
	Container *cont;
	uint uVar1;
	uint uVar2;
	EffectMisc *pEVar3;
	uint uVar4;
	float10 fVar5;
	Point2F local_14;
	Vector3F local_c;
	
	uVar4 = 0;
	pEVar3 = miscEffect;
	if (miscEffect->count != 0) {
		do {
			cont = pEVar3->contTable[0];
			if ((miscEffect == &globs::effectGlobs.birdScarerEffect) &&
				 (globs::effectGlobs.birdScarerEffect.field_2c =
							 elapsedGame + globs::effectGlobs.birdScarerEffect.field_2c,
				 (ushort)((ushort)(globs::effectGlobs.birdScarerEffect.field_2c < 12.5) << 8 |
								 (ushort)(globs::effectGlobs.birdScarerEffect.field_2c == 12.5) << 0xe) == 0)) {
				res::Container_GetPosition(cont,NULL,&local_c);
				local_14.x = local_c.x;
				local_14.y = local_c.y;
				game::Game_DoBirdScarerRadiusCallbacks_FUN_00440b80
									(NULL,&local_14,globs::legoGlobs.BirdScarerRadius);
				globs::effectGlobs.birdScarerEffect.field_2c = 0.0;
			}
			fVar5 = res::Container_MoveAnimation(cont,elapsedGame);
			if (fVar5 != (float10)0.0) {
				res::Container_Remove(cont);
				uVar1 = miscEffect->count;
				uVar2 = uVar1 - 1;
				miscEffect->count = uVar2;
				if (uVar4 == uVar2) {
					pEVar3->contTable[0] = NULL;
				}
				else {
					pEVar3->contTable[0] = miscEffect->contTable[uVar1 - 1];
				}
				uVar4 -= 1;
				pEVar3 = (EffectMisc *)&pEVar3[-1].field_34;
			}
			uVar4 += 1;
			pEVar3 = (EffectMisc *)(pEVar3->contTable + 1);
		} while (uVar4 < miscEffect->count);
	}
	return;
}



void __cdecl lego::effect::Effect_Update_MiscEffectsAll(float elapsedGame)
{
	Effect_Update_MiscEffect(&globs::effectGlobs.lazerHitEffect,elapsedGame);
	Effect_Update_MiscEffect(&globs::effectGlobs.pusherHitEffect,elapsedGame);
	Effect_Update_MiscEffect(&globs::effectGlobs.freezerHitEffect,elapsedGame);
	Effect_Update_MiscEffect(&globs::effectGlobs.pathDustEffect,elapsedGame);
	Effect_Update_MiscEffect(globs::effectGlobs.lavaErosionSmokeEffects,elapsedGame);
	Effect_Update_MiscEffect(globs::effectGlobs.lavaErosionSmokeEffects + 1,elapsedGame);
	Effect_Update_MiscEffect(globs::effectGlobs.lavaErosionSmokeEffects + 2,elapsedGame);
	Effect_Update_MiscEffect(globs::effectGlobs.lavaErosionSmokeEffects + 3,elapsedGame);
	Effect_Update_MiscEffect(&globs::effectGlobs.birdScarerEffect,elapsedGame);
	Effect_Update_MiscEffect(&globs::effectGlobs.upgradeEffect,elapsedGame);
	return;
}



BOOL __cdecl
lego::effect::Effect_Spawn_Particle
					(MiscEffectType miscEffectType,Vector3F *position,Vector3F *opt_dir)
{
	EffectMisc *pEVar1;
	Container *pCVar2;
	float dirx;
	float diry;
	float dirz;
	
	pEVar1 = Effect_GetMiscEffectData(miscEffectType);
	if (((pEVar1->count < 10) && (pEVar1 != NULL)) && (pEVar1->cont != NULL)) {
		pEVar1->field_2c = 0;
		pCVar2 = res::Container_Clone(pEVar1->cont);
		pEVar1->contTable[pEVar1->count] = pCVar2;
		res::Container_SetAnimationTime(pEVar1->contTable[pEVar1->count],0.0);
		res::Container_SetPosition
							(pEVar1->contTable[pEVar1->count],NULL,position->x,position->y,position->z);
		if (opt_dir == NULL) {
			dirz = 0.0;
			diry = 1.0;
			dirx = 0.0;
			pCVar2 = pEVar1->contTable[pEVar1->count];
		}
		else {
			dirz = opt_dir->z;
			diry = opt_dir->y;
			dirx = opt_dir->x;
			pCVar2 = pEVar1->contTable[pEVar1->count];
		}
		res::Container_SetOrientation(pCVar2,NULL,dirx,diry,dirz,0.0,0.0,-1.0);
		pEVar1->count = pEVar1->count + 1;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::ElectricFence_Initialise(LevelData *level)
{
	uint uVar1;
	int iVar2;
	BlockElectricFence *pBVar3;
	BlockElectricFence **ppBVar4;
	
	globs::efenceGlobs.fenceGrid =
			 (BlockElectricFence *)
			 std::malloc((level->dimensions).width * (level->dimensions).height * 0x14);
	if (globs::efenceGlobs.fenceGrid != NULL) {
		pBVar3 = globs::efenceGlobs.fenceGrid;
		for (uVar1 = (level->dimensions).width * (level->dimensions).height * 5 & 0x3fffffff; uVar1 != 0
				; uVar1 -= 1) {
			pBVar3->attachedObject = NULL;
			pBVar3 = (BlockElectricFence *)&pBVar3->blockPos;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pBVar3->attachedObject = 0;
			pBVar3 = (BlockElectricFence *)((int)&pBVar3->attachedObject + 1);
		}
	}
	globs::efenceGlobs.level = level;
	ppBVar4 = globs::efenceGlobs.listSet;
	for (iVar2 = 0x20; iVar2 != 0; iVar2 += -1) {
		*ppBVar4 = NULL;
		ppBVar4 = ppBVar4 + 1;
	}
	globs::efenceGlobs.freeList = NULL;
	globs::efenceGlobs.listCount = 0;
	return;
}



void __cdecl lego::game::ElectricFence_Shutdown(void)
{
	BlockElectricFence **ppBVar1;
	
	ppBVar1 = globs::efenceGlobs.listSet;
	do {
		if (*ppBVar1 != NULL) {
			std::free(*ppBVar1);
		}
		ppBVar1 = ppBVar1 + 1;
	} while (ppBVar1 < &globs::efenceGlobs.freeList);
	globs::efenceGlobs.freeList = NULL;
	if (globs::efenceGlobs.fenceGrid != NULL) {
		std::free(globs::efenceGlobs.fenceGrid);
		globs::efenceGlobs.fenceGrid = NULL;
	}
	return;
}



void __cdecl lego::game::ElectricFence_ResetAll(LevelData *level)
{
	ElectricFence_Shutdown();
	ElectricFence_Initialise(level);
	return;
}



void __cdecl lego::game::ElectricFence_UpdateBlockConnections(int bx,int by)
{
	int iVar1;
	int iVar2;
	int iVar3;
	BOOL BVar4;
	int *pDir;
	Point2I DIRECTIONS [4];
	
	iVar3 = by;
	DIRECTIONS[0].y = 1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	DIRECTIONS[2].y = -1;
	DIRECTIONS[3].x = -1;
	Level_BlockUpdateSurface(globs::efenceGlobs.level,bx,by,0);
	pDir = &DIRECTIONS[0].y;
	by = 4;
	do {
		iVar1 = pDir[-1];
		iVar2 = *pDir;
		BVar4 = Map3D_IsInsideDimensions
											((globs::efenceGlobs.level)->surfaceMap,iVar1 + bx,iVar3 + iVar2);
		if (BVar4 != 0) {
			Level_BlockUpdateSurface(globs::efenceGlobs.level,iVar1 + bx,iVar3 + iVar2,0);
		}
		pDir = pDir + 2;
		by += -1;
	} while (by != 0);
	return;
}



void __cdecl lego::game::ElectricFence_AssignBlockObject(LiveObject *liveObj)
{
	LiveObject *liveObj_00;
	int local_4;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
	ElectricFence_Create(liveObj_00,local_4,(int)liveObj);
	return;
}



BlockElectricFence * __cdecl lego::game::ElectricFence_Create(LiveObject *liveObj,int x,int y)
{
	LiveObject **ppLVar1;
	BlockElectricFence *pBVar2;
	
	if (globs::efenceGlobs.freeList == NULL) {
		ElectricFence_AddList();
	}
	pBVar2 = globs::efenceGlobs.freeList;
	ppLVar1 = &(globs::efenceGlobs.freeList)->attachedObject;
	globs::efenceGlobs.freeList = (globs::efenceGlobs.freeList)->nextFree;
	*ppLVar1 = NULL;
	(pBVar2->blockPos).x = 0;
	(pBVar2->blockPos).y = 0;
	pBVar2->timer = 0.0;
	pBVar2->nextFree = NULL;
	pBVar2->nextFree = pBVar2;
	pBVar2->attachedObject = liveObj;
	(pBVar2->blockPos).x = x;
	(pBVar2->blockPos).y = y;
	*(undefined4 *)
	 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
	 (((globs::efenceGlobs.level)->dimensions).width * y + x) * 0xc + 4) = 0;
	(&(globs::efenceGlobs.fenceGrid)->attachedObject)
	[(((globs::efenceGlobs.level)->dimensions).width * y + x) * 3] = (LiveObject *)pBVar2;
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_2000000;
	ElectricFence_UpdateBlockConnections(x,y);
	return pBVar2;
}



void __cdecl lego::game::ElectricFence_AddList(void)
{
	BlockElectricFence *pBVar1;
	BlockElectricFence *pBVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::efenceGlobs.listCount & 0x1f);
	pBVar2 = (BlockElectricFence *)std::malloc(uVar4 * 0x14);
	globs::efenceGlobs.listSet[globs::efenceGlobs.listCount] = pBVar2;
	pBVar2 = globs::efenceGlobs.listSet[globs::efenceGlobs.listCount];
	if (pBVar2 != NULL) {
		globs::efenceGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pBVar1 = pBVar2;
			do {
				pBVar1->nextFree = pBVar1 + 1;
				iVar3 += -1;
				pBVar1 = pBVar1 + 1;
			} while (iVar3 != 0);
		}
		pBVar2[uVar4 - 1].nextFree = globs::efenceGlobs.freeList;
		globs::efenceGlobs.freeList = pBVar2;
	}
	return;
}



void __cdecl lego::game::ElectricFence_LiveObject_Destroy(LiveObject *liveObj)
{
	int local_4;
	
	if ((liveObj->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE) {
		LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
		if ((&(globs::efenceGlobs.fenceGrid)->attachedObject)
				[(((globs::efenceGlobs.level)->dimensions).width * (int)liveObj + local_4) * 3] != NULL) {
			ElectricFence_Remove
								((BlockElectricFence *)
								 (&(globs::efenceGlobs.fenceGrid)->attachedObject)
								 [(((globs::efenceGlobs.level)->dimensions).width * (int)liveObj + local_4) * 3],
								 local_4,(int)liveObj);
		}
	}
	return;
}



void __cdecl lego::game::ElectricFence_Remove(BlockElectricFence *block,int x,int y)
{
	block->nextFree = globs::efenceGlobs.freeList;
	globs::efenceGlobs.freeList = block;
	*(undefined4 *)
	 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
	 (((globs::efenceGlobs.level)->dimensions).width * y + x) * 0xc + 4) = 0;
	(&(globs::efenceGlobs.fenceGrid)->attachedObject)
	[(((globs::efenceGlobs.level)->dimensions).width * y + x) * 3] = NULL;
	ElectricFence_UpdateBlockConnections(x,y);
	return;
}



BOOL __cdecl lego::game::ElectricFence_Debug_PlaceFence(int bx,int by)
{
	BOOL BVar1;
	LiveObject *liveObj;
	Point2F local_8;
	
	BVar1 = ElectricFence_CanPlaceFenceAtBlock(bx,by);
	if (BVar1 != 0) {
		Map3D_BlockToWorldPos((globs::efenceGlobs.level)->surfaceMap,bx,by,&local_8.x,&local_8.y);
		liveObj = LiveObject_CreateInWorld
												(globs::legoGlobs.contElectricFence,OBJECT_ELECTRICFENCE,0,0,local_8.x,
												 local_8.y,0.0);
		ElectricFence_Create(liveObj,bx,by);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::ElectricFence_Debug_RemoveFence(int bx,int by)
{
	LiveObject *liveObj;
	
	if ((&(globs::efenceGlobs.fenceGrid)->attachedObject)
			[(((globs::efenceGlobs.level)->dimensions).width * by + bx) * 3] != NULL) {
		liveObj = (LiveObject *)
							(&(globs::efenceGlobs.fenceGrid)->attachedObject)
							[(((globs::efenceGlobs.level)->dimensions).width * by + bx) * 3]->objType;
		ElectricFence_LiveObject_Destroy(liveObj);
		LiveObject_Remove(liveObj);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::ElectricFence_CanPlaceFenceAtBlock(int bx,int by)
{
	TerrainType TVar1;
	int iVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	Point2I DIRECTIONS [8];
	
	DIRECTIONS[4].y = 2;
	DIRECTIONS[5].x = 2;
	DIRECTIONS[6].y = -2;
	DIRECTIONS[7].x = -2;
	DIRECTIONS[0].y = 1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = -1;
	DIRECTIONS[3].x = -1;
	iVar2 = ((globs::efenceGlobs.level)->dimensions).width * by + bx;
	DIRECTIONS[4].x = 0;
	DIRECTIONS[5].y = 0;
	DIRECTIONS[6].x = 0;
	DIRECTIONS[7].y = 0;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	if (((((*(byte *)&(globs::efenceGlobs.level)->blocks[iVar2].flags1 & 8) == 0) ||
			 (TVar1 = (globs::efenceGlobs.level)->blocks[iVar2].terrain, TVar1 == TERRAIN_LAVA)) ||
			(TVar1 == TERRAIN_WATER_unused)) ||
		 (((&(globs::efenceGlobs.fenceGrid)->attachedObject)[iVar2 * 3] != NULL ||
			(BVar3 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx,by,0), BVar3 != 0)))) {
		return 0;
	}
	uVar4 = 0;
	do {
		uVar5 = *(int *)((int)&DIRECTIONS[0].x + uVar4) + bx;
		uVar6 = by + *(int *)((int)&DIRECTIONS[0].y + uVar4);
		BVar3 = Map3D_IsInsideDimensions((globs::efenceGlobs.level)->surfaceMap,uVar5,uVar6);
		if ((BVar3 != 0) &&
			 (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
				 [(((globs::efenceGlobs.level)->dimensions).width * uVar6 + uVar5) * 3] != NULL ||
				(BVar3 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,uVar5,uVar6,0),
				BVar3 != 0)))) {
			return TRUE;
		}
		uVar5 = *(int *)((int)&DIRECTIONS[4].x + uVar4) + bx;
		uVar6 = *(int *)((int)&DIRECTIONS[4].y + uVar4) + by;
		BVar3 = Map3D_IsInsideDimensions((globs::efenceGlobs.level)->surfaceMap,uVar5,uVar6);
		if (BVar3 != 0) {
			if ((&(globs::efenceGlobs.fenceGrid)->attachedObject)
					[(((globs::efenceGlobs.level)->dimensions).width * uVar6 + uVar5) * 3] != NULL) {
				return 1;
			}
			BVar3 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,uVar5,uVar6,0);
			if (BVar3 != 0) {
				return 1;
			}
		}
		uVar4 += 8;
		if (0x1f < uVar4) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl
lego::game::ElectricFence_Block_FUN_0040d320(LevelData *level,int bx,int by,BOOL param_4)
{
	BOOL BVar1;
	Point2I blockPos;
	
	blockPos.x = bx;
	blockPos.y = by;
	BVar1 = Level_Block_IsSolidBuilding(bx,by,TRUE);
	if (BVar1 != 0) {
		if (param_4 == 0) {
			return 1;
		}
		BVar1 = Level_Block_IsPowered(&blockPos);
		if (BVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::ElectricFence_Update(float elapsedGame)
{
	ElectricFence_EnumerateObjects(ElectricFence_CallbackUpdate,&elapsedGame);
	Search_LiveObjects_SkipIgnoreMes(ElectricFence_LiveObject_Callback_FUN_0040d650,NULL);
	Search_LiveObjects_SkipIgnoreMes(ElectricFence_Callback_FUN_0040d510,&elapsedGame);
	return;
}



void __cdecl
lego::game::ElectricFence_EnumerateObjects(ElectricFenceEnumerateCallback callback,void *data)
{
	int listSetCount;
	BlockElectricFence *efence;
	BlockElectricFence **pEFence;
	uint i;
	int listSetOff;
	
	i = 0;
	if (globs::efenceGlobs.listCount != 0) {
		pEFence = globs::efenceGlobs.listSet;
		do {
			if ((*pEFence != NULL) && (listSetCount = 1 << ((byte)i & 0x1f), listSetCount != 0)) {
				listSetOff = 0;
				do {
					efence = (BlockElectricFence *)((int)&(*pEFence)->attachedObject + listSetOff);
					if ((efence != NULL) && (efence->nextFree == efence)) {
						(*callback)(efence,data);
					}
					listSetOff += 0x14;
					listSetCount += -1;
				} while (listSetCount != 0);
			}
			i += 1;
			pEFence = pEFence + 1;
		} while (i < globs::efenceGlobs.listCount);
	}
	return;
}



BOOL __cdecl lego::game::ElectricFence_FUN_0040d420(LiveObject *liveObj,uint param_2,uint param_3)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	float local_8;
	float local_4;
	
	ElectricFence_EnumerateObjects(ElectricFence_CallbackUpdate,NULL);
	Search_LiveObjects_SkipIgnoreMes(ElectricFence_LiveObject_Callback_FUN_0040d650,NULL);
	if (liveObj == NULL) {
		if (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
				 [(((globs::efenceGlobs.level)->dimensions).width * param_3 + param_2) * 3] == NULL) &&
			 (BVar2 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,param_2,param_3,0),
			 BVar2 == 0)) {
			return 0;
		}
	}
	else {
		LiveObject_GetPosition(liveObj,&local_8,&local_4);
		Map3D_WorldToBlockPos_NoZ
							((globs::efenceGlobs.level)->surfaceMap,local_8,local_4,(int *)&param_2,
							 (int *)&param_3);
		OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
		if (((OVar1 & STATS2_SELFPOWERED) == STATS2_NONE) &&
			 ((liveObj->flags3 & LIVEOBJ3_HASPOWER) == LIVEOBJ3_NONE)) {
			return 0;
		}
	}
	ElectricFence_Block_FUN_0040d780(param_2,param_3,1,0.0);
	return TRUE;
}



BOOL __cdecl
lego::game::ElectricFence_Callback_FUN_0040d510(LiveObject *liveObj,float *pElapsedGame)
{
	float fVar1;
	BOOL BVar2;
	Point2I *pPVar3;
	Point2I *pPVar4;
	float *pfVar5;
	Point2I *pPVar6;
	Direction rotation;
	float *pfVar7;
	Point2F local_10;
	Point2I local_8;
	
	fVar1 = *pElapsedGame;
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_GetBlockPos(liveObj,&local_8.x,&local_8.y);
		BVar2 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,local_8.x,local_8.y,1);
		if (BVar2 != 0) {
			LiveObject_GetFaceDirection(liveObj,&local_10);
			if (ABS(local_10.x) <= ABS(local_10.y)) {
				if ((ushort)((ushort)(local_10.y < 0.0) << 8 | (ushort)(local_10.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_10.x < 0.0) << 8 | (ushort)(local_10.x == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_RIGHT;
				}
				else {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar3 = res::Building_GetShapePoints(liveObj->building,(uint *)&pElapsedGame);
			pPVar4 = res::SelectPlace_TransformShapePoints(&local_8,pPVar3,(int)pElapsedGame,rotation);
			pfVar7 = NULL;
			pfVar5 = pElapsedGame;
			pPVar3 = pPVar4;
			if (pElapsedGame != NULL) {
				do {
					pPVar6 = pPVar3 + 1;
					if (((pfVar7 == (float *)((int)pfVar5 - 1U)) || (pPVar4->x != pPVar6->x)) ||
						 (pPVar4->y != pPVar3[1].y)) {
						ElectricFence_Block_FUN_0040d780(pPVar4->x,pPVar4->y,0,fVar1);
						pfVar5 = pElapsedGame;
					}
					else {
						pfVar7 = (float *)((int)pfVar7 + 1);
						pPVar6 = pPVar3 + 2;
						pPVar4 = pPVar4 + 1;
					}
					pfVar7 = (float *)((int)pfVar7 + 1);
					pPVar4 = pPVar4 + 1;
					pPVar3 = pPVar6;
				} while (pfVar7 < pfVar5);
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::ElectricFence_LiveObject_Callback_FUN_0040d650(LiveObject *liveObj,void *data)
{
	Point2I blockPos;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_GetBlockPos(liveObj,&blockPos.x,&blockPos.y);
		*(undefined4 *)
		 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
		 (((globs::efenceGlobs.level)->dimensions).width * blockPos.y + blockPos.x) * 0xc + 4) = 0;
	}
	return 0;
}



void __cdecl
lego::game::ElectricFence_CallbackUpdate(BlockElectricFence *efence,float *pElapsedGame)
{
	BOOL BVar1;
	int *pDirY;
	uint bx;
	uint by;
	Point2I DIRECTIONS [4];
	BlockElectricFence *efence_00;
	
	efence_00 = efence;
	DIRECTIONS[0].y = 1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	*(undefined4 *)
	 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
	 (((globs::efenceGlobs.level)->dimensions).width * (efence->blockPos).y + (efence->blockPos).x) *
	 0xc + 4) = 0;
	pDirY = &DIRECTIONS[0].y;
	efence = (BlockElectricFence *)&DAT_00000004;
	do {
		bx = pDirY[-1] + (efence_00->blockPos).x;
		by = (efence_00->blockPos).y + *pDirY;
		BVar1 = Map3D_IsInsideDimensions((globs::efenceGlobs.level)->surfaceMap,bx,by);
		if (BVar1 != 0) {
			*(undefined4 *)
			 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
			 (((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc + 4) = 0;
		}
		pDirY = pDirY + 2;
		efence = (BlockElectricFence *)((int)&efence[-1].nextFree + 3);
	} while (efence != NULL);
	if ((pElapsedGame != NULL) &&
		 ((ushort)((ushort)(efence_00->timer < 0.0) << 8 | (ushort)(efence_00->timer == 0.0) << 0xe) ==
			0)) {
		efence_00->timer = efence_00->timer - *pElapsedGame;
	}
	return;
}



void __cdecl
lego::game::ElectricFence_Block_FUN_0040d780(uint bx,uint by,BOOL param_3,float param_4)
{
	uint bx_00;
	uint by_00;
	uint *puVar1;
	VehicleData *pVVar2;
	bool bVar3;
	short sVar4;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	uint bx_01;
	uint by_01;
	ulonglong uVar8;
	uint local_5c;
	float local_58;
	int *local_54;
	int local_50;
	uint local_48;
	uint local_44;
	int local_40;
	int local_3c [4];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 2;
	local_20[2] = 2;
	local_c = 0xfffffffe;
	local_8 = 0xfffffffe;
	local_3c[0] = 1;
	local_3c[1] = 1;
	local_2c = 0xffffffff;
	local_28 = 0xffffffff;
	local_20[0] = 0;
	local_20[3] = 0;
	local_10 = 0;
	local_4 = 0;
	local_40 = 0;
	local_3c[2] = 0;
	puVar1 = (uint *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
									 (((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc + 4);
	local_3c[3] = 0;
	local_24 = 0;
	local_5c = 0;
	*puVar1 = *puVar1 | 0x100;
	local_54 = &local_40;
	do {
		bVar3 = false;
		iVar6 = *local_54;
		bx_00 = bx + iVar6;
		by_00 = local_3c[local_5c * 2] + by;
		BVar5 = Map3D_IsInsideDimensions((globs::efenceGlobs.level)->surfaceMap,bx_00,by_00);
		if ((BVar5 != 0) &&
			 (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
				 [(((globs::efenceGlobs.level)->dimensions).width * by_00 + bx_00) * 3] != NULL ||
				((BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx_00,by_00,1),
				 BVar5 != 0 &&
				 (BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx,by,0), BVar5 == 0))))
			 )) {
			bVar3 = true;
			local_50 = 1;
			local_48 = bx_00;
			local_44 = by_00;
		}
		if (bVar3) {
LAB_0040d9a4:
			if (local_50 == 0) {
				iVar6 = ((globs::efenceGlobs.level)->dimensions).width * by_00 + bx + iVar6;
				*(uint *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos + iVar6 * 0xc + 4) =
						 *(uint *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos + iVar6 * 0xc + 4) | 0x100;
			}
			iVar6 = ((globs::efenceGlobs.level)->dimensions).width;
			iVar7 = local_44 * iVar6 + local_48;
			if (((&(globs::efenceGlobs.fenceGrid)->attachedObject)[iVar7 * 3] == NULL) ||
				 (pVVar2 = (&(globs::efenceGlobs.fenceGrid)->attachedObject)[iVar7 * 3]->vehicle,
				 (ushort)((ushort)((float)pVVar2 < 0.0) << 8 | (ushort)((float)pVVar2 == 0.0) << 0xe) != 0))
			{
				if ((*(uint *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos + iVar7 * 0xc + 4) &
						1 << ((byte)local_5c & 0x1f)) == 0) {
					puVar1 = (uint *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
													 (by * iVar6 + bx) * 0xc + 4);
					*puVar1 = *puVar1 | 1 << ((byte)local_5c - 2 & 3);
					local_58 = param_4;
					if ((ushort)((ushort)(param_4 < 200.0) << 8 | (ushort)(param_4 == 200.0) << 0xe) == 0) {
						local_58 = 200.0;
					}
					if (param_3 == 0) {
						if (local_58 != 0.0) {
							sVar4 = math::Maths_Rand();
							uVar8 = __ftol((float10)200.0 / (float10)local_58);
							if ((int)((ulonglong)(uint)(int)sVar4 % (uVar8 & 0xffffffff)) == 0) goto LAB_0040dab9;
						}
					}
					else {
LAB_0040dab9:
						ElectricFence_Block_UnkAreaDistanceBetweenBlocks(bx,by,local_48,local_44);
					}
				}
				BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,local_48,local_44,0);
				if ((BVar5 == 0) &&
					 ((*(uint *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
											(((globs::efenceGlobs.level)->dimensions).width * local_44 + local_48) * 0xc +
											4) & 0x100) == 0)) {
					ElectricFence_Block_FUN_0040d780(local_48,local_44,param_3,param_4);
				}
			}
		}
		else {
			by_01 = by + local_20[local_5c * 2 + 1];
			bx_01 = local_20[local_5c * 2] + bx;
			BVar5 = Map3D_IsInsideDimensions((globs::efenceGlobs.level)->surfaceMap,bx_01,by_01);
			if (((BVar5 != 0) &&
					((BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx_00,by_00,0),
					 BVar5 == 0 ||
					 (BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx,by,0), BVar5 == 0))
					)) && (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
									[(((globs::efenceGlobs.level)->dimensions).width * by_01 + bx_01) * 3] != NULL ||
								 ((BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx_01,by_01,1),
									BVar5 != 0 &&
									(BVar5 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,bx,by,0),
									BVar5 == 0)))))) {
				bVar3 = true;
				local_50 = 0;
				local_48 = bx_01;
				local_44 = by_01;
			}
			if (bVar3) goto LAB_0040d9a4;
		}
		local_5c += 1;
		local_54 = local_54 + 2;
		if (3 < local_5c) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::ElectricFence_Block_UnkAreaDistanceBetweenBlocks
					(uint bxFrom,uint byFrom,uint bxTo,uint byTo)
{
	bool bVar1;
	uint uVar2;
	uint uVar3;
	float10 fVar4;
	float local_58;
	float local_54;
	float local_50;
	Vector3F local_4c;
	Point2I DISTANCES_SET [2] [4];
	
	DISTANCES_SET[1][0].y = 2;
	DISTANCES_SET[1][1].x = 2;
	DISTANCES_SET[1][2].y = -2;
	DISTANCES_SET[1][3].x = -2;
	DISTANCES_SET[0][0].y = 1;
	DISTANCES_SET[0][1].x = 1;
	DISTANCES_SET[0][2].y = -1;
	DISTANCES_SET[0][3].x = -1;
	DISTANCES_SET[1][0].x = 0;
	DISTANCES_SET[1][1].y = 0;
	DISTANCES_SET[1][2].x = 0;
	DISTANCES_SET[1][3].y = 0;
	DISTANCES_SET[0][0].x = 0;
	DISTANCES_SET[0][1].y = 0;
	DISTANCES_SET[0][2].x = 0;
	DISTANCES_SET[0][3].y = 0;
	bVar1 = false;
	uVar2 = 0;
	do {
		if ((bxTo == *(int *)((int)&DISTANCES_SET[0].x + uVar2) + bxFrom) &&
			 (byTo == byFrom + *(int *)((int)&DISTANCES_SET[0].y + uVar2))) {
			bVar1 = true;
			uVar3 = 1;
			break;
		}
		if ((bxTo == *(int *)((int)&DISTANCES_SET[1][0].x + uVar2) + bxFrom) &&
			 (byTo == *(int *)((int)&DISTANCES_SET[1][0].y + uVar2) + byFrom)) {
			bVar1 = true;
			uVar3 = 0;
			break;
		}
		uVar2 += 8;
		uVar3 = byTo;
	} while (uVar2 < 0x20);
	if (!bVar1) {
		return 0;
	}
	ElectricFence_Block_GetDistanceBetweenBlocks(bxFrom,byFrom,bxTo,byTo,&local_4c);
	Map3D_BlockToWorldPos((globs::efenceGlobs.level)->surfaceMap,bxFrom,byFrom,&local_58,&local_54);
	fVar4 = Map3D_GetWorldZ((globs::efenceGlobs.level)->surfaceMap,local_58,local_54);
	local_50 = (float)fVar4;
	if (uVar3 == 0) {
		effect::Effect_ElectricFenceBeam_Spawn
							(1,local_58,local_54,local_50,local_4c.x,local_4c.y,local_4c.z);
		return TRUE;
	}
	effect::Effect_ElectricFenceBeam_Spawn
						(0,local_58,local_54,local_50,local_4c.x,local_4c.y,local_4c.z);
	return TRUE;
}



Vector3F * __cdecl
lego::game::ElectricFence_Block_GetDistanceBetweenBlocks
					(uint bxFrom,uint byFrom,uint bxTo,uint byTo,Vector3F *out_vector)
{
	float10 fVar1;
	Vector3F worldPosFrom;
	Vector3F worldPosTo;
	
	Map3D_BlockToWorldPos
						((globs::efenceGlobs.level)->surfaceMap,bxFrom,byFrom,&worldPosFrom.x,&worldPosFrom.y);
	fVar1 = Map3D_GetWorldZ((globs::efenceGlobs.level)->surfaceMap,worldPosFrom.x,worldPosFrom.y);
	worldPosFrom.z = (float)fVar1;
	Map3D_BlockToWorldPos
						((globs::efenceGlobs.level)->surfaceMap,bxTo,byTo,&worldPosTo.x,&worldPosTo.y);
	fVar1 = Map3D_GetWorldZ((globs::efenceGlobs.level)->surfaceMap,worldPosTo.x,worldPosTo.y);
	out_vector->x = worldPosTo.x - worldPosFrom.x;
	out_vector->y = worldPosTo.y - worldPosFrom.y;
	out_vector->z = (float)(fVar1 - (float10)worldPosFrom.z);
	return out_vector;
}



BOOL __cdecl lego::game::ElectricFence_LiveObject_FUN_0040dd70(LiveObject *liveObj)
{
	VehicleData *pVVar1;
	float fVar2;
	bool bVar3;
	BOOL BVar4;
	uint weaponType;
	int *piVar5;
	uint uVar6;
	uint uVar7;
	float10 fVar8;
	uint local_4c;
	uint local_48;
	float local_44;
	float local_40;
	uint local_3c;
	uint local_38;
	uint local_34;
	Point2F local_30;
	float local_28;
	float local_24;
	Point2I DIRECTIONS_I [4];
	
	DIRECTIONS_I[0].y = 1;
	DIRECTIONS_I[1].x = 1;
	DIRECTIONS_I[2].y = -1;
	DIRECTIONS_I[3].x = -1;
	DIRECTIONS_I[0].x = 0;
	DIRECTIONS_I[1].y = 0;
	DIRECTIONS_I[2].x = 0;
	DIRECTIONS_I[3].y = 0;
	local_44 = 0.0;
	bVar3 = false;
	LiveObject_GetPosition(liveObj,&local_30.x,&local_30.y);
	Map3D_WorldToBlockPos_NoZ
						((globs::efenceGlobs.level)->surfaceMap,local_30.x,local_30.y,(int *)&local_48,
						 (int *)&local_4c);
	uVar7 = local_48;
	uVar6 = local_4c;
	local_3c = local_48;
	local_38 = local_4c;
	if (((*(byte *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
								 (((globs::efenceGlobs.level)->dimensions).width * local_4c + local_48) * 0xc + 5) &
			 1) != 0) &&
		 (BVar4 = ElectricFence_Block_FUN_0040d320(globs::efenceGlobs.level,local_48,local_4c,0),
		 BVar4 == 0)) {
		if ((&(globs::efenceGlobs.fenceGrid)->attachedObject)
				[(((globs::efenceGlobs.level)->dimensions).width * local_4c + local_48) * 3] == NULL) {
			uVar6 = 0;
			piVar5 = &DIRECTIONS_I[0].y;
			do {
				if (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
						 [(((globs::efenceGlobs.level)->dimensions).width * (local_4c + *piVar5) +
							piVar5[-1] + local_48) * 3] != NULL) &&
					 (pVVar1 = (&(globs::efenceGlobs.fenceGrid)->attachedObject)
										 [(((globs::efenceGlobs.level)->dimensions).width * (local_4c + *piVar5) +
											piVar5[-1] + local_48) * 3]->vehicle,
					 (ushort)((ushort)((float)pVVar1 < 0.0) << 8 | (ushort)((float)pVVar1 == 0.0) << 0xe) != 0
					 )) {
					Map3D_BlockToWorldPos
										((globs::efenceGlobs.level)->surfaceMap,piVar5[-1] + local_48,local_4c + *piVar5
										 ,&local_28,&local_24);
					local_40 = local_30.x - local_28;
					fVar2 = SQRT((local_30.y - local_24) * (local_30.y - local_24) + local_40 * local_40);
					if ((fVar2 < local_44) || (local_44 == 0.0)) {
						bVar3 = true;
						local_44 = fVar2;
						local_34 = uVar6;
					}
				}
				uVar6 += 1;
				piVar5 = piVar5 + 2;
			} while (uVar6 < 4);
			uVar6 = local_38;
			uVar7 = local_3c;
			if (bVar3) {
				uVar6 = local_38 + DIRECTIONS_I[local_34].y;
				uVar7 = local_3c + DIRECTIONS_I[local_34].x;
			}
		}
		else {
			pVVar1 = (&(globs::efenceGlobs.fenceGrid)->attachedObject)
							 [(((globs::efenceGlobs.level)->dimensions).width * local_4c + local_48) * 3]->vehicle
			;
			if ((ushort)((ushort)((float)pVVar1 < 0.0) << 8 | (ushort)((float)pVVar1 == 0.0) << 0xe) != 0)
			{
				bVar3 = true;
			}
		}
		if (bVar3) {
			ElectricFence_LiveObject_SparkBlock_FUN_0040dff0(liveObj,&local_30,local_48,local_4c);
			ElectricFence_FUN_0040d420(NULL,uVar7,uVar6);
			weaponType = tools::Weapon_GetWeaponTypeByName("FenceSpark");
			fVar8 = tools::Weapon_GetRechargeTime(weaponType);
			(&(globs::efenceGlobs.fenceGrid)->attachedObject)
			[(((globs::efenceGlobs.level)->dimensions).width * uVar6 + uVar7) * 3]->vehicle =
					 (VehicleData *)(float)fVar8;
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::game::ElectricFence_LiveObject_SparkBlock_FUN_0040dff0
					(LiveObject *liveObj,Point2F *param_2,uint bx,uint by)
{
	uint weaponType;
	float10 fVar1;
	float10 fVar2;
	float10 fVar3;
	BOOL BVar4;
	float fVar5;
	Point2F *pPVar6;
	Point2F local_2c;
	Point2F worldPos;
	
	Map3D_BlockToWorldPos((globs::efenceGlobs.level)->surfaceMap,bx,by,&worldPos.x,&worldPos.y);
	fVar1 = Map3D_GetWorldZ((globs::efenceGlobs.level)->surfaceMap,worldPos.x,worldPos.y);
	local_2c.x = param_2->x;
	local_2c.y = param_2->y;
	fVar2 = Map3D_GetWorldZ((globs::efenceGlobs.level)->surfaceMap,local_2c.x,local_2c.y);
	fVar3 = stats::StatsObject_GetCollHeight(liveObj);
	local_2c.x = local_2c.x - worldPos.x;
	local_2c.y = local_2c.y - worldPos.y;
	effect::Effect_ElectricFenceBeam_Spawn
						(0,worldPos.x,worldPos.y,(float)fVar1,local_2c.x,local_2c.y,
						 (float)(((float10)(float)fVar2 - fVar3 * (float10)0.5) - (float10)(float)fVar1));
	pPVar6 = &local_2c;
	fVar5 = 0.0;
	BVar4 = 1;
	weaponType = tools::Weapon_GetWeaponTypeByName("FenceSpark");
	tools::Weapon_LiveObject_FUN_0046f530(liveObj,weaponType,BVar4,fVar5,pPVar6);
	LiveObject_UnkActivityCrumble_FUN_004424d0(liveObj);
	return;
}



BOOL __cdecl lego::game::ElectricFence_Block_FUN_0040e110(LevelData *level,uint bx,uint by)
{
	uint uVar1;
	BOOL BVar2;
	uint uVar3;
	int by_01;
	int *piVar4;
	int bx_00;
	int by_00;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar1 = by;
	local_20[1] = 1;
	local_20[2] = 1;
	local_20[0] = 0;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 0xffffffff;
	local_8 = 0xffffffff;
	local_4 = 0;
	if (((globs::efenceGlobs.fenceGrid == NULL) ||
			((&(globs::efenceGlobs.fenceGrid)->attachedObject)
			 [(((globs::efenceGlobs.level)->dimensions).width * by + bx) * 3] != NULL)) ||
		 (BVar2 = ElectricFence_Block_FUN_0040d320(level,bx,by,0), BVar2 != 0)) {
		return 0;
	}
	piVar4 = local_20 + 1;
	by = 0;
	do {
		bx_00 = piVar4[-1] + bx;
		by_00 = uVar1 + *piVar4;
		if (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
				 [(((globs::efenceGlobs.level)->dimensions).width * by_00 + bx_00) * 3] != NULL) ||
			 (BVar2 = ElectricFence_Block_FUN_0040d320(level,bx_00,by_00,0), BVar2 != 0)) {
			uVar3 = by - 2 & 3;
			by_01 = local_20[uVar3 * 2 + 1] + uVar1;
			if (((&(globs::efenceGlobs.fenceGrid)->attachedObject)
					 [(((globs::efenceGlobs.level)->dimensions).width * by_01 + local_20[uVar3 * 2] + bx) * 3]
					 != NULL) ||
				 ((BVar2 = ElectricFence_Block_FUN_0040d320(level,local_20[uVar3 * 2] + bx,by_01,0),
					BVar2 != 0 && (BVar2 = ElectricFence_Block_FUN_0040d320(level,bx_00,by_00,0), BVar2 == 0))
				 )) {
				return TRUE;
			}
		}
		piVar4 = piVar4 + 2;
		by += 1;
		if (3 < by) {
			return 0;
		}
	} while( true );
}



void __cdecl
lego::game::ElectricFence_Block_ElecFenceStud_FUN_0040e280
					(LevelData *level,uint bx,uint by,int param_4)
{
	LiveObject *pLVar1;
	float local_8;
	float local_4;
	
	if (globs::efenceGlobs.fenceGrid != NULL) {
		if (param_4 == 0) {
			pLVar1 = *(LiveObject **)
								((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
								(((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc);
			if (pLVar1 != NULL) {
				LiveObject_Remove(pLVar1);
				*(undefined4 *)
				 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
				 (((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc) = 0;
				*(undefined4 *)
				 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
				 (((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc + 4) = 0;
			}
		}
		else {
			if (*(int *)((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
									(((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc) == 0) {
				Map3D_BlockToWorldPos(level->surfaceMap,bx,by,&local_8,&local_4);
				pLVar1 = LiveObject_CreateInWorld
													 (globs::legoGlobs.contElectricFenceStud,OBJECT_ELECTRICFENCESTUD,0,0,
														local_8,local_4,0.0);
				*(LiveObject **)
				 ((int)&(globs::efenceGlobs.fenceGrid)->blockPos +
				 (((globs::efenceGlobs.level)->dimensions).width * by + bx) * 0xc) = pLVar1;
				return;
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::ElectricFence_Block_IsFence(int bx,int by)
{
	return (uint)((&(globs::efenceGlobs.fenceGrid)->attachedObject)
								[(((globs::efenceGlobs.level)->dimensions).width * by + bx) * 3] != NULL);
}



void __cdecl lego::front::Encyclopedia_Initialise(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	File *pFVar2;
	uint uVar3;
	File **ppFVar4;
	
	globs::encyclopediaGlobs.vehicleFiles =
			 (File **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	ppFVar4 = globs::encyclopediaGlobs.vehicleFiles;
	for (uVar3 = globs::legoGlobs.VehicleTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::legoGlobs.VehicleTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globs::encyclopediaGlobs.vehicleFiles[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::legoGlobs.VehicleTypes_COUNT);
	}
	globs::encyclopediaGlobs.minifigureFiles =
			 (File **)std::malloc(globs::legoGlobs.MiniFigureTypes_COUNT * 4);
	ppFVar4 = globs::encyclopediaGlobs.minifigureFiles;
	for (uVar3 = globs::legoGlobs.MiniFigureTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::legoGlobs.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::legoGlobs.MiniFigureTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globs::encyclopediaGlobs.minifigureFiles[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::legoGlobs.MiniFigureTypes_COUNT);
	}
	globs::encyclopediaGlobs.rockmonsterFiles =
			 (File **)std::malloc(globs::legoGlobs.RockMonsterTypes_COUNT * 4);
	ppFVar4 = globs::encyclopediaGlobs.rockmonsterFiles;
	for (uVar3 = globs::legoGlobs.RockMonsterTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::legoGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::legoGlobs.RockMonsterTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globs::encyclopediaGlobs.rockmonsterFiles[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::legoGlobs.RockMonsterTypes_COUNT);
	}
	globs::encyclopediaGlobs.buildingFiles =
			 (File **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	ppFVar4 = globs::encyclopediaGlobs.buildingFiles;
	for (uVar3 = globs::legoGlobs.BuildingTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::legoGlobs.BuildingTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globs::encyclopediaGlobs.buildingFiles[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::legoGlobs.BuildingTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::encyclopediaGlobs.powercrystalFile = lego::file::File_Open(pcVar1,"r");
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::encyclopediaGlobs.oreFile = lego::file::File_Open(pcVar1,"r");
	}
	return;
}



void __cdecl lego::front::Encyclopedia_SetObject(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	int local_4;
	
	pLVar1 = liveObj;
	game::LiveObject_GetTypeIndex(liveObj,&local_4,(int *)&liveObj);
	if (false) {
switchD_0040e655_caseD_5:
		globs::encyclopediaGlobs.currentObjFile = NULL;
		globs::encyclopediaGlobs.flags = globs::encyclopediaGlobs.flags & 0xfffffffe;
		return;
	}
	switch(local_4) {
	case 1:
		globs::encyclopediaGlobs.currentObjFile = globs::encyclopediaGlobs.vehicleFiles[(int)liveObj];
		break;
	case 2:
		globs::encyclopediaGlobs.currentObjFile = globs::encyclopediaGlobs.minifigureFiles[(int)liveObj]
		;
		break;
	case 3:
		globs::encyclopediaGlobs.currentObjFile =
				 globs::encyclopediaGlobs.rockmonsterFiles[(int)liveObj];
		break;
	case 4:
		globs::encyclopediaGlobs.currentObjFile = globs::encyclopediaGlobs.buildingFiles[(int)liveObj];
		break;
	default:
		goto switchD_0040e655_caseD_5;
	case 6:
		globs::encyclopediaGlobs.currentObjFile = globs::encyclopediaGlobs.powercrystalFile;
		break;
	case 7:
		globs::encyclopediaGlobs.currentObjFile = globs::encyclopediaGlobs.oreFile;
	}
	globs::encyclopediaGlobs.flags |= 3;
	globs::encyclopediaGlobs.currentObj = pLVar1;
	Panel_TextWindow_Clear(globs::panelGlobs.encyclopediaTextWnd);
	return;
}



void __cdecl lego::front::Encyclopedia_UnsetFlag1(void)
{
	globs::encyclopediaGlobs.flags = globs::encyclopediaGlobs.flags & 0xfffffffe;
	return;
}



void __cdecl lego::front::Encyclopedia_Update(float elapsedAbs)
{
	BOOL BVar1;
	char *pcVar2;
	char buff [512];
	
	if (((globs::encyclopediaGlobs.flags & 1) != 0) &&
		 (BVar1 = Panel_IsFlags_4_Not8(PANEL_ENCYCLOPEDIA), BVar1 == 0)) {
		if ((globs::encyclopediaGlobs.flags & 2) != 0) {
			if (globs::encyclopediaGlobs.currentObjFile == NULL) {
				Panel_TextWindow_PrintF
									(globs::panelGlobs.encyclopediaTextWnd,"Object has no encyclopedia file.");
			}
			else {
				lego::file::File_Seek(globs::encyclopediaGlobs.currentObjFile,0,SEEK_SET);
				pcVar2 = lego::file::File_GetS(buff,0x200,globs::encyclopediaGlobs.currentObjFile);
				while (pcVar2 != NULL) {
					Panel_TextWindow_PrintF(globs::panelGlobs.encyclopediaTextWnd,"%s",buff);
					pcVar2 = lego::file::File_GetS(buff,0x200,globs::encyclopediaGlobs.currentObjFile);
				}
			}
			globs::encyclopediaGlobs.flags &= 0xfffffffd;
		}
		Panel_TextWindow_Update(globs::panelGlobs.encyclopediaTextWnd,0,elapsedAbs);
	}
	return;
}



void __cdecl lego::front::Encyclopedia_DrawSelectBox(Viewport *viewMain)
{
	if (((((byte)globs::encyclopediaGlobs.flags & 1) != 0) &&
			(((byte)globs::panelGlobs.panelTable[11].flags & 2) != 0)) &&
		 (globs::encyclopediaGlobs.currentObj != NULL)) {
		game::LiveObject_DrawSelectedBox(globs::encyclopediaGlobs.currentObj,viewMain,0.0,1.0,0.0);
	}
	return;
}



void __cdecl lego::front::Encyclopedia_LiveObject_ClearPtr_004c8ea4_IfEqual(LiveObject *liveObj)
{
	if (globs::encyclopediaGlobs.currentObj == liveObj) {
		globs::encyclopediaGlobs.currentObj = NULL;
	}
	return;
}



void __cdecl lego::game::Erode_Initialise(float triggerTime,float erodeTime,float lockTime)
{
	int iVar1;
	BOOL *pBVar2;
	
	globs::erodeGlobs.ErodeTriggerTime = triggerTime * 25.0;
	globs::erodeGlobs.ErodeErodeTime = erodeTime * 25.0 * 0.2;
	globs::erodeGlobs.ErodeLockTime = lockTime * 25.0;
	globs::erodeGlobs.UnkBlocksCount = 0;
	pBVar2 = globs::erodeGlobs.activeStates;
	for (iVar1 = 2000; iVar1 != 0; iVar1 += -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	pBVar2 = globs::erodeGlobs.lockedStates;
	for (iVar1 = 1000; iVar1 != 0; iVar1 += -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	return;
}



BOOL __cdecl lego::game::Erode_GetFreeActiveIndex(int *out_index)
{
	float *pfVar1;
	int index;
	
	index = 0;
	pfVar1 = (float *)globs::erodeGlobs.activeStates;
	do {
		if (*pfVar1 == 0.0) {
			*out_index = index;
			return TRUE;
		}
		pfVar1 = pfVar1 + 1;
		index += 1;
	} while (pfVar1 < globs::erodeGlobs.activeTimers);
	return 0;
}



// return (float)(6 - block->erodeSpeed) * erodeGlobs.ErodeErodeTime * 25.0f

float10 __cdecl lego::game::Erode_GetBlockErodeRate(Point2I *blockPos)
{
	return (float10)(6 - (uint)(globs::legoGlobs.level)->blocks
														 [((globs::legoGlobs.level)->dimensions).width * blockPos->y +
															blockPos->x].erodeSpeed) * (float10)globs::erodeGlobs.ErodeErodeTime *
				 (float10)25.0;
}



void __cdecl lego::game::Erode_AddActiveBlock(Point2I *position,int unkModulusNum)
{
	LevelData *pLVar1;
	BOOL BVar2;
	float10 fVar3;
	int erodeIndex;
	int local_8;
	undefined4 local_4;
	
	pLVar1 = globs::legoGlobs.level;
	BVar2 = Erode_GetFreeActiveIndex(&erodeIndex);
	if (BVar2 != 0) {
		pLVar1->blocks[position->y * (pLVar1->dimensions).width + position->x].field_7 =
				 (byte)unkModulusNum;
		globs::erodeGlobs.activeBlocks[erodeIndex].x = position->x;
		globs::erodeGlobs.activeBlocks[erodeIndex].y = position->y;
		fVar3 = Erode_GetBlockErodeRate(position);
		local_8 = unkModulusNum + 1;
		local_4 = 0;
		globs::erodeGlobs.activeTimers[erodeIndex] = (float)(fVar3 / (float10)local_8);
		globs::erodeGlobs.activeStates[erodeIndex] = TRUE;
		Erode_Block_FUN_0040ed80(position,TRUE);
	}
	return;
}



void __cdecl lego::game::Erode_Update(float elapsedGame)
{
	float fVar1;
	LevelData *level;
	char cVar2;
	short sVar3;
	BOOL BVar4;
	int iVar5;
	float *pfVar6;
	uint uVar7;
	Point2I *blockPos;
	float10 fVar8;
	longlong lVar9;
	longlong lVar10;
	MiscEffectType miscEffectType;
	int local_24;
	Point2I local_20;
	Vector3F local_18;
	Vector3F local_c;
	
	level = globs::legoGlobs.level;
	sVar3 = math::Maths_Rand();
	globs::erodeGlobs.elapsedTimer = elapsedGame + globs::erodeGlobs.elapsedTimer;
						// if (globals::g_ErodeTimer > globals:g_ErodeTriggerTime) {
	if ((ushort)((ushort)(globs::erodeGlobs.elapsedTimer < globs::erodeGlobs.ErodeTriggerTime) << 8 |
							(ushort)(globs::erodeGlobs.elapsedTimer == globs::erodeGlobs.ErodeTriggerTime) << 0xe)
			== 0) {
		BVar4 = Erode_GetFreeActiveIndex(&local_24);
		if ((BVar4 != 0) && (uVar7 = 0, globs::erodeGlobs.UnkBlocksCount != 0)) {
			do {
				BVar4 = Erode_FUN_0040ef30(globs::erodeGlobs.UnkBlocksList +
																	 ((int)sVar3 + uVar7) % globs::erodeGlobs.UnkBlocksCount,&local_20
																	);
				if (BVar4 != 0) {
					BVar4 = Level_Block_IsPath(&local_20);
					if ((BVar4 == 0) ||
						 ((*(byte *)&level->blocks[local_20.y * (level->dimensions).width + local_20.x].flags2 &
							0x10) != 0)) {
						iVar5 = local_20.y * (level->dimensions).width + local_20.x;
						level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 & ~BLOCK2_UNK_10;
						globs::erodeGlobs.activeBlocks[local_24].x = local_20.x;
						globs::erodeGlobs.activeBlocks[local_24].y = local_20.y;
						fVar8 = Erode_GetBlockErodeRate(globs::erodeGlobs.activeBlocks + local_24);
						globs::erodeGlobs.activeTimers[local_24] = (float)fVar8;
						globs::erodeGlobs.activeStates[local_24] = 1;
						level->blocks[local_20.y * (level->dimensions).width + local_20.x].field_7 = 0;
						Erode_Block_FUN_0040ed80(&local_20,TRUE);
						front::Info_Send(INFO_LAVAERODE,NULL,NULL,&local_20);
						break;
					}
					Erode_AddLockedBlock(&local_20);
					iVar5 = local_20.y * (level->dimensions).width + local_20.x;
					level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 | BLOCK2_UNK_10;
				}
				uVar7 += 1;
			} while (uVar7 < globs::erodeGlobs.UnkBlocksCount);
		}
		globs::erodeGlobs.elapsedTimer = 0.0;
	}
	pfVar6 = globs::erodeGlobs.activeTimers;
	blockPos = globs::erodeGlobs.activeBlocks;
	do {
		if (pfVar6[-2000] != 0.0) {
			fVar8 = Erode_GetBlockErodeRate(blockPos);
			lVar9 = __ftol(((float10)*pfVar6 / fVar8) * (float10)4.0);
			*pfVar6 = *pfVar6 - elapsedGame;
			fVar8 = Erode_GetBlockErodeRate(blockPos);
			lVar10 = __ftol(((float10)*pfVar6 / fVar8) * (float10)4.0);
			cVar2 = (char)lVar10;
			if (cVar2 == (char)lVar9) goto LAB_0040ecc3;
			level->blocks[blockPos->y * (level->dimensions).width + blockPos->x].field_7 = 4 - cVar2;
			Map3D_BlockToWorldPos(level->surfaceMap,blockPos->x,blockPos->y,&local_18.x,&local_18.y);
			fVar8 = Map3D_GetWorldZ(level->surfaceMap,local_18.x,local_18.y);
			local_18.z = (float)fVar8;
			math::Maths_Vector3DRandom(&local_c);
			local_c.z = 0.0;
			switch(cVar2) {
			case '\0':
				pfVar6[-2000] = 0.0;
				level->blocks[blockPos->y * (level->dimensions).width + blockPos->x].terrain = TERRAIN_LAVA;
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE1;
				break;
			case '\x01':
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE2;
				break;
			case '\x02':
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE3;
				break;
			case '\x03':
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE4;
				break;
			default:
				goto switchD_0040ec49_caseD_4;
			}
			effect::Effect_Spawn_Particle(miscEffectType,&local_18,&local_c);
switchD_0040ec49_caseD_4:
			Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
		}
LAB_0040ecc3:
		blockPos = blockPos + 1;
		pfVar6 = pfVar6 + 1;
		if ((Point2I *)globs::erodeGlobs.activeStates <= blockPos) {
			pfVar6 = (float *)globs::erodeGlobs.lockedStates;
			do {
				if ((*pfVar6 != 0.0) &&
					 (fVar1 = pfVar6[-1000], pfVar6[-1000] = fVar1 - elapsedGame, fVar1 - elapsedGame < 0.0))
				{
					*pfVar6 = 0.0;
				}
				pfVar6 = pfVar6 + 1;
			} while (pfVar6 < &globs::erodeGlobs.elapsedTimer);
			return;
		}
	} while( true );
}



void __cdecl lego::game::Erode_AddLockedBlock(Point2I *blockPos)
{
	BOOL *pLockState;
	int iVar1;
	
	iVar1 = 0;
	pLockState = globs::erodeGlobs.lockedStates;
	do {
		if (*pLockState == FALSE) {
			globs::erodeGlobs.lockedBlocks[iVar1].x = blockPos->x;
			globs::erodeGlobs.lockedBlocks[iVar1].y = blockPos->y;
			globs::erodeGlobs.lockedTimers[iVar1] = globs::erodeGlobs.ErodeLockTime;
			globs::erodeGlobs.lockedStates[iVar1] = 1;
			return;
		}
		pLockState = pLockState + 1;
		iVar1 += 1;
	} while (pLockState < &globs::erodeGlobs.elapsedTimer);
	return;
}



void __cdecl lego::game::Erode_Block_FUN_0040ed80(Point2I *blockPos,BOOL doState2_else_add3)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	Point2I *pBlock;
	Erode_Globs *pEVar4;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	uVar1 = globs::erodeGlobs.UnkBlocksCount;
	if (doState2_else_add3 == 0) {
		uVar3 = 0;
		if (globs::erodeGlobs.UnkBlocksCount != 0) {
			pEVar4 = &globs::erodeGlobs;
			do {
				if ((blockPos->x == pEVar4->UnkBlocksList[0].x) &&
					 (blockPos->y == pEVar4->UnkBlocksList[0].y)) {
					iVar2 = globs::erodeGlobs.UnkBlocksCount - 1;
					globs::erodeGlobs.UnkBlocksCount = globs::erodeGlobs.UnkBlocksCount - 1;
					globs::erodeGlobs.UnkBlocksList[uVar3].x = globs::erodeGlobs.UnkBlocksList[iVar2].x;
					globs::erodeGlobs.UnkBlocksList[uVar3].y = globs::erodeGlobs.UnkBlocksList[uVar1 - 1].y;
					iVar2 = (level->dimensions).width * blockPos->y + blockPos->x;
					level->blocks[iVar2].flags1 = level->blocks[iVar2].flags1 & ~BLOCK1_UNK_80000000;
					break;
				}
				uVar3 += 1;
				pEVar4 = (Erode_Globs *)(pEVar4->UnkBlocksList + 1);
			} while (uVar3 < globs::erodeGlobs.UnkBlocksCount);
		}
		iVar2 = 0;
		pBlock = globs::erodeGlobs.activeBlocks;
		do {
			if ((blockPos->x == pBlock->x) && (blockPos->y == pBlock->y)) {
				globs::erodeGlobs.activeStates[iVar2] = 0;
				break;
			}
			pBlock = pBlock + 1;
			iVar2 += 1;
		} while (pBlock <= (Point2I *)((int)&globs::erodeGlobs.activeBlocks[1999].y + 3U));
		Erode_AddLockedBlock(blockPos);
	}
	else {
		if ((((globs::legoGlobs.level)->blocks
					[((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1 &
				 BLOCK1_UNK_80000000) == BLOCK1_NONE) && (globs::erodeGlobs.UnkBlocksCount < 2000)) {
			globs::erodeGlobs.UnkBlocksList[globs::erodeGlobs.UnkBlocksCount].x = blockPos->x;
			globs::erodeGlobs.UnkBlocksList[globs::erodeGlobs.UnkBlocksCount].y = blockPos->y;
			globs::erodeGlobs.UnkBlocksCount += 1;
			Level_Block_Proc_FUN_004301e0(blockPos);
			iVar2 = (level->dimensions).width * blockPos->y + blockPos->x;
			level->blocks[iVar2].flags1 = level->blocks[iVar2].flags1 | BLOCK1_UNK_80000000;
			return;
		}
	}
	return;
}



BOOL __cdecl lego::game::Erode_IsBlockLocked(Point2I *blockPos)
{
	BOOL *pLockState;
	Point2I *pLockBlock;
	
	pLockBlock = globs::erodeGlobs.lockedBlocks;
	pLockState = globs::erodeGlobs.lockedStates;
	while (((*pLockState == FALSE || (blockPos->x != pLockBlock->x)) || (blockPos->y != pLockBlock->y)
				 )) {
		pLockState = pLockState + 1;
		pLockBlock = pLockBlock + 1;
		if ((BOOL *)((int)globs::erodeGlobs.lockedStates + 3999U) < pLockState) {
			return 0;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::Erode_FUN_0040ef30(Point2I *blockPos,Point2I *out_blockPos)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *pLVar3;
	Point2I *pPVar4;
	BOOL BVar5;
	int iVar6;
	int *piVar7;
	Point2I DIRECTIONS [4];
	
	pPVar4 = blockPos;
	pLVar3 = globs::legoGlobs.level;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	if ((globs::legoGlobs.level)->blocks
			[blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].terrain !=
			TERRAIN_LAVA) {
		return 0;
	}
	blockPos = NULL;
	piVar7 = &DIRECTIONS[0].y;
	do {
		iVar6 = *piVar7;
		out_blockPos->x = piVar7[-1] + pPVar4->x;
		iVar6 = pPVar4->y + iVar6;
		out_blockPos->y = iVar6;
		pLVar1 = pLVar3->blocks + (pLVar3->dimensions).width * iVar6 + out_blockPos->x;
		LVar2 = pLVar1->flags1;
		if ((((LVar2 & BLOCK1_UNK_80000000) == BLOCK1_NONE) && ((LVar2 & BLOCK1_GROUND) != BLOCK1_NONE))
			 && (pLVar1->erodeSpeed != ERODE_NONE)) {
			BVar5 = Erode_IsBlockLocked(out_blockPos);
			if (BVar5 == 0) {
				return TRUE;
			}
		}
		piVar7 = piVar7 + 2;
		blockPos = (Point2I *)((int)&blockPos->x + 1);
	} while (blockPos < (Point2I *)&DAT_00000004);
	return 0;
}



uint __cdecl lego::game::Fallin_Update(float elapsedGame)
{
	short rng;
	SurfaceMap *surfMap;
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	Point2I blockPos;
	
	surfMap = lrr::Lego_GetMap();
	globs::s_Fallin_ElapsedTimer = globs::s_Fallin_ElapsedTimer - elapsedGame;
	uVar3 = (uint)(ushort)((ushort)(globs::s_Fallin_ElapsedTimer < 0.0) << 8 |
												(ushort)(globs::s_Fallin_ElapsedTimer == 0.0) << 0xe);
	uVar2 = (uint)surfMap & 0xffff0000 | uVar3;
						// if (floatVal <= 0.0f)
	if (uVar3 != 0) {
		uVar3 = 0;
		do {
			rng = math::Maths_Rand();
			blockPos.x = (uint)(int)rng % (uint)(surfMap->smallDimensions).width;
			rng = math::Maths_Rand();
			blockPos.y = (uint)(int)rng % (uint)(surfMap->smallDimensions).height;
			BVar1 = Fallin_Block_FUN_0040f0c0(&blockPos,TRUE);
			if (BVar1 != 0) {
				front::Info_Send(INFO_LANDSLIDE,NULL,NULL,&blockPos);
				break;
			}
			uVar3 += 1;
		} while (uVar3 < 100);
		rng = math::Maths_Rand();
						// div by 50 (0x32)
		uVar2 = (int)rng / 0x32;
		globs::s_Fallin_ElapsedTimer = (float)((int)rng % 0x32) - -750.0;
	}
	return uVar2;
}



BOOL __cdecl lego::game::Fallin_Block_FUN_0040f0c0(Point2I *blockPos,BOOL param_2)
{
	BOOL BVar1;
	uint unkIntensity;
	int *pDirY;
	uint i;
	int count;
	Point2I blockOffPos;
	Point2I DIRECTIONS [4];
	bool notSolidOrReinforced;
	
	i = 0;
	notSolidOrReinforced = true;
	unkIntensity = 0;
	count = 0;
	lrr::Lego_GetMap();
	DIRECTIONS[0].x = 0;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[3].y = 0;
	BVar1 = Fallin_Block_UpdateFallinsUnk1(blockPos);
	if (BVar1 != 0) {
		pDirY = &DIRECTIONS[0].y;
		do {
			blockOffPos.x = pDirY[-1] + blockPos->x;
			blockOffPos.y = *pDirY + blockPos->y;
			BVar1 = Level_Block_IsWall(blockOffPos.x,blockOffPos.y);
			if (BVar1 != 0) {
				BVar1 = Level_Block_IsImmovable(&blockOffPos);
				if (BVar1 == 0) {
					BVar1 = Level_Block_IsReinforced(blockOffPos.x,blockOffPos.y);
					if (BVar1 != 0) goto LAB_0040f164;
				}
				else {
LAB_0040f164:
					notSolidOrReinforced = false;
				}
				unkIntensity |= 1 << ((byte)i & 0x1f);
				BVar1 = Level_Block_IsCorner(blockOffPos.x,blockOffPos.y);
				if (BVar1 == 0) {
					count += 1;
				}
			}
			i += 1;
			pDirY = pDirY + 2;
		} while (i < 4);
		if (((notSolidOrReinforced) && (unkIntensity != 0)) && (count != 0)) {
			Fallin_Block_FUN_0040f260(blockPos,unkIntensity,param_2);
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Fallin_Block_UpdateFallinsUnk1(Point2I *blockPos)
{
	BOOL BVar1;
	LevelData *level;
	TerrainType terrain;
	
	level = globs::legoGlobs.level;
	BVar1 = Level_Block_IsGround(blockPos->x,blockPos->y);
	if ((((BVar1 != 0) && (BVar1 = Level_Block_IsBusy(blockPos), BVar1 == 0)) &&
			(terrain = level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].terrain,
			terrain != TERRAIN_LAVA)) && ((terrain != TERRAIN_LAKE && (terrain != TERRAIN_WATER_unused))))
	{
		if ((level->SafeCaverns != BOOL3_FALSE) && (BVar1 = Level_Block_IsExposed(blockPos), BVar1 != 0)
			 ) {
			return 0;
		}
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Fallin_Block_FUN_0040f260(Point2I *blockPos,int unkIntensity,BOOL param_3)
{
	int iVar1;
	Point2I *pPVar2;
	BOOL BVar3;
	int iVar4;
	Point2I *rockFallType;
	float10 fVar5;
	float dirX;
	float dirY;
	float local_30;
	Vector3F local_2c;
	Point2F DIRECTIONS_F [4];
	Point2I *blockPos_00;
	
	blockPos_00 = blockPos;
	DIRECTIONS_F[0].x = 0.0;
	DIRECTIONS_F[0].y = 1.0;
	DIRECTIONS_F[1].x = 1.0;
	DIRECTIONS_F[1].y = 0.0;
	DIRECTIONS_F[2].x = 0.0;
	DIRECTIONS_F[2].y = -1.0;
	DIRECTIONS_F[3].x = -1.0;
	DIRECTIONS_F[3].y = 0.0;
	iVar1 = Level_Block_ClearRubbleLayer(blockPos);
	while (iVar1 == 0) {
		iVar1 = Level_Block_ClearRubbleLayer(blockPos_00);
	}
	ai::AITask_DoClearTypeAction(blockPos_00,MESSAGE_CLEARFALLIN_COMPLETE);
	iVar1 = unkIntensity;
	pPVar2 = blockPos;
	rockFallType = blockPos;
	switch(unkIntensity) {
	case 1:
	case 0xe:
		pPVar2 = NULL;
		rockFallType = NULL;
		break;
	case 2:
	case 10:
	case 0xd:
		pPVar2 = (Point2I *)0x1;
		rockFallType = NULL;
		break;
	case 3:
		pPVar2 = (Point2I *)0x1;
		rockFallType = (Point2I *)0x1;
		break;
	case 4:
	case 5:
	case 0xb:
		pPVar2 = (Point2I *)0x2;
		rockFallType = NULL;
		break;
	case 6:
		pPVar2 = (Point2I *)0x2;
		rockFallType = (Point2I *)0x1;
		break;
	case 7:
	case 8:
		pPVar2 = (Point2I *)0x3;
		rockFallType = NULL;
		break;
	case 9:
		pPVar2 = NULL;
		rockFallType = (Point2I *)0x1;
		break;
	case 0xc:
		pPVar2 = (Point2I *)0x3;
		rockFallType = (Point2I *)0x1;
	}
	Map3D_BlockToWorldPos
						((globs::legoGlobs.level)->surfaceMap,blockPos_00->x,blockPos_00->y,&local_30,
						 (float *)&blockPos);
	dirY = DIRECTIONS_F[(int)pPVar2].y;
	dirX = DIRECTIONS_F[(int)pPVar2].x;
	fVar5 = Map3D_GetWorldZ((globs::legoGlobs.level)->surfaceMap,local_30,(float)blockPos);
	BVar3 = effect::Effect_Spawn_RockFall
										((RockFallType)rockFallType,blockPos_00->x,blockPos_00->y,local_30,blockPos,
										 (float)fVar5,dirX,dirY);
	if (BVar3 != 0) {
		local_2c.y = (float)blockPos;
		local_2c.x = local_30;
		fVar5 = Map3D_GetWorldZ((globs::legoGlobs.level)->surfaceMap,local_30,(float)blockPos);
		local_2c.z = (float)fVar5;
		iVar4 = ((globs::legoGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x;
		(globs::legoGlobs.level)->blocks[iVar4].flags1 =
				 (globs::legoGlobs.level)->blocks[iVar4].flags1 | BLOCK1_UNK_800;
		iVar4 = ((globs::legoGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x;
		(globs::legoGlobs.level)->blocks[iVar4].flags1 =
				 (globs::legoGlobs.level)->blocks[iVar4].flags1 | BLOCK1_UNK_1000;
		Level_Block_SetBusy(blockPos_00,TRUE);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_FALLIN,FALSE,FALSE,&local_2c);
	}
	if ((param_3 != 0) &&
		 (iVar4 = ((globs::legoGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x,
		 (globs::legoGlobs.level)->blocks[iVar4].numLandSlides =
					(globs::legoGlobs.level)->blocks[iVar4].numLandSlides + 1,
		 globs::fallinGlobs_NumberOfLandSlidesTillCaveIn <=
		 (globs::legoGlobs.level)->blocks
		 [((globs::legoGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x].numLandSlides)
		 ) {
		Fallin_LandSlideDoCaveIn(blockPos_00,iVar1);
		front::Info_Send(INFO_LANDSLIDE,NULL,NULL,blockPos_00);
	}
	Level_BlockUpdateSurface(globs::legoGlobs.level,blockPos_00->x,blockPos_00->y,0);
	return;
}



void __cdecl lego::game::Fallin_Initialise(int numLandSlidesTillCaveIn)
{
	globs::fallinGlobs_NumberOfLandSlidesTillCaveIn = numLandSlidesTillCaveIn;
	return;
}



void __cdecl lego::game::Fallin_LandSlideDoCaveIn(Point2I *blockPos,int unkIntensity)
{
	BOOL BVar1;
	int i;
	int *pAngleY;
	Point2I pAngle;
	Point2I ANGLES [8];
	
	ANGLES[0].x = 0;
	ANGLES[0].y = 1;
	ANGLES[1].x = 1;
	ANGLES[1].y = 1;
	ANGLES[2].x = 1;
	ANGLES[2].y = 0;
	ANGLES[3].x = 1;
	ANGLES[3].y = -1;
	ANGLES[4].x = 0;
	ANGLES[4].y = -1;
	ANGLES[5].x = -1;
	ANGLES[5].y = -1;
	ANGLES[6].x = -1;
	ANGLES[6].y = 0;
	ANGLES[7].x = -1;
	ANGLES[7].y = 1;
	pAngleY = &ANGLES[0].y;
	i = 8;
	do {
		pAngle.x = pAngleY[-1] + blockPos->x;
		pAngle.y = blockPos->y + *pAngleY;
		BVar1 = Map3D_IsInsideDimensions((globs::legoGlobs.level)->surfaceMap,pAngle.x,pAngle.y);
		if (BVar1 != 0) {
			BVar1 = Fallin_Block_FUN_0040f0c0(&pAngle,0);
			if (BVar1 == 0) {
				BVar1 = Fallin_Block_UpdateFallinsUnk1(&pAngle);
				if (BVar1 != 0) {
					Fallin_Block_FUN_0040f260(&pAngle,unkIntensity,0);
				}
			}
		}
		pAngleY = pAngleY + 2;
		i += -1;
	} while (i != 0);
	return;
}



FlocksItem * __cdecl
lego::game::Flocks_LiveObject_Flocks_CreateSubdata
					(Vector3F *vector_1,Vector3F *vector_2,float turn,float speed,float tightness,
					float goalUpdate,Container *resData)
{
	FlocksItem *pFVar1;
	
	pFVar1 = (FlocksItem *)std::malloc(0xa0);
	if (pFVar1 == NULL) {
		return NULL;
	}
	pFVar1->float_30 = 0.0;
	pFVar1->rotationZ_2c = 0.0;
	pFVar1->rotationX_28 = 0.0;
	pFVar1->rotationY_24 = 0.0;
	(pFVar1->vector_18).y = 0.0;
	(pFVar1->vector_18).x = 0.0;
	(pFVar1->vector_18).z = 1.0;
	if (vector_2 == NULL) {
		(pFVar1->vector_0).x = 0.0;
		(pFVar1->vector_0).y = 0.0;
		(pFVar1->vector_0).z = 0.0;
	}
	else {
		(pFVar1->vector_0).x = vector_2->x;
		(pFVar1->vector_0).y = vector_2->y;
		(pFVar1->vector_0).z = vector_2->z;
	}
	if (vector_1 == NULL) {
		(pFVar1->vector_c).x = 0.0;
		(pFVar1->vector_c).y = 0.0;
		(pFVar1->vector_c).z = 0.0;
	}
	else {
		(pFVar1->vector_c).x = vector_1->x;
		(pFVar1->vector_c).y = vector_1->y;
		(pFVar1->vector_c).z = vector_1->z;
	}
	pFVar1->float_34 = 0.0;
	pFVar1->Turn2 = turn;
	pFVar1->Turn1 = turn;
	pFVar1->Speed2 = speed;
	pFVar1->Speed1 = speed;
	pFVar1->Tightness2 = tightness;
	pFVar1->Tightness1 = tightness;
	pFVar1->GoalUpdate2 = goalUpdate;
	pFVar1->GoalUpdate1 = goalUpdate;
	pFVar1->resData_98 = resData;
	return pFVar1;
}



// Shared function used by multiple modules.

void __cdecl lego::util::freeNonNull(void *ptr)
{
	if (ptr != NULL) {
		std::free(ptr);
	}
	return;
}



Flocks * __cdecl
lego::game::Flocks_LiveObject_Flocks_CreateData
					(Vector3F *vector_1,Vector3F *vector_2,float turn,float speed,float tightness,
					Container *resData)
{
	Flocks *pFVar1;
	FlocksItem *pFVar2;
	
	pFVar1 = (Flocks *)std::malloc(0x28);
	if (pFVar1 == NULL) {
		return NULL;
	}
	pFVar2 = Flocks_LiveObject_Flocks_CreateSubdata
										 (vector_1,vector_2,turn,speed,tightness,0.0,resData);
	pFVar1->flocksSubdata1 = pFVar2;
	if (vector_1 == NULL) {
		pFVar1->hasVector1 = 0;
	}
	else {
		pFVar1->hasVector1 = 1;
	}
	if (vector_2 != NULL) {
		pFVar1->hasVector2 = 1;
		pFVar1->flocksSubdata2 = NULL;
		pFVar1->numSubdata = 0;
		return pFVar1;
	}
	pFVar1->hasVector2 = 0;
	pFVar1->flocksSubdata2 = NULL;
	pFVar1->numSubdata = 0;
	return pFVar1;
}



void __cdecl lego::game::Flocks_FreeData(Flocks *flocksData)
{
	FlocksItem *ptr;
	
	ptr = Flocks_Free_SubdataRecurse(flocksData);
	while (ptr != NULL) {
		util::freeNonNull(ptr);
		ptr = Flocks_Free_SubdataRecurse(flocksData);
	}
	util::freeNonNull(flocksData->flocksSubdata1);
	std::free(flocksData);
	return;
}



void __cdecl
lego::game::Flocks_Subdata_MathChangeRotationX(FlocksItem *flockSubdata,Vector3F *vector)
{
	float fVar1;
	
	if ((ushort)((ushort)(vector->y < 1.0) << 8 | (ushort)(vector->y == 1.0) << 0xe) == 0) {
		fVar1 = flockSubdata->Turn1 + flockSubdata->rotationX_28;
		flockSubdata->rotationX_28 = fVar1;
		if ((ushort)((ushort)(fVar1 < 0.8) << 8 | (ushort)(fVar1 == 0.8) << 0xe) == 0) {
			flockSubdata->rotationX_28 = 0.8;
			return;
		}
	}
	else {
		if (-1.0 <= vector->y) {
			flockSubdata->rotationX_28 = flockSubdata->rotationX_28 * 0.95;
			return;
		}
		fVar1 = flockSubdata->rotationX_28 - flockSubdata->Turn1;
		flockSubdata->rotationX_28 = fVar1;
		if (fVar1 < -0.8) {
			flockSubdata->rotationX_28 = -0.8;
			return;
		}
	}
	return;
}



void __cdecl
lego::game::Flocks_Subdata_MathChangeRotationsYZ(FlocksItem *subdata,Vector3F *ref_vector)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	
	ref_vector->y = 0.0;
	(subdata->vector_18).y = 0.0;
	fVar1 = (subdata->vector_18).x;
	fVar7 = (subdata->vector_18).z;
	fVar1 = 1.0 / SQRT(fVar1 * fVar1 + fVar7 * fVar7 + 0.0);
	(subdata->vector_18).x = fVar1 * (subdata->vector_18).x;
	(subdata->vector_18).y = fVar1 * (subdata->vector_18).y;
	(subdata->vector_18).z = fVar1 * (subdata->vector_18).z;
	fVar8 = 1.0 / SQRT(ref_vector->x * ref_vector->x +
										 ref_vector->z * ref_vector->z + ref_vector->y * ref_vector->y);
	fVar10 = fVar8 * ref_vector->x;
	fVar9 = fVar8 * ref_vector->y;
	fVar8 = fVar8 * ref_vector->z;
	ref_vector->x = fVar10;
	ref_vector->y = fVar9;
	ref_vector->z = fVar8;
	fVar1 = (subdata->vector_18).z;
	fVar7 = (subdata->vector_18).y;
	fVar2 = (subdata->vector_18).x;
	fVar3 = (subdata->vector_18).x;
	fVar4 = (subdata->vector_18).x;
	fVar5 = (subdata->vector_18).z;
	fVar6 = (subdata->vector_18).y;
	ref_vector->x = fVar9 * (subdata->vector_18).z - fVar8 * (subdata->vector_18).y;
	ref_vector->y = fVar3 * fVar8 - fVar10 * fVar5;
	ref_vector->z = fVar10 * fVar6 - fVar4 * fVar9;
	fVar1 = (1.0 - (fVar2 * fVar10 + fVar1 * fVar8 + fVar7 * fVar9)) * subdata->Turn1 * 10.0 * 0.5;
	if ((ushort)((ushort)(ref_vector->y < 0.01) << 8 | (ushort)(ref_vector->y == 0.01) << 0xe) == 0) {
		fVar1 = subdata->float_30 * 9.0 + fVar1;
	}
	else {
		if (0.01 <= ref_vector->y) goto LAB_0040fa04;
		fVar1 = subdata->float_30 * 9.0 - fVar1;
	}
	subdata->float_30 = fVar1 * 0.1;
LAB_0040fa04:
	subdata->rotationY_24 = subdata->rotationY_24 + subdata->float_30;
	subdata->rotationZ_2c = -(subdata->float_30 * 9.0);
	return;
}



void __cdecl lego::game::Flocks_Subdata_Matrix_MultRotXYZ(FlocksItem *subdata)
{
	Matrix4F matRotY;
	Matrix4F matRotZ;
	Matrix4F matRotX;
	Matrix4F matMultiply;
	
	math::Matrix_RotX(&matRotX,subdata->rotationX_28);
	math::Matrix_RotY(&matRotY,subdata->rotationY_24);
	math::Matrix_RotZ(&matRotZ,subdata->rotationZ_2c);
	math::Matrix_Mult(&matMultiply,&matRotY,&matRotX);
	math::Matrix_Mult(&subdata->matrix,&matMultiply,&matRotZ);
	return;
}



void __cdecl
lego::game::Flocks_Callback_SubdataMoveAndTurn
					(Flocks *unused_flocksData,FlocksItem *subdata,float *pElapsed)
{
	Vector3F *trans;
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F vector_b;
	Vector3F vector_a;
	Matrix4F matrix_b;
	Matrix4F matrix_a;
	
	vector_b.x = (subdata->vector_0).x - (subdata->vector_c).x;
	vector_b.y = (subdata->vector_0).y - (subdata->vector_c).y;
	trans = &subdata->vector_c;
	fVar2 = *pElapsed;
	vector_b.z = (subdata->vector_0).z - (subdata->vector_c).z;
	if (SQRT(vector_b.z * vector_b.z + vector_b.y * vector_b.y + vector_b.x * vector_b.x) < 1e-05) {
		math::Maths_Vector3DRandom(&vector_b);
	}
	Flocks_Subdata_MathChangeRotationX(subdata,&vector_b);
	Flocks_Subdata_MathChangeRotationsYZ(subdata,&vector_b);
	Flocks_Subdata_Matrix_MultRotXYZ(subdata);
	fVar1 = subdata->Speed1;
	fVar3 = (subdata->matrix).values[2][1];
	fVar4 = (subdata->matrix).values[2][2];
	(subdata->vector_18).x = (subdata->matrix).values[2][0];
	fVar1 = fVar1 * fVar2;
	(subdata->vector_18).y = fVar3;
	(subdata->vector_18).z = fVar4;
	fVar2 = (subdata->vector_18).y;
	fVar3 = (subdata->vector_18).z;
	trans->x = (subdata->vector_18).x * fVar1 + trans->x;
	(subdata->vector_c).y = (subdata->vector_c).y + fVar2 * fVar1;
	(subdata->vector_c).z = (subdata->vector_c).z + fVar3 * fVar1;
	math::Matrix_Translate(&matrix_a,trans);
	math::Matrix_Copy(&matrix_b,&subdata->matrix);
	math::Matrix_Mult(&subdata->matrix,&matrix_a,&matrix_b);
	return;
}



// out_vector = random_vector() * { x, y, z }

void __cdecl
lego::math::Flocks_MathX_Vector3DRandomMultiply(Vector3F *out_vector,float x,float y,float z)
{
	if (out_vector != NULL) {
		Maths_Vector3DRandom(out_vector);
		out_vector->x = x * out_vector->x;
		out_vector->y = y * out_vector->y;
		out_vector->z = z * out_vector->z;
	}
	return;
}



void __cdecl
lego::game::Flocks_Callback_SubdataMoveTightness
					(Flocks *flocksData,FlocksItem *subData,float *pElapsed)
{
	float fVar1;
	FlocksItem *pFVar2;
	float10 extraout_ST0;
	float10 fVar3;
	longlong lVar4;
	longlong lVar5;
	Vector3F direction;
	float tightness;
	
	fVar1 = subData->float_34;
	lVar4 = __ftol((float10)subData->float_34 / (float10)subData->GoalUpdate1);
	fVar3 = extraout_ST0;
	if (extraout_ST0 == (float10)0.0) {
		fVar3 = (float10)0.001;
	}
	fVar1 = (float)((float10)1.0 / fVar3 + (float10)fVar1);
	lVar5 = __ftol((float10)fVar1 / (float10)subData->GoalUpdate1);
	if ((int)lVar5 != (int)lVar4 && -1 < (int)lVar5 - (int)lVar4) {
		tightness = subData->Tightness1;
		math::Flocks_MathX_Vector3DRandomMultiply(&direction,tightness,tightness,tightness);
		pFVar2 = flocksData->flocksSubdata1;
		(subData->vector_0).x = (pFVar2->vector_c).x + direction.x;
		(subData->vector_0).y = (pFVar2->vector_c).y + direction.y;
		(subData->vector_0).z = (pFVar2->vector_c).z + direction.z;
	}
	subData->float_34 = fVar1;
	return;
}



void __cdecl lego::game::Flocks_SetVector2(Flocks *flocksData,Vector3F *vector2)
{
	FlocksItem *pFVar1;
	
	pFVar1 = flocksData->flocksSubdata1;
	(pFVar1->vector_0).x = vector2->x;
	(pFVar1->vector_0).y = vector2->y;
	(pFVar1->vector_0).z = vector2->z;
	flocksData->hasVector2 = TRUE;
	return;
}



void __cdecl lego::game::Flocks_Subdata_MoveAndTurn(FlocksItem *subdata,float elapsed)
{
	Flocks_Callback_SubdataMoveAndTurn(NULL,subdata,&elapsed);
	return;
}



void __cdecl lego::game::Flocks_Subdata_UpdateMove(Flocks *flocksData,float elapsed)
{
	Flocks_Subdata_MoveAndTurn(flocksData->flocksSubdata1,elapsed);
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SubdataMoveAndTurn,&elapsed);
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SubdataMoveTightness,&elapsed);
	return;
}



void __cdecl lego::game::Flocks_LiveObject_Flocks_AddSubdata(Flocks *flockData,FlocksItem *subdata)
{
	if ((flockData != NULL) && (subdata != NULL)) {
		subdata->subdataNext_9c = flockData->flocksSubdata2;
		flockData->flocksSubdata2 = subdata;
		flockData->numSubdata = flockData->numSubdata + 1;
	}
	return;
}



FlocksItem * __cdecl lego::game::Flocks_Free_SubdataRecurse(Flocks *flocksData)
{
	FlocksItem *pFVar1;
	FlocksItem *pFVar2;
	
	if ((flocksData != NULL) && (flocksData->numSubdata != 0)) {
		pFVar1 = flocksData->flocksSubdata2;
		pFVar2 = pFVar1->subdataNext_9c;
		flocksData->numSubdata = flocksData->numSubdata - 1;
		flocksData->flocksSubdata2 = pFVar2;
		return pFVar1;
	}
	return NULL;
}



void __cdecl
lego::game::Flocks_CallbackForAllSubdata(Flocks *flockData,FlocksCallback callback,void *data)
{
	FlocksItem *subdata;
	
	for (subdata = flockData->flocksSubdata2; subdata != NULL; subdata = subdata->subdataNext_9c) {
		(*callback)(flockData,subdata,data);
	}
	return;
}



// Maths_RandRange(0.0f, 1.0f)

float10 __cdecl lego::math::Flocks_MathX_RandRangeOne(void)
{
	float10 fVar1;
	
	fVar1 = Maths_RandRange(0.0,1.0);
	return fVar1;
}



void __cdecl
lego::game::Flocks_Callback_FUN_0040fe00(Flocks *flocksData,FlocksItem *subdata,float *param_3)
{
	float fVar1;
	float fVar2;
	float10 fVar3;
	
	fVar2 = *param_3;
	fVar3 = math::Flocks_MathX_RandRangeOne();
	fVar2 = 1.0 / fVar2;
	fVar1 = (float)((fVar3 + fVar3) - (float10)1.0);
	subdata->Turn1 = fVar2 * fVar1 * subdata->Turn2 + subdata->Turn2;
	subdata->Tightness1 = fVar2 * fVar1 * subdata->Tightness2 + subdata->Tightness2;
	subdata->GoalUpdate1 = fVar2 * fVar1 * subdata->GoalUpdate2 + subdata->GoalUpdate2;
	return;
}



void __cdecl lego::game::Flocks_FUN_0040fe80(Flocks *flocksData,float param_2)
{
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_FUN_0040fe00,&param_2);
	return;
}



void __cdecl
lego::game::Flocks_SetParameters1(Flocks *flocksData,float turn,float speed,float tightness)
{
	flocksData->flocksSubdata1->Turn1 = turn;
	flocksData->flocksSubdata1->Speed1 = speed;
	flocksData->flocksSubdata1->Tightness1 = tightness;
	return;
}



void __cdecl
lego::game::Flocks_Callback_SetSubdataParametersFromGlobals(Flocks *flocksData,FlocksItem *subdata)
{
	subdata->Turn2 = globs::flocksGlobs.Turn;
	subdata->Turn1 = globs::flocksGlobs.Turn;
	subdata->Speed2 = globs::flocksGlobs.Speed;
	subdata->Speed1 = globs::flocksGlobs.Speed;
	subdata->Tightness2 = globs::flocksGlobs.Tightness;
	subdata->Tightness1 = globs::flocksGlobs.Tightness;
	subdata->GoalUpdate2 = globs::flocksGlobs.GoalUpdate;
	subdata->GoalUpdate1 = globs::flocksGlobs.GoalUpdate;
	return;
}



void __cdecl
lego::game::Flocks_SetGlobal_AndAllSubdataParameters
					(Flocks *flockData,float turn,float speed,float tightness,float goalUpdate)
{
	globs::flocksGlobs.Speed = speed;
	globs::flocksGlobs.Turn = turn;
	globs::flocksGlobs.Tightness = tightness;
	globs::flocksGlobs.GoalUpdate = goalUpdate;
	Flocks_CallbackForAllSubdata(flockData,Flocks_Callback_SetSubdataParametersFromGlobals,NULL);
	return;
}



void __cdecl lego::game::Flocks_SetVector1(Flocks *flocksData,Vector3F *vector1)
{
	FlocksItem *pFVar1;
	
	if ((flocksData != NULL) && (vector1 != NULL)) {
		flocksData->hasVector1 = TRUE;
		pFVar1 = flocksData->flocksSubdata1;
		(pFVar1->vector_c).x = vector1->x;
		(pFVar1->vector_c).y = vector1->y;
		(pFVar1->vector_c).z = vector1->z;
	}
	return;
}



void __cdecl
lego::game::Flocks_Callback_SetSubdataVectorC
					(Flocks *flocksData,FlocksItem *subdata,Vector3F *vector)
{
	(subdata->vector_c).x = vector->x;
	(subdata->vector_c).y = vector->y;
	(subdata->vector_c).z = vector->z;
	return;
}



void __cdecl lego::game::Flocks_SetAllSubdataVectorC(Flocks *flocksData,Vector3F *vector)
{
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SetSubdataVectorC,vector);
	return;
}



void __cdecl
lego::game::Flocks_Callback_SetSubdataVector0
					(Flocks *flocksData,FlocksItem *subdata,Vector3F *vector)
{
	(subdata->vector_0).x = vector->x;
	(subdata->vector_0).y = vector->y;
	(subdata->vector_0).z = vector->z;
	return;
}



void __cdecl lego::game::Flocks_SetAllSubdataVector0(Flocks *flocksData,Vector3F *vector)
{
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SetSubdataVector0,vector);
	return;
}



void __cdecl
lego::game::Flocks_Callback_FUN_00410000(Flocks *flocksData,FlocksItem *subdata,float *pElapsed)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float fVar12;
	
	fVar2 = *pElapsed;
	pVVar1 = &subdata->vector_c;
	fVar3 = (subdata->vector_0).x;
	fVar4 = pVVar1->x;
	fVar5 = (subdata->vector_0).y;
	fVar6 = (subdata->vector_c).y;
	fVar7 = (subdata->vector_c).z;
	fVar8 = (subdata->vector_0).z;
	Flocks_Callback_SubdataMoveAndTurn(flocksData,subdata,pElapsed);
	fVar11 = fVar3 - fVar4;
	fVar9 = fVar5 - fVar6;
	fVar12 = fVar8 - fVar7;
	fVar2 = subdata->Speed1 * fVar2;
	fVar10 = SQRT(fVar12 * fVar12 + fVar9 * fVar9 + fVar11 * fVar11);
	if (fVar2 <= fVar10) {
		fVar10 = 1.0 / fVar10;
		pVVar1->x = fVar10 * fVar11 * fVar2 + fVar4;
		(subdata->vector_c).y = fVar10 * fVar9 * fVar2 + fVar6;
		(subdata->vector_c).z = fVar10 * fVar12 * fVar2 + fVar7;
	}
	else {
		pVVar1->x = (subdata->vector_0).x;
		(subdata->vector_c).y = (subdata->vector_0).y;
		(subdata->vector_c).z = (subdata->vector_0).z;
	}
	(subdata->vector_0).x = fVar3;
	fVar2 = (subdata->vector_c).z;
	(subdata->matrix).values[3][0] = pVVar1->x;
	(subdata->matrix).values[3][2] = fVar2;
	(subdata->vector_0).y = fVar5;
	(subdata->vector_0).z = fVar8;
	(subdata->matrix).values[3][1] = (subdata->vector_c).y;
	return;
}



void __cdecl
lego::game::Flocks_Callback_CompareVecs_0_c(Flocks *flocksData,FlocksItem *subdata,BOOL *pSuccess)
{
	if ((((subdata->vector_c).x == (subdata->vector_0).x) &&
			((subdata->vector_c).y == (subdata->vector_0).y)) &&
		 ((subdata->vector_c).z == (subdata->vector_0).z)) {
		res::Container_Hide(subdata->resData_98,TRUE);
		return;
	}
	*pSuccess = 0;
	return;
}



BOOL __cdecl lego::game::Flocks_CompareAllVecs_0_c(Flocks *flocksData)
{
	BOOL result;
	
	result = 1;
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_CompareVecs_0_c,&result);
	return result;
}



char * __cdecl lego::util::replaceTextSpaces(char *str)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	char *pcVar5;
	undefined4 *puVar6;
	
	uVar2 = 0xffffffff;
	pcVar5 = str;
	do {
		if (uVar2 == 0) break;
		uVar2 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	if (0xff < ~uVar2 - 1) {
		return str;
	}
	uVar2 = 0xffffffff;
	do {
		pcVar5 = str;
		if (uVar2 == 0) break;
		uVar2 -= 1;
		pcVar5 = str + 1;
		cVar1 = *str;
		str = pcVar5;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	puVar4 = (undefined4 *)(pcVar5 + -uVar2);
	puVar6 = (undefined4 *)CHAR_ARRAY_004dc748;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
		*puVar6 = *puVar4;
		puVar4 = puVar4 + 1;
		puVar6 = puVar6 + 1;
	}
	uVar3 = 0;
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		*(undefined *)puVar6 = *(undefined *)puVar4;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
		puVar6 = (undefined4 *)((int)puVar6 + 1);
	}
	do {
		if (CHAR_ARRAY_004dc748[uVar3] == '_') {
			CHAR_ARRAY_004dc748[uVar3] = ' ';
		}
		uVar3 += 1;
	} while (uVar3 < 0x100);
	return CHAR_ARRAY_004dc748;
}



void __cdecl lego::front::Missions_PrintF_LevelName(Font *font,int x,int y,char *format,...)
{
	Font **pFont;
	uint i;
	char (*pMsg) [1024];
	
	if (format == NULL) {
		i = 0;
		if (COUNT_004dc8d0 != 0) {
			pFont = FONT_ARRAY_004d8b08;
			pMsg = CHAR_ARRAY_ARRAY_004d8b48;
			do {
				lego::image::Font_PrintF
									(*pFont,POINT_X_ARRAY_004d88c8[i],POINT_Y_ARRAY_004dc850[i],(char *)pMsg);
				i += 1;
				pMsg = pMsg[1];
				pFont = pFont + 1;
			} while (i < COUNT_004dc8d0);
		}
		COUNT_004dc8d0 = 0;
		return;
	}
	if (COUNT_004dc8d0 < 0xf) {
		std::vsprintf((char *)CHAR_ARRAY_ARRAY_004d8b48[COUNT_004dc8d0],format,&stack0x00000014);
		POINT_X_ARRAY_004d88c8[COUNT_004dc8d0] = x;
		POINT_Y_ARRAY_004dc850[COUNT_004dc8d0] = y;
		FONT_ARRAY_004d8b08[COUNT_004dc8d0] = font;
		COUNT_004dc8d0 += 1;
	}
	return;
}



void __cdecl lego::front::MainMenuFull_TriggerShowCredits(void)
{
	Credits_Play(globs::legoGlobs.CreditsTextFile,globs::legoGlobs.bmpRSFont,
							 globs::legoGlobs.CreditsBackAVI);
	return;
}



void __cdecl lego::front::Front_PlayRockWipe_AndUnk(void)
{
	uint uVar1;
	
	if (globals::g_MenuWipeResource != NULL) {
		FLOAT_005584f4 = 0.0;
		FLAGS_005584f0 = FLAGS_005584f0 & 0xffffff00 | FLAGS_005584f0 & 0xff | 1 | 2;
		uVar1 = main::Main_GetTime();
		FLOAT_005584f8 = (float)(ulonglong)uVar1;
		snd::SFX_Sample_AddToQueue(SFX_ROCKWIPE,SOUND_ONCE);
	}
	return;
}



void __cdecl lego::front::Front_UnsetFlag3_005584f0(void)
{
	FLAGS_005584f0 = FLAGS_005584f0 & 0xfffffffc;
	return;
}



ImageCacheItem * __cdecl lego::image::ImageCache_FindByName(char *filename)
{
	int cmp;
	ImageCacheItem *cache;
	
	cache = globals::g_ImageCache_NEXT;
	if (globals::g_ImageCache_NEXT == NULL) {
		return NULL;
	}
	do {
		cmp = std::_stricmp(filename,cache->filename);
		if (cmp == 0) {
			return cache;
		}
		cache = cache->next;
	} while (cache != NULL);
	return NULL;
}



ImageCacheItem * __cdecl lego::image::ImageCache_Get(char *filename)
{
	char cVar1;
	ImageCacheItem *cache;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	
	if ((filename == NULL) || (*filename == '\0')) {
		cache = NULL;
	}
	else {
		cache = ImageCache_FindByName(filename);
		if (cache == NULL) {
			cache = (ImageCacheItem *)std::malloc(0x10);
						// cache->filename = ::_strdup(filename);
			uVar3 = 0xffffffff;
			pcVar6 = filename;
			do {
				if (uVar3 == 0) break;
				uVar3 -= 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			puVar2 = (undefined4 *)std::malloc(~uVar3);
			uVar3 = 0xffffffff;
			cache->filename = (char *)puVar2;
			do {
				pcVar6 = filename;
				if (uVar3 == 0) break;
				uVar3 -= 1;
				pcVar6 = filename + 1;
				cVar1 = *filename;
				filename = pcVar6;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar6 + -uVar3);
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar2 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar2 = puVar2 + 1;
			}
			for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
				*(undefined *)puVar2 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar2 = (undefined4 *)((int)puVar2 + 1);
			}
			cache->image = NULL;
			cache->next = globals::g_ImageCache_NEXT;
			cache->font = NULL;
			globals::g_ImageCache_NEXT = cache;
			return cache;
		}
	}
	return cache;
}



Image * __cdecl lego::image::ImageCache_LoadImage(char *filename)
{
	ImageCacheItem *cache;
	Image *image;
	
	if ((filename != NULL) && (*filename != '\0')) {
		cache = ImageCache_Get(filename);
		if (cache->image == NULL) {
			image = Image_LoadBMPScaled(filename,0,0);
			cache->image = image;
		}
		return cache->image;
	}
	return NULL;
}



Font * __cdecl lego::image::ImageCache_LoadFont(char *filename)
{
	ImageCacheItem *cache;
	Font *font;
	
	if ((filename != NULL) && (*filename != '\0')) {
		cache = ImageCache_Get(filename);
		if (cache->font == NULL) {
			font = Font_Load(filename);
			cache->font = font;
		}
		return cache->font;
	}
	return NULL;
}



char * __cdecl lego::util::_strdup2(char *str)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (str == NULL) {
		return (char *)NULL;
	}
	uVar3 = 0xffffffff;
	pcVar6 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	puVar2 = (undefined4 *)std::malloc(~uVar3);
	if (puVar2 == NULL) {
		return NULL;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar6 = str;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar6 = str + 1;
		cVar1 = *str;
		str = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



MenuItemMissions * __cdecl
lego::front::Menu_CreateMissionsDisplay
					(void *value,char *string1,char *string2,int param_4,int param_5,int param_6,int param_7,
					int param_8,int param_9,int param_10,int param_11,int param_12,void *callback,
					undefined4 param_14)
{
	MenuItemMissions *pMVar1;
	char *pcVar2;
	int iVar3;
	MenuItemMissions *pMVar4;
	
	pMVar1 = (MenuItemMissions *)std::malloc(0x5c);
	pMVar4 = pMVar1;
	for (iVar3 = 0x17; iVar3 != 0; iVar3 += -1) {
		pMVar4->levelsList = NULL;
		pMVar4 = (MenuItemMissions *)pMVar4->widths;
	}
	pcVar2 = util::_strdup2(string1);
	pMVar1->string1 = pcVar2;
	pcVar2 = util::_strdup2(string2);
	pMVar1->string2 = pcVar2;
	(pMVar1->rect1).x = param_4;
	pMVar1->value = (int *)value;
	(pMVar1->rect1).y = param_5;
	(pMVar1->rect1).height = param_7;
	(pMVar1->rect1).width = param_6;
	(pMVar1->rect2).x = param_8;
	(pMVar1->rect2).width = param_10;
	(pMVar1->rect2).y = param_9;
	(pMVar1->rect2).height = param_11;
	pMVar1->callback = (undefined *)callback;
	pMVar1->field_50 = param_12;
	pMVar1->field_4c = 0;
	pMVar1->field_58 = param_14;
	return pMVar1;
}



void __cdecl lego::front::Menu_FreeSubMenuItem_Count(int *param_1)
{
	int *piVar1;
	uint uVar2;
	int *buffer;
	int iVar3;
	int iVar4;
	int iVar5;
	
	buffer = param_1;
	iVar4 = 0;
	if (param_1 != NULL) {
		if ((void *)param_1[8] != NULL) {
			std::free((void *)param_1[8]);
		}
		if ((void *)param_1[9] != NULL) {
			std::free((void *)param_1[9]);
		}
		if (*param_1 != 0) {
			piVar1 = param_1 + 7;
			param_1 = NULL;
			if (0 < *piVar1) {
				do {
					uVar2 = *(uint *)(*buffer + iVar4);
					if ((uVar2 & 1) == 0) {
						if ((uVar2 & 2) != 0) {
							iVar5 = iVar4 + 8;
							iVar3 = 3;
							do {
								lego::image::Image_Remove(*(Image **)(*buffer + iVar5));
								iVar5 += 4;
								iVar3 += -1;
							} while (iVar3 != 0);
						}
					}
					else {
						std::free(*(void **)(*buffer + iVar4 + 4));
					}
					param_1 = (int *)((int)param_1 + 1);
					iVar4 += 0x20;
				} while ((int)param_1 < buffer[7]);
			}
			std::free((void *)*buffer);
		}
		std::free(buffer);
	}
	return;
}



void __cdecl
lego::front::Missions_AddLevel
					(MenuItemMissions *missions,char *menuBMPName,BOOL unkMode,Font *hiFont,int frontEndX,
					int frontEndY,BOOL frontEndOpen)
{
	int *piVar1;
	MenuItemMissions *pMVar2;
	MenuItemLevelIdentifier *pMVar3;
	void *pvVar4;
	int iVar5;
	char *pcVar6;
	Image *pIVar7;
	uint uVar8;
	int **ppiVar9;
	int **ppiVar10;
	int iVar11;
	int *apiStack24 [6];
	
	pMVar2 = missions;
	if (missions->levelsList == NULL) {
		pMVar3 = (MenuItemLevelIdentifier *)std::malloc((missions->levelsCount + 1) * 0x20);
		iVar11 = 0;
		do {
			pvVar4 = std::malloc(missions->levelsCount * 4 + 4);
			iVar5 = missions->levelsCount;
			*(void **)((int)apiStack24 + iVar11) = pvVar4;
			pvVar4 = std::malloc(iVar5 * 4 + 4);
			*(void **)((int)apiStack24 + iVar11 + 0xc) = pvVar4;
			iVar11 += 4;
		} while (iVar11 < 0xc);
	}
	else {
		pMVar3 = (MenuItemLevelIdentifier *)
						 std::realloc(missions->levelsList,(missions->levelsCount + 1) * 0x20);
		ppiVar10 = missions->heights;
		iVar11 = 0;
		do {
			pvVar4 = std::realloc(ppiVar10[-3],missions->levelsCount * 4 + 4);
			iVar5 = missions->levelsCount;
			piVar1 = *ppiVar10;
			*(void **)((int)apiStack24 + iVar11) = pvVar4;
			pvVar4 = std::realloc(piVar1,iVar5 * 4 + 4);
			*(void **)((int)apiStack24 + iVar11 + 0xc) = pvVar4;
			iVar11 += 4;
			ppiVar10 = ppiVar10 + 1;
		} while (iVar11 < 0xc);
	}
	if (pMVar3 != NULL) {
		missions->levelsList = pMVar3;
		pMVar3[missions->levelsCount].MenuBMPName = NULL;
		ppiVar10 = missions->heights;
		missions->levelsList[missions->levelsCount].flags = -(uint)(unkMode != 0) & 4;
		iVar11 = 0;
		ppiVar9 = ppiVar10;
		do {
			iVar5 = iVar11 + 4;
			ppiVar9[-3] = *(int **)((int)apiStack24 + iVar11);
			*ppiVar9 = *(int **)((int)apiStack24 + iVar11 + 0xc);
			ppiVar9 = ppiVar9 + 1;
			iVar11 = iVar5;
		} while (iVar5 < 0xc);
		if ((menuBMPName != NULL) && (pcVar6 = util::Util_StrIStr(menuBMPName,".bmp"), pcVar6 != NULL))
		{
			util::Util_Tokenise(menuBMPName,(char **)(apiStack24 + 3),",");
			iVar11 = 0;
			missions->levelsList[missions->levelsCount].flags =
					 missions->levelsList[missions->levelsCount].flags | 2;
			missions = (MenuItemMissions *)(apiStack24 + 3);
			do {
				pIVar7 = lego::image::ImageCache_LoadImage((char *)missions->levelsList);
				(&pMVar2->levelsList[pMVar2->levelsCount].HiImage)[iVar11] = pIVar7;
				pIVar7 = (&pMVar2->levelsList[pMVar2->levelsCount].HiImage)[iVar11];
				if (pIVar7 != NULL) {
					lego::image::Image_SetPenZeroTrans(pIVar7);
				}
				iVar11 += 1;
				ppiVar10[-3][pMVar2->levelsCount] = pIVar7->width;
				piVar1 = *ppiVar10;
				ppiVar10 = ppiVar10 + 1;
				piVar1[pMVar2->levelsCount] = pIVar7->height;
				missions = (MenuItemMissions *)missions->widths;
			} while (iVar11 < 3);
			pMVar2->levelsList[pMVar2->levelsCount].FrontEndX = frontEndX;
			pMVar2->levelsList[pMVar2->levelsCount].FrontEndY = frontEndY;
			pMVar2->levelsList[pMVar2->levelsCount].FrontEndOpen = frontEndOpen;
			pMVar2->levelsCount = pMVar2->levelsCount + 1;
			return;
		}
		missions->levelsList[missions->levelsCount].flags =
				 missions->levelsList[missions->levelsCount].flags | 1;
		pcVar6 = util::_strdup2(menuBMPName);
		missions->levelsList[missions->levelsCount].MenuBMPName = pcVar6;
		missions->levelsList[missions->levelsCount].FrontEndX = frontEndX;
		missions->levelsList[missions->levelsCount].FrontEndY = frontEndY;
		missions->levelsList[missions->levelsCount].FrontEndOpen = frontEndOpen;
		uVar8 = lego::image::Font_GetStringWidth(hiFont,menuBMPName);
		missions->widths[2][missions->levelsCount] = uVar8;
		missions->widths[1][missions->levelsCount] = missions->widths[2][missions->levelsCount];
		missions->widths[0][missions->levelsCount] = missions->widths[1][missions->levelsCount];
		uVar8 = lego::image::Font_GetHeight(hiFont);
		missions->heights[2][missions->levelsCount] = uVar8;
		missions->heights[1][missions->levelsCount] = missions->heights[2][missions->levelsCount];
		(*ppiVar10)[missions->levelsCount] = missions->heights[1][missions->levelsCount];
		missions->levelsCount = missions->levelsCount + 1;
	}
	return;
}



MenuItemCycle * __cdecl
lego::front::Menu_CreateCycle(uint count,void *value,int x2,int y2,void *callback)
{
	MenuItemCycle *cycleData;
	char **nameList;
	uint uVar1;
	int iVar2;
	
	cycleData = (MenuItemCycle *)std::malloc(0x1c);
	if (cycleData == NULL) {
		return NULL;
	}
	nameList = (char **)std::malloc(count * 4);
	cycleData->nameList = nameList;
	if (nameList == NULL) {
		Menu_FreeCycle(cycleData);
		return NULL;
	}
	for (uVar1 = count & 0x3fffffff; uVar1 != 0; uVar1 -= 1) {
		*nameList = NULL;
		nameList = nameList + 1;
	}
	for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
		*(undefined *)nameList = 0;
		nameList = (char **)((int)nameList + 1);
	}
	cycleData->value = (int *)value;
	cycleData->callback = (MenuItemCycleCallback)callback;
	cycleData->cycleCount = count;
	cycleData->nameCount = 0;
	cycleData->x2 = x2;
	cycleData->y2 = y2;
	return cycleData;
}



void __cdecl lego::front::Menu_AddCycleName(MenuItemCycle *cycleData,char *name)
{
	char *pcVar1;
	
	if (((cycleData != NULL) && (cycleData->nameList != NULL)) &&
		 (cycleData->nameCount < (int)cycleData->cycleCount)) {
		pcVar1 = util::_strdup2(name);
		cycleData->nameList[cycleData->nameCount] = pcVar1;
		if (cycleData->nameList[cycleData->nameCount] != NULL) {
			cycleData->nameCount = cycleData->nameCount + 1;
		}
	}
	return;
}



void __cdecl lego::front::Menu_FreeCycle(MenuItemCycle *cycleData)
{
	int iVar1;
	
	if (cycleData != NULL) {
		if (cycleData->nameList != NULL) {
			iVar1 = 0;
			if (0 < cycleData->nameCount) {
				do {
					if (cycleData->nameList[iVar1] != NULL) {
						std::free(cycleData->nameList[iVar1]);
					}
					iVar1 += 1;
				} while (iVar1 < cycleData->nameCount);
			}
			std::free(cycleData->nameList);
		}
		std::free(cycleData);
	}
	return;
}



int __cdecl lego::input::msx(void)
{
	return globs::INPUT.msx;
}



int __cdecl lego::input::msy(void)
{
	return globs::INPUT.msy;
}



BOOL __cdecl lego::input::mslb(void)
{
	return globs::INPUT.mslb;
}



MenuItemTrigger * __cdecl lego::front::Menu_CreateTrigger(void *value,BOOL end,void *callback)
{
	MenuItemTrigger *pMVar1;
	
	pMVar1 = (MenuItemTrigger *)std::malloc(0xc);
	if (pMVar1 == NULL) {
		return NULL;
	}
	pMVar1->value = (int *)value;
	pMVar1->end = end;
	pMVar1->callback = (MenuItemTriggerCallback)callback;
	return pMVar1;
}



MenuItemRealSlider * __cdecl
lego::front::Menu_CreateRealSlider
					(void *value,float lowLimit,float highLimit,float step,int x2,int y2,void *callback)
{
	MenuItemRealSlider *pMVar1;
	
	if ((ushort)((ushort)(highLimit < lowLimit) << 8 | (ushort)(highLimit == lowLimit) << 0xe) != 0) {
		return NULL;
	}
	pMVar1 = (MenuItemRealSlider *)std::malloc(0x1c);
	if (pMVar1 == NULL) {
		return NULL;
	}
	pMVar1->value = (float *)value;
	pMVar1->LowLimit = lowLimit;
	pMVar1->HighLimit = highLimit;
	pMVar1->Step = step;
	pMVar1->x2 = x2;
	pMVar1->y2 = y2;
	pMVar1->callback = (MenuItemRealSliderCallback)callback;
	return pMVar1;
}



MenuItemSlider * __cdecl
lego::front::Menu_CreateSlider
					(void *value,int lowLimit,int highLimit,int x2,int y2,void *callback,Image *offBarImage,
					Image *onBarImage,Image *leftCapImage,Image *rightCapImage,Image *loPlusImage,
					Image *loMinusImage,Image *hiPlusImage,Image *hiMinusImage)
{
	MenuItemSlider *pMVar1;
	
	if (highLimit <= lowLimit) {
		return NULL;
	}
	pMVar1 = (MenuItemSlider *)std::malloc(0x38);
	if (pMVar1 == NULL) {
		return NULL;
	}
	pMVar1->value = (int *)value;
	pMVar1->x2 = x2;
	pMVar1->y2 = y2;
	pMVar1->callback = (MenuItemSliderCallback)callback;
	pMVar1->OffBarImage = offBarImage;
	pMVar1->OnBarImage = onBarImage;
	pMVar1->LeftCapImage = leftCapImage;
	pMVar1->RightCapImage = rightCapImage;
	pMVar1->LoPlusImage = loPlusImage;
	pMVar1->LoMinusImage = loMinusImage;
	pMVar1->LowLimit = lowLimit;
	pMVar1->HighLimit = highLimit;
	pMVar1->HiPlusImage = hiPlusImage;
	pMVar1->HiMinusImage = hiMinusImage;
	return pMVar1;
}



void __cdecl lego::front::Menu_FreeMenuItem(MenuItem *menuItem)
{
	if (menuItem != NULL) {
		if (menuItem->banner != NULL) {
			std::free(menuItem->banner);
		}
		if (true) {
			switch(menuItem->itemType) {
			case MENUITEM_CYCLE:
				Menu_FreeCycle((MenuItemCycle *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_TRIGGER:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_TEXTINPUT:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_SLIDER:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_REALSLIDER:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_MISSIONS:
				Menu_FreeSubMenuItem_Count((int *)menuItem->itemData);
			}
		}
		std::free(menuItem);
	}
	return;
}



MenuItem * __cdecl
lego::front::Menu_CreateBannerItem
					(char *banner,Font *loFont,Font *hiFont,int x1,int y1,MenuItemType itemType,BOOL centered,
					void *itemData,BOOL isNext6)
{
	char cVar1;
	MenuItem *pMVar2;
	char *pcVar3;
	int iVar4;
	uint uVar5;
	MenuItem *pMVar6;
	
	if (banner == NULL) {
		return NULL;
	}
	pMVar2 = (MenuItem *)std::malloc(0x3c);
	if (pMVar2 == NULL) {
		return NULL;
	}
	pMVar6 = pMVar2;
	for (iVar4 = 0xf; iVar4 != 0; iVar4 += -1) {
		pMVar6->banner = NULL;
		pMVar6 = (MenuItem *)&pMVar6->length;
	}
	uVar5 = 0xffffffff;
	pcVar3 = banner;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar1 != '\0');
	pMVar2->length = ~uVar5 - 1;
	pcVar3 = util::_strdup2(banner);
	pMVar2->itemType = itemType;
	pMVar2->banner = pcVar3;
	pMVar2->x1 = x1;
	pMVar2->itemData = itemData;
	pMVar2->NotInTuto = isNext6;
	pMVar2->LoFont = loFont;
	pMVar2->HiFont = hiFont;
	pMVar2->y1 = y1;
	if (((centered != 0) && (loFont != NULL)) && (hiFont != NULL)) {
		uVar5 = lego::image::Font_GetStringWidth(loFont,banner);
		pMVar2->LoCenterOff = -(uVar5 >> 1);
		uVar5 = lego::image::Font_GetStringWidth(hiFont,banner);
		pMVar2->HiCenterOff = -(uVar5 >> 1);
		return pMVar2;
	}
	pMVar2->LoCenterOff = 0;
	pMVar2->HiCenterOff = 0;
	return pMVar2;
}



MenuItem * __cdecl
lego::front::Menu_CreateImageItem
					(char *banner,Font *loFont,Font *hiFont,char *loImageName,char *hiImageName,int x1,int y1,
					MenuItemType itemType,BOOL centered,char *toolTipName,void *itemData)
{
	char cVar1;
	MenuItem *pMVar2;
	char *pcVar3;
	Image *pIVar4;
	BOOL BVar5;
	int iVar6;
	uint uVar7;
	MenuItem *pMVar8;
	
	if (banner != NULL) {
		pMVar2 = (MenuItem *)std::malloc(0x3c);
		if (pMVar2 != NULL) {
			pMVar8 = pMVar2;
			for (iVar6 = 0xf; iVar6 != 0; iVar6 += -1) {
				pMVar8->banner = NULL;
				pMVar8 = (MenuItem *)&pMVar8->length;
			}
			uVar7 = 0xffffffff;
			pcVar3 = banner;
			do {
				if (uVar7 == 0) break;
				uVar7 -= 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar3 + 1;
			} while (cVar1 != '\0');
			pMVar2->length = ~uVar7 - 1;
			pcVar3 = util::_strdup2(banner);
			pMVar2->banner = pcVar3;
			pMVar2->HiFont = hiFont;
			pMVar2->LoFont = loFont;
			pIVar4 = lego::image::Image_LoadBMPScaled(loImageName,0,0);
			pMVar2->LoImage = pIVar4;
			if (pIVar4 != NULL) {
				pIVar4 = lego::image::Image_LoadBMPScaled(hiImageName,0,0);
				pMVar2->HiImage = pIVar4;
				if (pIVar4 != NULL) {
					pMVar2->isImageItem = 1;
				}
				pMVar2->itemData = itemData;
				pMVar2->itemType = itemType;
				pMVar2->x1 = x1;
				pMVar2->y1 = y1;
				BVar5 = ToolTip_GetType(toolTipName,&pMVar2->toolTipType);
				if (BVar5 == 0) {
					pMVar2->toolTipType = TOOLTIP_NULL;
				}
				if (((centered != 0) && (pMVar2->LoImage != NULL)) && (pMVar2->HiImage != NULL)) {
					pMVar2->LoCenterOff = -(pMVar2->LoImage->width >> 1);
					pMVar2->HiCenterOff = -(pMVar2->HiImage->width >> 1);
					return pMVar2;
				}
				pMVar2->LoCenterOff = 0;
				pMVar2->HiCenterOff = 0;
				return pMVar2;
			}
		}
	}
	return NULL;
}



void __cdecl lego::front::Menu_FreeSubMenu(SubMenu *submenu)
{
	MenuItem *menuItem;
	int iVar1;
	
	if (submenu != NULL) {
		if (submenu->string_0 != NULL) {
			std::free(submenu->string_0);
		}
		if (submenu->string_4 != NULL) {
			std::free(submenu->string_4);
		}
		if (submenu->Items != NULL) {
			std::free(submenu->Items);
		}
		iVar1 = 0;
		if (0 < submenu->ItemCount) {
			do {
				menuItem = (MenuItem *)(&submenu->Items->banner)[iVar1];
				if (menuItem != NULL) {
					Menu_FreeMenuItem(menuItem);
				}
				iVar1 += 1;
			} while (iVar1 < submenu->ItemCount);
		}
		if (submenu->MenuImage != NULL) {
			lego::image::Image_Remove(submenu->MenuImage);
		}
		std::free(submenu);
	}
	return;
}



BOOL __cdecl lego::front::Menu_LoadMenuImage(SubMenu *param_1,char *param_2,BOOL isLightImage)
{
	char cVar1;
	Image *pIVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	float10 fVar9;
	char *local_410;
	char *local_40c;
	char *local_408;
	char *local_404;
	undefined4 local_400 [256];
	
	local_410 = NULL;
	local_40c = NULL;
	local_408 = NULL;
	local_404 = NULL;
	if (param_2 == NULL) {
		return 0;
	}
	uVar4 = 0xffffffff;
	do {
		pcVar7 = param_2;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar7 = param_2 + 1;
		cVar1 = *param_2;
		param_2 = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	puVar8 = local_400;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar8 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	uVar4 = util::Util_Tokenise((char *)local_400,&local_410,":");
	if (2 < uVar4) {
		param_1->uint_34 = param_1->uint_34 | 1;
		fVar9 = std::atof(local_40c);
		*(float *)&param_1->field_0x38 = (float)fVar9;
		fVar9 = std::atof(local_408);
		*(float *)&param_1->field_0x3c = (float)fVar9;
	}
	if (isLightImage != 0) {
		pIVar2 = lego::image::ImageCache_LoadImage(local_410);
		param_1->MenuImage = pIVar2;
		if ((pIVar2 != NULL) && (uVar4 == 4)) {
			iVar3 = std::atoi(local_404);
			if (iVar3 == 1) {
				lego::image::Image_SetPenZeroTrans(param_1->MenuImage);
			}
		}
		return (uint)(param_1->MenuImage != NULL);
	}
	pIVar2 = lego::image::ImageCache_LoadImage(local_410);
	param_1->MenuImageDark = pIVar2;
	if ((pIVar2 != NULL) && (uVar4 == 4)) {
		iVar3 = std::atoi(local_404);
		if (iVar3 == 1) {
			lego::image::Image_SetupTrans(param_1->MenuImageDark,0.0,0.0,0.0,0.0,0.0,0.0);
		}
	}
	return (uint)(param_1->MenuImageDark != NULL);
}



SubMenu * __cdecl
lego::front::Menu_CreateSubMenu
					(char *title,char *fullName,Font *menuFont,int positionX,int positionY,BOOL autoCenter,
					BOOL displayTitle,int param_8,BOOL canScroll,char *anchored_str)
{
	char cVar1;
	SubMenu *submenu_00;
	char *pcVar2;
	MenuItem *pMVar3;
	int iVar4;
	uint uVar5;
	SubMenu *submenu;
	char *local_190;
	char *local_18c;
	
	submenu_00 = (SubMenu *)std::malloc(0xa0);
	if (submenu_00 == NULL) {
		return NULL;
	}
	submenu = submenu_00;
	for (iVar4 = 0x28; iVar4 != 0; iVar4 += -1) {
		submenu->string_0 = NULL;
		submenu = (SubMenu *)&submenu->string_4;
	}
	pcVar2 = util::_strdup2(title);
	submenu_00->string_0 = pcVar2;
	pcVar2 = util::_strdup2(fullName);
	submenu_00->string_4 = pcVar2;
	if (submenu_00->string_0 == NULL) {
		return NULL;
	}
	if (pcVar2 == NULL) {
		return NULL;
	}
	uVar5 = 0xffffffff;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar1 = *title;
		title = title + 1;
	} while (cVar1 != '\0');
	submenu_00->length_8 = ~uVar5 - 1;
	pMVar3 = (MenuItem *)std::malloc(0x3c);
	submenu_00->Items = pMVar3;
	if (pMVar3 == NULL) {
		Menu_FreeSubMenu(submenu_00);
		return NULL;
	}
	submenu_00->MenuFont = menuFont;
	(submenu_00->Position).y = positionY;
	submenu_00->AutoCenter = autoCenter;
	submenu_00->DisplayTitle = displayTitle;
	(submenu_00->Position).x = positionX;
	submenu_00->int_20 = 0xf;
	submenu_00->ItemCount = 0;
	submenu_00->field_24 = 0;
	submenu_00->field_28 = 0;
	submenu_00->flags_58 = param_8;
	submenu_00->uint_34 = -(uint)(canScroll != 0) & 2;
	if (anchored_str != NULL) {
		submenu_00->isAnchored = 1;
		util::Util_Tokenise(anchored_str,&local_190,":");
		iVar4 = std::atoi(local_190);
		(submenu_00->AnchoredPosition).x = iVar4;
		iVar4 = std::atoi(local_18c);
		(submenu_00->AnchoredPosition).y = iVar4;
	}
	return submenu_00;
}



BOOL __cdecl lego::front::Menu_AddSubMenuItem(SubMenu *submenu,MenuItem *menuItem)
{
	int iVar1;
	MenuItem *pMVar2;
	
	if ((menuItem == NULL) || (submenu == NULL)) {
		return 0;
	}
	iVar1 = submenu->int_20;
	if (submenu->ItemCount == iVar1) {
		if (submenu->Items == NULL) {
			pMVar2 = (MenuItem *)std::malloc(iVar1 * 4 + 0x3c);
		}
		else {
			pMVar2 = (MenuItem *)std::realloc(submenu->Items,iVar1 * 4 + 0x3c);
		}
		if (pMVar2 == NULL) {
			return 0;
		}
		submenu->Items = pMVar2;
		submenu->int_20 = submenu->int_20 + 0xf;
	}
	(&submenu->Items->banner)[submenu->ItemCount] = (char *)menuItem;
	submenu->ItemCount = submenu->ItemCount + 1;
	return 1;
}



BOOL __cdecl
lego::math::MathX_IsPointInsideRect(int ptX,int ptY,int rcX,int rcY,int rcWidth,int rcHeight)
{
	if ((rcX <= ptX) && (ptX <= rcWidth + rcX)) {
		if ((rcY <= ptY) && (ptY <= rcHeight + rcY)) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::math::MathX_IsPointInsideRect_OptCenterX
					(int ptX,int ptY,int rcX,int rcY,int rcWidth,int rcHeight,BOOL shouldCenterX)
{
	int iVar1;
	BOOL BVar2;
	
	if (shouldCenterX == 0) {
		iVar1 = 0;
	}
	else {
		iVar1 = -(rcWidth / 2);
	}
	BVar2 = MathX_IsPointInsideRect(ptX,ptY,iVar1 + rcX,rcY,rcWidth,rcHeight);
	return BVar2;
}



int __cdecl
lego::front::Front_SubmenuItem_CollisionCheck_FUN_00411290
					(SubMenu *submenu,MenuItem *item,int *itemData)
{
	MenuItem *pMVar1;
	MenuItem *pMVar2;
	BOOL BVar3;
	uint rcWidth;
	byte *pbVar4;
	int iVar5;
	uint rcHeight;
	int iVar6;
	
	pMVar1 = item;
	rcHeight = 0;
	if (item->HiFont == NULL) {
		item = NULL;
	}
	else {
		pMVar2 = (MenuItem *)lego::image::Font_GetStringWidth(item->HiFont,(char *)itemData[8]);
		rcHeight = lego::image::Font_GetHeight(item->HiFont);
		item = pMVar2;
	}
	BVar3 = math::MathX_IsPointInsideRect_OptCenterX
										(globs::INPUT.msx,globs::INPUT.msy,itemData[0xf] + (submenu->Position).x,
										 itemData[0x10] + (submenu->Position).y,(int)item,rcHeight,0);
	if (BVar3 != 0) {
		return -2;
	}
	if (pMVar1->HiFont == NULL) {
		rcWidth = 0;
	}
	else {
		rcWidth = lego::image::Font_GetStringWidth(pMVar1->HiFont,(char *)itemData[9]);
	}
	BVar3 = math::MathX_IsPointInsideRect_OptCenterX
										(globs::INPUT.msx,globs::INPUT.msy,itemData[0x11] + (submenu->Position).x,
										 itemData[0x12] + (submenu->Position).y,rcWidth,rcHeight,0);
	if (BVar3 != 0) {
		return -3;
	}
	iVar6 = 0;
	if (0 < itemData[0xe]) {
		while (iVar5 = itemData[0x13] + iVar6, iVar5 < itemData[7]) {
			pbVar4 = (byte *)(*itemData + iVar5 * 0x20);
			if ((*pbVar4 & 4) != 0) {
				BVar3 = math::MathX_IsPointInsideRect_OptCenterX
													(globs::INPUT.msx,globs::INPUT.msy,
													 pMVar1->x1 + itemData[0xb] + *(int *)(pbVar4 + 0x14) +
													 (int)Point2F_005584dc.x + (submenu->Position).x,
													 itemData[0xd] * iVar6 + pMVar1->y1 + itemData[0xc] +
													 *(int *)(pbVar4 + 0x18) + (int)Point2F_005584dc.y + (submenu->Position).y
													 ,*(int *)(itemData[1] + iVar5 * 4),*(int *)(itemData[4] + iVar5 * 4),
													 submenu->AutoCenter);
				if (BVar3 != 0) {
					return iVar6 + itemData[0x13];
				}
			}
			iVar6 += 1;
			if (itemData[0xe] <= iVar6) {
				return -1;
			}
		}
	}
	return -1;
}



BOOL __cdecl lego::front::Front_SubmenuItem_FUN_00411420(SubMenu *submenu,int itemIndex)
{
	MenuItem *item;
	int iVar1;
	
	if ((itemIndex < submenu->ItemCount) &&
		 (item = (MenuItem *)(&submenu->Items->banner)[itemIndex], item->itemType == MENUITEM_MISSIONS))
	{
		iVar1 = Front_SubmenuItem_CollisionCheck_FUN_00411290(submenu,item,(int *)item->itemData);
		return (uint)(iVar1 != -1);
	}
	return 0;
}



BOOL __cdecl
lego::front::Front_Submenu_FUN_00411460
					(SubMenu *submenu,int itemIndex,int *out_rcX,int *out_rcY,int *out_rcWidth,
					int *out_rcHeight)
{
	char **ppcVar1;
	Font *pFVar2;
	uint uVar3;
	char *pcVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	char *pcVar8;
	char *pcVar9;
	int iVar10;
	int iVar11;
	
	if (submenu->ItemCount <= itemIndex) {
		return 0;
	}
	ppcVar1 = (char **)(&submenu->Items->banner)[itemIndex];
	if (ppcVar1[5] == (char *)0x3) {
		pcVar9 = ppcVar1[9] + (submenu->Position).x + (int)ppcVar1[6];
		pcVar6 = ppcVar1[4];
		pcVar4 = ppcVar1[7] + (submenu->Position).y;
		if (submenu->field_24 == itemIndex) {
			pFVar2 = (Font *)ppcVar1[2];
		}
		else {
			pFVar2 = (Font *)ppcVar1[3];
		}
		uVar3 = lego::image::Font_GetStringWidth(pFVar2,*ppcVar1);
		pcVar7 = (&submenu->Items->banner)[itemIndex];
		if (submenu->field_24 == itemIndex) {
			pFVar2 = *(Font **)(pcVar7 + 8);
		}
		else {
			pFVar2 = *(Font **)(pcVar7 + 0xc);
		}
		uVar5 = lego::image::Font_GetHeight(pFVar2);
		pcVar7 = ppcVar1[6] + (submenu->Position).x + *(int *)(pcVar6 + 0xc);
		pcVar8 = ppcVar1[7] + (submenu->Position).y + *(int *)(pcVar6 + 0x10);
		if (*(int *)(pcVar6 + 0x24) == 0) {
			iVar10 = 0;
		}
		else {
			iVar10 = *(int *)(*(int *)(pcVar6 + 0x24) + 4);
		}
		if (*(int *)(pcVar6 + 0x28) == 0) {
			iVar11 = 0;
		}
		else {
			iVar11 = *(int *)(*(int *)(pcVar6 + 0x28) + 4);
		}
		pcVar6 = pcVar9;
		if ((int)pcVar7 <= (int)pcVar9) {
			pcVar6 = pcVar7;
		}
		*out_rcX = (int)pcVar6;
		pcVar6 = pcVar4;
		if ((int)pcVar8 <= (int)pcVar4) {
			pcVar6 = pcVar8;
		}
		*out_rcY = (int)pcVar6;
		pcVar6 = pcVar7 + iVar11 + 0x68 + iVar10;
		if ((int)(pcVar7 + iVar11 + 0x68 + iVar10) < (int)(pcVar9 + uVar3)) {
			pcVar6 = pcVar9 + uVar3;
		}
		*out_rcWidth = (int)pcVar6;
		pcVar6 = pcVar4 + uVar5;
		if ((int)(pcVar4 + uVar5) <= (int)(pcVar8 + 0x14)) {
			pcVar6 = pcVar8 + 0x14;
		}
		*out_rcHeight = (int)pcVar6;
		*out_rcWidth = *out_rcWidth - *out_rcX;
		*out_rcHeight = *out_rcHeight - *out_rcY;
		return TRUE;
	}
	if (ppcVar1[5] == (char *)0x6) {
		return 0;
	}
	*out_rcX = (int)(ppcVar1[9] + (submenu->Position).x + (int)ppcVar1[6]);
	*out_rcY = *(int *)((&submenu->Items->banner)[itemIndex] + 0x1c) + (submenu->Position).y;
	ppcVar1 = (char **)(&submenu->Items->banner)[itemIndex];
	if (ppcVar1[10] != NULL) {
		if (submenu->field_24 == itemIndex) {
			pcVar6 = ppcVar1[0xc];
		}
		else {
			pcVar6 = ppcVar1[0xb];
		}
		*out_rcWidth = *(int *)(pcVar6 + 4);
		pcVar6 = (&submenu->Items->banner)[itemIndex];
		if (submenu->field_24 == itemIndex) {
			*out_rcHeight = *(int *)(*(int *)(pcVar6 + 0x30) + 8);
			return TRUE;
		}
		*out_rcHeight = *(int *)(*(int *)(pcVar6 + 0x2c) + 8);
		return TRUE;
	}
	if (submenu->field_24 == itemIndex) {
		pFVar2 = (Font *)ppcVar1[2];
	}
	else {
		pFVar2 = (Font *)ppcVar1[3];
	}
	uVar3 = lego::image::Font_GetStringWidth(pFVar2,*ppcVar1);
	*out_rcWidth = uVar3;
	pcVar6 = (&submenu->Items->banner)[itemIndex];
	if (submenu->field_24 == itemIndex) {
		uVar3 = lego::image::Font_GetHeight(*(Font **)(pcVar6 + 8));
		*out_rcHeight = uVar3;
		return TRUE;
	}
	uVar3 = lego::image::Font_GetHeight(*(Font **)(pcVar6 + 0xc));
	*out_rcHeight = uVar3;
	return TRUE;
}



BOOL __cdecl lego::front::Front_Submenu_FUN_004116c0(SubMenu *submenu,int *out_itemResult)
{
	BOOL BVar1;
	BOOL BVar2;
	int itemIndex;
	int rcHeight;
	int rcWidth;
	int rcY;
	int rcX;
	
	itemIndex = 0;
	rcX = 0;
	rcY = 0;
	rcWidth = 0;
	rcHeight = 0;
	BVar2 = 0;
	while( true ) {
		BVar1 = Front_Submenu_FUN_00411460(submenu,itemIndex,&rcX,&rcY,&rcWidth,&rcHeight);
		if (BVar1 == 0) {
			BVar2 = Front_SubmenuItem_FUN_00411420(submenu,itemIndex);
			if (BVar2 == 0) {
				return 0;
			}
		}
		if (BVar2 != 0) break;
		BVar1 = math::MathX_IsPointInsideRect
											(globs::INPUT.msx,globs::INPUT.msy,rcX,rcY,rcWidth,rcHeight);
		if (BVar1 != 0) break;
		itemIndex += 1;
	}
	if (out_itemResult != NULL) {
		*out_itemResult = itemIndex;
	}
	return TRUE;
}



BOOL __cdecl lego::front::Front_GetMousePressedState(void)
{
	BOOL BVar1;
	
	if ((globs::INPUT.mslb != 0) || (BVar1 = TRUE, BOOL_004dc8d4 != TRUE)) {
		BVar1 = 0;
	}
	BOOL_004dc8d4 = globs::INPUT.mslb;
	return BVar1;
}



BOOL __cdecl
lego::front::Front_Submenu_Slider_FUN_004117a0(SubMenu *param_1,int param_2,int **param_3)
{
	int *piVar1;
	BOOL BVar2;
	int iVar3;
	int rcX;
	float10 fVar4;
	longlong lVar5;
	
	rcX = (int)param_3[3] + *(int *)(param_2 + 0x18) + (param_1->Position).x;
	iVar3 = (param_1->Position).y + *(int *)(param_2 + 0x1c) + (int)param_3[4];
	BVar2 = math::MathX_IsPointInsideRect(globs::INPUT.msx,globs::INPUT.msy,rcX,iVar3,100,0x14);
	if (BVar2 != 0) {
		fVar4 = ((float10)globs::INPUT.msx - (float10)rcX) * (float10)0.01;
		if ((ushort)((ushort)(fVar4 < (float10)1.0) << 8 | (ushort)(fVar4 == (float10)1.0) << 0xe) == 0)
		{
			fVar4 = (float10)1.0;
		}
		if (fVar4 < (float10)0.0) {
			fVar4 = (float10)0.0;
		}
		lVar5 = __ftol((float10)((int)param_3[2] - (int)param_3[1]) * fVar4);
		**param_3 = (int)lVar5;
		return 1;
	}
	piVar1 = param_3[0xb];
	if ((piVar1 != NULL) && (param_3[10] != NULL)) {
		BVar2 = math::MathX_IsPointInsideRect
											(globs::INPUT.msx,globs::INPUT.msy,(rcX - piVar1[1]) + -4,iVar3,piVar1[1],
											 piVar1[2]);
		if (BVar2 == 0) {
			BVar2 = math::MathX_IsPointInsideRect
												(globs::INPUT.msx,globs::INPUT.msy,param_3[9][1] + 0x68 + rcX,iVar3,
												 param_3[10][1],param_3[10][2]);
			if (BVar2 == 0) {
				return 0;
			}
			iVar3 = **param_3;
			if (iVar3 < (int)param_3[2]) {
				**param_3 = iVar3 + 1;
			}
		}
		else {
			iVar3 = **param_3;
			if ((int)param_3[1] < iVar3) {
				**param_3 = iVar3 + -1;
				return 1;
			}
		}
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Front_SubmenuItemCheckHasTutorialFlags(MenuItem *item)
{
	TutorialFlags TVar1;
	
	if ((item != NULL) && (item->NotInTuto != 0)) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if (TVar1 != TUTORIAL_NONE) {
			return TRUE;
		}
	}
	return 0;
}



SubMenu * __cdecl lego::front::Front_Submenu_FUN_00411930(undefined4 param_1,SubMenu *submenu)
{
	undefined *puVar1;
	float *pfVar2;
	int **ppiVar3;
	int **ppiVar4;
	float **ppfVar5;
	MenuItemType MVar6;
	undefined4 *puVar7;
	int *piVar8;
	bool bVar9;
	bool bVar10;
	BOOL BVar11;
	int iVar12;
	int iVar13;
	MenuItem *item;
	int iVar14;
	int local_4;
	
	local_4 = -1;
	iVar14 = submenu->field_24;
	bVar10 = false;
	if (iVar14 < 0) {
		item = NULL;
	}
	else {
		item = (MenuItem *)(&submenu->Items->banner)[iVar14];
	}
	if (((byte)FLAGS_005584f0 & 2) != 0) {
		return submenu;
	}
	bVar9 = true;
	if ((item == NULL) && (-1 < iVar14)) {
		submenu->field_28 = 1;
	}
	BVar11 = Front_Submenu_FUN_004116c0(submenu,&local_4);
	if (BVar11 != 0) {
		submenu->field_24 = local_4;
		item = (MenuItem *)(&submenu->Items->banner)[local_4];
	}
	BVar11 = Front_SubmenuItemCheckHasTutorialFlags(item);
	if (BVar11 != 0) {
		return submenu;
	}
	BVar11 = Front_GetMousePressedState();
	if ((BVar11 == 0) || (BVar11 = Front_Submenu_FUN_004116c0(submenu,&local_4), BVar11 == 0)) {
		bVar9 = false;
	}
	if ((item == NULL) && ((int)submenu->field_24 < 0)) {
		return submenu;
	}
						// IsKeyPressed(KEY_CURSORRIGHT) (205)
	if (((globs::INPUT.Key_Map[205] != false) &&
			(globs::INPUT.prevKey_Map[205] != globs::INPUT.Key_Map[205])) || (bVar9)) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_OKAY,FALSE);
		if (true) {
			switch(item->itemType) {
			case MENUITEM_CYCLE:
				iVar14 = item->itemData;
				**(int **)(iVar14 + 0xc) = (**(int **)(iVar14 + 0xc) + 1) % *(int *)(iVar14 + 8);
				bVar10 = bVar9;
				if (*(code **)(iVar14 + 0x18) != NULL) {
					(**(code **)(iVar14 + 0x18))(**(undefined4 **)(iVar14 + 0xc));
				}
				break;
			case MENUITEM_TEXTINPUT:
				iVar14 = item->itemData;
				iVar13 = *(int *)(iVar14 + 8) + 1;
				iVar12 = *(int *)(iVar14 + 4) + -1;
				*(int *)(iVar14 + 8) = iVar13;
				bVar10 = bVar9;
				if (iVar12 < iVar13) {
					*(int *)(iVar14 + 8) = iVar12;
				}
				break;
			case MENUITEM_SLIDER:
				ppiVar4 = (int **)item->itemData;
				if (bVar9) {
					Front_Submenu_Slider_FUN_004117a0(submenu,(int)item,ppiVar4);
					if (ppiVar4[5] != NULL) {
						(*(code *)ppiVar4[5])(**ppiVar4);
					}
				}
				else {
					**ppiVar4 = **ppiVar4 + 1;
					ppiVar3 = (int **)*ppiVar4;
					piVar8 = ppiVar4[2];
					if (*ppiVar3 != piVar8 && (int)piVar8 <= (int)*ppiVar3) {
						*ppiVar3 = piVar8;
					}
					bVar10 = false;
					if (ppiVar4[5] != NULL) {
						(*(code *)ppiVar4[5])(**ppiVar4);
					}
				}
				break;
			case MENUITEM_REALSLIDER:
				ppfVar5 = (float **)item->itemData;
				**ppfVar5 = (float)ppfVar5[3] + **ppfVar5;
				pfVar2 = (float *)**ppfVar5;
				if ((ushort)((ushort)((float)pfVar2 < (float)ppfVar5[2]) << 8 |
										(ushort)((float)pfVar2 == (float)ppfVar5[2]) << 0xe) == 0) {
					**ppfVar5 = (float)ppfVar5[2];
				}
				bVar10 = bVar9;
				if (ppfVar5[6] != NULL) {
					(*(code *)ppfVar5[6])(**ppfVar5);
				}
				break;
			case MENUITEM_MISSIONS:
				piVar8 = (int *)item->itemData;
				iVar14 = Front_SubmenuItem_CollisionCheck_FUN_00411290(submenu,item,piVar8);
				if (bVar9) {
					if (iVar14 == -3) {
						if (piVar8[0x13] < 1) break;
						iVar14 = piVar8[0x13] + -1;
					}
					else {
						if (iVar14 != -2) {
							if (iVar14 != -1) {
								if (piVar8[0x16] != 0) {
									*(int *)piVar8[10] = iVar14;
									if ((code *)piVar8[0x15] != NULL) {
										(*(code *)piVar8[0x15])(param_1,iVar14);
									}
									if ((submenu == globals::g_MainMenuFull->menus[3]) ||
										 (submenu == *globals::g_SaveMenu->menus)) {
										globals::g_SaveMenu_INT_004a2f4c = iVar14;
										globals::g_SaveMenu_OutNumber = iVar14;
									}
									return (SubMenu *)piVar8[0x16];
								}
								*(int *)piVar8[10] = iVar14;
								if ((code *)piVar8[0x15] != NULL) {
									(*(code *)piVar8[0x15])(param_1,iVar14);
								}
								submenu->field_28 = 1;
								if ((submenu == globals::g_MainMenuFull->menus[3]) ||
									 (submenu == *globals::g_SaveMenu->menus)) {
									globals::g_SaveMenu_INT_004a2f4c = iVar14;
									globals::g_SaveMenu_OutNumber = iVar14;
								}
							}
							break;
						}
						if (piVar8[7] - piVar8[0xe] <= piVar8[0x13]) break;
						iVar14 = piVar8[0x13] + 1;
					}
					piVar8[0x13] = iVar14;
				}
			}
		}
	}
						// IsKeyPressed(KEY_CURSORLEFT) (203)
	if (((globs::INPUT.Key_Map[203] != false) &&
			(globs::INPUT.prevKey_Map[203] != globs::INPUT.Key_Map[203])) && (true)) {
		switch(item->itemType) {
		case MENUITEM_CYCLE:
			iVar14 = item->itemData;
			**(int **)(iVar14 + 0xc) = **(int **)(iVar14 + 0xc) + -1;
			if (**(int **)(iVar14 + 0xc) < 0) {
				**(int **)(iVar14 + 0xc) = *(int *)(iVar14 + 8) + -1;
			}
			break;
		case MENUITEM_TEXTINPUT:
			iVar14 = item->itemData;
			iVar12 = *(int *)(iVar14 + 8) + -1;
			*(int *)(iVar14 + 8) = iVar12;
			if (iVar12 < 0) {
				*(undefined4 *)(iVar14 + 8) = 0;
			}
			break;
		case MENUITEM_SLIDER:
			ppiVar4 = (int **)item->itemData;
			**ppiVar4 = **ppiVar4 + -1;
			if ((int)**ppiVar4 < (int)ppiVar4[1]) {
				**ppiVar4 = (int)ppiVar4[1];
			}
			if (ppiVar4[5] != NULL) {
				(*(code *)ppiVar4[5])(**ppiVar4);
			}
			break;
		case MENUITEM_REALSLIDER:
			ppfVar5 = (float **)item->itemData;
			**ppfVar5 = **ppfVar5 - (float)ppfVar5[3];
			if ((float)**ppfVar5 < (float)ppfVar5[1]) {
				**ppfVar5 = (float)ppfVar5[1];
			}
			if (ppfVar5[6] != NULL) {
				(*(code *)ppfVar5[6])(**ppfVar5);
			}
		}
	}
	if ((bVar9) && (!bVar10)) {
		MVar6 = item->itemType;
		if (MVar6 == MENUITEM_CYCLE) {
			piVar8 = *(int **)(item->itemData + 0xc);
			*piVar8 = (*piVar8 + 1) % *(int *)(item->itemData + 8);
		}
		else {
			if (MVar6 == MENUITEM_TRIGGER) {
				puVar7 = (undefined4 *)item->itemData;
				if ((code *)puVar7[2] != NULL) {
					(*(code *)puVar7[2])();
				}
				if (puVar7[1] != 0) {
					submenu->field_28 = 1;
					*(undefined4 *)*puVar7 = 1;
				}
			}
			else {
				if (MVar6 == MENUITEM_NEXT) {
					return (SubMenu *)item->itemData;
				}
			}
		}
	}
	if (item->itemType == MENUITEM_TEXTINPUT) {
		piVar8 = (int *)item->itemData;
		iVar14 = 0;
		do {
			if ((globs::INPUT.Key_Map[iVar14] != false) &&
				 (globs::INPUT.prevKey_Map[iVar14] != globs::INPUT.Key_Map[iVar14])) {
				if ((iVar14 == 0xe) && (iVar12 = piVar8[2], 0 < iVar12)) {
					if (iVar12 < piVar8[1]) {
						do {
							puVar1 = (undefined *)(*piVar8 + iVar12);
							iVar12 += 1;
							puVar1[-1] = *puVar1;
						} while (iVar12 < piVar8[1]);
					}
					piVar8[2] = piVar8[2] + -1;
					piVar8[1] = piVar8[1] + -1;
				}
				if (((piVar8[1] != piVar8[3]) && (piVar8[2] < piVar8[3] + -1)) &&
					 (globs::constant::c_keyCharMap[iVar14] != 0)) {
					iVar12 = piVar8[1] + -1;
					if (piVar8[2] <= iVar12) {
						do {
							puVar1 = (undefined *)(*piVar8 + iVar12);
							iVar12 += -1;
							puVar1[1] = *puVar1;
						} while (piVar8[2] <= iVar12);
					}
					*(undefined *)(*piVar8 + piVar8[2]) =
							 *(undefined *)(globs::constant::c_keyCharMap + iVar14);
					if ((globs::INPUT.Key_Map[42] != false) || (globs::INPUT.Key_Map[54] != false)) {
						*(char *)(*piVar8 + piVar8[2]) = *(char *)(*piVar8 + piVar8[2]) + -0x20;
					}
					piVar8[2] = piVar8[2] + 1;
					piVar8[1] = piVar8[1] + 1;
				}
			}
			iVar14 += 1;
		} while (iVar14 < 0x100);
	}
	return submenu;
}



int __cdecl lego::input::Input_GetKeyCharacter(int diKey)
{
	return globs::constant::c_keyCharMap[diKey];
}



void __cdecl FUN_00411e40(int param_1,uint param_2,uint param_3,int param_4,uint param_5)
{
	float fVar1;
	float fVar2;
	float fVar3;
	ulonglong uVar4;
	int iVar5;
	BOOL BVar6;
	longlong lVar7;
	Image *image;
	int iVar8;
	int iVar9;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Area2F local_10;
	
	local_18 = param_3;
	uStack20 = 0;
	local_10.x = 0.0;
	local_10.y = 0.0;
	local_10.height = 20.0;
	fVar1 = (float)(ulonglong)((uint)(param_4 * 100) / param_5);
	fVar2 = (float)(ulonglong)param_2;
	uVar4 = (ulonglong)param_3;
	fVar3 = (float)uVar4;
	local_20.x = fVar2;
	local_20.y = fVar3;
	local_10.width = fVar1;
	lego::image::Image_DisplayScaled(*(Image **)(param_1 + 0x1c),&local_10,&local_20,NULL);
	local_10.width = 100.0 - fVar1;
	local_20.x = fVar2 + fVar1;
	local_10.y = 0.0;
	local_10.height = 20.0;
	local_20.y = fVar3;
	local_10.x = fVar1;
	lego::image::Image_DisplayScaled(*(Image **)(param_1 + 0x18),&local_10,&local_20,NULL);
	if (*(Image **)(param_1 + 0x20) != NULL) {
		local_20.x = fVar2;
		local_20.y = fVar3;
		lego::image::Image_DisplayScaled(*(Image **)(param_1 + 0x20),NULL,&local_20,NULL);
	}
	if (*(Image **)(param_1 + 0x24) != NULL) {
		local_20.x = fVar2 - -100.0;
		local_20.y = fVar3;
		lego::image::Image_DisplayScaled(*(Image **)(param_1 + 0x24),NULL,&local_20,NULL);
	}
	iVar8 = *(int *)(param_1 + 0x2c);
	if ((iVar8 != 0) && (*(int *)(param_1 + 0x34) != 0)) {
		local_20.x = fVar2 - (float)(*(int *)(iVar8 + 4) + 4);
		iVar9 = *(int *)(iVar8 + 8);
		iVar8 = *(int *)(iVar8 + 4);
		local_20.y = fVar3;
		lVar7 = __ftol((float10)uVar4);
		iVar5 = (int)lVar7;
		lVar7 = __ftol((float10)local_20.x);
		BVar6 = lego::math::MathX_IsPointInsideRect
											(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)lVar7,iVar5,iVar8,iVar9);
		if (BVar6 == 0) {
			image = *(Image **)(param_1 + 0x2c);
		}
		else {
			image = *(Image **)(param_1 + 0x34);
		}
		lego::image::Image_DisplayScaled(image,NULL,&local_20,NULL);
	}
	iVar8 = *(int *)(param_1 + 0x28);
	if ((iVar8 != 0) && (*(int *)(param_1 + 0x30) != 0)) {
		local_20.x = ((float)*(int *)(*(int *)(param_1 + 0x24) + 4) + fVar2) - -104.0;
		iVar9 = *(int *)(iVar8 + 8);
		iVar8 = *(int *)(iVar8 + 4);
		local_20.y = fVar3;
		lVar7 = __ftol((float10)uVar4);
		iVar5 = (int)lVar7;
		lVar7 = __ftol((float10)local_20.x);
		BVar6 = lego::math::MathX_IsPointInsideRect
											(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)lVar7,iVar5,iVar8,iVar9);
		if (BVar6 != 0) {
			lego::image::Image_DisplayScaled(*(Image **)(param_1 + 0x30),NULL,&local_20,NULL);
			return;
		}
		lego::image::Image_DisplayScaled(*(Image **)(param_1 + 0x28),NULL,&local_20,NULL);
	}
	return;
}



int __cdecl lego::unk::Lego_CountLinkedStruct1C_At40(int param_1)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	for (iVar1 = *(int *)(param_1 + 0x40); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x18)) {
		iVar2 += 1;
	}
	return iVar2;
}



BOOL __cdecl lego::util::randomBool_1_In_400(void)
{
	int iVar1;
	
	iVar1 = std::rand();
	return (uint)(iVar1 % 400 == 0);
}



void __cdecl lego::front::Front_FUN_004120e0(int param_1)
{
	char **ppcVar1;
	uint uVar2;
	uint uVar3;
	BOOL BVar4;
	int iVar5;
	ulonglong uVar6;
	ulonglong uVar7;
	Area2F local_10;
	
	if (PTRImageFlic_0055806c == NULL) {
		ppcVar1 = *(char ***)(param_1 + 0x40);
		if (ppcVar1 != NULL) {
			if (*(int *)(param_1 + 0x9c) == 1) {
				BVar4 = util::randomBool_1_In_400();
				if (BVar4 == 0) {
					uVar2 = 0;
				}
				else {
					uVar2 = unk::Lego_CountLinkedStruct1C_At40(param_1);
				}
				if (uVar2 != 0) {
					uVar3 = std::rand();
					for (uVar3 %= uVar2; uVar3 != 0; uVar3 -= 1) {
						ppcVar1 = (char **)ppcVar1[6];
					}
					BVar4 = lego::image::Flic_Setup(*ppcVar1,&PTRImageFlic_0055806c,FLICDISK);
					if (BVar4 != 0) {
						snd::SFX_Sample_AddToQueue((SFXType)ppcVar1[5],SOUND_ONCE);
						DAT_00558068 = ppcVar1[3];
						DAT_00558064 = ppcVar1[4];
						TIMEUINT_00558070 = main::Main_GetTime();
						TIMEUINT_00558074 = TIMEUINT_00558070;
						return;
					}
				}
			}
			else {
				if (-1 < globals::g_SaveMenu_INDEX_004a2f50) {
					for (iVar5 = 4 - globals::g_SaveMenu_INDEX_004a2f50; iVar5 != 0; iVar5 += -1) {
						ppcVar1 = (char **)ppcVar1[6];
					}
					BVar4 = lego::image::Flic_Setup(*ppcVar1,&PTRImageFlic_0055806c,FLICDISK);
					if (BVar4 != 0) {
						snd::SFX_Sample_AddToQueue((SFXType)ppcVar1[5],SOUND_ONCE);
						DAT_00558068 = ppcVar1[3];
						DAT_00558064 = ppcVar1[4];
						TIMEUINT_00558070 = main::Main_GetTime();
						TIMEUINT_00558074 = TIMEUINT_00558070;
					}
					globals::g_SaveMenu_INT_004a2f4c = -1;
					globals::g_SaveMenu_INDEX_004a2f50 = -1;
					BOOL_004dc8c0 = 1;
					return;
				}
				if (-1 < globals::g_SaveMenu_INT_004a2f4c) {
					globals::g_SaveMenu_INDEX_004a2f50 = globals::g_SaveMenu_INT_004a2f4c;
					BOOL_004dc8c8 = 0;
				}
			}
		}
	}
	else {
						// Flic_GetWidth
		uVar2 = res::AnimClone_IsLws__Flic_GetWidth((AnimClone *)PTRImageFlic_0055806c);
		uVar3 = lego::image::Flic_GetHeight(PTRImageFlic_0055806c);
		local_10.x = (float)(int)DAT_00558068;
		local_10.y = (float)(int)DAT_00558064;
		local_10.width = (float)(ulonglong)uVar2;
		local_10.height = (float)(ulonglong)uVar3;
		uVar3 = main::Main_GetTime();
		uVar2 = TIMEUINT_00558070;
		uVar6 = __ftol((float10)(ulonglong)(TIMEUINT_00558074 - TIMEUINT_00558070) * (float10)0.025);
		uVar7 = __ftol((float10)(ulonglong)(uVar3 - uVar2) * (float10)0.025);
		if ((BOOL_004dc8c0 != 0) &&
			 (uVar7 &= 0xffffffff,
			 (int)(uint)(PTRImageFlic_0055806c->fsHeader).frames <= PTRImageFlic_0055806c->currentframe))
		{
			uVar7 = uVar6 & 0xffffffff;
			globals::g_SaveMenu_INDEX_004a2f50 = -2;
		}
		TIMEUINT_00558074 = uVar3;
		BVar4 = lego::image::Flic_Animate
											(PTRImageFlic_0055806c,&local_10,(uint)((int)uVar7 != (int)uVar6),0);
		if (BVar4 == 0) {
			lego::image::Flic_Close(PTRImageFlic_0055806c);
			std::free(PTRImageFlic_0055806c);
			PTRImageFlic_0055806c = NULL;
			TIMEUINT_00558070 = 0;
			TIMEUINT_00558074 = 0;
			snd::Sound3D_Stream_Stop(0);
		}
		if ((BOOL_004dc8c0 != 0) && (globs::INPUT.mslb != 0)) {
			globals::g_SaveMenu_INDEX_004a2f50 = -2;
			BOOL_004dc8c0 = 0;
			return;
		}
	}
	return;
}



void __cdecl
lego::front::Front_UnkDraw_FUN_00412380
					(int param_1,int param_2,undefined4 *param_3,int *param_4,int param_5,int param_6)
{
	Image *image;
	byte *pbVar1;
	int iVar2;
	Point2F local_8;
	
	pbVar1 = (byte *)(param_5 * 0x20 + *param_4);
	if ((*pbVar1 & 1) != 0) {
		lego::image::Font_PrintF((Font *)param_3,param_1,param_2,*(char **)(pbVar1 + 4));
		return;
	}
	local_8.y = (float)param_2;
	local_8.x = (float)param_1;
	image = *(Image **)(*param_4 + 8 + (param_6 + param_5 * 8) * 4);
	if ((((image != NULL) && (param_1 < 0x280)) &&
			(iVar2 = -image->width,
			param_1 != iVar2 && SBORROW4(param_1,iVar2) == (int)(param_1 + image->width) < 0)) &&
		 ((iVar2 = -image->height,
			param_2 != iVar2 && SBORROW4(param_2,iVar2) == (int)(param_2 + image->height) < 0 &&
			(param_2 < 0x1e0)))) {
		lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
	}
	return;
}



void __cdecl
lego::front::SaveMenu_UnkCfgLoad_FUN_00412420
					(int param_1,int param_2,undefined4 param_3,int param_4)
{
	Image *image;
	char *pcVar1;
	int iVar2;
	char local_34 [8];
	Size2F local_2c;
	Point2F local_24;
	int local_1c;
	undefined4 uStack24;
	char *local_14;
	char *local_10;
	
	if (((SubMenu *)param_1 == globals::g_MainMenuFull->menus[3]) ||
		 ((SubMenu *)param_1 == *globals::g_SaveMenu->menus)) {
		image = globals::g_SaveSlotImages_TABLE[param_2];
		if (image != NULL) {
			std::sprintf(local_34,"pos%d",param_2 + 1);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage",local_34,0);
			pcVar1 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar1);
			util::Util_Tokenise(pcVar1,&local_14,"|");
			iVar2 = std::atoi(local_14);
			local_24.x = (float)iVar2;
			iVar2 = std::atoi(local_10);
			local_24.y = (float)iVar2;
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage","Width",0);
			pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
			if (pcVar1 == NULL) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage","Width",0);
				pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
			}
			iVar2 = std::atoi(pcVar1);
			local_2c.width = (float)iVar2;
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage","Height",0);
			pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
			if (pcVar1 == NULL) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage","Height",0);
				pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
			}
			iVar2 = std::atoi(pcVar1);
			local_2c.height = (float)iVar2;
			if (param_4 != 0) {
				local_1c = globals::g_Menu_SaveImage_BigSize.height;
				uStack24 = 0;
				local_24.x = local_24.x -
										 ((float)(ulonglong)(uint)globals::g_Menu_SaveImage_BigSize.width -
										 local_2c.width) * 0.25;
				local_24.y = local_24.y -
										 ((float)(ulonglong)(uint)globals::g_Menu_SaveImage_BigSize.height -
										 local_2c.height) * 0.25;
				local_2c.width =
						 local_2c.width -
						 ((float)(ulonglong)(uint)globals::g_Menu_SaveImage_BigSize.width - local_2c.width) *
						 -0.5;
				local_2c.height =
						 local_2c.height -
						 ((float)(ulonglong)(uint)globals::g_Menu_SaveImage_BigSize.height - local_2c.height) *
						 -0.5;
			}
			lego::image::Image_DisplayScaled(image,NULL,&local_24,&local_2c);
		}
	}
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Front_FUN_00412680(SubMenu **pSubmenu,int *param_2,int *param_3)
{
	int *piVar1;
	SubMenu *pSVar2;
	int iVar3;
	char *pcVar4;
	int iVar5;
	int iVar6;
	longlong lVar7;
	
	pSVar2 = *pSubmenu;
	if ((pSVar2 != globals::g_MainMenuFull->menus[3]) && (pSVar2 != *globals::g_SaveMenu->menus))
	goto LAB_0041287c;
	if ((pSVar2 == *globals::g_SaveMenu->menus) && (-1 < globals::g_SaveMenu_INT_004a2f4c)) {
		if (globals::g_SaveSlotPtrs_TABLE[globals::g_SaveMenu_INT_004a2f4c] == NULL) {
			BOOL_00558508 = 0;
			(*pSubmenu)->field_28 = 1;
		}
		else {
			BOOL_004dc8bc = 1;
		}
	}
	TextWindow_Clear(globals::g_MenuSaveTextWindow->textWindow);
	TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,"\n");
	if (globals::g_SaveMenu_INDEX_004a2f50 == -2) {
		if (BOOL_004dc8c8 != 0) {
			*param_2 = BOOL_004dc8c8;
		}
		BOOL_004dc8c8 = 0;
		globals::g_SaveMenu_INDEX_004a2f48 = -1;
		globals::g_SaveMenu_INDEX_004a2f54 = -1;
LAB_00412766:
		*param_3 = 0;
		globals::g_SaveMenu_INT_004a2f4c = -1;
		pcVar4 = globals::g_MenuSaveTextWindow->LoadText;
		if (*pSubmenu != globals::g_MainMenuFull->menus[3]) {
			pcVar4 = globals::g_MenuSaveTextWindow->SaveText;
		}
		TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,pcVar4);
	}
	else {
		if (globals::g_SaveMenu_INDEX_004a2f50 == -1) goto LAB_00412766;
		BOOL_004dc8c8 = *param_2;
		*param_2 = *param_3;
		globals::g_SaveMenu_INDEX_004a2f54 = globals::g_SaveMenu_INDEX_004a2f50;
	}
	if (globals::g_SaveMenu_INDEX_004a2f54 < 0) {
		if (-1 < globals::g_SaveMenu_INDEX_004a2f48) {
			param_2 = (int *)(float)ZEXT48(globals::g_SaveSlotPtrs_TABLE
																		 [globals::g_SaveMenu_INDEX_004a2f48]);
			if ((ushort)((ushort)((float)param_2 < 100.0) << 8 | (ushort)((float)param_2 == 100.0) << 0xe)
					== 0) {
				param_2 = (int *)&DAT_42c80000;
			}
			TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,"\n");
			lVar7 = __ftol((float10)(float)param_2);
			TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,
												globals::g_MenuSaveTextWindow->SlotText,(int)lVar7);
		}
	}
	else {
		TextWindow_Clear(globals::g_MenuSaveTextWindow->textWindow);
		if (*pSubmenu == globals::g_MainMenuFull->menus[3]) {
			TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,
												globals::g_MenuSaveTextWindow->LoadSelText,
												globals::g_SaveMenu_INDEX_004a2f54 + 1,0);
		}
	}
	if (globals::g_MenuSaveTextWindow->textWindow != NULL) {
		TextWindow_Update(globals::g_MenuSaveTextWindow->textWindow,0,1.0,NULL);
	}
LAB_0041287c:
	pSVar2 = *pSubmenu;
	if (((pSVar2 == globals::g_MainMenuFull->menus[3]) && (true)) &&
		 (iVar6 = 0, 0 < pSVar2->ItemCount)) {
		do {
			pcVar4 = (&pSVar2->Items->banner)[iVar6];
			if (*(int *)(pcVar4 + 0x14) == 6) {
				piVar1 = *(int **)(pcVar4 + 0x10);
				iVar3 = 0;
				if (0 < piVar1[7]) {
					iVar5 = 0;
					do {
						iVar3 += 1;
						std::sprintf(*(char **)(*piVar1 + 4 + iVar5),"%s %d",globals::g_Menu_LoadGame_text,iVar3
												);
						iVar5 += 0x20;
					} while (iVar3 < piVar1[7]);
				}
			}
			pSVar2 = *pSubmenu;
			iVar6 += 1;
		} while (iVar6 < pSVar2->ItemCount);
	}
	return;
}



void __cdecl lego::front::Struct728_FUN_00412900(SubMenu **pSubmenu)
{
	MenuTextWindow *pMVar1;
	Size2F size;
	Point2F point;
	
	pMVar1 = globals::g_MenuSaveLevelWindow;
	if ((*pSubmenu == globals::g_MainMenuFull->menus[1]) ||
		 (*pSubmenu == globals::g_MainMenuFull->menus[2])) {
		if (globals::g_MenuSaveLevelWindow->PanelImage != NULL) {
			point.x = (globals::g_MenuSaveLevelWindow->PanelArea).x;
			point.y = (globals::g_MenuSaveLevelWindow->PanelArea).y;
			size.width = (globals::g_MenuSaveLevelWindow->PanelArea).width;
			size.height = (globals::g_MenuSaveLevelWindow->PanelArea).height;
			lego::image::Image_DisplayScaled(globals::g_MenuSaveLevelWindow->PanelImage,NULL,&point,&size)
			;
		}
		if (pMVar1->textWindow != NULL) {
			TextWindow_Update(pMVar1->textWindow,0,1.0,NULL);
			TextWindow_Clear(pMVar1->textWindow);
			TextWindow_PrintF(pMVar1->textWindow,"\n");
			if ((*pSubmenu == globals::g_MainMenuFull->menus[1]) && (pMVar1->LevelText != NULL)) {
				TextWindow_PrintF(pMVar1->textWindow,pMVar1->LevelText);
				TextWindow_PrintF(pMVar1->textWindow,"\n");
			}
			if ((*pSubmenu == globals::g_MainMenuFull->menus[2]) && (pMVar1->TutorialText != NULL)) {
				TextWindow_PrintF(pMVar1->textWindow,pMVar1->TutorialText);
				TextWindow_PrintF(pMVar1->textWindow,"\n");
			}
			BOOL_004dc8c4 = TRUE;
		}
	}
	return;
}



void __cdecl lego::front::SaveMenu_Draw_FUN_00412a20(int param_1,BOOL param_2)
{
	Image *pIVar1;
	Point2F local_18;
	Area2F local_10;
	
	if (param_2 == 0) {
		pIVar1 = *(Image **)(param_1 + 0x14);
		if (pIVar1 != NULL) {
			if ((*(byte *)(param_1 + 0x34) & 1) != 0) {
				lego::image::Image_DisplayScaled(pIVar1,NULL,(Point2F *)(param_1 + 0x38),NULL);
				return;
			}
			local_10.x = -(float)(int)Point2F_005584dc.x;
			local_10.y = -(float)(int)Point2F_005584dc.y;
			local_10.width = 640.0;
			local_10.height = 480.0;
			local_18.x = 0.0;
			local_18.y = 0.0;
			lego::image::Image_DisplayScaled(pIVar1,&local_10,&local_18,NULL);
		}
	}
	else {
		pIVar1 = *(Image **)(param_1 + 0x10);
		if (pIVar1 != NULL) {
			if ((*(byte *)(param_1 + 0x34) & 1) != 0) {
				lego::image::Image_DisplayScaled(pIVar1,NULL,(Point2F *)(param_1 + 0x38),NULL);
				return;
			}
			local_10.x = -(float)(int)Point2F_005584dc.x;
			local_10.y = -(float)(int)Point2F_005584dc.y;
			local_10.width = 640.0;
			local_10.height = 480.0;
			local_18.x = 0.0;
			local_18.y = 0.0;
			lego::image::Image_DisplayScaled(pIVar1,&local_10,&local_18,NULL);
			return;
		}
	}
	return;
}



SubMenu * __cdecl
lego::front::SaveMenu_FUN_00412b30(undefined4 param_1,SubMenu *submenu,BOOL *out_bool)
{
	Font **ppFVar1;
	int iVar2;
	char **ppcVar3;
	char *pcVar4;
	char **ppcVar5;
	MenuItem *item;
	int **ppiVar6;
	float **ppfVar7;
	int *piVar8;
	ulonglong uVar9;
	float fVar10;
	Viewport *view;
	Container *pCVar11;
	char *pcVar12;
	uint uVar13;
	BOOL BVar14;
	char *pcVar15;
	int iVar16;
	Font *pFVar17;
	SubMenu *pSVar18;
	uint *puVar19;
	int iVar20;
	int iVar21;
	int iVar22;
	char *pcVar23;
	int local_864;
	Point2F local_850;
	char local_845;
	SubMenu *local_844;
	Container *local_840;
	Viewport *local_83c;
	undefined4 uStack2104;
	Point2F local_834;
	SubMenu *local_82c;
	PointerType local_828;
	Vector3F local_824;
	Vector3F local_818;
	Vector3F local_80c;
	char buff [2048];
	
	save::Save_GetCurrentSaveData();
	local_828 = Pointer_GetCurrentType();
	view = globs::legoGlobs.viewMain;
	local_83c = globs::legoGlobs.viewMain;
	local_840 = lego::view::Viewport_GetCamera(globs::legoGlobs.viewMain);
	globals::g_SaveMenu_INT_004a2f4c = -1;
	submenu->field_24 = 0xffffffff;
	if (out_bool != NULL) {
		*out_bool = 0;
	}
	Pointer_SetCurrent_IfTimerFinished(POINTER_STANDARD);
	local_844 = submenu;
	local_82c = submenu;
	if ((BOOL_004dc8bc == 0) && (BOOL_004dc8c8 == 0)) {
		local_844 = Front_Submenu_FUN_00411930(param_1,submenu);
	}
	if (((submenu == *globals::g_SaveMenu->menus) && (-1 < globals::g_SaveMenu_INT_004a2f4c)) &&
		 (globals::g_SaveMenu_INT_004a2f58 < 0)) {
		submenu->field_28 = 0;
		local_844->field_28 = 0;
	}
	if (-1 < globals::g_SaveMenu_INDEX_004a2f50) {
		local_844 = local_82c;
	}
	iVar22 = (submenu->Position).x;
	iVar2 = (submenu->Position).y;
	if ((globals::g_MenuWipeResource != NULL) && (((byte)FLAGS_005584f0 & 1) != 0)) {
		lego::view::Viewport_Clear(view,TRUE);
		res::Container_SetParent(globals::g_MenuWipeResource,globs::legoGlobs.contRoot);
		pCVar11 = lego::view::Viewport_GetCamera(view);
		local_840 = pCVar11;
		res::Container_GetPosition(pCVar11,NULL,&local_80c);
		res::Container_GetOrientation(pCVar11,NULL,&local_818,&local_824);
		res::Container_SetPosition(pCVar11,NULL,0.0,0.0,5.0);
		res::Container_SetOrientation(pCVar11,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_SetAnimationTime(globals::g_MenuWipeResource,FLOAT_005584f4);
	}
	SaveMenu_Draw_FUN_00412a20((int)submenu,TRUE);
	if (submenu != *globals::g_SaveMenu->menus) {
		Front_FUN_004120e0((int)submenu);
	}
	Front_FUN_00412680(&submenu,(int *)&local_844,(int *)&local_82c);
	if (submenu->DisplayTitle != 0) {
		pcVar12 = util::replaceTextSpaces(submenu->string_4);
		uVar13 = lego::image::Font_GetStringWidth(submenu->MenuFont,pcVar12);
		iVar21 = (submenu->AnchoredPosition).y;
		iVar20 = (int)globs::mainGlobs.appWidth / 2;
		pcVar12 = util::replaceTextSpaces(submenu->string_4);
		lego::image::Font_PrintF(submenu->MenuFont,iVar20 - (uVar13 >> 1),iVar21 + iVar2,pcVar12);
	}
	globals::g_SaveMenu_INDEX_004a2f48 = -1;
	local_834.x = 0.0;
	if (0 < submenu->ItemCount) {
		do {
			fVar10 = local_834.x;
			if (((float)submenu->field_24 != local_834.x) || (BOOL_004dc8bc != 0)) {
LAB_004131e8:
				ppcVar3 = (char **)(&submenu->Items->banner)[(int)fVar10];
				pcVar12 = ppcVar3[6];
				pcVar23 = ppcVar3[7];
				pcVar4 = ppcVar3[8];
				ppFVar1 = (Font **)(ppcVar3 + 3);
				if (ppcVar3[3] != NULL) {
					pcVar15 = util::replaceTextSpaces(*ppcVar3);
					lego::image::Font_PrintF
										(*(Font **)((&submenu->Items->banner)[(int)fVar10] + 0xc),
										 (int)(pcVar4 + (int)pcVar12 + iVar22),(int)(pcVar23 + iVar2),"%s",pcVar15);
				}
				pcVar15 = (&submenu->Items->banner)[(int)fVar10];
				if (true) {
					switch(*(undefined4 *)(pcVar15 + 0x14)) {
					case 0:
						piVar8 = *(int **)(pcVar15 + 0x10);
						if (*ppFVar1 != NULL) {
							pcVar15 = util::replaceTextSpaces(*(char **)(*piVar8 + *(int *)piVar8[3] * 4));
							pcVar23 = pcVar23 + iVar2 + piVar8[5];
							pFVar17 = *ppFVar1;
							pcVar12 = pcVar4 + piVar8[4] + (int)pcVar12 + iVar22;
							goto LAB_004134b2;
						}
						break;
					case 2:
						ppcVar3 = *(char ***)(pcVar15 + 0x10);
						if (*ppFVar1 != NULL) {
							pcVar15 = util::replaceTextSpaces(*ppcVar3);
							lego::image::Font_PrintF
												(*ppFVar1,(int)(ppcVar3[4] + (int)pcVar4 + (int)pcVar12 + iVar22),
												 (int)(ppcVar3[5] + (int)pcVar23 + iVar2),"%s",pcVar15);
						}
						break;
					case 3:
						ppiVar6 = *(int ***)(pcVar15 + 0x10);
						FUN_00411e40((int)ppiVar6,(uint)((char *)((int)ppiVar6[3] + (int)pcVar12) + iVar22),
												 (uint)((char *)((int)ppiVar6[4] + (int)pcVar23) + iVar2),
												 **ppiVar6 - (int)ppiVar6[1],(int)ppiVar6[2] - (int)ppiVar6[1]);
						break;
					case 4:
						ppfVar7 = *(float ***)(pcVar15 + 0x10);
						if (*ppFVar1 != NULL) {
							lego::image::Font_PrintF
												(*ppFVar1,(int)((char *)((int)ppfVar7[4] + (int)pcVar4) + (int)pcVar12 +
																			 iVar22),
												 (int)((char *)((int)ppfVar7[5] + (int)pcVar23) + iVar2),"%.2f",
												 (double)**ppfVar7);
						}
						break;
					case 6:
						piVar8 = *(int **)(pcVar15 + 0x10);
						iVar21 = 0;
						if (0 < piVar8[0xe]) {
							do {
								local_850.x = (float)(iVar21 + piVar8[0x13]);
								if (piVar8[7] <= (int)local_850.x) break;
								iVar20 = -(*(int *)(piVar8[1] + (int)local_850.x * 4) / 2);
								puVar19 = (uint *)((int)local_850.x * 0x20 + *piVar8);
								uVar13 = ~*puVar19 >> 1 & 2;
								if (submenu->AutoCenter == 0) {
									iVar20 = 0;
								}
								if (uVar13 == 0) {
									uVar13 = 1;
								}
								Front_UnkDraw_FUN_00412380
													((int)(pcVar12 +
																(int)Point2F_005584dc.x + iVar22 + piVar8[0xb] + puVar19[5] + iVar20
																),(int)(pcVar23 +
																			 (int)Point2F_005584dc.y +
																			 iVar2 + piVar8[0xd] * iVar21 + piVar8[0xc] + puVar19[6]),
													 &(*ppFVar1)->image,piVar8,(int)local_850.x,uVar13);
								SaveMenu_UnkCfgLoad_FUN_00412420((int)submenu,iVar21 + piVar8[0x13],piVar8,0);
								iVar21 += 1;
							} while (iVar21 < piVar8[0xe]);
						}
						if ((piVar8[0x13] < piVar8[7] - piVar8[0xe]) && (*ppFVar1 != NULL)) {
							lego::image::Font_PrintF
												(*ppFVar1,piVar8[0xf] + iVar22,piVar8[0x10] + iVar2,(char *)piVar8[8]);
						}
						if ((0 < piVar8[0x13]) && (pFVar17 = *ppFVar1, pFVar17 != NULL)) {
							pcVar15 = (char *)piVar8[9];
							pcVar23 = (char *)piVar8[0x12];
							pcVar12 = (char *)piVar8[0x11];
							goto LAB_004134b1;
						}
					}
				}
				goto switchD_00413263_caseD_1;
			}
			BVar14 = Front_SubmenuItemCheckHasTutorialFlags
												 ((MenuItem *)(&submenu->Items->banner)[(int)local_834.x]);
			if (BVar14 != 0) goto LAB_004131e8;
			ppcVar3 = (char **)(&submenu->Items->banner)[(int)fVar10];
			pcVar23 = ppcVar3[7];
			pcVar12 = ppcVar3[6];
			pcVar4 = ppcVar3[9];
			local_850.x = (float)pcVar12;
			if (ppcVar3[2] != NULL) {
				pcVar15 = util::replaceTextSpaces(*ppcVar3);
				lego::image::Font_PrintF
									((Font *)ppcVar3[2],(int)(pcVar4 + (int)pcVar12 + iVar22),(int)(pcVar23 + iVar2),
									 "%s",pcVar15);
			}
			pcVar15 = (&submenu->Items->banner)[submenu->field_24];
			if (false) goto switchD_00413263_caseD_1;
			switch(*(undefined4 *)(pcVar15 + 0x14)) {
			case 0:
				piVar8 = *(int **)(pcVar15 + 0x10);
				if (ppcVar3[2] == NULL) break;
				pcVar15 = util::replaceTextSpaces(*(char **)(*piVar8 + *(int *)piVar8[3] * 4));
				pcVar23 = pcVar23 + piVar8[5];
				pFVar17 = (Font *)ppcVar3[2];
				pcVar12 = pcVar4 + piVar8[4] + (int)local_850.x;
LAB_004134b1:
				pcVar23 = pcVar23 + iVar2;
				pcVar12 = pcVar12 + iVar22;
				goto LAB_004134b2;
			case 2:
				ppcVar5 = *(char ***)(pcVar15 + 0x10);
				local_845 = (*ppcVar5)[(int)ppcVar5[2]];
				COUNT_004dc8dc += 1;
				if ((COUNT_004dc8dc != 0) &&
					 (uVar13 = COUNT_004dc8dc / 2 >> 0x1f,
					 ((COUNT_004dc8dc / 2 ^ uVar13) - uVar13 & 1 ^ uVar13) != uVar13)) {
					(*ppcVar5)[(int)ppcVar5[2]] = '_';
				}
				if (ppcVar3[2] != NULL) {
					pcVar12 = util::replaceTextSpaces(*ppcVar5);
					lego::image::Font_PrintF
										((Font *)ppcVar3[2],(int)(ppcVar5[4] + (int)pcVar4 + (int)local_850.x + iVar22),
										 (int)(ppcVar5[5] + (int)pcVar23 + iVar2),"%s",pcVar12);
				}
				if ((COUNT_004dc8dc != 0) &&
					 (uVar13 = COUNT_004dc8dc / 2 >> 0x1f,
					 ((COUNT_004dc8dc / 2 ^ uVar13) - uVar13 & 1 ^ uVar13) != uVar13)) {
					(*ppcVar5)[(int)ppcVar5[2]] = local_845;
				}
				break;
			case 3:
				ppiVar6 = *(int ***)(pcVar15 + 0x10);
				FUN_00411e40((int)ppiVar6,(uint)((char *)((int)ppiVar6[3] + (int)pcVar12) + iVar22),
										 (uint)((char *)((int)ppiVar6[4] + (int)pcVar23) + iVar2),
										 **ppiVar6 - (int)ppiVar6[1],(int)ppiVar6[2] - (int)ppiVar6[1]);
				break;
			case 4:
				ppfVar7 = *(float ***)(pcVar15 + 0x10);
				if ((Font *)ppcVar3[2] != NULL) {
					lego::image::Font_PrintF
										((Font *)ppcVar3[2],
										 (int)((char *)((int)ppfVar7[4] + (int)pcVar4) + (int)pcVar12 + iVar22),
										 (int)((char *)((int)ppfVar7[5] + (int)pcVar23) + iVar2),"%.2f",
										 (double)**ppfVar7);
				}
				break;
			case 6:
				item = (MenuItem *)(&submenu->Items->banner)[(int)fVar10];
				piVar8 = (int *)item->itemData;
				iVar21 = Front_SubmenuItem_CollisionCheck_FUN_00411290(submenu,item,piVar8);
				local_864 = 0;
				globals::g_SaveMenu_INDEX_004a2f48 = iVar21;
				if (0 < piVar8[0xe]) {
					do {
						iVar20 = piVar8[0x13] + local_864;
						if (piVar8[7] <= iVar20) break;
						puVar19 = (uint *)(iVar20 * 0x20 + *piVar8);
						iVar16 = -(*(int *)(piVar8[1] + iVar20 * 4) / 2);
						uVar13 = ~*puVar19 >> 1 & 2;
						if (submenu->AutoCenter == 0) {
							iVar16 = 0;
						}
						if (iVar21 == iVar20) {
							Front_UnkDraw_FUN_00412380
												((int)((int)local_850.x +
															(int)Point2F_005584dc.x + iVar22 + piVar8[0xb] + puVar19[5] + iVar16),
												 (int)(pcVar23 +
															(int)Point2F_005584dc.y +
															iVar2 + piVar8[0xd] * local_864 + piVar8[0xc] + puVar19[6]),
												 (undefined4 *)ppcVar3[2],piVar8,iVar20,uVar13);
							if ((code *)piVar8[0x15] != NULL) {
								(*(code *)piVar8[0x15])();
							}
							iVar20 = 1;
						}
						else {
							if (uVar13 == 0) {
								uVar13 = 1;
							}
							Front_UnkDraw_FUN_00412380
												((int)((int)local_850.x +
															(int)Point2F_005584dc.x + iVar22 + piVar8[0xb] + puVar19[5] + iVar16),
												 (int)(pcVar23 +
															(int)Point2F_005584dc.y +
															iVar2 + piVar8[0xd] * local_864 + piVar8[0xc] + puVar19[6]),
												 (undefined4 *)ppcVar3[3],piVar8,iVar20,uVar13);
							iVar20 = 0;
						}
						SaveMenu_UnkCfgLoad_FUN_00412420((int)submenu,local_864 + piVar8[0x13],piVar8,iVar20);
						local_864 += 1;
					} while (local_864 < piVar8[0xe]);
				}
				if ((iVar21 == -2) && (piVar8[0x13] < piVar8[7] - piVar8[0xe])) {
					pFVar17 = (Font *)ppcVar3[2];
joined_r0x00413184:
					if (pFVar17 != NULL) {
						lego::image::Font_PrintF
											(pFVar17,piVar8[0xf] + iVar22,piVar8[0x10] + iVar2,(char *)piVar8[8]);
					}
				}
				else {
					if (piVar8[0x13] < piVar8[7] - piVar8[0xe]) {
						pFVar17 = (Font *)ppcVar3[3];
						goto joined_r0x00413184;
					}
				}
				if (iVar21 != -3) {
					if (0 < piVar8[0x13]) {
						pFVar17 = (Font *)ppcVar3[3];
						goto LAB_004131c3;
					}
					break;
				}
				if (piVar8[0x13] < 1) break;
				pFVar17 = (Font *)ppcVar3[2];
LAB_004131c3:
				if (pFVar17 == NULL) break;
				pcVar15 = (char *)piVar8[9];
				pcVar23 = (char *)(piVar8[0x12] + iVar2);
				pcVar12 = (char *)(piVar8[0x11] + iVar22);
LAB_004134b2:
				lego::image::Font_PrintF(pFVar17,(int)pcVar12,(int)pcVar23,pcVar15);
			}
switchD_00413263_caseD_1:
			local_834.x = (float)((int)local_834.x + 1);
		} while ((int)local_834.x < submenu->ItemCount);
	}
	Struct728_FUN_00412900(&submenu);
	iVar22 = 0;
	pSVar18 = submenu;
	if (0 < submenu->ItemCount) {
		do {
			pcVar12 = (&pSVar18->Items->banner)[iVar22];
			if (*(int *)(pcVar12 + 0x28) != 0) {
				if (pSVar18->field_24 == iVar22) {
					if (*(Image **)(pcVar12 + 0x30) != NULL) {
						local_834.x = (float)(*(int *)(pcVar12 + 0x18) + (pSVar18->Position).x);
						local_834.y = (float)(*(int *)(pcVar12 + 0x1c) + (pSVar18->Position).y);
						lego::image::Image_DisplayScaled(*(Image **)(pcVar12 + 0x30),NULL,&local_834,NULL);
					}
					ToolTip_AddFlag4(*(ToolTipType *)(pcVar12 + 0x34));
					pSVar18 = submenu;
				}
				else {
					if (*(Image **)(pcVar12 + 0x2c) != NULL) {
						local_850.x = (float)(*(int *)(pcVar12 + 0x18) + (pSVar18->Position).x);
						local_850.y = (float)(*(int *)(pcVar12 + 0x1c) + (pSVar18->Position).y);
						lego::image::Image_DisplayScaled(*(Image **)(pcVar12 + 0x2c),NULL,&local_850,NULL);
						pSVar18 = submenu;
					}
				}
			}
			iVar22 += 1;
		} while (iVar22 < pSVar18->ItemCount);
	}
	if (((((globs::mainGlobs.flags & CMD_SHOWVERSION) != CMD_NONE) && (FONT_00558078 != NULL)) &&
			(globals::g_Main_Version != NULL)) && (globs::mainGlobs.programmerLevel == PROGRAMMER_OFF)) {
		lego::image::Font_PrintF(FONT_00558078,0x221,0x1c2,globals::g_Main_Version);
	}
	Missions_PrintF_LevelName(NULL,0,0,NULL);
	if ((submenu == *globals::g_SaveMenu->menus) && (BOOL_004dc8bc != 0)) {
		std::sprintf(buff,globals::g_Overwrite_Text);
		globals::g_SaveMenu_INT_004a2f58 =
				 SaveMenu_ConfirmMessage_FUN_004354f0
									 (globals::g_Overwrite_Title,buff,globals::g_Overwrite_Ok,
										globals::g_Overwrite_Cancel);
		if (globals::g_SaveMenu_INT_004a2f58 == 0) {
			BOOL_00558508 = 1;
			submenu->field_28 = 1;
			BOOL_004dc8bc = 0;
			globals::g_SaveMenu_OutNumber = -1;
		}
		else {
			if (globals::g_SaveMenu_INT_004a2f58 == 1) {
				BOOL_00558508 = 0;
				submenu->field_28 = 1;
				BOOL_004dc8bc = 0;
			}
		}
	}
	if ((globals::g_MenuWipeResource != NULL) && (((byte)FLAGS_005584f0 & 1) != 0)) {
		res::Container_Hide(PTRContLight_005584fc,0);
		lego::view::Viewport_Render(local_83c,globs::legoGlobs.contRoot,0.0);
		res::Container_Hide(PTRContLight_005584fc,1);
		pCVar11 = local_840;
		res::Container_SetPosition(local_840,NULL,local_80c.x,local_80c.y,local_80c.z);
		res::Container_SetOrientation
							(pCVar11,NULL,local_818.x,local_818.y,local_818.z,local_824.x,local_824.y,local_824.z)
		;
		res::Container_SetParent(globals::g_MenuWipeResource,NULL);
		local_83c = (Viewport *)res::Container_GetAnimationFrames(globals::g_MenuWipeResource);
		uStack2104 = 0;
		local_840 = (Container *)(float)ZEXT48(local_83c);
		local_83c = (Viewport *)main::Main_GetTime();
		uStack2104 = 0;
		uVar9 = ZEXT48(local_83c);
		fVar10 = ((float)uVar9 - FLOAT_005584f8) * 0.001 * 25.0;
		local_850.x = fVar10 + fVar10;
		if ((ushort)((ushort)(local_850.x < 3.0) << 8 | (ushort)(local_850.x == 3.0) << 0xe) == 0) {
			local_850.x = 3.0;
		}
		fVar10 = (float)local_840 * 0.5;
		if (((ushort)((ushort)(FLOAT_005584f4 < fVar10) << 8 | (ushort)(FLOAT_005584f4 == fVar10) << 0xe
								 ) != 0) && (fVar10 <= local_850.x + FLOAT_005584f4)) {
			if (out_bool != NULL) {
				*out_bool = 1;
			}
			globals::g_SaveMenu_INDEX_004a2f50 = -1;
			globals::g_SaveMenu_INT_004a2f4c = -1;
			BOOL_004dc8c8 = 0;
			BOOL_004dc8c0 = 0;
			if (PTRImageFlic_0055806c != NULL) {
				TIMEUINT_00558070 = 0;
				TIMEUINT_00558074 = 0;
			}
		}
		if ((ushort)((ushort)(FLOAT_005584f4 < (float)local_840) << 8 |
								(ushort)(FLOAT_005584f4 == (float)local_840) << 0xe) == 0) {
			Front_UnsetFlag3_005584f0();
		}
		FLOAT_005584f4 = local_850.x + FLOAT_005584f4;
		FLOAT_005584f8 = (float)uVar9;
	}
	Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
	Pointer_SetCurrent_IfTimerFinished(local_828);
	return local_844;
}



void __cdecl lego::front::Menu_Submenu_FUN_004138a0(SubMenu *submenu)
{
	uint uVar1;
	float fVar2;
	float10 fVar3;
	longlong lVar4;
	
	if ((submenu->MenuImage == NULL) || ((*(byte *)&submenu->uint_34 & 2) == 0)) {
		Point2F_005584dc.x = 0.0;
		Point2F_005584dc.y = 0.0;
	}
	else {
		fVar2 = (float)globs::INPUT.msy;
		if (((ushort)((ushort)(fVar2 < 280.0) << 8 | (ushort)(fVar2 == 280.0) << 0xe) == 0) ||
			 (fVar2 < 200.0)) {
			uVar1 = submenu->MenuImage->height;
			if ((fVar2 < 480.0) && ((globs::INPUT.mslb == 0 && (globs::INPUT.msrb == 0)))) {
				fVar3 = (float10)globs::INPUT.msy * (float10)0.2083333 - (float10)50.0;
				fVar3 = fVar3 * fVar3 * (float10)0.02;
				if (fVar2 < 240.0) {
					fVar3 = -fVar3;
				}
				lVar4 = __ftol(fVar3 * (float10)-0.25);
				Point2F_005584dc.y = (float)((int)Point2F_005584dc.y + (int)lVar4);
			}
			if (0 < (int)Point2F_005584dc.y) {
				Point2F_005584dc.y = 0.0;
			}
			if (SBORROW4((int)Point2F_005584dc.y + -0x1e0,-uVar1) !=
					(int)((int)Point2F_005584dc.y + -0x1e0 + uVar1) < 0) {
				Point2F_005584dc.y = (float)(0x1e0 - uVar1);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::front::Front_LoadSaveSlotImages(void)
{
	char *pcVar1;
	Image *pIVar2;
	int iVar3;
	float *pfVar4;
	uint saveIndex;
	Image **ppIVar5;
	void **ppvVar6;
	int iVar7;
	undefined4 *puVar8;
	SaveData local_b8;
	
	iVar7 = 0;
	ppIVar5 = globals::g_SaveSlotImages_TABLE;
	do {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage","Path",0,iVar7);
		pcVar1 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar1);
		std::sprintf((char *)&local_b8,"%s\\%d.dat",pcVar1);
		pIVar2 = lego::image::Image_LoadBMPScaled((char *)&local_b8,0,0);
		*ppIVar5 = pIVar2;
		ppIVar5 = ppIVar5 + 1;
		iVar7 += 1;
	} while (ppIVar5 < &DAT_004dc8a4);
	saveIndex = 0;
	ppvVar6 = globals::g_SaveSlotPtrs_TABLE;
	do {
		local_b8.field_0x0 = 0;
		puVar8 = &local_b8.field_0x4;
		for (iVar7 = 0x2d; iVar7 != 0; iVar7 += -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		save::Save_ReadSaveFile(saveIndex,&local_b8,1);
		*ppvVar6 = NULL;
		if (8 < local_b8.missionsCount) {
			pfVar4 = &local_b8.missionsTable[8].reward.items[9].percentFloat;
			iVar7 = local_b8.missionsCount - 8;
			do {
				if (*pfVar4 == 0.0) {
					iVar3 = 0;
				}
				else {
					iVar3 = 4;
				}
				*ppvVar6 = (void *)((int)*ppvVar6 + iVar3);
				pfVar4 = pfVar4 + 0xc64;
				iVar7 += -1;
			} while (iVar7 != 0);
		}
		std::free(local_b8.missionsTable);
		ppvVar6 = ppvVar6 + 1;
		saveIndex += 1;
	} while (ppvVar6 < &BOOL_004dc8bc);
	return;
}



void __cdecl lego::front::Front_FreeSaveSlotImages(void)
{
	Image **ppIVar1;
	
	ppIVar1 = globals::g_SaveSlotImages_TABLE;
	do {
		if (*ppIVar1 != NULL) {
			lego::image::Image_Remove(*ppIVar1);
		}
		ppIVar1 = ppIVar1 + 1;
	} while (ppIVar1 < &DAT_004dc8a4);
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Front_ScreenSubmenuLoop(SubMenu *submenu)
{
	int iVar1;
	bool bVar2;
	float elapsedAbs;
	SubMenu *pSVar3;
	DWORD DVar4;
	RewardLevel *pRVar5;
	char *pcVar6;
	BOOL local_98;
	SubMenu *local_94;
	float local_90;
	DWORD local_8c;
	uint local_88;
	undefined4 uStack132;
	char buff [128];
	
	bVar2 = false;
	local_98 = 0;
	local_90 = 1.0;
	Front_LoadSaveSlotImages();
	BOOL_004dc8c8 = 0;
	globals::g_SaveMenu_INDEX_004a2f50 = -1;
	globals::g_SaveMenu_INT_004a2f4c = -1;
	globals::g_SaveMenu_INDEX_004a2f54 = -1;
	globals::g_SaveMenu_INT_004a2f58 = -1;
	globals::g_SaveMenu_OutNumber = -1;
	BOOL_004dc8c0 = 0;
	BOOL_004dc8bc = 0;
	BOOL_004dc8c4 = 0;
	globals::g_SaveMenu_IsLoadMode = 1;
	BOOL_00558508 = 1;
	PTRImageFlic_0055806c = NULL;
	local_8c = timeGetTime();
	iVar1 = submenu->field_28;
	elapsedAbs = local_90;
	while (local_90 = elapsedAbs, iVar1 == 0) {
		if (bVar2) {
			SaveMenu_FUN_00412b30(elapsedAbs,submenu,&local_98);
		}
		else {
			local_94 = SaveMenu_FUN_00412b30(elapsedAbs,submenu,NULL);
		}
						// if ((submenu == globals::menu::g_MainMenuFull->menus[0]) ...
		if ((submenu == *globals::g_MainMenuFull->menus) && (local_94 != submenu)) {
			globals::g_MenuMenuFull_MissionsTutorial = -1;
			Front_TutorialsCallback_FUN_00414fe0(elapsedAbs,-1);
		}
		Menu_Submenu_FUN_004138a0(submenu);
		ToolTip_Update(globs::INPUT.msx,globs::INPUT.msy,elapsedAbs);
		snd::SFX_Update(elapsedAbs);
		main::Main_LoopUpdate(0);
		DVar4 = timeGetTime();
		pSVar3 = local_94;
		local_88 = DVar4 - local_8c;
		uStack132 = 0;
		local_90 = (float)(ulonglong)local_88 * 0.025;
		local_8c = DVar4;
		if ((!bVar2) && (local_94 != submenu)) {
			Front_PlayRockWipe_AndUnk();
			bVar2 = true;
			if (globals::g_MenuWipeResource == NULL) {
				local_98 = 1;
			}
		}
		if ((bVar2) && (local_98 != 0)) {
			if ((submenu->MenuImage != pSVar3->MenuImage) && (PTRImageFlic_0055806c != NULL)) {
				lego::image::Flic_Close(PTRImageFlic_0055806c);
				std::free(PTRImageFlic_0055806c);
				snd::Sound3D_Stream_Stop(0);
				PTRImageFlic_0055806c = NULL;
				TIMEUINT_00558070 = 0;
				TIMEUINT_00558074 = 0;
			}
			Point2F_005584dc.y = 0.0;
			Point2F_005584dc.x = 0.0;
			bVar2 = false;
			local_98 = 0;
			submenu = pSVar3;
		}
		elapsedAbs = local_90;
		iVar1 = submenu->field_28;
	}
	Front_FreeSaveSlotImages();
	if ((((local_94 == *globals::g_SaveMenu->menus) && (-1 < globals::g_SaveMenu_OutNumber)) &&
			(pRVar5 = reward::GetRewardLevel(), pRVar5 != NULL)) &&
		 (pRVar5 = reward::GetRewardLevel(), pRVar5->saveHasCapture != 0)) {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::SaveImage","Path",0);
						// MORE MEMORY LEAKS!!!! GAHHHHHH
		pcVar6 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar6);
		std::sprintf(buff,"%s\\%d.dat",pcVar6,globals::g_SaveMenu_OutNumber);
		lego::image::Image_SaveBMP(&pRVar5->saveCaptureImage,buff);
	}
	if (PTRImageFlic_0055806c != NULL) {
		lego::image::Flic_Close(PTRImageFlic_0055806c);
		std::free(PTRImageFlic_0055806c);
		snd::Sound3D_Stream_Stop(0);
		PTRImageFlic_0055806c = NULL;
		TIMEUINT_00558070 = 0;
		TIMEUINT_00558074 = 0;
	}
	Front_UnsetFlag3_005584f0();
	return;
}



void __cdecl lego::front::Front_RunScreenMenu(MenuCollection *menuCol,int submenuIndex)
{
	int iVar1;
	int iVar2;
	
	iVar1 = 0;
	if (0 < (int)menuCol->count) {
		do {
			iVar2 = iVar1 + 1;
			menuCol->menus[iVar1]->field_28 = 0;
			iVar1 = iVar2;
		} while (iVar2 < (int)menuCol->count);
	}
	Front_ScreenSubmenuLoop(menuCol->menus[submenuIndex]);
	return;
}



MenuItemType __cdecl lego::front::Menu_ParseMenuControlType(char *controlName)
{
	int iVar1;
	
	iVar1 = std::_stricmp(controlName,"cycle");
	if (iVar1 == 0) {
		return MENUITEM_CYCLE;
	}
	iVar1 = std::_stricmp(controlName,"trigger");
	if (iVar1 == 0) {
		return MENUITEM_TRIGGER;
	}
	iVar1 = std::_stricmp(controlName,"textinput");
	if (iVar1 == 0) {
		return MENUITEM_TEXTINPUT;
	}
	iVar1 = std::_stricmp(controlName,"slider");
	if (iVar1 == 0) {
		return MENUITEM_SLIDER;
	}
	iVar1 = std::_stricmp(controlName,"realslider");
	if (iVar1 == 0) {
		return MENUITEM_REALSLIDER;
	}
	iVar1 = std::_stricmp(controlName,"next");
	return (-(uint)(iVar1 != 0) & 0xfffffffa) + MENUITEM_NEXT;
}



char * __cdecl lego::util::stringReplaceChar(char *text,char origChar,char newChar)
{
	char *pcVar1;
	char *pcVar2;
	char c;
	
	c = *text;
	pcVar2 = text;
	while (c != '\0') {
		if (c == origChar) {
			*pcVar2 = newChar;
		}
		pcVar1 = pcVar2 + 1;
		pcVar2 = pcVar2 + 1;
		c = *pcVar1;
	}
	return text;
}



int __cdecl lego::front::Menu_GetOverlayType(char **param_1)
{
	char *pcVar1;
	char cVar2;
	int iVar3;
	char *_Str2;
	
	_Str2 = *param_1;
	cVar2 = *_Str2;
	while (cVar2 != '.') {
		pcVar1 = _Str2 + 1;
		_Str2 = _Str2 + 1;
		cVar2 = *pcVar1;
	}
	iVar3 = std::_stricmp(".avi",_Str2);
	if (iVar3 != 0) {
		iVar3 = std::_stricmp(".bmp",_Str2);
		if (iVar3 != 0) {
			iVar3 = std::_stricmp(".lws",_Str2);
			return (-(uint)(iVar3 != 0) & 0xfffffffd) + 3;
		}
		return 2;
	}
	return 1;
}



// ref_overlay functions as an input argument for the last overlay, and output argument for the new
// overlay (which is linked to the previous via linked list)

MenuOverlay * __cdecl
lego::front::Menu_CreateOverlay
					(char *filename,MenuOverlay **ref_overlay,int positionX,int positionY,SFXType sfxType)
{
	MenuOverlay *pMVar1;
	char *pcVar2;
	int iVar3;
	MenuOverlay *pMVar4;
	
	pMVar1 = (MenuOverlay *)std::malloc(0x20);
	pMVar4 = pMVar1;
	for (iVar3 = 8; iVar3 != 0; iVar3 += -1) {
		pMVar4->filename = NULL;
		pMVar4 = (MenuOverlay *)&pMVar4->overlayType;
	}
	iVar3 = std::_strnicmp(filename,"Null",4);
	if (iVar3 != 0) {
		if (filename != NULL) {
			pcVar2 = util::_strdup2(filename);
			pMVar1->filename = pcVar2;
		}
		iVar3 = Menu_GetOverlayType((char **)pMVar1);
		pMVar1->overlayType = iVar3;
		pMVar1->field_1c = 0;
		pMVar4 = *ref_overlay;
		(pMVar1->position).x = positionX;
		pMVar1->previous = pMVar4;
		pMVar1->sfxType = sfxType;
		(pMVar1->position).y = positionY;
		*ref_overlay = pMVar1;
	}
	return pMVar1;
}



void __cdecl lego::front::Menu_LoadSliderImages(int numParts,char **stringParts,Image **outImages)
{
	Image *image;
	int iVar1;
	char **ppcVar2;
	
	if (numParts == 0x10) {
		ppcVar2 = stringParts + 8;
		iVar1 = 8;
		do {
			image = lego::image::ImageCache_LoadImage(*ppcVar2);
			*outImages = image;
			if (image != NULL) {
				lego::image::Image_SetPenZeroTrans(image);
			}
			ppcVar2 = ppcVar2 + 1;
			outImages = outImages + 1;
			iVar1 += -1;
		} while (iVar1 != 0);
		return;
	}
	for (iVar1 = 8; iVar1 != 0; iVar1 += -1) {
		*outImages = NULL;
		outImages = outImages + 1;
	}
	return;
}



MenuCollection * __cdecl lego::front::Menu_CreateCollection(uint count)
{
	MenuCollection *menuCollection;
	SubMenu **ppSVar1;
	uint uVar2;
	int iVar3;
	
	menuCollection = (MenuCollection *)std::malloc(8);
	menuCollection->menus = NULL;
	menuCollection->count = 0;
	ppSVar1 = (SubMenu **)std::malloc(count * 4);
	uVar2 = count & 0x3fffffff;
	menuCollection->menus = ppSVar1;
	for (; uVar2 != 0; uVar2 -= 1) {
		*ppSVar1 = NULL;
		ppSVar1 = ppSVar1 + 1;
	}
	for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
		*(undefined *)ppSVar1 = 0;
		ppSVar1 = (SubMenu **)((int)ppSVar1 + 1);
	}
	menuCollection->count = count;
	return menuCollection;
}



MenuCollection * __cdecl
lego::front::Menu_ParseMenu(CFGProperty *root_unused,char *menuName,void *dst,void *callback,...)
{
	MenuItemType MVar1;
	char *pcVar2;
	uint uVar3;
	MenuCollection *menuCol;
	char *pcVar4;
	char *pcVar5;
	int iVar6;
	int iVar7;
	BoolTri BVar8;
	uint uVar9;
	char *pcVar10;
	SubMenu *pSVar11;
	int menuIndex;
	Font *loFont;
	Font *hiFont;
	SFXType SVar12;
	MenuItemType MVar13;
	MenuItemCycle *cycleData;
	int highLimit;
	int lowLimit;
	MenuItem *submenu;
	MenuItemCallbackPair *pMVar14;
	MenuItemCallbackPair *argPtrNext;
	MenuItemCallbackPair *argptr;
	float10 fVar15;
	Image *offBarImage;
	Image *onBarImage;
	Font *pFVar16;
	Image *leftCapImage;
	Font *pFVar17;
	Image *rightCapImage;
	float highLimit_00;
	Image *loPlusImage;
	float step;
	Image *loMinusImage;
	MenuItemType MVar18;
	Image *hiPlusImage;
	MenuItemCycle *itemData;
	Image *hiMinusImage;
	MenuItemSlider *itemData_00;
	char **local_dd0;
	char *str;
	int local_dc8;
	SFXType local_dc4;
	char *local_dc0;
	int menuCount;
	int menuNumber;
	int itemNumber;
	Image *sliderImages [8];
	char *stringParts [100];
	char submenuPathBuff [1024];
	char overItemBuff [1024];
	char menuPathBuff [1024];
	void *argCallback;
	void *argValue;
	BOOL isLight;
	
	pMVar14 = (MenuItemCallbackPair *)&dst;
	std::sprintf(menuPathBuff,"Menu::%s",menuName);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,menuPathBuff,"MenuCount",0);
	pcVar2 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,menuPathBuff,"MenuCount",0);
		pcVar2 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar2);
	}
	uVar3 = std::atoi(pcVar2);
	menuCount = uVar3;
	menuCol = Menu_CreateCollection(uVar3);
	menuIndex = 0;
	if (0 < (int)uVar3) {
		do {
			menuNumber = menuIndex + 1;
			local_dc8 = 0;
			std::sprintf(submenuPathBuff,"%s::Menu%i",menuPathBuff,menuNumber);
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"Title",0);
			pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
			pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"FullName",0);
			pcVar4 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar4);
			pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"Position",0);
			pcVar5 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar5);
			util::Util_Tokenise(pcVar5,stringParts,":");
			iVar6 = std::atoi(stringParts[0]);
			iVar7 = std::atoi(stringParts[1]);
			if (pcVar5 != NULL) {
				std::free(pcVar5);
			}
			pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"MenuFont",0);
			pcVar5 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar5);
			loFont = lego::image::ImageCache_LoadFont(pcVar5);
			pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"AutoCenter",0);
			BVar8 = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar5);
			uVar3 = (uint)(BVar8 == BOOL3_TRUE);
			pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"DisplayTitle",0);
			BVar8 = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar5);
			local_dc4 = (SFXType)(BVar8 != BOOL3_FALSE);
			pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"Anchored",0);
			local_dc0 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar5);
			if (((uVar3 != 0) && (pcVar2 != NULL)) && (*pcVar2 != '\0')) {
				uVar9 = lego::image::Font_GetStringWidth(loFont,pcVar2);
				local_dc8 = -((int)uVar9 / 2);
			}
			pcVar5 = local_dc0;
			pcVar10 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"CanScroll",0);
			BVar8 = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar10);
			uVar9 = (uint)(BVar8 == BOOL3_TRUE);
			SVar12 = local_dc4;
			pcVar4 = util::stringReplaceChar(pcVar4,'_',' ');
			pcVar10 = util::stringReplaceChar(pcVar2,'_',' ');
			pSVar11 = Menu_CreateSubMenu(pcVar10,pcVar4,loFont,iVar6,iVar7,uVar3,SVar12,local_dc8,uVar9,
																	 pcVar5);
			isLight = 1;
			menuCol->menus[menuIndex] = pSVar11;
			pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"MenuImage",0);
			pcVar4 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar4);
			Menu_LoadMenuImage(menuCol->menus[menuIndex],pcVar4,isLight);
			isLight = 0;
			pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"MenuImageDark",0);
			pcVar4 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar4);
			Menu_LoadMenuImage(menuCol->menus[menuIndex],pcVar4,isLight);
			std::sprintf(menuCol->menus[menuIndex]->CfgName,"%s",submenuPathBuff);
			pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,menuCol->menus[menuIndex]->CfgName,
																 "PlayRandom",0);
			BVar8 = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar4);
			menuCol->menus[menuIndex]->PlayRandom = BVar8;
			std::free(pcVar2);
			menuIndex = menuNumber;
			uVar3 = menuCount;
		} while (menuNumber < menuCount);
	}
	menuIndex = 0;
	if ((int)uVar3 < 1) {
		return menuCol;
	}
LAB_00414425:
	menuNumber = menuIndex + 1;
	MVar1 = menuCol->menus[menuIndex]->AutoCenter;
	std::sprintf(submenuPathBuff,"%s::Menu%i",menuPathBuff,menuNumber);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"LoFont",0);
	pcVar2 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar2);
	loFont = lego::image::ImageCache_LoadFont(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"HiFont",0);
	pcVar2 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar2);
	hiFont = lego::image::ImageCache_LoadFont(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"ItemCount",0);
	pcVar2 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,"ItemCount",0);
		pcVar2 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar2);
	}
	local_dc0 = (char *)std::atoi(pcVar2);
	local_dd0 = (char **)0x1;
	do {
		std::sprintf(overItemBuff,"Overlay%i",local_dd0);
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,overItemBuff,0);
		str = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
		if (str == NULL) {
			if ((globs::mainGlobs.flags & CMD_REDUCEFLICS) != CMD_NONE) break;
			std::sprintf(overItemBuff,"!Overlay%i",local_dd0);
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,overItemBuff,0);
			str = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
			if (str == NULL) break;
		}
		util::Util_Tokenise(str,stringParts,":");
		SVar12 = snd::SFX_GetType(stringParts[1],&local_dc4);
		if (SVar12 == SFX_NULL) {
			local_dc4 = SVar12;
		}
		SVar12 = local_dc4;
		iVar6 = std::atoi(stringParts[3]);
		iVar7 = std::atoi(stringParts[2]);
		Menu_CreateOverlay(stringParts[0],&menuCol->menus[menuIndex]->Overlays,iVar7,iVar6,SVar12);
		if (str != NULL) {
			std::free(str);
		}
		local_dd0 = (char **)((int)local_dd0 + 1);
	} while( true );
	iVar6 = 0;
	argptr = pMVar14;
	if (0 < (int)local_dc0) {
		do {
			itemNumber = iVar6 + 1;
			std::sprintf(overItemBuff,"Item%i",itemNumber);
			if (str != NULL) {
				std::free(str);
			}
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,submenuPathBuff,overItemBuff,0);
			str = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
			iVar6 = util::Util_Tokenise(str,stringParts,":");
			MVar13 = Menu_ParseMenuControlType(stringParts[0]);
			pMVar14 = argptr;
			if (false) goto switchD_00414714_caseD_2;
			MVar18 = MVar1;
			switch(MVar13) {
			case MENUITEM_CYCLE:
				argValue = argptr->value;
				pMVar14 = argptr + 1;
				argCallback = argptr->callback;
				iVar6 = std::atoi(stringParts[4]);
				iVar7 = std::atoi(stringParts[3]);
				uVar3 = std::atoi(stringParts[6]);
				cycleData = Menu_CreateCycle(uVar3,argValue,iVar7,iVar6,argCallback);
				isLight = 0;
				MVar18 = MENUITEM_CYCLE;
				MVar13 = MVar1;
				itemData = cycleData;
				iVar6 = std::atoi(stringParts[2]);
				iVar7 = std::atoi(stringParts[1]);
				pFVar16 = loFont;
				pFVar17 = hiFont;
				pcVar2 = util::stringReplaceChar(stringParts[5],'_',' ');
				submenu = Menu_CreateBannerItem
														(pcVar2,pFVar16,pFVar17,iVar7,iVar6,MVar18,MVar13,itemData,isLight);
				Menu_AddSubMenuItem(menuCol->menus[menuIndex],submenu);
				local_dc8 = 0;
				iVar6 = std::atoi(stringParts[6]);
				if (0 < iVar6) {
					local_dd0 = stringParts + 7;
					do {
						pcVar2 = util::stringReplaceChar(*local_dd0,'_',' ');
						Menu_AddCycleName(cycleData,pcVar2);
						local_dc8 += 1;
						local_dd0 = local_dd0 + 1;
						iVar6 = std::atoi(stringParts[6]);
					} while (local_dc8 < iVar6);
				}
				break;
			case MENUITEM_TRIGGER:
				if (iVar6 == 8) {
					argValue = argptr->value;
					pMVar14 = argptr + 1;
					argCallback = argptr->callback;
					iVar6 = std::atoi(stringParts[7]);
					pSVar11 = (SubMenu *)Menu_CreateTrigger(argValue,(uint)(iVar6 == 1),argCallback);
					MVar13 = MENUITEM_TRIGGER;
LAB_00414992:
					pcVar2 = stringParts[6];
					iVar6 = std::atoi(stringParts[2]);
					iVar7 = std::atoi(stringParts[1]);
					submenu = Menu_CreateImageItem
															(____EMPTYSTR__,loFont,hiFont,stringParts[3],stringParts[4],iVar7,
															 iVar6,MVar13,MVar18,pcVar2,pSVar11);
					pSVar11 = menuCol->menus[menuIndex];
					argptr = pMVar14;
					goto LAB_00414b5a;
				}
				if (iVar6 != 5) break;
				argValue = argptr->value;
				argPtrNext = argptr + 1;
				isLight = 0;
				argCallback = argptr->callback;
				iVar6 = std::atoi(stringParts[4]);
				itemData_00 = (MenuItemSlider *)Menu_CreateTrigger(argValue,(uint)(iVar6 == 1),argCallback);
				MVar13 = MENUITEM_TRIGGER;
LAB_00414a6e:
				iVar6 = std::atoi(stringParts[2]);
				iVar7 = std::atoi(stringParts[1]);
				pcVar2 = stringParts[3];
				argptr = argPtrNext;
				goto LAB_00414b41;
			case MENUITEM_SLIDER:
				argValue = argptr->value;
				Menu_LoadSliderImages(iVar6,stringParts,sliderImages);
				isLight = 0;
				argCallback = argptr->callback;
				offBarImage = sliderImages[0];
				onBarImage = sliderImages[1];
				leftCapImage = sliderImages[2];
				rightCapImage = sliderImages[3];
				loPlusImage = sliderImages[4];
				loMinusImage = sliderImages[5];
				hiPlusImage = sliderImages[6];
				hiMinusImage = sliderImages[7];
				iVar6 = std::atoi(stringParts[4]);
				iVar7 = std::atoi(stringParts[3]);
				highLimit = std::atoi(stringParts[7]);
				lowLimit = std::atoi(stringParts[6]);
				itemData_00 = Menu_CreateSlider(argValue,lowLimit,highLimit,iVar7,iVar6,argCallback,
																				offBarImage,onBarImage,leftCapImage,rightCapImage,
																				loPlusImage,loMinusImage,hiPlusImage,hiMinusImage);
				MVar13 = MENUITEM_SLIDER;
				goto LAB_00414b10;
			case MENUITEM_REALSLIDER:
				argValue = argptr->value;
				isLight = 0;
				argCallback = argptr->callback;
				iVar6 = std::atoi(stringParts[4]);
				iVar7 = std::atoi(stringParts[3]);
				fVar15 = std::atof(stringParts[8]);
				step = (float)fVar15;
				fVar15 = std::atof(stringParts[7]);
				highLimit_00 = (float)fVar15;
				fVar15 = std::atof(stringParts[6]);
				itemData_00 = (MenuItemSlider *)
											Menu_CreateRealSlider
																(argValue,(float)fVar15,highLimit_00,step,iVar7,iVar6,argCallback);
				MVar13 = MENUITEM_REALSLIDER;
LAB_00414b10:
				argptr = argptr + 1;
				iVar6 = std::atoi(stringParts[2]);
				iVar7 = std::atoi(stringParts[1]);
				pcVar2 = stringParts[5];
LAB_00414b41:
				pFVar16 = loFont;
				pFVar17 = hiFont;
				pcVar2 = util::stringReplaceChar(pcVar2,'_',' ');
				submenu = Menu_CreateBannerItem
														(pcVar2,pFVar16,pFVar17,iVar7,iVar6,MVar13,MVar18,itemData_00,isLight);
				pSVar11 = menuCol->menus[menuIndex];
LAB_00414b5a:
				Menu_AddSubMenuItem(pSVar11,submenu);
				pMVar14 = argptr;
				break;
			case MENUITEM_NEXT:
				if (iVar6 == 8) {
					iVar6 = std::atoi(stringParts[7] + 4);
					pSVar11 = menuCol->menus[iVar6 + -1];
					MVar13 = MENUITEM_NEXT;
					goto LAB_00414992;
				}
				if (iVar6 == 6) {
					iVar6 = std::atoi(stringParts[4] + 4);
					isLight = 1;
				}
				else {
					if (*stringParts[4] == '\0') {
						isLight = 0;
						itemData_00 = NULL;
						argPtrNext = argptr;
						MVar13 = MVar1;
						MVar18 = MENUITEM_NEXT;
						goto LAB_00414a6e;
					}
					iVar6 = std::atoi(stringParts[4] + 4);
					isLight = 0;
				}
				pSVar11 = menuCol->menus[iVar6 + -1];
				MVar18 = MENUITEM_NEXT;
				MVar13 = MVar1;
				iVar6 = std::atoi(stringParts[2]);
				iVar7 = std::atoi(stringParts[1]);
				pFVar16 = loFont;
				pFVar17 = hiFont;
				pcVar2 = util::stringReplaceChar(stringParts[3],'_',' ');
				submenu = Menu_CreateBannerItem
														(pcVar2,pFVar16,pFVar17,iVar7,iVar6,MVar18,MVar13,pSVar11,isLight);
				pSVar11 = menuCol->menus[menuIndex];
				goto LAB_00414b5a;
			}
switchD_00414714_caseD_2:
			iVar6 = itemNumber;
			argptr = pMVar14;
		} while (itemNumber < (int)local_dc0);
	}
	if (str != NULL) {
		std::free(str);
	}
	menuIndex = menuNumber;
	if (menuCount <= menuNumber) {
		return menuCol;
	}
	goto LAB_00414425;
}



int __cdecl lego::front::Menu_GetSubMenuIDByName(MenuCollection *menuCol,char *name)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if ((int)menuCol->count < 1) {
		return -1;
	}
	while ((menuCol->menus[iVar2] == NULL ||
				 (iVar1 = std::_stricmp(menuCol->menus[iVar2]->string_0,name), iVar1 != 0))) {
		iVar2 += 1;
		if ((int)menuCol->count <= iVar2) {
			return -1;
		}
	}
	return iVar2;
}



BOOL __cdecl lego::front::FrontEnd_IsIntrosEnabled(void)
{
	char *keyPath;
	BoolTri BVar1;
	
	keyPath = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DontPlayAvis",0);
	BVar1 = cfg::CFG_ReadBool(globs::legoGlobs.config,keyPath);
	if ((BVar1 != BOOL3_TRUE) && (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_3)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::front::PausedMenu_SliderBrightness(int slider_0_10)
{
	float r;
	float r_00;
	
	r = (float)slider_0_10 * 0.1;
	r_00 = r * 0.8 - -0.2;
	res::Container_SetColourAlpha(globs::legoGlobs.contTopSpotlight,r,r,r,1.0);
	res::Container_SetColourAlpha(globs::legoGlobs.contFPLight,r_00,r_00,r_00,1.0);
	res::Container_Light_SetSpotPenumbra(globs::legoGlobs.contTopSpotlight,r * 1.5 - -0.5);
	res::Container_Light_SetSpotUmbra(globs::legoGlobs.contTopSpotlight,r * 0.8 - -0.2);
	return;
}



void __cdecl lego::front::PausedMenu_SliderSoundVolume(int slider_0_10)
{
	snd::Sound3D_SetGlobalVolumePrescaled(slider_0_10);
	return;
}



void __cdecl lego::front::PausedMenu_SliderMusicVolume(int slider_0_10)
{
	main::Main_SetCDVolume((float)slider_0_10 * 0.1111111,(float)slider_0_10 * 0.1111111);
	return;
}



int __cdecl lego::front::PausedMenu_CalcSliderCDVolume(void)
{
	BOOL BVar1;
	int iVar2;
	longlong lVar3;
	float rightVol;
	float leftVol;
	
	iVar2 = 0;
	BVar1 = main::Main_GetCDVolume(&leftVol,&rightVol);
	if (BVar1 != 0) {
		lVar3 = __ftol(((float10)rightVol + (float10)leftVol) * (float10)0.5 * (float10)9.0);
		iVar2 = (int)lVar3;
	}
	return iVar2;
}



void __cdecl lego::front::PausedMenu_CycleWallDetail(int cycle_High_Low)
{
	if (cycle_High_Low == 0) {
		globs::legoGlobs.flags1 |= GAME1_WALLPROMESHES;
	}
	else {
		if (cycle_High_Low == 1) {
			globs::legoGlobs.flags1 = globs::legoGlobs.flags1 & ~GAME1_WALLPROMESHES;
			return;
		}
	}
	return;
}



void __cdecl lego::front::PausedMenu_CycleAutoGameSpeed(int cycle_On_Off)
{
	Info_SetAutoGameSpeed((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleMusic(int cycle_On_Off)
{
	snd::Music_PlayNext((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleSound(int cycle_On_Off)
{
	lrr::Lego_SetSoundEnabled((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleHelpWindow(int cycle_Off_On)
{
	if (cycle_Off_On == 0) {
		HelpWindow_SetEnabled(FALSE,TRUE);
	}
	else {
		if (cycle_Off_On == 1) {
			HelpWindow_SetEnabled(FALSE,FALSE);
			return;
		}
	}
	return;
}



void __cdecl lego::front::PausedMenu_TriggerReplayObjective(void)
{
	game::Objective_SetCompleteStatus(LEVELSTATUS_NONE);
	return;
}



void __cdecl lego::front::PausedMenu_SliderGameSpeed(int slider_0_5)
{
	if (true) {
		switch(slider_0_5) {
		case 0:
			globs::legoGlobs.gameSpeed = 0.3333333;
			return;
		case 1:
			globs::legoGlobs.gameSpeed = 0.6666667;
			return;
		case 3:
			globs::legoGlobs.gameSpeed = 1.333333;
			return;
		case 4:
			globs::legoGlobs.gameSpeed = 1.666667;
			return;
		case 5:
			globs::legoGlobs.gameSpeed = 2.0;
			return;
		}
	}
	globs::legoGlobs.gameSpeed = 1.0;
	return;
}



void __cdecl lego::front::FrontEnd_UpdateSliderGameSpeed(void)
{
	if (globs::legoGlobs.gameSpeed < 0.6666666) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 0;
		return;
	}
	if (globs::legoGlobs.gameSpeed < 1.0) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 1;
		return;
	}
	if (globs::legoGlobs.gameSpeed < 1.333333) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 2;
		return;
	}
	if (globs::legoGlobs.gameSpeed < 1.666667) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 3;
		return;
	}
	globals::g_PausedMenu_SliderGameSpeed_0_5 = 4;
	if (2.0 <= globs::legoGlobs.gameSpeed) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 5;
	}
	return;
}



int __cdecl lego::front::PausedMenu_CalcSliderGameSpeed(void)
{
	int iVar1;
	
	if (globs::legoGlobs.gameSpeed < 0.6666666) {
		return 0;
	}
	if (globs::legoGlobs.gameSpeed < 1.0) {
		return 1;
	}
	if (globs::legoGlobs.gameSpeed < 1.333333) {
		return 2;
	}
	if (globs::legoGlobs.gameSpeed < 1.666667) {
		return 3;
	}
	iVar1 = 4;
	if (2.0 <= globs::legoGlobs.gameSpeed) {
		iVar1 = 5;
	}
	return iVar1;
}



void __cdecl lego::front::Front_TutorialsCallback_FUN_00414fe0(float elapsedAbs,int saveIndex)
{
	SaveData *pSVar1;
	SaveReward *pSVar2;
	LevelCollection *levelCol;
	MenuItemTrigger *pMVar3;
	undefined4 uVar4;
	
	save::Save_SetSaveNumber(saveIndex);
	pSVar1 = save::Save_GetCurrentSaveData();
	if (pSVar1 == NULL) {
		uVar4 = 1;
		pMVar3 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
		levelCol = &globals::g_MissionLevels;
		pSVar2 = NULL;
	}
	else {
		uVar4 = 0;
		pMVar3 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
		levelCol = &globals::g_MissionLevels;
		pSVar1 = save::Save_GetCurrentSaveData();
		pSVar2 = pSVar1->missionsTable;
	}
	LevelIdentifier_FUN_00417310(globals::g_StartMissionLevel,(int)pSVar2,levelCol,pMVar3,uVar4);
	LevelIdentifier_FUN_00417310
						(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
						 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
	return;
}



void __cdecl lego::front::Front_UpdatePausedMenuSliders(void)
{
	int saveIndex;
	SaveData *pSVar1;
	
	saveIndex = save::Save_GetSaveNumber();
	pSVar1 = save::Save_GetSaveData_OfNumber(saveIndex);
	if (pSVar1 != NULL) {
		PausedMenu_SliderSoundVolume(pSVar1->SliderSoundVolume);
		PausedMenu_SliderBrightness(pSVar1->SliderBrightness);
		PausedMenu_SliderMusicVolume(pSVar1->field_0x4);
	}
	return;
}



void __cdecl lego::front::SaveMenu_TriggerBack(void)
{
	SaveData *pSVar1;
	LevelCollection *levelCol;
	MenuItemTrigger *pMVar2;
	undefined4 uVar3;
	
	globals::g_SaveMenu_IsLoadMode = FALSE;
	BOOL_00558508 = FALSE;
	globals::g_SaveMenu_INT_004a2f4c = -1;
	pSVar1 = save::Save_GetCurrentSaveData();
	if (pSVar1 != NULL) {
		uVar3 = 0;
		pMVar2 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
		levelCol = &globals::g_MissionLevels;
		pSVar1 = save::Save_GetCurrentSaveData();
		LevelIdentifier_FUN_00417310
							(globals::g_StartMissionLevel,(int)pSVar1->missionsTable,levelCol,pMVar2,uVar3);
		return;
	}
	LevelIdentifier_FUN_00417310
						(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
						 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10),1);
	return;
}



void __cdecl lego::debug::Debug_ProgrammerMode11_LoadLevel(void)
{
	char *levelName;
	int i;
	MenuCollection *menuCol;
	char buff [128];
	
	std::sprintf(buff,"%s",(globs::legoGlobs.level)->levelName);
	game::Game_SetPaused(FALSE,FALSE);
	game::Level_Free();
	levelName = util::_strdup(buff);
	lrr::Lego_LoadLevel(levelName);
	i = 0;
	menuCol = globals::g_PausedMenu;
	if (0 < (int)globals::g_PausedMenu->count) {
		do {
			if (menuCol->menus[i] != NULL) {
				menuCol->menus[i]->field_28 = 1;
				menuCol = globals::g_PausedMenu;
			}
			i += 1;
		} while (i < (int)menuCol->count);
	}
	globals::g_PausedMenu_TriggerRestart = 0;
	globs::legoGlobs.flags1 |= GAME1_PAUSED;
	save::ObjectRecall_Save_CreateNewObjectRecall();
	return;
}



void __cdecl lego::front::Save_GetLevelCompleteWithPoints(SaveData *saveData,char *out_buffer)
{
	uint *puVar1;
	SaveData *pSVar2;
	int iVar3;
	int iVar4;
	uint index;
	longlong lVar5;
	SaveData *saveData_00;
	
	saveData_00 = saveData;
	if (saveData != NULL) {
		puVar1 = &saveData->missionsCount;
		iVar4 = 0;
		index = 0;
		saveData = NULL;
		pSVar2 = NULL;
		if (*puVar1 != 0) {
			iVar3 = 0;
			do {
				lVar5 = Missions_SaveData_GetUnkField_FUN_00417360(index,saveData_00);
				iVar4 += (int)lVar5;
				if ((*(byte *)((int)&saveData_00->missionsTable->flags + iVar3) & 1) != 0) {
					saveData = (SaveData *)((int)&saveData->field_0x0 + 1);
				}
				index += 1;
				iVar3 += 0x3190;
				pSVar2 = saveData;
			} while (index < saveData_00->missionsCount);
		}
		if (pSVar2 != NULL) {
			lVar5 = __ftol(((float10)ZEXT48(pSVar2) / (float10)saveData_00->missionsCount) *
										 (float10)100.0);
						// Some hardcoded language text here...
			std::sprintf(out_buffer,"Game %i%% complete with %i points scored",(int)lVar5,iVar4);
		}
	}
	return;
}



void __cdecl lego::front::FrontEnd_UpdateGameSpeedSliderLevel(void)
{
	globals::g_PausedMenu_SliderGameSpeed_0_5 = PausedMenu_CalcSliderGameSpeed();
	return;
}



// WARNING: Type propagation algorithm not settling

BOOL __cdecl lego::front::Front_FUN_004152a0(float elapsed,BOOL param_2)
{
	SubMenu *pSVar1;
	int iVar2;
	BOOL BVar3;
	MenuCollection *pMVar4;
	uint uVar5;
	
	uVar5 = 1;
	FrontEnd_UpdateGameSpeedSliderLevel();
	pMVar4 = globals::g_PausedMenu;
	if ((param_2 != 0) && (pMVar4 = globals::g_OptionsMenu, param_2 != 1)) {
		return TRUE;
	}
	if (((((PTRSubMenu_004dc8e0 != NULL) && (globals::g_PausedMenu_TriggerRestart == 0)) &&
			 (globals::g_PausedMenu_TriggerQuit == 0)) &&
			((globals::g_PausedMenu_TriggerReplayObjective == 0 && (PTRMenuCollection_004dc8e4 == pMVar4))
			)) && (BVar3 = game::Objective_IsObjectiveFinished(), BVar3 == 0)) {
LAB_0041535f:
		BVar3 = game::Objective_IsObjectiveFinished();
		if (BVar3 == 0) {
			PTRSubMenu_004dc8e0 = SaveMenu_FUN_00412b30(elapsed,PTRSubMenu_004dc8e0,NULL);
		}
		if (param_2 != 0) {
			if (param_2 == 1) {
				iVar2 = (*pMVar4->menus)->field_28;
				(*pMVar4->menus)->field_28 = 0;
				uVar5 = (uint)(iVar2 == 1);
			}
			return uVar5;
		}
		uVar5 = 1;
		pSVar1 = *pMVar4->menus;
		if ((pSVar1->field_28 != 1) && (pMVar4->menus[2]->field_28 != 1)) {
			uVar5 = 0;
		}
		pSVar1->field_28 = 0;
		pMVar4->menus[2]->field_28 = 0;
		return uVar5;
	}
	globals::g_PausedMenu_TriggerQuit = 0;
	PTRSubMenu_004dc8e0 = (SubMenu *)((SubMenu *)pMVar4->menus)->string_0;
	PTRMenuCollection_004dc8e4 = pMVar4;
	if (globals::g_PausedMenu_TriggerReplayObjective == 0) {
		if (globals::g_PausedMenu_TriggerRestart != 1) goto LAB_0041535f;
	}
	else {
		if (*pMVar4->menus != NULL) {
			(*pMVar4->menus)->field_28 = 1;
		}
		if (pMVar4->menus[2] != NULL) {
			pMVar4->menus[2]->field_28 = 1;
		}
		if (param_2 == 0) {
			globals::g_PausedMenu_TriggerReplayObjective = 0;
			return 0;
		}
	}
	return 0;
}



// levelKey is either "StartLevel" or "TutorialStartLevel"

BOOL __cdecl
lego::front::LevelCollection_Load(CFGProperty *root,LevelCollection *levelCol,char *levelKey)
{
	uint size;
	char **ppcVar1;
	LevelIdentifier **ppLVar2;
	BOOL *pBVar3;
	char *fullName;
	uint uVar4;
	int i;
	uint count;
	char *nextName;
	
	nextName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",levelKey,0);
	nextName = cfg::CFG_CopyString(globs::legoGlobs.config,nextName);
	if (nextName == NULL) {
		return 0;
	}
	count = 1;
						// MEMORY LEAKS!! MEMORY LEAKS EVERYWHERE!!!
	nextName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,nextName,"NextLevel",0);
	for (nextName = cfg::CFG_CopyString(globs::legoGlobs.config,nextName); nextName != NULL;
			nextName = cfg::CFG_CopyString(globs::legoGlobs.config,nextName)) {
		count += 1;
		nextName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,nextName,"NextLevel",0);
	}
	size = count * 4;
	levelCol->count = count;
	ppcVar1 = (char **)std::malloc(size);
	levelCol->LevelNames = ppcVar1;
	ppcVar1 = (char **)std::malloc(size);
	levelCol->FullNames = ppcVar1;
	ppLVar2 = (LevelIdentifier **)std::malloc(size);
	levelCol->LevelList = ppLVar2;
	for (uVar4 = count & 0x3fffffff; uVar4 != 0; uVar4 -= 1) {
		*ppLVar2 = NULL;
		ppLVar2 = ppLVar2 + 1;
	}
	for (i = 0; i != 0; i += -1) {
		*(undefined *)ppLVar2 = 0;
		ppLVar2 = (LevelIdentifier **)((int)ppLVar2 + 1);
	}
	pBVar3 = (BOOL *)std::malloc(size);
	levelCol->IsLinked = pBVar3;
	for (count &= 0x3fffffff; count != 0; count -= 1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	for (i = 0; i != 0; i += -1) {
		*(undefined *)pBVar3 = 0;
		pBVar3 = (BOOL *)((int)pBVar3 + 1);
	}
	if (levelCol->LevelNames != NULL) {
		if (levelCol->FullNames != NULL) {
			nextName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",levelKey,0);
			nextName = cfg::CFG_CopyString(globs::legoGlobs.config,nextName);
			*levelCol->LevelNames = nextName;
			nextName = *levelCol->LevelNames;
			fullName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,nextName,"FullName",0);
			fullName = cfg::CFG_CopyString(globs::legoGlobs.config,fullName);
			*levelCol->FullNames = fullName;
			if (*levelCol->FullNames == NULL) {
				fullName = util::_strdup2(*levelCol->LevelNames);
				*levelCol->FullNames = fullName;
			}
			else {
				util::stringReplaceChar(*levelCol->FullNames,'_',' ');
			}
			i = 1;
			if (1 < levelCol->count) {
				do {
					nextName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,nextName,"NextLevel",0);
					nextName = cfg::CFG_CopyString(globs::legoGlobs.config,nextName);
					levelCol->LevelNames[i] = nextName;
					nextName = levelCol->LevelNames[i];
					fullName = cfg::CFG_JoinPath(globs::legoGlobs.gameName,nextName,"FullName",0);
					fullName = cfg::CFG_CopyString(globs::legoGlobs.config,fullName);
					levelCol->FullNames[i] = fullName;
					if (levelCol->FullNames[i] == NULL) {
						fullName = util::_strdup2(levelCol->LevelNames[i]);
						levelCol->FullNames[i] = fullName;
					}
					else {
						util::stringReplaceChar(levelCol->FullNames[i],'_',' ');
					}
					i += 1;
				} while (i < levelCol->count);
			}
			return TRUE;
		}
		return 0;
	}
	return 0;
}



// Plays an alread-loaded Movie_t from the G98CMovie C wrapper API.
//  Allows terminating the movie playback during runtime with isSkippable.

void __cdecl lego::front::Front_PlayMovie(Movie_t *mov,BOOL skippable)
{
	BOOL BVar1;
	uint uVar2;
	ulonglong uVar3;
	float local_1c;
	RECT rect;
	
						// HARDCODED SCREEN RESOLUTION!!
	rect.left = 0;
	rect.top = 0;
	rect.right = 640;
	rect.bottom = 480;
	local_1c = 0.0;
	BVar1 = video::Movie_Update(mov,1.0,&rect);
	if (BVar1 != 0) {
		while( true ) {
			main::Main_LoopUpdate(0);
			local_1c = local_1c - -1.0;
			uVar3 = video::Movie_GetDuration(mov);
			if ((float)(uVar3 & 0xffffffff) < local_1c) break;
			if (skippable != 0) {
				uVar2 = input::Input_AnyKeyPressed();
				if (uVar2 != 0) {
					return;
				}
				if (globs::INPUT.msrb != 0) {
					return;
				}
				if (globs::INPUT.mslb != 0) {
					return;
				}
			}
			BVar1 = video::Movie_Update(mov,1.0,&rect);
			if (BVar1 == 0) {
				return;
			}
		}
	}
	return;
}



void __cdecl lego::front::Front_ShowIntroSplash(char *imageKey,BOOL skippable,char *timeKey)
{
	char *pcVar1;
	DWORD DVar2;
	Image *image;
	DWORD DVar3;
	uint uVar4;
	float10 fVar5;
	longlong lVar6;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",timeKey,0);
	pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",timeKey,0);
		pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
	}
	fVar5 = std::atof(pcVar1);
	timeKey = (char *)(float)fVar5;
	if ((float)timeKey == 0.0) {
						// 3.0; // default seconds
		timeKey = (char *)1077936128;
	}
	DVar2 = timeGetTime();
	lVar6 = __ftol((float10)(float)timeKey * (float10)-1000.0);
	if (imageKey != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",imageKey,0);
		pcVar1 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar1);
		if ((pcVar1 != NULL) && (image = lego::image::Image_LoadBMPScaled(pcVar1,0,0), image != NULL)) {
			while( true ) {
				lego::image::Image_DisplayScaled(image,NULL,NULL,NULL);
				main::Main_LoopUpdate(0);
				Sleep(100);
				DVar3 = timeGetTime();
				if (DVar2 - (int)lVar6 <= DVar3) break;
				if ((skippable != 0) &&
					 (((uVar4 = input::Input_AnyKeyPressed(), uVar4 != 0 || (globs::INPUT.msrb != 0)) ||
						(globs::INPUT.mslb != 0)))) break;
			}
			lego::image::Image_Remove(image);
		}
	}
	return;
}



void __cdecl lego::front::Front_ShowIntroMovie(char *aviKey,BOOL skippable)
{
	char *keyPath;
	char *fName;
	BOOL exists;
	Movie_t *mov;
	
	if (aviKey != NULL) {
		keyPath = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",aviKey,0);
		fName = cfg::CFG_CopyString(globs::legoGlobs.config,keyPath);
		if (fName != NULL) {
			exists = lego::file::File_Exists(fName);
			if (exists != 0) {
				mov = video::Movie_Load(fName);
				Front_PlayMovie(mov,skippable);
				video::Movie_Free(mov);
				std::free(fName);
			}
		}
	}
	return;
}



void __cdecl lego::game::Level_DoVideo__004158c0(char *levelName,int param_2)
{
	char *pcVar1;
	BOOL BVar2;
	Movie_t *mov;
	
	if (levelName != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"Video",0);
		pcVar1 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar1);
		if (pcVar1 != NULL) {
			BVar2 = lego::file::File_Exists(pcVar1);
			if (BVar2 != 0) {
				mov = video::Movie_Load(pcVar1);
				front::Front_PlayMovie(mov,param_2);
				video::Movie_Free(mov);
			}
			std::free(pcVar1);
		}
	}
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Menu_LoadAllMissions(MenuCollection *mainMenuCol)
{
	int iVar1;
	int iVar2;
	int iVar3;
	MenuItemMissions *missions;
	MenuItem *pMVar4;
	MenuItemMissions *missions_00;
	char *pcVar7;
	int iVar8;
	SaveData *pSVar9;
	undefined4 uVar10;
	int iVar11;
	code *pcVar12;
	char buff [100];
	MenuItem *pcVar6;
	MenuItem *pcVar5;
	
	globals::g_StartMissionLevel =
			 LevelCollection_LoadLinks(&globals::g_MissionLevels,*globals::g_MissionLevels.LevelNames);
	globals::g_StartTutorialLevel =
			 LevelCollection_LoadLinks(&globals::g_TutorialLevels,*globals::g_TutorialLevels.LevelNames);
	LevelCollections_ClearAllLinks();
	iVar1 = Menu_GetSubMenuIDByName(globals::g_MainMenuFull,"Levels");
	iVar2 = Menu_GetSubMenuIDByName(globals::g_MainMenuFull,"Tutorials");
	iVar3 = Menu_GetSubMenuIDByName(globals::g_MainMenuFull,"Load Level Save");
	missions = Menu_CreateMissionsDisplay
											 (&globals::g_MenuMenuFull_MissionsTutorial,____EMPTYSTR__,____EMPTYSTR__,-200
												,-100,60,5,-20,200,-20,-40,0,Front_TutorialsCallback_FUN_00414fe0,
												globals::g_MainMenuFull->menus[iVar1]);
	pcVar5 = (MenuItem *)globals::g_MainMenuFull->menus[iVar3]->Items->banner;
	pMVar4 = Menu_CreateBannerItem
										 (____EMPTYSTR__,pcVar5->LoFont,pcVar5->HiFont,0,0,MENUITEM_MISSIONS,TRUE,
											missions,FALSE);
	Menu_AddSubMenuItem(globals::g_MainMenuFull->menus[iVar3],pMVar4);
	missions_00 = Menu_CreateMissionsDisplay
													(&globals::g_MenuMenuFull_MissionsTutorial,____EMPTYSTR__,____EMPTYSTR__,
													 -200,-100,60,5,-20,200,-20,-40,0,Front_TutorialsCallback_FUN_00414fe0,0);
	pcVar6 = (MenuItem *)globals::g_MainMenuFull->menus[iVar3]->Items->banner;
	pMVar4 = Menu_CreateBannerItem
										 (____EMPTYSTR__,pcVar6->LoFont,pcVar6->HiFont,0,0,MENUITEM_MISSIONS,TRUE,
											missions_00,FALSE);
	Menu_AddSubMenuItem(*globals::g_SaveMenu->menus,pMVar4);
	iVar8 = 0;
	pSVar9 = globals::g_SaveData_TABLE;
	do {
		iVar8 += 1;
		iVar11 = iVar8;
		pcVar7 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","Save_Game",0);
		pcVar7 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar7);
		std::sprintf(buff,"%s %i",pcVar7,iVar11);
		util::stringReplaceChar(buff,'_',' ');
		Save_GetLevelCompleteWithPoints(pSVar9,buff);
		Missions_AddLevel(missions,buff,TRUE,
											*(Font **)(globals::g_MainMenuFull->menus[iVar3]->Items->banner + 8),0,0,0);
		Missions_AddLevel(missions_00,buff,TRUE,
											*(Font **)(globals::g_MainMenuFull->menus[iVar3]->Items->banner + 8),0,0,0);
		pSVar9 = pSVar9 + 1;
	} while ((int)pSVar9 < 0x558418);
	save::Front_StructB8_HasClearSaves_FUN_00417d20();
	pcVar12 = Missions_StartMenuItemCallback_uses_testercall;
	uVar10 = 0;
	pSVar9 = save::Save_GetCurrentSaveData();
	MainMenuFull_AddMissionsDisplay
						(4,globals::g_StartMissionLevel,&globals::g_MissionLevels.count,
						 globals::g_MainMenuFull->menus[iVar1],pSVar9,uVar10,pcVar12);
	pcVar12 = Missions_TutorialMenuItemCallback;
	uVar10 = 0;
	pSVar9 = save::Save_GetCurrentSaveData();
	MainMenuFull_AddMissionsDisplay
						(5,globals::g_StartTutorialLevel,&globals::g_TutorialLevels.count,
						 globals::g_MainMenuFull->menus[iVar2],pSVar9,uVar10,pcVar12);
	return;
}



void __cdecl lego::save::Save_ClearSaveNumber(void)
{
	globals::g_SaveNumber = -1;
	return;
}



void __cdecl
lego::front::MenuTextWindow_Load(CFGProperty *root,char *rootPath,MenuTextWindow *menuWnd)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	TextWindow *pTVar4;
	Image *pIVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	char *pcVar9;
	undefined4 *puVar10;
	Area2F local_24;
	char *local_14;
	char *local_10;
	char *local_c;
	char *local_8;
	char *local_4;
	
	local_24.y = 0.0;
	local_24.width = 0.0;
	local_24.x = 0.0;
	local_24.height = 0.0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Load",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->LoadText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Save",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->SaveText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Slot",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->SlotText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"SaveSel",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->SaveSelText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"LoadSel",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->LoadSelText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Level",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->LevelText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Tutorial",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->TutorialText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Window",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		iVar3 = util::Util_Tokenise(pcVar2,&local_14,"|");
		if (iVar3 == 4) {
			iVar3 = std::atoi(local_14);
			local_24.x = (float)iVar3;
			(menuWnd->WindowArea).x = local_24.x;
			iVar3 = std::atoi(local_10);
			local_24.y = (float)iVar3;
			(menuWnd->WindowArea).y = local_24.y;
			iVar3 = std::atoi(local_c);
			local_24.width = (float)iVar3;
			(menuWnd->WindowArea).width = local_24.width;
			iVar3 = std::atoi(local_8);
			local_24.height = (float)iVar3;
			(menuWnd->WindowArea).height = local_24.height;
			pTVar4 = TextWindow_Create(globs::legoGlobs.bmpFONT5_HI,&local_24,0x200);
			menuWnd->textWindow = pTVar4;
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,rootPath,"Panel",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		iVar3 = util::Util_Tokenise(pcVar2,&local_14,"|");
		if ((iVar3 == 5) && (local_14 != NULL)) {
			pIVar5 = lego::image::Image_LoadBMPScaled(local_14,0,0);
			menuWnd->PanelImage = pIVar5;
			if (pIVar5 != NULL) {
				iVar3 = std::atoi(local_10);
				(menuWnd->PanelArea).x = (float)iVar3;
				iVar3 = std::atoi(local_c);
				(menuWnd->PanelArea).y = (float)iVar3;
				iVar3 = std::atoi(local_8);
				(menuWnd->PanelArea).width = (float)iVar3;
				iVar3 = std::atoi(local_4);
				pIVar5 = menuWnd->PanelImage;
				(menuWnd->PanelArea).height = (float)iVar3;
				lego::image::Image_SetupTrans(pIVar5,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
	}
	return;
}



BOOL __cdecl lego::front::Missions_StreamLevelNameSFX(int levelNumber)
{
	BOOL BVar1;
	SFXType sfxType;
	char buff [128];
	
	std::sprintf(buff,"Stream_LevelName_Level%d",levelNumber);
	BVar1 = snd::SFX_GetType(buff,&sfxType);
	if (BVar1 != 0) {
		BVar1 = snd::SFX_Sample_Random_SetAndPlayGlobalSample(sfxType,NULL);
	}
	return BVar1;
}



BOOL __cdecl lego::front::Missions_StreamTutorialLevelNameSFX(int levelNumber)
{
	BOOL BVar1;
	SFXType sfxType;
	char buff [128];
	
	std::sprintf(buff,"Stream_LevelName_TLevel%d",levelNumber);
	BVar1 = snd::SFX_GetType(buff,&sfxType);
	if (BVar1 != 0) {
		BVar1 = snd::SFX_Sample_Random_SetAndPlayGlobalSample(sfxType,NULL);
	}
	return BVar1;
}



void __cdecl lego::front::Menu_LoadMenus(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	char *pcVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	MenuTextWindow *pMVar8;
	char *pcVar9;
	undefined4 *puVar10;
	
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","MenuWipe",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","!MenuWipe",0);
		pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
		if (pcVar2 == NULL) goto LAB_004161da;
		if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
			iVar3 = std::_strnicmp(pcVar2,"Null",4);
			goto joined_r0x004161b8;
		}
	}
	else {
		iVar3 = std::_strnicmp(pcVar2,"Null",4);
joined_r0x004161b8:
		if (iVar3 != 0) {
			globals::g_MenuWipeResource = res::Container_Load(NULL,pcVar2,"LWS",1);
		}
	}
	std::free(pcVar2);
LAB_004161da:
	globals::g_MenuSaveTextWindow = (MenuTextWindow *)std::malloc(0x728);
	pMVar8 = globals::g_MenuSaveTextWindow;
	for (iVar3 = 0x1ca; iVar3 != 0; iVar3 += -1) {
		pMVar8->textWindow = NULL;
		pMVar8 = (MenuTextWindow *)&pMVar8->PanelImage;
	}
	MenuTextWindow_Load(root,"Menu::SaveText",globals::g_MenuSaveTextWindow);
	globals::g_MenuSaveLevelWindow = (MenuTextWindow *)std::malloc(0x728);
	pMVar8 = globals::g_MenuSaveLevelWindow;
	for (iVar3 = 0x1ca; iVar3 != 0; iVar3 += -1) {
		pMVar8->textWindow = NULL;
		pMVar8 = (MenuTextWindow *)&pMVar8->PanelImage;
	}
	MenuTextWindow_Load(root,"Menu::LevelText",globals::g_MenuSaveLevelWindow);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","Save_Game",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::g_Menu_SaveGame_text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","Load_Game",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::g_Menu_LoadGame_text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::Overwrite","Title",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::g_Overwrite_Title;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::Overwrite","Text",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::g_Overwrite_Text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::Overwrite","Ok",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar4 = pcVar2;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar4 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar4;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar4 + -uVar5);
		puVar10 = (undefined4 *)globals::g_Overwrite_Ok;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu::Overwrite","Cancel",0);
	pcVar2 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar4 = pcVar2;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar4 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar4;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar4 + -uVar5);
		puVar10 = (undefined4 *)globals::g_Overwrite_Cancel;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	FONT_00558078 = globs::legoGlobs.bmpMbriefFONT2;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","Version",0);
	globals::g_Main_Version = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","DefaultLevelBMPS",0);
	globals::g_Menu_DefaultLevelBMPS = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar2);
	PTRContLight_005584fc =
			 res::Container_MakeLight(globs::legoGlobs.contRoot,D3DRMLIGHT_DIRECTIONAL,0.8,0.8,0.8);
	res::Container_Hide(PTRContLight_005584fc,1);
	globals::g_MainMenuFull =
			 Menu_ParseMenu(root,"MainMenuFull",&globals::g_MainMenuFull_TriggerCredits,
											MainMenuFull_TriggerShowCredits,&globals::g_MainMenuFull_TriggerYesQuit,0,
											0xffffffff);
	globals::g_SaveMenu =
			 Menu_ParseMenu(root,"SaveMenu",&globals::g_SaveMenu_TriggerBack,SaveMenu_TriggerBack,
											0xffffffff);
	LevelCollection_Load(globs::legoGlobs.config,&globals::g_MissionLevels,"StartLevel");
	LevelCollection_Load(globs::legoGlobs.config,&globals::g_TutorialLevels,"TutorialStartLevel");
	Menu_LoadAllMissions(globals::g_MainMenuFull);
	globals::g_PausedMenu =
			 Menu_ParseMenu(root,"PausedMenu",&globals::g_PausedMenu_TriggerContinue,NULL,
											&globals::g_PausedMenu_SliderGameSpeed_0_5,PausedMenu_SliderGameSpeed,
											&globals::g_PausedMenu_SliderSoundVolume_0_10,PausedMenu_SliderSoundVolume,
											&globals::g_PausedMenu_SliderMusicVolume_0_10,PausedMenu_SliderMusicVolume,
											&globals::g_PausedMenu_SliderBrightness_0_10,PausedMenu_SliderBrightness,
											&globals::g_PausedMenu_CycleHelpWindow_Off_On,PausedMenu_CycleHelpWindow,
											&globals::g_PausedMenu_TriggerReplayObjective,
											PausedMenu_TriggerReplayObjective,&globals::g_PausedMenu_TriggerQuit,0,
											&globals::g_PausedMenu_TriggerRestart,0,
											&globals::g_PausedMenu_CycleWallDetail_High_Low,PausedMenu_CycleWallDetail,
											&globals::g_PausedMenu_CycleMusic_On_Off,PausedMenu_CycleMusic,
											&globals::g_PausedMenu_CycleSound_On_Off,PausedMenu_CycleSound,
											&globals::g_PausedMenu_CycleAutoGameSpeed_On_Off,PausedMenu_CycleAutoGameSpeed
											,0xffffffff);
	globals::g_OptionsMenu =
			 Menu_ParseMenu(root,"OptionsMenu",&globals::g_PausedMenu_SliderGameSpeed_0_5,
											PausedMenu_SliderGameSpeed,&globals::g_PausedMenu_SliderSoundVolume_0_10,
											PausedMenu_SliderSoundVolume,&globals::g_PausedMenu_SliderMusicVolume_0_10,
											PausedMenu_SliderMusicVolume,&globals::g_PausedMenu_SliderBrightness_0_10,
											PausedMenu_SliderBrightness,&globals::g_PausedMenu_CycleHelpWindow_Off_On,
											PausedMenu_CycleHelpWindow,&globals::g_PausedMenu_TriggerReplayObjective,
											PausedMenu_TriggerReplayObjective,&globals::g_PausedMenu_TriggerContinue,0,
											0xffffffff);
	globals::g_PausedMenu_SliderSoundVolume_0_10 = 8;
	globals::g_PausedMenu_TriggerContinue = 0;
	globals::g_PausedMenu_SliderBrightness_0_10 = 5;
	globals::g_PausedMenu_CycleHelpWindow_Off_On = 1;
	globals::g_PausedMenu_TriggerReplayObjective = 0;
	globals::g_PausedMenu_SliderGameSpeed_0_5 = PausedMenu_CalcSliderGameSpeed();
	globals::g_PausedMenu_SliderMusicVolume_0_10 = PausedMenu_CalcSliderCDVolume();
	BOOL_00558500 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","MaxLevelScreens",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","MaxLevelScreens",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_MaxLevelScreens = std::atoi(pcVar2);
	if (globals::g_Menu_MaxLevelScreens == 0) {
		globals::g_Menu_MaxLevelScreens = 1;
	}
	DAT_00558824 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","SaveImage","BigWidth",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","SaveImage","BigWidth",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_SaveImage_BigSize.width = std::atoi(pcVar2);
	if (globals::g_Menu_SaveImage_BigSize.width == 0) {
		globals::g_Menu_SaveImage_BigSize.width = 80;
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","SaveImage","BigHeight",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","SaveImage","BigHeight",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_SaveImage_BigSize.height = std::atoi(pcVar2);
	if (globals::g_Menu_SaveImage_BigSize.height == 0) {
		globals::g_Menu_SaveImage_BigSize.height = 60;
	}
	Front_SetBool_0055881c(1);
	return;
}



void __cdecl lego::front::PausedMenu_UpdateUnkStruct_FromSliderValues(void)
{
	SaveData *pSVar1;
	
	pSVar1 = save::Save_GetCurrentSaveData();
	if (pSVar1 != NULL) {
		pSVar1->SliderGameSpeed = globals::g_PausedMenu_SliderGameSpeed_0_5;
		pSVar1->SliderSoundVolume = globals::g_PausedMenu_SliderSoundVolume_0_10;
		pSVar1->SliderBrightness = globals::g_PausedMenu_SliderBrightness_0_10;
	}
	return;
}



void __cdecl lego::front::Front_SetOptionParameters(BOOL fromSave,BOOL reset)
{
	SaveData *saveData;
	
	if (reset != 0) {
		globals::g_MainMenuFull_TriggerYesQuit = 0;
		globals::g_Menu_LabelUnkValue_1 = -1;
		globals::g_MenuMenuFull_MissionsNormal = -1;
		globals::g_PausedMenu_TriggerContinue = 0;
	}
	if (fromSave != 0) {
		if (globals::g_MenuMenuFull_MissionsTutorial != -1) {
			saveData = save::Save_GetCurrentSaveData();
			if (saveData != NULL) {
				saveData = save::Save_GetCurrentSaveData();
				globals::g_PausedMenu_SliderGameSpeed_0_5 = saveData->SliderGameSpeed;
				globals::g_PausedMenu_SliderSoundVolume_0_10 = saveData->SliderSoundVolume;
				globals::g_PausedMenu_SliderBrightness_0_10 = saveData->SliderBrightness;
				return;
			}
		}
						// 100%(?)
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 1;
		globals::g_PausedMenu_SliderSoundVolume_0_10 = 8;
		globals::g_PausedMenu_SliderBrightness_0_10 = 5;
	}
	return;
}



void __cdecl lego::front::Menu_FUN_004168f0(ScreenMenuType menuId)
{
	SaveData *pSVar1;
	SaveReward *pSVar2;
	LevelCollection *pLVar3;
	MenuItemTrigger *pMVar4;
	undefined4 uVar5;
	
	switch(menuId) {
	case MENU_SCREEN_TITLE:
		globals::g_MenuMenuFull_MissionsTutorial = -1;
		Front_SetOptionParameters(TRUE,TRUE);
		pSVar1 = save::Save_GetCurrentSaveData();
		if (pSVar1 == NULL) {
			if (BOOL_0055881c != 0) {
				LevelIdentifier_FUN_00417310
									(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
									 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10),1)
				;
			}
		}
		else {
LAB_00416af1:
			uVar5 = 0;
			pMVar4 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar1 = save::Save_GetCurrentSaveData();
			LevelIdentifier_FUN_00417310
								(globals::g_StartMissionLevel,(int)pSVar1->missionsTable,pLVar3,pMVar4,uVar5);
		}
		break;
	case MENU_SCREEN_MISSIONS:
		Front_SetOptionParameters(TRUE,TRUE);
		pSVar1 = save::Save_GetCurrentSaveData();
		if (pSVar1 == NULL) {
			if (BOOL_0055881c == 0) goto LAB_004169dd;
			uVar5 = 1;
			pMVar4 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar2 = NULL;
		}
		else {
			uVar5 = 0;
			pMVar4 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar1 = save::Save_GetCurrentSaveData();
			pSVar2 = pSVar1->missionsTable;
		}
		LevelIdentifier_FUN_00417310(globals::g_StartMissionLevel,(int)pSVar2,pLVar3,pMVar4,uVar5);
LAB_004169dd:
		LevelIdentifier_FUN_00417310
							(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
							 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
		Front_SetBool_0055881c(TRUE);
		return;
	case MENU_SCREEN_TRAINING:
		Front_SetOptionParameters(TRUE,TRUE);
		pSVar1 = save::Save_GetCurrentSaveData();
		if (pSVar1 == NULL) {
			if (BOOL_0055881c == 0) goto LAB_00416a8d;
			uVar5 = 1;
			pMVar4 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar2 = NULL;
		}
		else {
			uVar5 = 0;
			pMVar4 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar1 = save::Save_GetCurrentSaveData();
			pSVar2 = pSVar1->missionsTable;
		}
		LevelIdentifier_FUN_00417310(globals::g_StartMissionLevel,(int)pSVar2,pLVar3,pMVar4,uVar5);
LAB_00416a8d:
		LevelIdentifier_FUN_00417310
							(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
							 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
		Front_SetBool_0055881c(1);
		return;
	case MENU_SCREEN_LOAD_unused:
		Front_SetOptionParameters(FALSE,TRUE);
		Front_SetBool_0055881c(TRUE);
		return;
	case MENU_SCREEN_SAVE:
		Front_SetOptionParameters(FALSE,TRUE);
		pSVar1 = save::Save_GetCurrentSaveData();
		if (pSVar1 != NULL) goto LAB_00416af1;
		if (BOOL_0055881c != 0) {
			LevelIdentifier_FUN_00417310
								(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
								 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10),1);
			BOOL_00558500 = TRUE;
		}
		break;
	default:
		goto switchD_004168fd_caseD_5;
	}
	LevelIdentifier_FUN_00417310
						(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
						 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
switchD_004168fd_caseD_5:
	Front_SetBool_0055881c(TRUE);
	return;
}



BOOL __cdecl lego::front::Front_RunScreenMenuType(ScreenMenuType screenMenuType)
{
	MenuCollection *menuCol;
	int submenuIndex;
	
	menuCol = globals::g_MainMenuFull;
	Menu_FUN_004168f0(screenMenuType);
	snd::SFX_Sample_AddToQueue(SFX_AMBIENTMUSICLOOP,SOUND_LOOP);
	if (true) {
		switch(screenMenuType) {
		case MENU_SCREEN_TITLE:
						// MainMenuFull::Menu1 "Main"
			submenuIndex = 0;
			break;
		case MENU_SCREEN_MISSIONS:
						// MainMenuFull::Menu2 "Missions"
			submenuIndex = 1;
			break;
		case MENU_SCREEN_TRAINING:
						// MainMenuFull::Menu3 "Training_Missions"
			submenuIndex = 2;
			break;
		default:
			goto switchD_00416bd6_caseD_3;
		case MENU_SCREEN_SAVE:
						// SaveMenu::Menu1 "Load_A_Saved_Game"  (save a game)
			submenuIndex = 0;
			menuCol = globals::g_SaveMenu;
		}
		Front_RunScreenMenu(menuCol,submenuIndex);
	}
switchD_00416bd6_caseD_3:
	snd::Sound3D_Stream_Stop(TRUE);
	snd::Sound3D_Stream_Stop(FALSE);
	return 0;
}



BOOL __cdecl lego::front::Front_IsFrontEndEnabled(void)
{
	char *keyPath;
	BoolTri BVar1;
	
	keyPath = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","FrontEnd",0);
	BVar1 = cfg::CFG_ReadBool(globs::legoGlobs.config,keyPath);
	if ((BVar1 == BOOL3_TRUE) && (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_3)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Front_IsMenuLabelUnkValue1_NotM1(void)
{
	return (uint)(globals::g_Menu_LabelUnkValue_1 != -1);
}



BOOL __cdecl lego::front::Front_GetUnkTutoOrMissions(void)
{
	return (uint)(globals::g_MenuMenuFull_MissionsNormal != -1);
}



char * __cdecl lego::front::Front_GetSelectedLevel(void)
{
	BOOL BVar1;
	int iVar2;
	
	BVar1 = Front_IsMenuLabelUnkValue1_NotM1();
	if (BVar1 == 0) {
		BVar1 = Front_GetUnkTutoOrMissions();
		if (BVar1 == 0) {
			return NULL;
		}
		iVar2 = LevelIdentifier_FUN_00417200
											(globals::g_StartTutorialLevel,globals::g_MenuMenuFull_MissionsNormal);
		if (iVar2 != -1) {
			return globals::g_TutorialLevels.LevelNames[iVar2];
		}
	}
	else {
		iVar2 = LevelIdentifier_FUN_00417200
											(globals::g_StartMissionLevel,globals::g_Menu_LabelUnkValue_1);
		if (iVar2 != -1) {
			return globals::g_MissionLevels.LevelNames[iVar2];
		}
	}
	return NULL;
}



int __cdecl lego::front::Front_IsTriggerAppQuit(void)
{
	return globals::g_MainMenuFull_TriggerYesQuit;
}



BOOL __cdecl lego::front::Front_IsTriggerMissionQuit(void)
{
	return (uint)(globals::g_PausedMenu_TriggerQuit != 0);
}



BOOL __cdecl lego::front::Front_IsTriggerMissionRestart(void)
{
	return (uint)(globals::g_PausedMenu_TriggerRestart != 0);
}



LevelCollection * __cdecl lego::front::LevelCollections_GetTutorialOrMissions(void)
{
	BOOL BVar1;
	LevelCollection *pLVar2;
	
	BVar1 = Front_GetUnkTutoOrMissions();
	pLVar2 = &globals::g_TutorialLevels;
	if (BVar1 == 0) {
		pLVar2 = &globals::g_MissionLevels;
	}
	return pLVar2;
}



int __cdecl lego::front::LevelCollection_IndexOf(LevelCollection *levelCol,char *levelName)
{
	int cmp;
	int i;
	
	i = 0;
	if (levelCol->count < 1) {
		return -1;
	}
	do {
		cmp = std::_stricmp(levelName,levelCol->LevelNames[i]);
		if (cmp == 0) {
			return i;
		}
		i += 1;
	} while (i < levelCol->count);
	return -1;
}



void __cdecl lego::front::LevelCollections_ClearAllLinks(void)
{
	int iVar1;
	
	iVar1 = 0;
	if (0 < globals::g_MissionLevels.count) {
		do {
			if (globals::g_MissionLevels.LevelList[iVar1] != NULL) {
				globals::g_MissionLevels.LevelList[iVar1]->field_10 = 0;
				globals::g_MissionLevels.IsLinked[iVar1] = 0;
			}
			iVar1 += 1;
		} while (iVar1 < globals::g_MissionLevels.count);
	}
	iVar1 = 0;
	if (0 < globals::g_TutorialLevels.count) {
		do {
			if (globals::g_TutorialLevels.LevelList[iVar1] != NULL) {
				globals::g_TutorialLevels.LevelList[iVar1]->field_10 = 0;
				globals::g_TutorialLevels.IsLinked[iVar1] = 0;
			}
			iVar1 += 1;
		} while (iVar1 < globals::g_TutorialLevels.count);
	}
	return;
}



void __cdecl
lego::front::LevelCollection_SetLinked(LevelCollection *levelCol,char *levelName,BOOL isLinked)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416e3d:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416e42;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416e3d;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416e42:
		if (cmp == 0) {
			levelCol->IsLinked[i] = isLinked;
			return;
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return;
		}
	} while( true );
}



BOOL __cdecl lego::front::LevelCollection_IsLinked(LevelCollection *levelCol,char *levelName)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return 0;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416ead:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416eb2;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416ead;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416eb2:
		if (cmp == 0) {
			return levelCol->IsLinked[i];
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return 0;
		}
	} while( true );
}



void __cdecl
lego::front::LevelCollection_SetIdentifier
					(LevelCollection *levelCol,char *levelName,LevelIdentifier *identifier)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416f1d:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416f22;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416f1d;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416f22:
		if (cmp == 0) {
			levelCol->LevelList[i] = identifier;
			return;
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return;
		}
	} while( true );
}



LevelIdentifier * __cdecl
lego::front::LevelCollection_GetIdentifier(LevelCollection *levelCol,char *levelName)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return NULL;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
						// iVar3 = std::strcmp(levelCol->NextLevels[i],levelName);
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416f8d:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416f92;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416f8d;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416f92:
		if (cmp == 0) {
			return levelCol->LevelList[i];
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return NULL;
		}
	} while( true );
}



LevelIdentifier * __cdecl
lego::front::LevelCollection_LoadLinks(LevelCollection *levelCol,char *levelName)
{
	BOOL isLinked;
	LevelIdentifier *identifier;
	int colIndex;
	char *linkNames;
	uint numParts;
	LevelIdentifier **levelLinks;
	LevelIdentifier *linkIdentifier;
	uint i;
	char *stringParts [15];
	
	if (levelName != NULL) {
		isLinked = LevelCollection_IsLinked(levelCol,levelName);
		if (isLinked != 0) {
			linkIdentifier = LevelCollection_GetIdentifier(levelCol,levelName);
			return linkIdentifier;
		}
		identifier = (LevelIdentifier *)std::malloc(0x14);
		LevelCollection_SetLinked(levelCol,levelName,TRUE);
		LevelCollection_SetIdentifier(levelCol,levelName,identifier);
		if (identifier != NULL) {
			colIndex = LevelCollection_IndexOf(levelCol,levelName);
			if (colIndex != -1) {
				linkNames = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"LevelLinks",0);
				linkNames = cfg::CFG_CopyString(globs::legoGlobs.config,linkNames);
				identifier->index = colIndex;
				i = 0;
				if (linkNames == NULL) {
					identifier->LevelLinks = NULL;
				}
				else {
					numParts = util::Util_Tokenise(linkNames,stringParts,",");
					if (numParts == 0) goto LAB_004170bd;
					levelLinks = (LevelIdentifier **)std::malloc(numParts * 4);
					identifier->LevelLinks = levelLinks;
					if (numParts != 0) {
						do {
							linkIdentifier = LevelCollection_LoadLinks(levelCol,stringParts[i]);
							identifier->LevelLinks[i] = linkIdentifier;
							i += 1;
						} while (i < numParts);
						identifier->NumLinks = i;
						return identifier;
					}
				}
				identifier->NumLinks = 0;
				return identifier;
			}
LAB_004170bd:
			std::free(identifier);
			return NULL;
		}
	}
	return NULL;
}



BOOL __cdecl
lego::front::LevelIdentifier_RecurseCallbacks
					(LevelIdentifier *identifier,LevelIdentifierCallback callback,void *data)
{
	BOOL BVar1;
	uint uVar2;
	
	if ((identifier != NULL) && (identifier->field_10 == 0)) {
		identifier->field_10 = 1;
		BVar1 = (*callback)(identifier,data);
		if (BVar1 != 0) {
			return TRUE;
		}
		if ((identifier->LevelLinks != NULL) && (uVar2 = 0, identifier->NumLinks != 0)) {
			do {
				BVar1 = LevelIdentifier_RecurseCallbacks(identifier->LevelLinks[uVar2],callback,data);
				if (BVar1 != 0) {
					return TRUE;
				}
				uVar2 += 1;
			} while (uVar2 < identifier->NumLinks);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::front::LevelIdentifier_Callback_IncCount(LevelIdentifier *identifier,int *pCount)
{
	*pCount = *pCount + 1;
	return 0;
}



BOOL __cdecl
lego::front::LevelIdentifier_SearchCallback_FUN_00417180
					(LevelIdentifier *identifier,SearchLevelIdentifier_10 *search)
{
	int iVar1;
	
	iVar1 = search->currentIndex;
	if (search->searchIndex == iVar1) {
		search->resultIndex = iVar1;
		search->result = identifier;
		return TRUE;
	}
	search->currentIndex = iVar1 + 1;
	return 0;
}



LevelIdentifier * __cdecl
lego::front::LevelIdentifier_FindByUnkCallbacks_FUN_004171b0
					(LevelIdentifier *identifier,int searchIndex)
{
	BOOL BVar1;
	SearchLevelIdentifier_10 search;
	
	search.result = NULL;
	search.currentIndex = 0;
	search.resultIndex = 0;
	search.searchIndex = searchIndex;
	BVar1 = LevelIdentifier_RecurseCallbacks
										(identifier,LevelIdentifier_SearchCallback_FUN_00417180,&search);
	if (BVar1 != 0) {
		LevelCollections_ClearAllLinks();
		return search.result;
	}
	LevelCollections_ClearAllLinks();
	return NULL;
}



int __cdecl lego::front::LevelIdentifier_FUN_00417200(LevelIdentifier *identifier,int param_2)
{
	LevelIdentifier *pLVar1;
	
	pLVar1 = LevelIdentifier_FindByUnkCallbacks_FUN_004171b0(identifier,param_2);
	if (pLVar1 != NULL) {
		return pLVar1->index;
	}
	return -1;
}



void __cdecl
lego::front::LevelIdentifier_FUN_00417220
					(LevelIdentifier *identifier,int *ref_struct14_2,BOOL param_3)
{
	uint *puVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = 0;
	if ((identifier != NULL) && (identifier->field_10 == 0)) {
		if ((PROGRAMMER_MODE_1 < globs::mainGlobs.programmerLevel) ||
			 ((globs::mainGlobs.flags & CMD_TESTLEVELS) != CMD_NONE)) {
			ref_struct14_2[4] = 0;
		}
		identifier->field_10 = 1;
		if (((*ref_struct14_2 == 0) || (PROGRAMMER_MODE_1 < globs::mainGlobs.programmerLevel)) ||
			 ((globs::mainGlobs.flags & CMD_TESTLEVELS) != CMD_NONE)) {
			uVar3 = (uint)(ref_struct14_2[4] == 0);
		}
		else {
			uVar3 = *(uint *)(identifier->index * 0x3190 + *ref_struct14_2) & 1;
		}
		if (((uVar3 == 0) && (param_3 == 0)) &&
			 (puVar1 = (uint *)(*(int *)ref_struct14_2[2] + ref_struct14_2[3] * 0x20),
			 *(int *)(*(int *)ref_struct14_2[2] + 0x1c + ref_struct14_2[3] * 0x20) == 0)) {
			uVar2 = *puVar1 & 0xfffffffb;
		}
		else {
			puVar1 = (uint *)(*(int *)ref_struct14_2[2] + ref_struct14_2[3] * 0x20);
			uVar2 = *(uint *)(*(int *)ref_struct14_2[2] + ref_struct14_2[3] * 0x20) | 4;
		}
		*puVar1 = uVar2;
		ref_struct14_2[3] = ref_struct14_2[3] + 1;
		if (identifier->NumLinks != 0) {
			do {
				LevelIdentifier_FUN_00417220(identifier->LevelLinks[uVar4],ref_struct14_2,uVar3);
				uVar4 += 1;
			} while (uVar4 < identifier->NumLinks);
		}
	}
	return;
}



void __cdecl
lego::front::LevelIdentifier_FUN_00417310
					(LevelIdentifier *identifier,int param_2,LevelCollection *levelCol,
					MenuItemTrigger *param_4,undefined4 param_5)
{
	LevelIdentifier local_14;
	
	local_14.LevelLinks = (LevelIdentifier **)levelCol;
	local_14.NumLinks = (uint)param_4;
	local_14.index = param_2;
	local_14.field_c = 0;
	local_14.field_10 = param_5;
	LevelIdentifier_FUN_00417220(identifier,&local_14.index,TRUE);
	LevelCollections_ClearAllLinks();
	return;
}



longlong __cdecl
lego::front::Missions_SaveData_GetUnkField_FUN_00417360(int index,SaveData *saveData)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)saveData->missionsTable[index].reward.items[9].percentFloat);
	return lVar1;
}



void __cdecl
lego::front::Missions_StartMenuItemCallback_uses_testercall(float elapsed,int searchIndex)
{
	Font *font;
	SaveRewardFlags SVar1;
	MenuTextWindow *pMVar2;
	LevelIdentifier *identifier;
	SaveData *saveData;
	uint uVar3;
	char *pcVar4;
	int iVar5;
	undefined4 *puVar6;
	longlong lVar7;
	char buffLevel [64];
	char buffMsg [300];
	
	pMVar2 = globals::g_MenuSaveLevelWindow;
	font = globals::g_MainMenuFull->menus[1]->MenuFont;
	identifier = LevelIdentifier_FindByUnkCallbacks_FUN_004171b0
												 (globals::g_StartMissionLevel,searchIndex);
	pcVar4 = globals::g_MissionLevels.FullNames[identifier->index];
	buffLevel[0] = '\0';
	puVar6 = (undefined4 *)(buffLevel + 1);
	for (iVar5 = 0xf; iVar5 != 0; iVar5 += -1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	*(undefined2 *)puVar6 = 0;
	*(undefined *)((int)puVar6 + 2) = 0;
	saveData = save::Save_GetCurrentSaveData();
	globals::g_Missions_LastLevelNumber = globals::g_Missions_HoverLevelNumber;
	globals::g_Missions_HoverLevelNumber = identifier->index + 1;
	if ((globs::mainGlobs.flags & CMD_TESTERCALL) != CMD_NONE) {
		std::sprintf(buffLevel," (Level %d)",identifier->index + 1);
	}
	if ((pcVar4 == NULL) || (*pcVar4 == '\0')) {
		pcVar4 = globals::g_MissionLevels.LevelNames[identifier->index];
	}
	if (pMVar2->textWindow == NULL) {
		uVar3 = lego::image::Font_GetStringWidth(font,pcVar4);
		Missions_PrintF_LevelName(font,(int)globs::mainGlobs.appWidth / 2 - (int)uVar3 / 2,390,pcVar4);
	}
	else {
		if ((BOOL_004dc8c4 != 0) &&
			 (TextWindow_PrintF(pMVar2->textWindow,pcVar4),
			 (globs::mainGlobs.flags & CMD_TESTERCALL) != CMD_NONE)) {
			TextWindow_PrintF(pMVar2->textWindow,buffLevel);
		}
	}
	if (saveData != NULL) {
		SVar1 = saveData->missionsTable[identifier->index].flags;
		if (((SVar1 & SAVEREWARD_UNK_1) != SAVEREWARD_NONE) &&
			 ((SVar1 & SAVEREWARD_UNK_2) == SAVEREWARD_NONE)) {
			lVar7 = Missions_SaveData_GetUnkField_FUN_00417360(identifier->index,saveData);
			iVar5 = (int)lVar7;
			pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","Level_Completed",0);
			pcVar4 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar4);
			std::sprintf(buffMsg," %s (%i)",pcVar4,iVar5);
			util::stringReplaceChar(buffMsg,'_',' ');
			goto LAB_0041757a;
		}
	}
	pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Menu","Level_Incomplete",0);
	pcVar4 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar4);
	std::sprintf(buffMsg," %s",pcVar4);
	util::stringReplaceChar(buffMsg,'_',' ');
LAB_0041757a:
	if ((pMVar2->textWindow != NULL) && (BOOL_004dc8c4 != 0)) {
						// Ahhh, lovely... nested printf calls without sanitization,
						//  it may be possible to intentionally corrupt memory with this.
		TextWindow_PrintF(pMVar2->textWindow,buffMsg);
		if (globals::g_Missions_HoverLevelNumber != globals::g_Missions_LastLevelNumber) {
			BOOL_0055883c = TRUE;
			FLOAT_00558840 = 0.0;
		}
		if ((BOOL_0055883c != 0) &&
			 (FLOAT_00558840 = elapsed + FLOAT_00558840,
			 (ushort)((ushort)(FLOAT_00558840 * 25.0 < 500.0) << 8 |
							 (ushort)(FLOAT_00558840 * 25.0 == 500.0) << 0xe) == 0)) {
						// Uhhh, well then...
						//  tutorial levels are kind of hardcoded to max of 9...???
			if ((int)globals::g_Missions_HoverLevelNumber < 9) {
				iVar5 = Missions_StreamTutorialLevelNameSFX(globals::g_Missions_HoverLevelNumber);
			}
			else {
				iVar5 = Missions_StreamLevelNameSFX(globals::g_Missions_HoverLevelNumber - 8);
			}
			if (iVar5 != 0) {
				BOOL_0055883c = 0;
			}
		}
	}
	BOOL_004dc8c4 = 0;
	return;
}



void __cdecl lego::front::Missions_TutorialMenuItemCallback(float elapsed,int searchIndex)
{
	MenuTextWindow *pMVar1;
	LevelIdentifier *identifier;
	BOOL BVar2;
	char *fullLevelName;
	
	pMVar1 = globals::g_MenuSaveLevelWindow;
	identifier = LevelIdentifier_FindByUnkCallbacks_FUN_004171b0
												 (globals::g_StartTutorialLevel,searchIndex);
	fullLevelName = globals::g_TutorialLevels.FullNames[identifier->index];
	globals::g_Missions_LastLevelNumber = globals::g_Missions_HoverLevelNumber;
	globals::g_Missions_HoverLevelNumber = identifier->index + 1;
	if ((fullLevelName == NULL) || (*fullLevelName == '\0')) {
		fullLevelName = globals::g_TutorialLevels.LevelNames[identifier->index];
	}
	if ((pMVar1->textWindow != NULL) && (BOOL_004dc8c4 != 0)) {
		TextWindow_PrintF(pMVar1->textWindow,fullLevelName);
		if (globals::g_Missions_HoverLevelNumber != globals::g_Missions_LastLevelNumber) {
			BOOL_0055883c = TRUE;
			FLOAT_00558840 = 0.0;
		}
		if ((BOOL_0055883c != 0) &&
			 (FLOAT_00558840 = elapsed + FLOAT_00558840,
			 (ushort)((ushort)(FLOAT_00558840 * 25.0 < 500.0) << 8 |
							 (ushort)(FLOAT_00558840 * 25.0 == 500.0) << 0xe) == 0)) {
			BVar2 = Missions_StreamTutorialLevelNameSFX(globals::g_Missions_HoverLevelNumber);
			if (BVar2 != 0) {
				BOOL_0055883c = FALSE;
			}
		}
	}
	BOOL_004dc8c4 = FALSE;
	return;
}



BOOL __cdecl lego::front::Missions_AddLevelCallback(LevelIdentifier *identifier,int *search)
{
	char cVar1;
	undefined4 uVar2;
	char *pcVar3;
	int frontEndX;
	int frontEndY;
	BoolTri frontEndOpen;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char buff [1024];
	
	uVar2 = *(undefined4 *)(*(int *)(*search + 4) + identifier->index * 4);
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,uVar2,"FrontEndX",0);
	pcVar3 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar3);
	if (pcVar3 == NULL) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,uVar2,"FrontEndX",0);
		pcVar3 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar3);
	}
	frontEndX = std::atoi(pcVar3);
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,uVar2,"FrontEndY",0);
	pcVar3 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar3);
	if (pcVar3 == NULL) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,uVar2,"FrontEndY",0);
		pcVar3 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar3);
	}
	frontEndY = std::atoi(pcVar3);
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,uVar2,"FrontEndOpen",0);
	frontEndOpen = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar3);
	if (frontEndOpen == BOOL3_ERROR) {
		frontEndOpen = BOOL3_FALSE;
	}
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,uVar2,"MenuBMP",0);
	pcVar3 = cfg::CFG_CopyString(globs::legoGlobs.config,pcVar3);
	if (pcVar3 != NULL) {
		Missions_AddLevel((MenuItemMissions *)search[2],pcVar3,FALSE,NULL,frontEndX,frontEndY,
											frontEndOpen);
		std::free(pcVar3);
		return 0;
	}
	uVar4 = 0xffffffff;
	pcVar3 = globals::g_Menu_DefaultLevelBMPS;
	do {
		pcVar7 = pcVar3;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar7 = pcVar3 + 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	puVar8 = (undefined4 *)buff;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar8 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	Missions_AddLevel((MenuItemMissions *)search[2],buff,FALSE,NULL,frontEndX,frontEndY,frontEndOpen);
	return 0;
}



void __cdecl
lego::front::MainMenuFull_AddMissionsDisplay
					(int valueOffset,LevelIdentifier *startIdentifier,int *pLevelCount,SubMenu *in_submenu,
					undefined4 param_5,undefined4 param_6,void *callback)
{
	SubMenu *submenu;
	MenuItemMissions *itemData;
	MenuItem *menuItem;
	int *local_10;
	SubMenu *local_c;
	MenuItemMissions *local_8;
	undefined4 local_4;
	
	submenu = in_submenu;
	local_10 = pLevelCount;
	local_c = in_submenu;
	local_8 = NULL;
	local_4 = param_5;
	pLevelCount = NULL;
	LevelIdentifier_RecurseCallbacks(startIdentifier,LevelIdentifier_Callback_IncCount,&pLevelCount);
	LevelCollections_ClearAllLinks();
	itemData = Menu_CreateMissionsDisplay
											 (&globals::g_MainMenuFull_TriggerCredits + valueOffset,____EMPTYSTR__,
												____EMPTYSTR__,0,0,0,(int)pLevelCount,0,0,0,0,0,callback,param_6);
	menuItem = Menu_CreateBannerItem("Levels!!!",NULL,NULL,0,0,MENUITEM_MISSIONS,TRUE,itemData,FALSE);
	Menu_AddSubMenuItem(submenu,menuItem);
	local_8 = itemData;
	LevelIdentifier_RecurseCallbacks(startIdentifier,Missions_AddLevelCallback,&local_10);
	LevelCollections_ClearAllLinks();
	return;
}



BOOL __cdecl lego::save::Save_ReadSaveFile(uint saveIndex,SaveData *out_saveData,BOOL param_3)
{
	uint saveNumber;
	File *f;
	SaveReward *out_buffer;
	int iVar1;
	SaveData *pSVar2;
	undefined4 local_68;
	char buff [100];
	
	saveNumber = saveIndex;
	if (saveIndex < 6) {
		std::sprintf(buff,"%s\\%i.sav","Saves",saveIndex);
		f = lego::file::File_Open(buff,"rb");
		pSVar2 = out_saveData;
		if (f != NULL) {
			saveIndex = 0;
			local_68 = 0;
						// Read the data directly into the structure.
						//  This means we can learn from the file format! :D
			lego::file::File_Read(out_saveData,0xb0,1,f);
			front::LevelIdentifier_RecurseCallbacks
								(globals::g_StartMissionLevel,front::LevelIdentifier_Callback_IncCount,&saveIndex);
			front::LevelCollections_ClearAllLinks();
			front::LevelIdentifier_RecurseCallbacks
								(globals::g_StartTutorialLevel,front::LevelIdentifier_Callback_IncCount,&local_68);
			front::LevelCollections_ClearAllLinks();
			if ((pSVar2->missionsCount != saveIndex) && (param_3 == 0)) {
				Save_SPrintfFileUnkWrite__00417b00(saveNumber,NULL);
				for (iVar1 = 0x2e; iVar1 != 0; iVar1 += -1) {
					pSVar2->field_0x0 = 0;
					pSVar2 = (SaveData *)&pSVar2->field_0x4;
				}
				return 0;
			}
			out_buffer = (SaveReward *)std::malloc(pSVar2->missionsCount * 0x3190);
			pSVar2->missionsTable = out_buffer;
			lego::file::File_Read(out_buffer,0x3190,pSVar2->missionsCount,f);
			lego::file::File_Close(f);
			return TRUE;
		}
		if (param_3 == 0) {
			Save_SPrintfFileUnkWrite__00417b00(saveNumber,NULL);
		}
	}
	return 0;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl lego::save::Save_SPrintfFileUnkWrite__00417b00(uint saveNumber,SaveData *saveData)
{
	File *pFVar1;
	int iVar2;
	uint uVar3;
	undefined4 *puVar4;
	uint uStack12976;
	undefined4 uStack12972;
	undefined4 auStack12968 [5];
	uint auStack12948 [40];
	char acStack12788 [100];
	undefined4 uStack12688;
	undefined4 auStack12684 [3170];
	undefined4 uStack4;
	
	uStack4 = 0x417b0a;
	if (saveNumber < 6) {
		std::sprintf(acStack12788,"%s\\%i.sav","Saves",saveNumber);
		uVar3 = 0;
		if (saveData == NULL) {
			lego::file::File_MakeDir("Saves");
			pFVar1 = lego::file::File_Open(acStack12788,"wb");
			if (pFVar1 != NULL) {
				uStack12972 = 0;
				puVar4 = auStack12968;
				for (iVar2 = 0x2d; iVar2 != 0; iVar2 += -1) {
					*puVar4 = 0;
					puVar4 = puVar4 + 1;
				}
				uStack12688 = 0;
				auStack12968[1] = 7;
				puVar4 = auStack12684;
				for (iVar2 = 0xc63; iVar2 != 0; iVar2 += -1) {
					*puVar4 = 0;
					puVar4 = puVar4 + 1;
				}
				auStack12968[0] = 5;
				auStack12968[3] = 5;
				auStack12968[2] = 1;
				auStack12948[0] = 0;
				front::LevelIdentifier_RecurseCallbacks
									(globals::g_StartMissionLevel,front::LevelIdentifier_Callback_IncCount,
									 auStack12948);
				front::LevelCollections_ClearAllLinks();
				lego::file::File_Write(&uStack12972,0xb4,1,pFVar1);
				if (auStack12948[0] != 0) {
					do {
						lego::file::File_Write(&uStack12688,0x3190,1,pFVar1);
						uVar3 += 1;
					} while (uVar3 < auStack12948[0]);
				}
				lego::file::File_Close(pFVar1);
				return 1;
			}
		}
		else {
			uStack12976 = 0;
			front::LevelIdentifier_RecurseCallbacks
								(globals::g_StartMissionLevel,front::LevelIdentifier_Callback_IncCount,&uStack12976)
			;
			front::LevelCollections_ClearAllLinks();
			if (uStack12976 != saveData->missionsCount) {
				Save_SPrintfFileUnkWrite__00417b00(saveNumber,NULL);
				return 1;
			}
			pFVar1 = lego::file::File_Open(acStack12788,"wb");
			if (pFVar1 != NULL) {
				lego::file::File_Write(saveData,0xb0,1,pFVar1);
				if (saveData->missionsCount != 0) {
					lego::file::File_Write(saveData->missionsTable,0x3190,saveData->missionsCount,pFVar1);
				}
				lego::file::File_Close(pFVar1);
				std::sprintf(acStack12788,"%s\\%i.osf","Saves",saveNumber);
				ObjectRecall_SaveRROSFile(acStack12788);
				return TRUE;
			}
		}
	}
	return 0;
}



void __cdecl lego::save::Front_StructB8_HasClearSaves_FUN_00417d20(void)
{
	BOOL BVar1;
	SaveData *out_saveData;
	uint saveIndex;
	
	saveIndex = 0;
	out_saveData = globals::g_SaveData_TABLE;
	do {
		if ((globs::mainGlobs.flags & CMD_CLEANSAVES) == CMD_NONE) {
			BVar1 = Save_ReadSaveFile(saveIndex,out_saveData,0);
			if (BVar1 == 0) goto LAB_00417d53;
		}
		else {
			Save_SPrintfFileUnkWrite__00417b00(saveIndex,NULL);
LAB_00417d53:
			Save_ReadSaveFile(saveIndex,out_saveData,0);
		}
		out_saveData = out_saveData + 1;
		saveIndex += 1;
		if ((SaveData *)((int)&globals::g_SaveData_TABLE[5].field_0xb4 + 3U) < out_saveData) {
			return;
		}
	} while( true );
}



SaveData * __cdecl lego::save::Save_GetSaveData_OfNumber(int saveIndex)
{
	if ((saveIndex < 6) && (-1 < saveIndex)) {
		return globals::g_SaveData_TABLE + saveIndex;
	}
	return NULL;
}



SaveData * __cdecl lego::save::Save_GetCurrentSaveData(void)
{
	SaveData *pSVar1;
	
	if (globals::g_SaveNumber != -1) {
		pSVar1 = Save_GetSaveData_OfNumber(globals::g_SaveNumber);
		return pSVar1;
	}
	return NULL;
}



int __cdecl lego::save::Save_GetSaveNumber(void)
{
	return globals::g_SaveNumber;
}



void __cdecl lego::save::Save_SetSaveNumber(int saveIndex)
{
	globals::g_SaveNumber = saveIndex;
	return;
}



void __cdecl lego::front::Front_LevelSave_Unk_FUN_00417de0(uint levelIndex)
{
	SaveData *save;
	BOOL BVar1;
	
	save = lego::save::Save_GetCurrentSaveData();
	if (save != NULL) {
		BVar1 = Front_GetUnkTutoOrMissions();
		if (BVar1 == 0) {
			if (7 < levelIndex) {
				if (save->missionsCount <= levelIndex && levelIndex != save->missionsCount) {
					return;
				}
				save->missionsTable[levelIndex].flags =
						 save->missionsTable[levelIndex].flags | SAVEREWARD_UNK_1;
				return;
			}
		}
		else {
			if (7 < levelIndex) {
				return;
			}
		}
		save->missionsTable[levelIndex].flags = save->missionsTable[levelIndex].flags | SAVEREWARD_UNK_1
		;
		save->missionsTable[levelIndex].flags = save->missionsTable[levelIndex].flags | SAVEREWARD_UNK_2
		;
	}
	return;
}



void __cdecl lego::save::SaveStruct18_FUN_00417e50(SaveStruct_18 *param_1)
{
	SaveData *pSVar1;
	int iVar2;
	SaveStruct_18 *pSVar3;
	
	pSVar1 = Save_GetCurrentSaveData();
	if (pSVar1 != NULL) {
		pSVar3 = &pSVar1->saveStruct18_1c;
		for (iVar2 = 6; iVar2 != 0; iVar2 += -1) {
			*(undefined4 *)pSVar3 = *(undefined4 *)param_1;
			param_1 = (SaveStruct_18 *)&param_1->field_0x4;
			pSVar3 = (SaveStruct_18 *)&pSVar3->field_0x4;
		}
	}
	return;
}



BOOL __cdecl lego::front::Front_CopyRewardToSave(int levelIndex,RewardLevel *reward)
{
	SaveData *save;
	int iVar1;
	SaveReward *pSVar2;
	
	save = lego::save::Save_GetCurrentSaveData();
	if ((save != NULL) && (levelIndex < (int)save->missionsCount)) {
						// std::memcpy( & save->missionsTable[levelIndex].reward, reward );
		pSVar2 = save->missionsTable + levelIndex;
		for (iVar1 = 0xc63; pSVar2 = (SaveReward *)&pSVar2->reward, iVar1 != 0; iVar1 += -1) {
			pSVar2->flags = reward->Enabled;
			reward = (RewardLevel *)&reward->saveHasCapture;
		}
		return TRUE;
	}
	return 0;
}



int __cdecl lego::front::LevelIndex_FUN_00417ec0(int levelIndex)
{
	SaveData *pSVar1;
	
	pSVar1 = save::Save_GetCurrentSaveData();
	if ((pSVar1 != NULL) && (levelIndex < (int)pSVar1->missionsCount)) {
		return (int)&pSVar1->missionsTable[levelIndex].reward;
	}
	return (int)NULL;
}



BOOL __cdecl lego::front::Front_FUN_00417ef0(void)
{
	SaveData *saveData;
	BOOL BVar1;
	
	saveData = save::Save_GetCurrentSaveData();
	BVar1 = save::Save_SPrintfFileUnkWrite__00417b00(globals::g_SaveNumber,saveData);
	return BVar1;
}



BOOL __cdecl lego::front::Front_GetBool_00558500(void)
{
	return BOOL_00558500;
}



void __cdecl lego::front::Front_SetBool_00558500(BOOL state)
{
	BOOL_00558500 = state;
	return;
}



void __cdecl lego::front::Front_FUN_00417f30(void)
{
	int saveNumber;
	SaveData *saveData;
	
	saveData = NULL;
	saveNumber = save::Save_GetSaveNumber();
	save::Save_SPrintfFileUnkWrite__00417b00(saveNumber,saveData);
	LevelIdentifier_FUN_00417310
						(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
						 *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10),1);
	return;
}



void __cdecl lego::save::Save_CopyData(SaveData *out_saveData)
{
	SaveData *pSVar1;
	SaveReward *pSVar2;
	int iVar3;
	uint uVar4;
	SaveData *pSVar5;
	SaveReward *pSVar6;
	
	pSVar1 = Save_GetCurrentSaveData();
	if (pSVar1 != NULL) {
		pSVar1 = Save_GetCurrentSaveData();
		pSVar5 = out_saveData;
		for (iVar3 = 0x2e; iVar3 != 0; iVar3 += -1) {
			pSVar5->field_0x0 = pSVar1->field_0x0;
			pSVar1 = (SaveData *)&pSVar1->field_0x4;
			pSVar5 = (SaveData *)&pSVar5->field_0x4;
		}
		pSVar2 = (SaveReward *)std::malloc(out_saveData->missionsCount * 0x3190);
		out_saveData->missionsTable = pSVar2;
		if (pSVar2 != NULL) {
			uVar4 = out_saveData->missionsCount;
			pSVar1 = Save_GetCurrentSaveData();
			pSVar2 = pSVar1->missionsTable;
			pSVar6 = out_saveData->missionsTable;
			for (uVar4 = uVar4 * 0x3190 >> 2; uVar4 != 0; uVar4 -= 1) {
				pSVar6->flags = pSVar2->flags;
				pSVar2 = (SaveReward *)&pSVar2->reward;
				pSVar6 = (SaveReward *)&pSVar6->reward;
			}
			for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
				*(undefined *)&pSVar6->flags = *(undefined *)&pSVar2->flags;
				pSVar2 = (SaveReward *)((int)&pSVar2->flags + 1);
				pSVar6 = (SaveReward *)((int)&pSVar6->flags + 1);
			}
		}
	}
	return;
}



void __cdecl lego::front::Save_OverwriteData(SaveData *saveData)
{
	SaveData *pSVar1;
	SaveData *pSVar2;
	int iVar3;
	
	pSVar1 = save::Save_GetCurrentSaveData();
	if (pSVar1 != NULL) {
		pSVar1 = save::Save_GetCurrentSaveData();
		if (pSVar1->missionsTable != NULL) {
			pSVar1 = save::Save_GetCurrentSaveData();
			std::free(pSVar1->missionsTable);
		}
		pSVar2 = save::Save_GetCurrentSaveData();
		pSVar1 = saveData;
		for (iVar3 = 0x2e; iVar3 != 0; iVar3 += -1) {
			pSVar2->field_0x0 = pSVar1->field_0x0;
			pSVar1 = (SaveData *)&pSVar1->field_0x4;
			pSVar2 = (SaveData *)&pSVar2->field_0x4;
		}
		pSVar1 = save::Save_GetCurrentSaveData();
		pSVar1->missionsTable = saveData->missionsTable;
	}
	return;
}



void __cdecl lego::front::Front_SetBool_0055881c(BOOL state)
{
	BOOL_0055881c = state;
	return;
}



BOOL __cdecl lego::front::Front_SaveData_FUN_00418050(void)
{
	SaveData *save;
	uint uVar1;
	uint uVar2;
	int iVar3;
	longlong lVar4;
	
	save = lego::save::Save_GetCurrentSaveData();
	if (save != NULL) {
		uVar1 = 0;
		uVar2 = 8;
		save = lego::save::Save_GetCurrentSaveData();
		if (8 < save->missionsCount) {
			iVar3 = 0x18c80;
			do {
				save = lego::save::Save_GetCurrentSaveData();
				lVar4 = __ftol((float10)*(float *)((save->missionsTable->reward).items[9].Text +
																					iVar3 + -0x1c));
				uVar1 += (int)lVar4;
				uVar2 += 1;
				iVar3 += 0x3190;
				save = lego::save::Save_GetCurrentSaveData();
			} while (uVar2 < save->missionsCount);
		}
		save = lego::save::Save_GetCurrentSaveData();
		if (99 < uVar1 / (save->missionsCount - 8)) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::front::HelpWindow_SetFont(Font *font)
{
	globs::helpwindowGlobs.font = font;
	return;
}



void __cdecl lego::front::HelpWindow_ClearFlag1(void)
{
						// &= ~HELPWINDOW_UNK_1 (~0x1)
	globs::helpwindowGlobs.flags = globs::helpwindowGlobs.flags & ~HELPWINDOW_UNK_1;
	return;
}



void __cdecl lego::front::HelpWindow_Initialise(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	int iVar4;
	Area2F rect;
	char *stringParts [16];
	
	HelpWindow_LoadLevelsInfo(root,rootPath);
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","BackGroundImage",0);
	pcVar3 = cfg::CFG_CopyString(root,pcVar3);
	if (pcVar3 != NULL) {
		util::Util_Tokenise(pcVar3,stringParts,",");
		globs::helpwindowGlobs.BackgroundImage = lego::image::Image_LoadBMPScaled(stringParts[0],0,0);
		if (globs::helpwindowGlobs.BackgroundImage != NULL) {
			lego::image::Image_SetupTrans(globs::helpwindowGlobs.BackgroundImage,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		iVar4 = std::atoi(stringParts[1]);
		globs::helpwindowGlobs.BackgroundPosition.x = (float)iVar4;
		iVar4 = std::atoi(stringParts[2]);
		globs::helpwindowGlobs.BackgroundPosition.y = (float)iVar4;
		std::free(pcVar3);
	}
	HelpWindow_LoadButtons(root,rootPath);
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","TextWindowArea",0);
	pcVar3 = cfg::CFG_CopyString(root,pcVar3);
	if (pcVar3 != NULL) {
		util::Util_Tokenise(pcVar3,stringParts,",");
		iVar4 = std::atoi(stringParts[0]);
		rect.x = (float)iVar4;
		iVar4 = std::atoi(stringParts[1]);
		rect.y = (float)iVar4;
		iVar4 = std::atoi(stringParts[2]);
		rect.width = (float)iVar4;
		iVar4 = std::atoi(stringParts[3]);
		rect.height = (float)iVar4;
		globs::helpwindowGlobs.textWnd = TextWindow_Create(globs::helpwindowGlobs.font,&rect,0x400);
		globs::helpwindowGlobs.TextWindowBottom = rect.y + rect.height;
		globs::helpwindowGlobs.TextWindowPosition.x = rect.x;
		globs::helpwindowGlobs.TextWindowPosition.y = rect.y;
		std::free(pcVar3);
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanBuildMessage",0);
	globs::helpwindowGlobs.CanBuildMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globs::helpwindowGlobs.CanBuildMessage != NULL) {
		cVar2 = *globs::helpwindowGlobs.CanBuildMessage;
		pcVar3 = globs::helpwindowGlobs.CanBuildMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanTransportMessage",0);
	globs::helpwindowGlobs.CanTransportMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globs::helpwindowGlobs.CanTransportMessage != NULL) {
		cVar2 = *globs::helpwindowGlobs.CanTransportMessage;
		pcVar3 = globs::helpwindowGlobs.CanTransportMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanBuildAndTransportMessage",0);
	globs::helpwindowGlobs.CanBuildAndTransportMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globs::helpwindowGlobs.CanBuildAndTransportMessage != NULL) {
		cVar2 = *globs::helpwindowGlobs.CanBuildAndTransportMessage;
		pcVar3 = globs::helpwindowGlobs.CanBuildAndTransportMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
						// |= (HELPWINDOW_UNK_4|HELPWINDOW_UNK_2) (0x4 | 0x2)
	globs::helpwindowGlobs.flags =
			 globs::helpwindowGlobs.flags & 0xffffff00 |
			 globs::helpwindowGlobs.flags & 0xff | HELPWINDOW_UNK_4 | HELPWINDOW_UNK_2;
	HelpWindow_SetEnabled(FALSE,FALSE);
	return;
}



void __cdecl lego::front::HelpWindow_LoadLevelsInfo(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	uint uVar5;
	char *(*papcVar6) [16];
	char local_400 [1024];
	
	uVar4 = 0;
	if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
		papcVar6 = globs::helpwindowGlobs.VehicleInfos;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globs::legoGlobs.VehicleTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				(*papcVar6)[0] = pcVar3;
				if (pcVar3 != NULL) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 += 1;
				papcVar6 = (char *(*) [16])(*papcVar6 + 1);
			} while (uVar5 < 0x10);
			uVar4 += 1;
		} while (uVar4 < globs::legoGlobs.VehicleTypes_COUNT);
	}
	uVar4 = 0;
	if (globs::legoGlobs.MiniFigureTypes_COUNT != 0) {
		papcVar6 = globs::helpwindowGlobs.MiniFigureInfos;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globs::legoGlobs.MiniFigureTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				(*papcVar6)[0] = pcVar3;
				if (pcVar3 != NULL) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 += 1;
				papcVar6 = (char *(*) [16])(*papcVar6 + 1);
			} while (uVar5 < 0x10);
			uVar4 += 1;
		} while (uVar4 < globs::legoGlobs.MiniFigureTypes_COUNT);
	}
	uVar4 = 0;
	if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
		papcVar6 = globs::helpwindowGlobs.BuildingInfos;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globs::legoGlobs.BuildingTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				(*papcVar6)[0] = pcVar3;
				if (pcVar3 != NULL) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 += 1;
				papcVar6 = (char *(*) [16])(*papcVar6 + 1);
			} while (uVar5 < 0x10);
			uVar4 += 1;
		} while (uVar4 < globs::legoGlobs.BuildingTypes_COUNT);
	}
	return;
}



void __cdecl lego::front::HelpWindow_LoadButtons(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	char *stringParts [16];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"HelpWindow","ContinueButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,stringParts,",");
		iVar2 = std::atoi(stringParts[0]);
		globs::helpwindowGlobs.Buttons[0].window.x =
				 (float)iVar2 + globs::helpwindowGlobs.BackgroundPosition.x;
		iVar2 = std::atoi(stringParts[1]);
		globs::helpwindowGlobs.Buttons[0].window.y =
				 (float)iVar2 + globs::helpwindowGlobs.BackgroundPosition.y;
		iVar2 = std::atoi(stringParts[2]);
		globs::helpwindowGlobs.Buttons[0].window.width = (float)iVar2;
		iVar2 = std::atoi(stringParts[3]);
		globs::helpwindowGlobs.Buttons[0].window.height = (float)iVar2;
		globs::helpwindowGlobs.Buttons[0].HiImage = lego::image::Image_LoadBMPScaled(stringParts[4],0,0)
		;
		globs::helpwindowGlobs.Buttons[0].LoImage = lego::image::Image_LoadBMPScaled(stringParts[5],0,0)
		;
		globs::helpwindowGlobs.Buttons[0].Text = util::Util_RemoveUnderscores(stringParts[6]);
		ToolTip_SetText(TOOLTIP_INFOMENUCONTINUE,globs::helpwindowGlobs.Buttons[0].Text);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CancelFutureButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,stringParts,",");
		iVar2 = std::atoi(stringParts[0]);
		globs::helpwindowGlobs.Buttons[1].window.x =
				 (float)iVar2 + globs::helpwindowGlobs.BackgroundPosition.x;
		iVar2 = std::atoi(stringParts[1]);
		globs::helpwindowGlobs.Buttons[1].window.y =
				 (float)iVar2 + globs::helpwindowGlobs.BackgroundPosition.y;
		iVar2 = std::atoi(stringParts[2]);
		globs::helpwindowGlobs.Buttons[1].window.width = (float)iVar2;
		iVar2 = std::atoi(stringParts[3]);
		globs::helpwindowGlobs.Buttons[1].window.height = (float)iVar2;
		globs::helpwindowGlobs.Buttons[1].HiImage = lego::image::Image_LoadBMPScaled(stringParts[4],0,0)
		;
		globs::helpwindowGlobs.Buttons[1].LoImage = lego::image::Image_LoadBMPScaled(stringParts[5],0,0)
		;
		globs::helpwindowGlobs.Buttons[1].Text = util::Util_RemoveUnderscores(stringParts[6]);
		ToolTip_SetText(TOOLTIP_INFOMENUDISABLEFUTURE,globs::helpwindowGlobs.Buttons[1].Text);
	}
	return;
}



void __cdecl lego::front::HelpWindow_IfFlag4_AndParam_Clear1_Set2_Else_Clear3(BOOL state)
{
	if ((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_4) != HELPWINDOW_NONE) {
		if (state != 0) {
						// &= ~HELPWINDOW_UNK_1; (~0x1)
						// |= HELPWINDOW_UNK_2; (0x2)
			globs::helpwindowGlobs.flags =
					 globs::helpwindowGlobs.flags & 0xffffff00 |
					 globs::helpwindowGlobs.flags & 0xfe | HELPWINDOW_UNK_2;
			return;
		}
		globs::helpwindowGlobs.flags &= ~(HELPWINDOW_UNK_1|HELPWINDOW_UNK_2);
	}
	return;
}



void __cdecl
lego::front::HelpWindow_RecallDependencies
					(ObjectType objType,int objIndex,int objLevel,BOOL noHelpWindow)
{
	BOOL BVar1;
	
	game::Dependencies_Prepare_Unk();
	BVar1 = game::Dependencies_Object_GetLevelFlag_100(objType,objIndex,objLevel);
	if (BVar1 == 0) {
		game::Dependencies_Object_AddLevelFlag_100(objType,objIndex,objLevel);
		if (noHelpWindow == 0) {
			globs::helpwindowGlobs.activeObjType = objType;
			globs::helpwindowGlobs.activeObjIndex = objIndex;
			globs::helpwindowGlobs.activeObjLevel = objLevel;
			if (objType == OBJECT_VEHICLE) {
				globs::helpwindowGlobs.activeObjName =
						 globs::helpwindowGlobs.VehicleInfos[objIndex][objLevel];
			}
			else {
				if (objType == OBJECT_MINIFIGURE) {
					globs::helpwindowGlobs.activeObjName =
							 globs::helpwindowGlobs.MiniFigureInfos[objIndex][objLevel];
				}
				else {
					if (objType == OBJECT_BUILDING) {
						globs::helpwindowGlobs.activeObjName =
								 globs::helpwindowGlobs.BuildingInfos[objIndex][objLevel];
					}
				}
			}
			TextWindow_Clear(globs::helpwindowGlobs.textWnd);
			globs::helpwindowGlobs.flags |= HELPWINDOW_UNK_8;
			HelpWindow_Object_Unlock(objType,objIndex,objLevel);
			globs::helpwindowGlobs.flags |= HELPWINDOW_UNK_1;
			globs::helpwindowGlobs.float_d58 = 0.0;
			globs::helpwindowGlobs.float_d5c = 0.0;
		}
	}
	return;
}



void __cdecl lego::front::HelpWindow_Object_Unlock(ObjectType objType,int objIndex,int objLevel)
{
	int iVar1;
	int iVar2;
	BOOL BVar3;
	int *pUnlock;
	uint i;
	DependencyUnlocks unlocks;
	
	i = 0;
	globs::helpwindowGlobs.unlockedCount = 0;
	game::Dependencies_Object_Unlock(objType,objIndex,objLevel,&unlocks);
	if (unlocks.count != 0) {
		pUnlock = unlocks.objIndexes;
		do {
			BVar3 = game::Dependencies_Object_IsLevelFlag4(pUnlock[-0x20],*pUnlock,pUnlock[0x20]);
			if (BVar3 != 0) {
				iVar1 = *pUnlock;
				globs::helpwindowGlobs.unlockedObjTypes[globs::helpwindowGlobs.unlockedCount] =
						 pUnlock[-0x20];
				iVar2 = pUnlock[0x20];
				globs::helpwindowGlobs.unlockedObjIndexes[globs::helpwindowGlobs.unlockedCount] = iVar1;
				globs::helpwindowGlobs.unlockedObjLevels[globs::helpwindowGlobs.unlockedCount] = iVar2;
				globs::helpwindowGlobs.unlockedCount += 1;
			}
			i += 1;
			pUnlock = pUnlock + 1;
		} while (i < unlocks.count);
	}
	return;
}



void __cdecl lego::front::HelpWindow_Close_FUN_00418900(void)
{
	if (((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_2) != HELPWINDOW_NONE) &&
		 ((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_1) != HELPWINDOW_NONE)) {
		game::Game_SetPaused(FALSE,FALSE);
		game::Game_SetMenuNextPosition(NULL);
		globs::helpwindowGlobs.flags &= ~HELPWINDOW_UNK_1;
	}
	return;
}



void __cdecl lego::front::HelpWindow_FUN_00418930(void)
{
	BOOL BVar1;
	TutorialFlags TVar2;
	Image *image;
	char *pcVar3;
	ObjectType *pOVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	float10 fVar8;
	longlong lVar9;
	char *format;
	undefined8 uVar10;
	float local_14;
	Point2F local_10;
	Point2F local_8;
	
	BVar1 = HelpWindow_IsEnabled();
	if (BVar1 == 0) {
		HelpWindow_Close_FUN_00418900();
	}
	BVar1 = HelpWindow_IsEnabled();
	if (BVar1 == 0) {
		return;
	}
	if ((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_2) == HELPWINDOW_NONE) {
		return;
	}
	if ((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_1) == HELPWINDOW_NONE) {
		return;
	}
	TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar2 & TUTORIAL_UNK_800) != TUTORIAL_NONE) {
		return;
	}
	game::Game_SetPaused(0,TRUE);
	if ((globs::helpwindowGlobs.activeObjName == NULL) && (globs::helpwindowGlobs.unlockedCount == 0))
	{
		HelpWindow_Close_FUN_00418900();
		return;
	}
	if (globs::helpwindowGlobs.BackgroundImage != NULL) {
		lego::image::Image_DisplayScaled
							(globs::helpwindowGlobs.BackgroundImage,NULL,
							 &globs::helpwindowGlobs.BackgroundPosition,NULL);
	}
	if ((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_8) != HELPWINDOW_NONE) {
		if (globs::helpwindowGlobs.activeObjName != NULL) {
			TextWindow_PrintF(globs::helpwindowGlobs.textWnd,"%s",globs::helpwindowGlobs.activeObjName);
		}
		globs::helpwindowGlobs.flags &= ~HELPWINDOW_UNK_8;
	}
	if (globs::helpwindowGlobs.activeObjName == NULL) {
		lVar9 = __ftol((float10)globs::helpwindowGlobs.TextWindowPosition.y);
		local_14 = (float)lVar9;
	}
	else {
		TextWindow_Update(globs::helpwindowGlobs.textWnd,0,0.0,(int *)&local_14);
	}
	if (globs::helpwindowGlobs.unlockedCount == 0) goto LAB_00418cb8;
	local_8.x = local_14;
	local_8.y = 0.0;
	iVar7 = 0;
	iVar6 = 0;
	local_10.y = (float)(ulonglong)(uint)local_14 - -10.0;
	local_10.x = globs::helpwindowGlobs.TextWindowPosition.x;
	if (globs::helpwindowGlobs.unlockedCount != 0) {
		pOVar4 = globs::helpwindowGlobs.unlockedObjTypes;
		uVar5 = globs::helpwindowGlobs.unlockedCount;
		do {
			if (*pOVar4 == OBJECT_VEHICLE) {
				iVar6 += 1;
			}
			else {
				if (*pOVar4 == OBJECT_BUILDING) {
					iVar7 += 1;
				}
			}
			pOVar4 = pOVar4 + 1;
			uVar5 -= 1;
		} while (uVar5 != 0);
	}
	if (iVar6 == 0) {
		if (globs::helpwindowGlobs.CanBuildMessage != NULL) {
			uVar10 = CONCAT44(globs::helpwindowGlobs.CanBuildMessage,0x4a2d60);
			lVar9 = __ftol((float10)local_10.y);
			iVar6 = (int)lVar9;
			lVar9 = __ftol((float10)local_10.x);
			iVar7 = (int)lVar9;
			goto override_prt_418b00_2c9bc250;
		}
	}
	else {
		if (iVar7 == 0) {
			if (globs::helpwindowGlobs.CanTransportMessage != NULL) {
				uVar10 = CONCAT44(globs::helpwindowGlobs.CanTransportMessage,0x4a2d60);
				lVar9 = __ftol((float10)local_10.y);
				iVar6 = (int)lVar9;
				lVar9 = __ftol((float10)local_10.x);
				iVar7 = (int)lVar9;
override_prt_418b00_2c9bc250:
				lego::image::Font_PrintF
									(globs::helpwindowGlobs.font,iVar7,iVar6,(char *)uVar10,
									 (char *)((ulonglong)uVar10 >> 0x20));
			}
		}
		else {
			if (globs::helpwindowGlobs.CanBuildAndTransportMessage != NULL) {
				uVar10 = CONCAT44(globs::helpwindowGlobs.CanBuildAndTransportMessage,0x4a2d60);
				lVar9 = __ftol((float10)local_10.y);
				iVar6 = (int)lVar9;
				lVar9 = __ftol((float10)local_10.x);
				iVar7 = (int)lVar9;
				goto override_prt_418b00_2c9bc250;
			}
		}
	}
	uVar5 = lego::image::Font_GetHeight(globs::helpwindowGlobs.font);
	local_8.x = (float)(uVar5 + 10);
	local_8.y = 0.0;
	local_10.y = (float)(ulonglong)(uint)local_8.x + local_10.y;
	fVar8 = std::floor((double)globs::helpwindowGlobs.float_d58);
	local_10.y = (float)((float10)local_10.y -
											((float10)globs::helpwindowGlobs.float_d58 - fVar8) * (float10)45.0);
	fVar8 = std::floor((double)globs::helpwindowGlobs.float_d58);
	lVar9 = __ftol(fVar8);
	uVar5 = (uint)lVar9;
	if (uVar5 < globs::helpwindowGlobs.unlockedCount) {
		pOVar4 = globs::helpwindowGlobs.unlockedObjTypes + uVar5;
		do {
			local_10.x = globs::helpwindowGlobs.TextWindowPosition.x;
			image = Interface_GetObjectBuildImage(*pOVar4,pOVar4[0x1e],TRUE);
			if (image != NULL) {
				if (globs::helpwindowGlobs.TextWindowBottom <= (float)image->height + local_10.y) {
					if (globs::helpwindowGlobs.float_d5c == 0.0) {
						local_8.y = 0.0;
						local_8.x = (float)((globs::helpwindowGlobs.unlockedCount - uVar5) - 1);
						globs::helpwindowGlobs.float_d5c = (float)(ulonglong)(uint)local_8.x;
					}
					if (globs::helpwindowGlobs.float_d58 < globs::helpwindowGlobs.float_d5c) {
						local_8.x = 345.0;
						local_8.y = 350.0;
						game::Game_SetMenuNextPosition(&local_8);
					}
					break;
				}
				lego::image::Image_DisplayScaled(image,NULL,&local_10,NULL);
			}
			local_10.x = local_10.x - -50.0;
			local_10.y = local_10.y - -10.0;
			pcVar3 = game::Object_GetTheName(*pOVar4,pOVar4[0x1e]);
			format = "%s";
			lVar9 = __ftol((float10)local_10.y);
			iVar6 = (int)lVar9;
			lVar9 = __ftol((float10)local_10.x);
			lego::image::Font_PrintF(globs::helpwindowGlobs.font,(int)lVar9,iVar6,format,pcVar3);
			local_10.y = local_10.y - -35.0;
			uVar5 += 1;
			pOVar4 = pOVar4 + 1;
			if (globs::helpwindowGlobs.unlockedCount <= uVar5) {
				HelpWindow_DrawButtons();
				return;
			}
		} while( true );
	}
LAB_00418cb8:
	HelpWindow_DrawButtons();
	return;
}



BOOL __cdecl
lego::front::HelpWindow_FUN_00418cd0
					(uint mouseX,uint mouseY,BOOL leftButton,BOOL leftLast,BOOL leftReleased,float elapsed)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	MenuButton *pMVar5;
	uint uVar6;
	
	if (((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_2) != HELPWINDOW_NONE) &&
		 ((globs::helpwindowGlobs.flags & HELPWINDOW_UNK_1) != HELPWINDOW_NONE)) {
		globs::helpwindowGlobs.flags &= ~(HELPWINDOW_UNK_10|HELPWINDOW_UNK_20);
		fVar3 = (float)(ulonglong)mouseX;
		if ((345.0 <= fVar3) &&
			 ((((fVar1 = (float)(globs::legoGlobs.NextButtonImage)->width - -345.0,
					(ushort)((ushort)(fVar3 < fVar1) << 8 | (ushort)(fVar3 == fVar1) << 0xe) != 0 &&
					(fVar1 = (float)(ulonglong)mouseY, 350.0 <= fVar1)) &&
				 (fVar2 = (float)(globs::legoGlobs.NextButtonImage)->height - -350.0,
				 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
				(ToolTip_AddFlag4(TOOLTIP_MORE), leftReleased != 0)))) {
			HelpWindow_FUN_00418f60(3,5.0);
			game::Game_SetPointer_AndPlayEnumSFX(0);
		}
		uVar6 = 0;
		pMVar5 = globs::helpwindowGlobs.Buttons;
		do {
			fVar1 = (pMVar5->window).x;
			fVar2 = (pMVar5->window).y;
			if (((fVar1 <= fVar3) &&
					(fVar1 = fVar1 + (pMVar5->window).width,
					(ushort)((ushort)(fVar3 < fVar1) << 8 | (ushort)(fVar3 == fVar1) << 0xe) != 0)) &&
				 ((fVar1 = (float)(ulonglong)mouseY, fVar2 <= fVar1 &&
					(fVar2 = fVar2 + (pMVar5->window).height,
					(ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)))) {
				globs::helpwindowGlobs.flags |= HELPWINDOW_UNK_10;
				globs::helpwindowGlobs.count_d60 = uVar6;
				BVar4 = HelpWindow_FUN_00418ef0(uVar6,leftButton,leftLast);
				if ((BVar4 != 0) && (leftReleased != 0)) {
					HelpWindow_FUN_00418f60(uVar6,elapsed);
					game::Game_SetPointer_AndPlayEnumSFX(0);
				}
				if ((leftButton == 0) && (leftReleased == 0)) {
					HelpWindow_ToolTip_FUN_00418eb0(uVar6);
				}
				return TRUE;
			}
			pMVar5 = pMVar5 + 1;
			uVar6 += 1;
		} while (pMVar5 < globs::helpwindowGlobs.Buttons + 2);
		HelpWindow_FUN_00418ef0(4,leftButton,leftLast);
	}
	return 0;
}



void __cdecl lego::front::HelpWindow_ToolTip_FUN_00418eb0(int param_1)
{
	if (true) {
		switch(param_1) {
		case 0:
			ToolTip_AddFlag4(TOOLTIP_INFOMENUCONTINUE);
			return;
		case 1:
			ToolTip_AddFlag4(TOOLTIP_INFOMENUDISABLEFUTURE);
		}
	}
	return;
}



BOOL __cdecl lego::front::HelpWindow_FUN_00418ef0(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = globs::helpwindowGlobs.field_d64;
	if (param_2 == 0) {
		globs::helpwindowGlobs.field_d64 = 4;
	}
	else {
		if (globs::helpwindowGlobs.field_d64 == 4) {
			if (param_3 == 0) {
				globs::helpwindowGlobs.field_d64 = param_1;
				globs::helpwindowGlobs.flags = globs::helpwindowGlobs.flags | HELPWINDOW_UNK_20;
				return (uint)(param_1 == 4);
			}
		}
		else {
			if (globs::helpwindowGlobs.field_d64 == param_1) {
				globs::helpwindowGlobs.flags = globs::helpwindowGlobs.flags | HELPWINDOW_UNK_20;
				return (uint)(globs::helpwindowGlobs.field_d64 == param_1);
			}
		}
	}
	return (uint)(iVar1 == param_1);
}



void __cdecl lego::front::HelpWindow_FUN_00418f60(undefined4 param_1,float elapsed)
{
	switch(param_1) {
	case 0:
		HelpWindow_Close_FUN_00418900();
		return;
	case 1:
		HelpWindow_SetEnabled(1,0);
		HelpWindow_Close_FUN_00418900();
		return;
	case 2:
		if (((ushort)((ushort)(globs::helpwindowGlobs.float_d58 < 0.0) << 8 |
								 (ushort)(globs::helpwindowGlobs.float_d58 == 0.0) << 0xe) == 0) &&
			 (globs::helpwindowGlobs.float_d58 = globs::helpwindowGlobs.float_d58 - elapsed * 0.2,
			 globs::helpwindowGlobs.float_d58 < 0.0)) {
			globs::helpwindowGlobs.float_d58 = 0.0;
			return;
		}
		break;
	case 3:
		if ((globs::helpwindowGlobs.float_d58 < globs::helpwindowGlobs.float_d5c) &&
			 (globs::helpwindowGlobs.float_d58 = globs::helpwindowGlobs.float_d58 - elapsed * -0.2,
			 globs::helpwindowGlobs.float_d5c <= globs::helpwindowGlobs.float_d58)) {
			globs::helpwindowGlobs.float_d58 = globs::helpwindowGlobs.float_d5c;
			game::Game_SetMenuNextPosition(NULL);
		}
	}
	return;
}



void __cdecl lego::front::HelpWindow_DrawButtons(void)
{
	Image *image;
	float *pfVar1;
	int buttonIndex;
	Point2F position;
	
	buttonIndex = 0;
	pfVar1 = &globs::helpwindowGlobs.Buttons[0].window.y;
	do {
		position.x = pfVar1[-1];
		position.y = *pfVar1;
		image = HelpWindow_GetButtonImage(buttonIndex);
		if (image != NULL) {
			lego::image::Image_DisplayScaled(image,NULL,&position,NULL);
		}
		pfVar1 = pfVar1 + 7;
		buttonIndex += 1;
	} while (pfVar1 < &globs::helpwindowGlobs.Buttons[2].window.y);
	return;
}



Image * __cdecl lego::front::HelpWindow_GetButtonImage(int buttonIndex)
{
	if ((buttonIndex == 1) && (((byte)globs::helpwindowGlobs.flags & 4) == 0)) {
		return globs::helpwindowGlobs.Buttons[1].LoImage;
	}
	if ((((byte)globs::helpwindowGlobs.flags & 0x10) != 0) &&
		 (globs::helpwindowGlobs.count_d60 == buttonIndex)) {
		if (((byte)globs::helpwindowGlobs.flags & 0x20) != 0) {
			return globs::helpwindowGlobs.Buttons[buttonIndex].LoImage;
		}
		return globs::helpwindowGlobs.Buttons[buttonIndex].HiImage;
	}
	return NULL;
}



BOOL __cdecl lego::front::HelpWindow_IsEnabled_AndFlags_3_AndNoTutorialFlags(void)
{
	BOOL BVar1;
	HelpWindowFlags HVar2;
	TutorialFlags TVar3;
	HelpWindowFlags HVar4;
	
	BVar1 = HelpWindow_IsEnabled();
	HVar2 = globs::helpwindowGlobs.flags & HELPWINDOW_UNK_1;
	HVar4 = globs::helpwindowGlobs.flags & HELPWINDOW_UNK_2;
	TVar3 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((((BVar1 != 0) && (HVar4 != HELPWINDOW_NONE)) && (HVar2 != HELPWINDOW_NONE)) &&
		 (TVar3 == TUTORIAL_NONE)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::front::HelpWindow_IsEnabled(void)
{
	return globs::helpwindowGlobs.flags & HELPWINDOW_ENABLED;
}



void __cdecl lego::front::HelpWindow_SetEnabled(BOOL toggle,BOOL enable)
{
	if (toggle != 0) {
		enable = globs::helpwindowGlobs.flags & HELPWINDOW_ENABLED;
	}
	if (enable == HELPWINDOW_NONE) {
		globs::helpwindowGlobs.flags = globs::helpwindowGlobs.flags | HELPWINDOW_ENABLED;
		return;
	}
	globs::helpwindowGlobs.flags = globs::helpwindowGlobs.flags & ~HELPWINDOW_ENABLED;
	return;
}



void __cdecl lego::front::Info_Initialise(Font *font)
{
	globs::infoGlobs.infoName[0] = "Info_CrystalFound";
	globs::infoGlobs.infoName[1] = "Info_OreSeamFound";
	globs::infoGlobs.infoName[2] = "Info_RockMonster";
	globs::infoGlobs.infoName[3] = "Info_LavaRockMonster";
	globs::infoGlobs.infoName[4] = "Info_IceRockMonster";
	globs::infoGlobs.infoName[5] = "Info_UnderAttack";
	globs::infoGlobs.infoName[6] = "Info_Landslide";
	globs::infoGlobs.infoName[7] = "Info_CaveIn";
	globs::infoGlobs.infoName[8] = "Info_Constructed";
	globs::infoGlobs.infoName[9] = "Info_CavernLocated";
	globs::infoGlobs.infoName[10] = "Info_LegoManDeath";
	globs::infoGlobs.infoName[11] = "Info_VehicleDeath";
	globs::infoGlobs.infoName[12] = "Info_BuildingDeath";
	globs::infoGlobs.infoName[13] = "Info_DynamitePlaced";
	globs::infoGlobs.infoName[14] = "Info_NoPower";
	globs::infoGlobs.infoName[15] = "Info_PowerDrain";
	globs::infoGlobs.infoName[16] = "Info_AirDepleting";
	globs::infoGlobs.infoName[17] = "Info_AirLow";
	globs::infoGlobs.infoName[18] = "Info_AirOut";
	globs::infoGlobs.infoName[19] = "Info_AirRestored";
	globs::infoGlobs.infoName[20] = "Info_TrainDriver";
	globs::infoGlobs.infoName[21] = "Info_TrainDynamite";
	globs::infoGlobs.infoName[22] = "Info_TrainRepair";
	globs::infoGlobs.infoName[23] = "Info_TrainPilot";
	globs::infoGlobs.infoName[24] = "Info_TrainSailor";
	globs::infoGlobs.infoName[25] = "Info_TrainScanner";
	globs::infoGlobs.infoName[26] = "Info_OreCollected";
	globs::infoGlobs.infoName[27] = "Info_WallDug";
	globs::infoGlobs.infoName[28] = "Info_WallReinforced";
	globs::infoGlobs.infoName[29] = "Info_CrystalPower";
	globs::infoGlobs.infoName[30] = "Info_LavaErode";
	globs::infoGlobs.infoName[31] = "Info_SlugEmerge";
	globs::infoGlobs.infoName[32] = "Info_PathCompleted";
	globs::infoGlobs.infoName[33] = "Info_FoundMinifigure";
	globs::infoGlobs.infoName[34] = "Info_CanUpgradeMinifigure";
	globs::infoGlobs.infoName[35] = "Info_CanTrainMinifigure";
	globs::infoGlobs.infoName[36] = "Info_CrystalSeamFound";
	globs::infoGlobs.infoName[37] = "Info_GenericSeamFound";
	globs::infoGlobs.infoName[38] = "Info_GenericDeath";
	globs::infoGlobs.infoName[39] = "Info_GenericMonster";
	globs::infoGlobs.font = font;
	globs::infoGlobs.flags = globs::infoGlobs.flags | (INFO_FLAG_UNK_8|INFO_FLAG_AUTOGAMESPEED);
	return;
}



BOOL __cdecl lego::front::Info_GetInfoType(char *infoName,InfoType *out_infoType)
{
	int cmp;
	char **pInfoName;
	InfoType i;
	
	i = INFO_CRYSTALFOUND;
	pInfoName = (char **)&globs::infoGlobs;
	do {
		cmp = std::_stricmp(*pInfoName,infoName);
		if (cmp == 0) {
			*out_infoType = i;
			return TRUE;
		}
		pInfoName = (char **)((int)pInfoName + 4);
		i += INFO_ORESEAMFOUND;
	} while (pInfoName < globs::infoGlobs.infoDataTable);
	return 0;
}



void * __cdecl lego::front::Info_GetTypePtr4(InfoType infoType)
{
	return globs::infoGlobs.infoDataTable[infoType].ptr_4;
}



void __cdecl lego::front::Info_SetOverFlowImageFile(char *filename)
{
	globs::infoGlobs.OverFlowImage = lego::image::Image_LoadBMPScaled(filename,0,0);
	lego::image::Image_SetPenZeroTrans(globs::infoGlobs.OverFlowImage);
	return;
}



void __cdecl lego::front::Info_SetAutoGameSpeed(BOOL autoOn)
{
	if (autoOn != 0) {
		globs::infoGlobs.flags = globs::infoGlobs.flags | INFO_FLAG_AUTOGAMESPEED;
		return;
	}
	globs::infoGlobs.flags = globs::infoGlobs.flags & ~INFO_FLAG_AUTOGAMESPEED;
	return;
}



void __cdecl lego::front::Info_SetTypeChangeGameSpeed(InfoType infoType,BOOL changeSpeedOn)
{
	InfoDataFlags IVar1;
	
	IVar1 = globs::infoGlobs.infoDataTable[infoType].flags;
	if (changeSpeedOn != 0) {
		globs::infoGlobs.infoDataTable[infoType].flags = IVar1 | INFOTYPE_FLAG_CHANGEGAMESPEED;
		return;
	}
	globs::infoGlobs.infoDataTable[infoType].flags = IVar1 & ~INFOTYPE_FLAG_CHANGEGAMESPEED;
	return;
}



void __cdecl lego::front::Info_SetTypeText(InfoType infoType,char *text)
{
	char *buffer;
	
	buffer = globs::infoGlobs.infoDataTable[infoType].text;
	if (buffer != NULL) {
		std::free(buffer);
	}
	Info_SetText_internal(text,&globs::infoGlobs.infoDataTable[infoType].text);
	return;
}



void __cdecl lego::front::Info_SetTypeFlag_20000(InfoType infoType,BOOL setFlag20000)
{
	InfoDataFlags IVar1;
	
	IVar1 = globs::infoGlobs.infoDataTable[infoType].flags;
	if (setFlag20000 != 0) {
		globs::infoGlobs.infoDataTable[infoType].flags = IVar1 | INFOTYPE_FLAG_UNK_20000;
		return;
	}
	globs::infoGlobs.infoDataTable[infoType].flags = IVar1 & ~INFOTYPE_FLAG_UNK_20000;
	return;
}



void __cdecl lego::front::Info_SetText_internal(char *text,char **pInfoText)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	Image *pIVar7;
	char *pcVar8;
	char *pcVar9;
	uint local_30;
	InfoType local_2c;
	char acStack40 [8];
	char local_20 [32];
	
	pcVar9 = text;
	uVar5 = 0xffffffff;
	local_30 = 0;
	pcVar3 = text;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar2 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar2 != '\0');
	pcVar3 = (char *)std::malloc(~uVar5 + 0xb);
	*pInfoText = pcVar3;
	cVar2 = *pcVar9;
	while (cVar2 != '\0') {
		cVar2 = *pcVar9;
		if (cVar2 == '_') {
			*pcVar3 = ' ';
		}
		else {
			if (cVar2 == '$') {
				pcVar8 = pcVar9 + 1;
				iVar6 = 0;
				pIVar7 = NULL;
				cVar2 = pcVar9[1];
				pcVar9 = pcVar8;
				while (cVar2 != '$') {
					local_20[iVar6] = cVar2;
					pcVar1 = pcVar8 + 1;
					iVar6 += 1;
					pcVar8 = pcVar8 + 1;
					pcVar9 = pcVar9 + 1;
					cVar2 = *pcVar1;
				}
				local_20[iVar6] = '\0';
				BVar4 = Pointer_GetType(local_20,(PointerType *)&text);
				if (BVar4 == 0) {
					BVar4 = Info_GetInfoType(local_20,&local_2c);
					if (BVar4 != 0) {
						pIVar7 = (Image *)Info_GetTypePtr4(local_2c);
					}
				}
				else {
					pIVar7 = Pointers_GetImage((PointerType)text);
				}
				if (pIVar7 != NULL) {
					*pcVar3 = '%';
					pcVar3 = pcVar3 + 1;
					acStack40[local_30] = (char)pIVar7;
					local_30 += 1;
					*pcVar3 = 'b';
				}
			}
			else {
				if ((cVar2 == '\\') && (pcVar9[1] == 'n')) {
					*pcVar3 = '\n';
					pcVar9 = pcVar9 + 1;
				}
				else {
					*pcVar3 = cVar2;
				}
			}
		}
		pcVar8 = pcVar9 + 1;
		pcVar3 = pcVar3 + 1;
		pcVar9 = pcVar9 + 1;
		cVar2 = *pcVar8;
	}
	*pcVar3 = '\0';
	pcVar3 = pcVar3 + 1;
	uVar5 = 0;
	*pcVar3 = (char)local_30;
	do {
		pcVar3 = pcVar3 + 1;
		if (uVar5 < local_30) {
			*pcVar3 = acStack40[uVar5];
		}
		else {
			*pcVar3 = '\0';
		}
		uVar5 += 1;
	} while (uVar5 < 5);
	return;
}



void __cdecl lego::front::Info_SetTypeImageFile(InfoType infoType,char *filename)
{
	Image *image;
	
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globs::infoGlobs.infoDataTable[infoType].ptr_4 = image;
	lego::image::Image_SetPenZeroTrans(image);
	return;
}



void __cdecl lego::front::Info_SetTypeSFX(InfoType infoType,SFXType sfxType)
{
	globs::infoGlobs.infoDataTable[infoType].sfxType = sfxType;
	return;
}



BOOL __cdecl
lego::front::Info_EnumerateMessageInstances(int handle,InfoEnumerateCallback callback,void *data)
{
	BOOL stop;
	InfoMessageInstance *instance;
	
	instance = globs::infoGlobs.infoMessageTable[handle].instance;
	if (instance == NULL) {
		return 0;
	}
	do {
		stop = (*callback)(instance,data);
		if (stop != 0) {
			return TRUE;
		}
		instance = instance->next;
	} while (instance != NULL);
	return 0;
}



void __cdecl lego::front::Info_AddMessageInstance(int handle,InfoMessageInstance *instance)
{
	InfoMessageInstance *pIVar1;
	InfoMessageInstance *pIVar2;
	int iVar3;
	
	pIVar1 = globs::infoGlobs.infoMessageTable[handle].instance;
	if (pIVar1 == NULL) {
		globs::infoGlobs.infoMessageTable[handle].instance = instance;
		instance->next = NULL;
		globs::infoGlobs.infoMessageTable[handle].instanceCount =
				 globs::infoGlobs.infoMessageTable[handle].instanceCount + 1;
		return;
	}
	iVar3 = 1;
	pIVar2 = pIVar1->next;
	while (pIVar2 != NULL) {
		iVar3 += 1;
		if (iVar3 == 9) {
						// Maximum of 9 instances for a single type, pop the oldest one.
			Info_RemoveMessageInstance(handle,0);
		}
		pIVar1 = pIVar1->next;
		pIVar2 = pIVar1->next;
	}
	pIVar1->next = instance;
	instance->next = NULL;
	globs::infoGlobs.infoMessageTable[handle].instanceCount =
			 globs::infoGlobs.infoMessageTable[handle].instanceCount + 1;
	return;
}



InfoMessageInstance * __cdecl lego::front::Info_GetMessageInstance(int handle,int instanceIndex)
{
	InfoMessageInstance *instance;
	
	instance = globs::infoGlobs.infoMessageTable[handle].instance;
	if ((instanceIndex < 0) ||
		 ((int)globs::infoGlobs.infoMessageTable[handle].instanceCount <= instanceIndex)) {
		instance = NULL;
	}
	else {
		if (0 < instanceIndex) {
			do {
				instance = instance->next;
				instanceIndex += -1;
			} while (instanceIndex != 0);
			return instance;
		}
	}
	return instance;
}



InfoMessageInstance * __cdecl lego::front::Info_RemoveMessageInstance(int handle,int instanceIndex)
{
	InfoMessageInstance *instance;
	InfoMessageInstance *prevInstance;
	
	instance = Info_GetMessageInstance(handle,instanceIndex);
	if (instance == NULL) {
		return NULL;
	}
	prevInstance = Info_GetMessageInstance(handle,instanceIndex + -1);
	if (instanceIndex == 0) {
		globs::infoGlobs.infoMessageTable[handle].instance = instance->next;
	}
	else {
		prevInstance->next = instance->next;
	}
	globs::infoGlobs.infoMessageTable[handle].instanceCount =
			 globs::infoGlobs.infoMessageTable[handle].instanceCount - 1;
	return instance;
}



BOOL __cdecl
lego::front::Info_LiveObject_Release_internal_FUN_00419740
					(InfoMessageInstance *instance,SearchInfoObject_8 *search)
{
	if (instance->object == search->object) {
		return TRUE;
	}
	search->index = search->index + 1;
	return 0;
}



void __cdecl lego::front::Info_RemoveAllForObject(LiveObject *liveObj)
{
	int iVar1;
	uint handle;
	uint uVar2;
	uint *puVar3;
	SearchInfoObject_8 search;
	
	search.object = liveObj;
	handle = 0;
	if (globs::infoGlobs.infoMessageCount != 0) {
		puVar3 = &globs::infoGlobs.infoMessageTable[0].instanceCount;
		do {
			search.index = 0;
			iVar1 = Info_EnumerateMessageInstances
												(handle,Info_LiveObject_Release_internal_FUN_00419740,&search);
			while (iVar1 != 0) {
				Info_RemoveMessageInstance(handle,search.index);
				search.index = 0;
				iVar1 = Info_EnumerateMessageInstances
													(handle,Info_LiveObject_Release_internal_FUN_00419740,&search);
			}
			uVar2 = handle;
			if (*puVar3 == 0) {
				uVar2 = handle - 1;
				puVar3 = puVar3 + -5;
				Info_RemoveMessage(handle);
			}
			handle = uVar2 + 1;
			puVar3 = puVar3 + 5;
		} while (handle < globs::infoGlobs.infoMessageCount);
	}
	return;
}



BOOL __cdecl
lego::front::Info_Callback_FindBlockPos
					(InfoMessageInstance *infoInstance,SearchInfoBlockPos_8 *search)
{
	if (((infoInstance->blockPos).x == search->pBlockPos->x) &&
		 ((infoInstance->blockPos).y == search->pBlockPos->y)) {
		return TRUE;
	}
	search->index = search->index + 1;
	return 0;
}



void __cdecl lego::front::Info_RemoveAllAtBlockPos(Point2I *blockPos)
{
	int iVar1;
	uint *pCount;
	uint handle;
	uint uVar2;
	InfoType *pInfoType;
	SearchInfoBlockPos_8 search;
	
	search.pBlockPos = blockPos;
	handle = 0;
	if (globs::infoGlobs.infoMessageCount != 0) {
		pCount = &globs::infoGlobs.infoMessageTable[0].instanceCount;
		pInfoType = &globs::infoGlobs.infoMessageTable[0].infoType;
		do {
			uVar2 = handle;
			if ((*pInfoType == INFO_LANDSLIDE) || (*pInfoType == INFO_CAVEIN)) {
				search.index = 0;
				iVar1 = Info_EnumerateMessageInstances(handle,Info_Callback_FindBlockPos,&search);
				while (iVar1 != 0) {
					Info_RemoveMessageInstance(handle,search.index);
					search.index = 0;
					iVar1 = Info_EnumerateMessageInstances(handle,Info_Callback_FindBlockPos,&search);
				}
				if (*pCount == 0) {
					uVar2 = handle - 1;
					pInfoType = pInfoType + -5;
					pCount = pCount + -5;
					Info_RemoveMessage(handle);
				}
			}
			handle = uVar2 + 1;
			pInfoType = pInfoType + 5;
			pCount = pCount + 5;
		} while (handle < globs::infoGlobs.infoMessageCount);
	}
	return;
}



BOOL __cdecl
lego::front::Info_Callback_FindObjectAndBlockPos
					(InfoMessageInstance *instance,SearchInfoObjectBlockPos_8 *search)
{
	Point2I *searchBlockPos;
	LiveObject *searchObj;
	
	searchObj = search->optObject;
	if ((((searchObj != NULL) || (search->optBlockPos != NULL)) &&
			((searchObj == NULL || (instance->object != searchObj)))) &&
		 (((searchBlockPos = search->optBlockPos, searchBlockPos == NULL ||
			 ((instance->blockPos).x != searchBlockPos->x)) ||
			((instance->blockPos).y != searchBlockPos->y)))) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl
lego::front::Info_HasTypeAtObjectOrBlockPos
					(InfoType infoType,LiveObject *opt_liveObj,Point2I *opt_blockPos)
{
	BOOL found;
	uint handle;
	InfoType *pInfoType;
	SearchInfoObjectBlockPos_8 search;
	
	if ((((infoType != INFO_LEGOMANDEATH) && (infoType != INFO_BUILDINGDEATH)) &&
			(infoType != INFO_VEHICLEDEATH)) && (infoType != INFO_GENERICDEATH)) {
		search.optBlockPos = opt_blockPos;
		handle = 0;
		search.optObject = opt_liveObj;
		if (globs::infoGlobs.infoMessageCount != 0) {
			pInfoType = &globs::infoGlobs.infoMessageTable[0].infoType;
			do {
				if (infoType == *pInfoType) {
					found = Info_EnumerateMessageInstances(handle,Info_Callback_FindObjectAndBlockPos,&search)
					;
					if (found != 0) {
						return TRUE;
					}
				}
				handle += 1;
				pInfoType = pInfoType + 5;
			} while (handle < globs::infoGlobs.infoMessageCount);
			return 0;
		}
	}
	return 0;
}



InfoMessageInstance * __cdecl
lego::front::Info_CreateInstance(Point2I *opt_blockPos,LiveObject *opt_liveObj,char *opt_text)
{
	InfoMessageInstance *instance;
	
	instance = (InfoMessageInstance *)std::malloc(0x14);
	if (instance == NULL) {
		return NULL;
	}
	if (opt_blockPos == NULL) {
		(instance->blockPos).y = -1;
		(instance->blockPos).x = -1;
	}
	else {
		(instance->blockPos).x = opt_blockPos->x;
		(instance->blockPos).y = opt_blockPos->y;
	}
	instance->object = opt_liveObj;
	if (opt_text != NULL) {
		Info_SetText_internal(opt_text,&instance->text);
		return instance;
	}
	instance->text = NULL;
	return instance;
}



void __cdecl lego::front::Info_SetFlag4(BOOL state)
{
	if (state != 0) {
		globs::infoGlobs.flags = globs::infoGlobs.flags | INFO_FLAG_UNK_4;
		return;
	}
	globs::infoGlobs.flags = globs::infoGlobs.flags & ~INFO_FLAG_UNK_4;
	return;
}



BOOL __cdecl lego::front::Info_HasTypeText(InfoType infoType)
{
	return (uint)(globs::infoGlobs.infoDataTable[infoType].text != NULL);
}



int __cdecl lego::front::Info_FindExistingMessageType(InfoType infoType)
{
	int i;
	InfoType *pMsgInfoType;
	
	i = 0;
	if (0 < (int)globs::infoGlobs.infoMessageCount) {
		pMsgInfoType = &globs::infoGlobs.infoMessageTable[0].infoType;
		do {
			if (*pMsgInfoType == infoType) {
				return i;
			}
			i += 1;
			pMsgInfoType = pMsgInfoType + 5;
		} while (i < (int)globs::infoGlobs.infoMessageCount);
	}
	return -1;
}



float10 __cdecl lego::front::Info_FUN_00419a80(void)
{
	InfoType IVar1;
	InfoType *pInfoType;
	uint count;
	float10 fVar2;
	
	fVar2 = (float10)333.0;
	if (globs::infoGlobs.infoMessageCount != 0) {
		pInfoType = &globs::infoGlobs.infoMessageTable[0].infoType;
		count = globs::infoGlobs.infoMessageCount;
		do {
			IVar1 = *pInfoType;
			pInfoType = pInfoType + 5;
			count -= 1;
			fVar2 = fVar2 - (float10)*(int *)((int)globs::infoGlobs.infoDataTable[IVar1].ptr_4 + 8);
		} while (count != 0);
	}
	return fVar2;
}



void __cdecl
lego::front::Info_Send
					(InfoType infoType,char *opt_text,LiveObject *opt_liveObj,Point2I *opt_blockPos)
{
	float fVar1;
	void *pvVar2;
	InfoMessage *pIVar3;
	uint uVar4;
	TutorialFlags tutFlags;
	BOOL BVar5;
	uint handle;
	InfoMessageInstance *instance;
	ProgrammerMode progMode;
	float10 fVar6;
	
	if (((byte)globs::infoGlobs.flags & INFO_FLAG_UNK_4) != 0) {
		tutFlags = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((tutFlags & TUTORIAL_UNK_100) == TUTORIAL_NONE) {
			if (((((byte)globs::infoGlobs.flags & INFO_FLAG_UNK_8) != 0) &&
					((globs::infoGlobs.infoDataTable[infoType].flags & INFOTYPE_FLAG_UNK_20000) !=
					 INFOTYPE_FLAG_NONE)) &&
				 (fVar1 = globs::infoGlobs.infoDataTable[infoType].float_c,
				 (ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0)) {
				globs::infoGlobs.infoDataTable[infoType].float_c = 25.0;
				if (((infoType == INFO_LEGOMANDEATH) || (infoType == INFO_VEHICLEDEATH)) ||
					 (infoType == INFO_BUILDINGDEATH)) {
					globs::infoGlobs.infoDataTable[10].float_c = 25.0;
					globs::infoGlobs.infoDataTable[11].float_c = 25.0;
					globs::infoGlobs.infoDataTable[12].float_c = 25.0;
					globs::infoGlobs.infoDataTable[38].float_c = 25.0;
				}
				snd::SFX_Sample_Random_SetAndPlayGlobalSample
									(globs::infoGlobs.infoDataTable[infoType].sfxType,NULL);
			}
			BVar5 = Info_HasTypeAtObjectOrBlockPos(infoType,opt_liveObj,opt_blockPos);
			if (BVar5 == 0) {
				BVar5 = Info_HasTypeText(infoType);
				if (BVar5 != 0) {
					pvVar2 = globs::infoGlobs.infoDataTable[infoType].ptr_4;
					if (((((byte)globs::infoGlobs.flags & INFO_FLAG_UNK_8) != 0) &&
							((globs::infoGlobs.infoDataTable[infoType].flags & INFOTYPE_FLAG_UNK_20000) ==
							 INFOTYPE_FLAG_NONE)) &&
						 (fVar1 = globs::infoGlobs.infoDataTable[infoType].float_c,
						 (ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0)) {
						globs::infoGlobs.infoDataTable[infoType].float_c = 25.0;
						if ((((infoType == INFO_LEGOMANDEATH) || (infoType == INFO_VEHICLEDEATH)) ||
								(infoType == INFO_BUILDINGDEATH)) || (infoType == INFO_GENERICDEATH)) {
							globs::infoGlobs.infoDataTable[10].float_c = 25.0;
							globs::infoGlobs.infoDataTable[11].float_c = 25.0;
							globs::infoGlobs.infoDataTable[12].float_c = 25.0;
							globs::infoGlobs.infoDataTable[38].float_c = 25.0;
						}
						snd::SFX_Sample_Random_SetAndPlayGlobalSample
											(globs::infoGlobs.infoDataTable[infoType].sfxType,NULL);
					}
					if (globs::infoGlobs.infoMessageCount != 0x28) {
						handle = Info_FindExistingMessageType(infoType);
						uVar4 = globs::infoGlobs.infoMessageCount;
						if (handle == 0xffffffff) {
							pIVar3 = globs::infoGlobs.infoMessageTable + globs::infoGlobs.infoMessageCount;
							globs::infoGlobs.infoMessageCount = globs::infoGlobs.infoMessageCount + 1;
							pIVar3->float_c = -(float)*(int *)((int)pvVar2 + 4);
							fVar6 = Info_FUN_00419a80();
							globs::infoGlobs.infoMessageTable[uVar4].next = (InfoMessage *)(float)fVar6;
							handle = uVar4;
						}
						globs::infoGlobs.infoMessageTable[handle].infoType = infoType;
						instance = Info_CreateInstance(opt_blockPos,opt_liveObj,opt_text);
						Info_AddMessageInstance(handle,instance);
						progMode = main::Main_ProgrammerMode();
						if (((progMode < 5) && (((byte)globs::infoGlobs.flags & INFO_FLAG_AUTOGAMESPEED) != 0))
							 && ((globs::infoGlobs.infoDataTable[infoType].flags & INFOTYPE_FLAG_CHANGEGAMESPEED)
									 != INFOTYPE_FLAG_NONE)) {
							fVar6 = game::Game_GetGameSpeed();
							if ((ushort)((ushort)(fVar6 < (float10)1.0) << 8 |
													(ushort)(fVar6 == (float10)1.0) << 0xe) == 0) {
								game::Game_SetGameSpeed(1.0);
							}
						}
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::front::Info_GotoFirst(void)
{
	if ((globs::infoGlobs.infoMessageCount != 0) &&
		 (globs::infoGlobs.infoMessageTable[0].instanceCount != 0)) {
		if (((globs::infoGlobs.infoMessageTable[0].instance)->object != NULL) ||
			 ((0 < ((globs::infoGlobs.infoMessageTable[0].instance)->blockPos).x &&
				(0 < ((globs::infoGlobs.infoMessageTable[0].instance)->blockPos).y)))) {
			lrr::Lego_GotoInfo((globs::infoGlobs.infoMessageTable[0].instance)->object,
												 &(globs::infoGlobs.infoMessageTable[0].instance)->blockPos,FALSE);
		}
	}
	return;
}



void __cdecl lego::front::Info_UpdateMessage(uint handle)
{
	InfoMessage *pIVar1;
	int iVar2;
	InfoMessage *pIVar3;
	InfoMessageInstance **ppIVar4;
	InfoMessage *pIVar5;
	InfoMessageInstance *local_14 [5];
	
	if (handle < globs::infoGlobs.infoMessageCount) {
		if (handle != 0) {
			pIVar3 = globs::infoGlobs.infoMessageTable + handle;
			ppIVar4 = local_14;
			for (iVar2 = 5; pIVar1 = globs::infoGlobs.infoMessageTable + handle, iVar2 != 0; iVar2 += -1)
			{
				*ppIVar4 = pIVar3->instance;
				pIVar3 = (InfoMessage *)&pIVar3->instanceCount;
				ppIVar4 = ppIVar4 + 1;
			}
			do {
				handle -= 1;
				pIVar3 = pIVar1 + -1;
				pIVar5 = pIVar1;
				for (iVar2 = 5; iVar2 != 0; iVar2 += -1) {
					pIVar5->instance = pIVar3->instance;
					pIVar3 = (InfoMessage *)&pIVar3->instanceCount;
					pIVar5 = (InfoMessage *)&pIVar5->instanceCount;
				}
				pIVar1 = pIVar1 + -1;
			} while (handle != 0);
			ppIVar4 = local_14;
			pIVar3 = globs::infoGlobs.infoMessageTable;
			for (iVar2 = 5; iVar2 != 0; iVar2 += -1) {
				pIVar3->instance = *ppIVar4;
				ppIVar4 = ppIVar4 + 1;
				pIVar3 = (InfoMessage *)&pIVar3->instanceCount;
			}
		}
		globs::infoGlobs.flags |= INFO_FLAG_UNK_1|INFO_FLAG_UNK_2;
	}
	return;
}



void __cdecl lego::front::Info_PopFirstMessage(void)
{
	if (globs::infoGlobs.infoMessageCount != 0) {
		Info_RemoveMessage(0);
	}
	return;
}



void __cdecl lego::front::Info_RemoveMessage(uint handle)
{
	InfoMessageInstance *instance;
	InfoMessage *pIVar1;
	int iVar2;
	uint uVar3;
	InfoMessage *pIVar4;
	InfoMessage *pIVar5;
	
	if (handle < globs::infoGlobs.infoMessageCount) {
		instance = Info_RemoveMessageInstance(handle,0);
		if ((instance != NULL) && (instance->text != NULL)) {
			std::free(instance->text);
		}
		if (globs::infoGlobs.infoMessageTable[handle].instanceCount == 0) {
			if (handle < globs::infoGlobs.infoMessageCount) {
				pIVar1 = globs::infoGlobs.infoMessageTable + handle;
				uVar3 = handle;
				do {
					uVar3 += 1;
					pIVar4 = pIVar1 + 1;
					pIVar5 = pIVar1;
					for (iVar2 = 5; iVar2 != 0; iVar2 += -1) {
						pIVar5->instance = pIVar4->instance;
						pIVar4 = (InfoMessage *)&pIVar4->instanceCount;
						pIVar5 = (InfoMessage *)&pIVar5->instanceCount;
					}
					pIVar1 = pIVar1 + 1;
				} while (uVar3 < globs::infoGlobs.infoMessageCount);
			}
			globs::infoGlobs.infoMessageCount -= 1;
		}
		if (handle == 0) {
			globs::infoGlobs.flags &= ~INFO_FLAG_UNK_1;
		}
	}
	return;
}



void __cdecl lego::front::Info_ClearAllMessages(void)
{
	if (globs::infoGlobs.infoMessageCount != 0) {
		do {
			Info_RemoveMessage(0);
		} while (globs::infoGlobs.infoMessageCount != 0);
	}
	return;
}



void __cdecl lego::front::Info_Draw(float elapsedAbs)
{
	Image *image;
	int y;
	int x;
	Font *font;
	uint uVar1;
	InfoMessage **ppIVar2;
	longlong lVar3;
	char *msg;
	InfoMessage *pIVar4;
	Point2F local_8;
	
	local_8.y = 333.0;
	uVar1 = 0;
	if (globs::infoGlobs.infoMessageCount == 0) {
		return;
	}
	ppIVar2 = &globs::infoGlobs.infoMessageTable[0].next;
	while( true ) {
		image = (Image *)globs::infoGlobs.infoDataTable[(int)ppIVar2[-2]].ptr_4;
		if ((ushort)((ushort)(local_8.y < (float)*ppIVar2) << 8 |
								(ushort)(local_8.y == (float)*ppIVar2) << 0xe) == 0) {
			*ppIVar2 = (InfoMessage *)((float)*ppIVar2 - elapsedAbs * -8.0);
		}
		if (local_8.y < (float)*ppIVar2) {
			*ppIVar2 = (InfoMessage *)local_8.y;
		}
		if ((float)ppIVar2[-1] < 0.0) {
			ppIVar2[-1] = (InfoMessage *)((float)ppIVar2[-1] - elapsedAbs * -3.0);
		}
		if ((ushort)((ushort)((float)ppIVar2[-1] < 0.0) << 8 |
								(ushort)((float)ppIVar2[-1] == 0.0) << 0xe) == 0) {
			ppIVar2[-1] = NULL;
		}
		local_8.y = (float)*ppIVar2;
		local_8.x = (float)ppIVar2[-1];
		lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
		if (local_8.y < 0.0) break;
		pIVar4 = ppIVar2[-3];
		msg = "%i";
		lVar3 = __ftol((float10)local_8.y);
		y = (int)lVar3 + 10;
		lVar3 = __ftol((float10)local_8.x);
		x = (int)lVar3 + 2;
		font = Interface_GetFont_FUN_004ddd58();
		lego::image::Font_PrintF(font,x,y,msg,pIVar4);
		uVar1 += 1;
		ppIVar2 = ppIVar2 + 5;
		local_8.y = local_8.y - (float)image->height;
		if (globs::infoGlobs.infoMessageCount <= uVar1) {
			return;
		}
	}
	local_8.y = 0.0;
	lego::image::Image_DisplayScaled(globs::infoGlobs.OverFlowImage,NULL,&local_8,NULL);
	return;
}



void __cdecl lego::front::Info_DrawPanel(float elapsedAbs)
{
	char cVar1;
	uint uVar2;
	char *msg;
	char *pcVar3;
	
	if (((globs::infoGlobs.flags & INFO_FLAG_UNK_1) == INFO_FLAG_NONE) ||
		 (globs::infoGlobs.infoMessageCount == 0)) {
		if (((byte)globs::panelGlobs.panelTable[7].flags & 4) == 0) {
			Panel_ChangeFlags_BasedOnState(PANEL_INFORMATION);
		}
	}
	else {
		if (((byte)globs::panelGlobs.panelTable[7].flags & 2) == 0) {
			Panel_ChangeFlags_BasedOnState(PANEL_INFORMATION);
		}
		if ((globs::infoGlobs.flags & INFO_FLAG_UNK_2) != INFO_FLAG_NONE) {
			Panel_TextWindow_Clear(globs::panelGlobs.infoTextWnd);
			msg = (globs::infoGlobs.infoMessageTable[0].instance)->text;
			if (msg == NULL) {
				msg = globs::infoGlobs.infoDataTable[globs::infoGlobs.infoMessageTable[0].infoType].text;
			}
			uVar2 = 0xffffffff;
			pcVar3 = msg;
			do {
				if (uVar2 == 0) break;
				uVar2 -= 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar3 + 1;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			if (msg[uVar2] == '\0') {
				Panel_TextWindow_PrintF(globs::panelGlobs.infoTextWnd,msg);
			}
			else {
				Panel_TextWindow_PrintF
									(globs::panelGlobs.infoTextWnd,msg,(uint)(byte)msg[uVar2 + 1],
									 (uint)(byte)msg[uVar2 + 2],(uint)(byte)msg[uVar2 + 3],(uint)(byte)msg[uVar2 + 4],
									 (uint)(byte)msg[uVar2 + 5]);
			}
			Panel_TextWindow_Update(globs::panelGlobs.infoTextWnd,globs::infoGlobs.int_6ec,elapsedAbs);
			Info_FUN_0041a180();
			globs::infoGlobs.flags &= ~INFO_FLAG_UNK_2;
		}
	}
	Panel_TextWindow_Update(globs::panelGlobs.infoTextWnd,globs::infoGlobs.int_6ec,elapsedAbs);
	return;
}



BOOL __cdecl lego::front::Info_Update_FUN_0041a0d0(int mouseX,int mouseY,BOOL leftReleased)
{
	void *pvVar1;
	int iVar2;
	uint i;
	InfoMessage **ppIVar3;
	longlong lVar4;
	
	i = 0;
	if (globs::infoGlobs.infoMessageCount == 0) {
		return 0;
	}
	ppIVar3 = &globs::infoGlobs.infoMessageTable[0].next;
	do {
		pvVar1 = globs::infoGlobs.infoDataTable[(int)ppIVar3[-2]].ptr_4;
		iVar2 = *(int *)((int)pvVar1 + 8);
		if ((-1 < mouseX) && (mouseX <= *(int *)((int)pvVar1 + 4))) {
			lVar4 = __ftol((float10)(float)*ppIVar3);
			if (((int)lVar4 <= mouseY) && (mouseY <= iVar2 + (int)lVar4)) {
				if (leftReleased != 0) {
					if (((globs::infoGlobs.flags & INFO_FLAG_UNK_1) != INFO_FLAG_NONE) && (i == 0)) {
						Panel_ChangeFlags_BasedOnState(PANEL_INFORMATION);
						globs::infoGlobs.flags = globs::infoGlobs.flags & ~INFO_FLAG_UNK_1;
						return TRUE;
					}
					Info_UpdateMessage(i);
				}
				return TRUE;
			}
		}
		i += 1;
		ppIVar3 = ppIVar3 + 5;
		if (globs::infoGlobs.infoMessageCount <= i) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::front::Info_FUN_0041a180(void)
{
	int avail;
	uint linesCount;
	uint linesCapacity;
	
	Panel_TextWindow_GetInfo(globs::panelGlobs.infoTextWnd,&linesCount,&linesCapacity);
	avail = linesCount - linesCapacity;
	if (avail < 0) {
		avail = 0;
	}
	ScrollInfo_SetSubStruct28_Fields1C_20(0,avail,0);
	Info_UpdateInt6EC_FromScrollInfo();
	return;
}



void __cdecl lego::front::Info_UpdateInt6EC_FromScrollInfo(void)
{
	int local_8;
	int local_4;
	
	ScrollInfo_GetSubStruct28_Fields1C_20(0,&local_8,&local_4);
	globs::infoGlobs.int_6ec = local_8 - local_4;
	return;
}



void __cdecl lego::front::Info_FUN_0041a1f0(float elapsed)
{
	float *pfVar1;
	
	pfVar1 = &globs::infoGlobs.infoDataTable[0].float_c;
	do {
		if ((ushort)((ushort)(*pfVar1 < 0.0) << 8 | (ushort)(*pfVar1 == 0.0) << 0xe) == 0) {
			*pfVar1 = *pfVar1 - elapsed;
		}
		pfVar1 = pfVar1 + 5;
	} while (pfVar1 < &globs::infoGlobs.infoMessageTable[0].float_c);
	return;
}



Font * __cdecl lego::front::Interface_GetFont_FUN_004ddd58(void)
{
	return PTRImageFont_004ddd58;
}



void __cdecl lego::front::Interface_Initialise(uint x_565,uint y_18,Font *font)
{
	ToolTip_SetFlag10(TOOLTIP_INTERFACEMENU,TRUE);
	Point2F_004decd0.x = (float)(ulonglong)x_565;
	globals::g_InterfaceMenuItemNames_TABLE[0] = "Interface_MenuItem_BackToDefault";
	Point2F_004decd0.y = (float)(ulonglong)y_18;
	PTRImageFont_004ddd58 = font;
	globals::g_InterfaceMenuItemNames_TABLE[1] = "Interface_MenuItem_TeleportMan";
	globals::g_InterfaceMenuItemNames_TABLE[2] = "Interface_MenuItem_BuildBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[3] = "Interface_MenuItem_BuildSmallVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[4] = "Interface_MenuItem_BuildLargeVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[5] = "Interface_MenuItem_LayPath";
	globals::g_InterfaceMenuItemNames_TABLE[7] = "Interface_MenuItem_RepairLava";
	globals::g_InterfaceMenuItemNames_TABLE[8] = "Interface_MenuItem_GeologistTest";
	globals::g_InterfaceMenuItemNames_TABLE[9] = "Interface_MenuItem_ClearRubble";
	globals::g_InterfaceMenuItemNames_TABLE[10] = "Interface_MenuItem_Dam";
	globals::g_InterfaceMenuItemNames_TABLE[17] = "Interface_MenuItem_SelectMan";
	globals::g_InterfaceMenuItemNames_TABLE[32] = "Interface_MenuItem_DeleteMan";
	globals::g_InterfaceMenuItemNames_TABLE[41] = "Interface_MenuItem_DeleteVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[40] = "Interface_MenuItem_DeleteBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[43] = "Interface_MenuItem_Attack";
	globals::g_InterfaceMenuItemNames_TABLE[18] = "Interface_MenuItem_SelectVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[22] = "Interface_MenuItem_UnLoadVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[23] = "Interface_MenuItem_UnLoadMinifigure";
	globals::g_InterfaceMenuItemNames_TABLE[20] = "Interface_MenuItem_VehiclePickUp";
	globals::g_InterfaceMenuItemNames_TABLE[21] = "Interface_MenuItem_MinifigurePickUp";
	globals::g_InterfaceMenuItemNames_TABLE[25] = "Interface_MenuItem_GetOut";
	globals::g_InterfaceMenuItemNames_TABLE[24] = "Interface_MenuItem_GetIn";
	globals::g_InterfaceMenuItemNames_TABLE[26] = "Interface_MenuItem_GotoDock";
	globals::g_InterfaceMenuItemNames_TABLE[11] = "Interface_MenuItem_Dig";
	globals::g_InterfaceMenuItemNames_TABLE[12] = "Interface_MenuItem_Reinforce";
	globals::g_InterfaceMenuItemNames_TABLE[13] = "Interface_MenuItem_Dynamite";
	globals::g_InterfaceMenuItemNames_TABLE[64] = "Interface_MenuItem_UpgradeMan";
	globals::g_InterfaceMenuItemNames_TABLE[31] = "Interface_MenuItem_GoFeed";
	globals::g_InterfaceMenuItemNames_TABLE[45] = "Interface_MenuItem_GotoFirstPerson";
	globals::g_InterfaceMenuItemNames_TABLE[46] = "Interface_MenuItem_GotoSecondPerson";
	globals::g_InterfaceMenuItemNames_TABLE[57] = "Interface_MenuItem_TrainSkill";
	globals::g_InterfaceMenuItemNames_TABLE[34] = "Interface_MenuItem_PowerOn";
	globals::g_InterfaceMenuItemNames_TABLE[35] = "Interface_MenuItem_PowerOff";
	globals::g_InterfaceMenuItemNames_TABLE[65] = "Interface_MenuItem_UpgradeBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[36] = "Interface_MenuItem_Repair";
	globals::g_InterfaceMenuItemNames_TABLE[19] = "Interface_MenuItem_SelectBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[44] = "Interface_MenuItem_GotoTopView";
	globals::g_InterfaceMenuItemNames_TABLE[48] = "Interface_MenuItem_GetTool";
	globals::g_InterfaceMenuItemNames_TABLE[49] = "Interface_MenuItem_GetDrill";
	globals::g_InterfaceMenuItemNames_TABLE[50] = "Interface_MenuItem_GetSpade";
	globals::g_InterfaceMenuItemNames_TABLE[51] = "Interface_MenuItem_GetHammer";
	globals::g_InterfaceMenuItemNames_TABLE[52] = "Interface_MenuItem_GetSpanner";
	globals::g_InterfaceMenuItemNames_TABLE[58] = "Interface_MenuItem_TrainDriver";
	globals::g_InterfaceMenuItemNames_TABLE[59] = "Interface_MenuItem_TrainEngineer";
	globals::g_InterfaceMenuItemNames_TABLE[60] = "Interface_MenuItem_TrainGeologist";
	globals::g_InterfaceMenuItemNames_TABLE[61] = "Interface_MenuItem_TrainPilot";
	globals::g_InterfaceMenuItemNames_TABLE[62] = "Interface_MenuItem_TrainSailor";
	globals::g_InterfaceMenuItemNames_TABLE[63] = "Interface_MenuItem_TrainDynamite";
	globals::g_InterfaceMenuItemNames_TABLE[73] = "Interface_MenuItem_Build";
	globals::g_InterfaceMenuItemNames_TABLE[14] = "Interface_MenuItem_PlaceFence";
	globals::g_InterfaceMenuItemNames_TABLE[37] = "Interface_MenuItem_MakeTeleporterPrimary";
	globals::g_InterfaceMenuItemNames_TABLE[15] = "Interface_MenuItem_DeselectDig";
	globals::g_InterfaceMenuItemNames_TABLE[72] = "Interface_MenuItem_ClearSelection";
	globals::g_InterfaceMenuItemNames_TABLE[71] = "Interface_MenuItem_Encyclopedia";
	globals::g_InterfaceMenuItemNames_TABLE[38] = "Interface_MenuItem_EjectCrystal";
	globals::g_InterfaceMenuItemNames_TABLE[39] = "Interface_MenuItem_EjectOre";
	globals::g_InterfaceMenuItemNames_TABLE[47] = "Interface_MenuItem_TrackObject";
	globals::g_InterfaceMenuItemNames_TABLE[27] = "Interface_MenuItem_LegoManGoto";
	globals::g_InterfaceMenuItemNames_TABLE[30] = "Interface_MenuItem_LegoManDig";
	globals::g_InterfaceMenuItemNames_TABLE[28] = "Interface_MenuItem_VehicleGoto";
	globals::g_InterfaceMenuItemNames_TABLE[29] = "Interface_MenuItem_VehicleDig";
	globals::g_InterfaceMenuItemNames_TABLE[6] = "Interface_MenuItem_RemovePath";
	globals::g_InterfaceMenuItemNames_TABLE[66] = "Interface_MenuItem_UpgradeVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[67] = "Interface_MenuItem_UpgradeEngine";
	globals::g_InterfaceMenuItemNames_TABLE[68] = "Interface_MenuItem_UpgardeDrill";
	globals::g_InterfaceMenuItemNames_TABLE[69] = "Interface_MenuItem_UpgardeScan";
	globals::g_InterfaceMenuItemNames_TABLE[70] = "Interface_MenuItem_UpgardeCarry";
	globals::g_InterfaceMenuItemNames_TABLE[42] = "Interface_MenuItem_DeleteElectricFence";
	globals::g_InterfaceMenuItemNames_TABLE[53] = "Interface_MenuItem_GetLaser";
	globals::g_InterfaceMenuItemNames_TABLE[54] = "Interface_MenuItem_GetPusherGun";
	globals::g_InterfaceMenuItemNames_TABLE[55] = "Interface_MenuItem_GetFreezerGun";
	globals::g_InterfaceMenuItemNames_TABLE[56] = "Interface_MenuItem_GetBirdScarer";
	globals::g_InterfaceMenuItemNames_TABLE[33] = "Interface_MenuItem_DropBirdScarer";
	globals::g_InterfaceMenuItemNames_TABLE[16] = "Interface_MenuItem_CancelConstruction";
	Interface_AddAllMenuItems();
	Interface_SetUnkPositions1(x_565,y_18,globs::mainGlobs.appWidth + 10,y_18,750.0);
	Interface_ResetUnkValues();
	return;
}



void __cdecl lego::front::Interface_AddAllMenuItems(void)
{
	Interface_AddMenuItem
						(INTERFACE_MENU_MAIN,4,INTERFACE_MENUITEM_TELEPORTMAN,INTERFACE_MENUITEM_BUILDBUILDING,
						 INTERFACE_MENUITEM_BUILDSMALLVEHICLE,INTERFACE_MENUITEM_BUILDLARGEVEHICLE);
	Interface_AddMenuItem
						(INTERFACE_MENU_GROUND,3,INTERFACE_MENUITEM_LAYPATH,INTERFACE_MENUITEM_REMOVEPATH,
						 INTERFACE_MENUITEM_PLACEFENCE);
	Interface_AddMenuItem(INTERFACE_MENU_ERODE,1,INTERFACE_MENUITEM_REPAIRLAVA);
	Interface_AddMenuItem(INTERFACE_MENU_PLACEFENCE,1,INTERFACE_MENUITEM_PLACEFENCE);
	Interface_AddMenuItem(INTERFACE_MENU_CONSTRUCTION,1,INTERFACE_MENUITEM_CANCELCONSTRUCTION);
	Interface_AddMenuItem
						(INTERFACE_MENU_RUBBLE,2,INTERFACE_MENUITEM_CLEARRUBBLE,INTERFACE_MENUITEM_PLACEFENCE);
	Interface_AddMenuItem
						(INTERFACE_MENU_WALL,4,INTERFACE_MENUITEM_DIG,INTERFACE_MENUITEM_REINFORCE,
						 INTERFACE_MENUITEM_DYNAMITE,INTERFACE_MENUITEM_DESELECTDIG);
	Interface_AddMenuItem
						(INTERFACE_MENU_TRACKER,2,INTERFACE_MENUITEM_ATTACK,INTERFACE_MENUITEM_TRACKOBJECT);
	Interface_AddMenuItem
						(INTERFACE_MENU_VEHICLE,7,INTERFACE_MENUITEM_UNLOADVEHICLE,
						 INTERFACE_MENUITEM_VEHICLEPICKUP,INTERFACE_MENUITEM_UPGRADEVEHICLE,
						 INTERFACE_MENUITEM_GETOUT,INTERFACE_MENUITEM_GOTOFIRSTPERSON,
						 INTERFACE_MENUITEM_GOTOSECONDPERSON,INTERFACE_MENUITEM_DELETEVEHICLE);
	Interface_AddMenuItem
						(INTERFACE_MENU_WATERVEHICLE,6,INTERFACE_MENUITEM_UNLOADVEHICLE,
						 INTERFACE_MENUITEM_VEHICLEPICKUP,INTERFACE_MENUITEM_GETOUT,
						 INTERFACE_MENUITEM_GOTOFIRSTPERSON,INTERFACE_MENUITEM_GOTOSECONDPERSON,
						 INTERFACE_MENUITEM_GOTODOCK);
	Interface_AddMenuItem
						(INTERFACE_MENU_UNMANNEDVEHICLE,2,INTERFACE_MENUITEM_GETIN,
						 INTERFACE_MENUITEM_DELETEVEHICLE);
	Interface_AddMenuItem
						(INTERFACE_MENU_LEGOMAN,10,INTERFACE_MENUITEM_GOFEED,INTERFACE_MENUITEM_UNLOADMINIFIGURE
						 ,INTERFACE_MENUITEM_MINIFIGUREPICKUP,INTERFACE_MENUITEM_GETTOOL,
						 INTERFACE_MENUITEM_DROPBIRDSCARER,INTERFACE_MENUITEM_UPGRADEMAN,
						 INTERFACE_MENUITEM_TRAINSKILL,INTERFACE_MENUITEM_GOTOFIRSTPERSON,
						 INTERFACE_MENUITEM_GOTOSECONDPERSON,INTERFACE_MENUITEM_DELETEMAN);
	Interface_AddMenuItem
						(INTERFACE_MENU_BUILDING,4,INTERFACE_MENUITEM_REPAIR,INTERFACE_MENUITEM_POWERON,
						 INTERFACE_MENUITEM_UPGRADEBUILDING,INTERFACE_MENUITEM_DELETEBUILDING);
	Interface_AddMenuItem(INTERFACE_MENU_ELECTRICFENCE,1,INTERFACE_MENUITEM_DELETEELECTRICFENCE);
	Interface_AddMenuItem
						(INTERFACE_MENU_FIRSTPERSON,3,INTERFACE_MENUITEM_GOTOTOPVIEW,
						 INTERFACE_MENUITEM_GOTOSECONDPERSON,INTERFACE_MENUITEM_GOTOFIRSTPERSON);
	Interface_AddMenuItem
						(INTERFACE_MENU_GETTOOL,8,INTERFACE_MENUITEM_GETDRILL,INTERFACE_MENUITEM_GETSPADE,
						 INTERFACE_MENUITEM_GETHAMMER,INTERFACE_MENUITEM_GETSPANNER,INTERFACE_MENUITEM_GETLASER,
						 INTERFACE_MENUITEM_GETPUSHERGUN,INTERFACE_MENUITEM_GETFREEZERGUN,
						 INTERFACE_MENUITEM_GETBIRDSCARER);
	Interface_AddMenuItem
						(INTERFACE_MENU_TRAINSKILL,6,INTERFACE_MENUITEM_TRAINDRIVER,
						 INTERFACE_MENUITEM_TRAINENGINEER,INTERFACE_MENUITEM_TRAINGEOLOGIST,
						 INTERFACE_MENUITEM_TRAINPILOT,INTERFACE_MENUITEM_TRAINSAILOR,
						 INTERFACE_MENUITEM_TRAINDYNAMITE);
	Interface_AddMenuItem
						(INTERFACE_MENU_UPGRADEVEHICLE,4,INTERFACE_MENUITEM_UPGRADEENGINE,
						 INTERFACE_MENUITEM_UPGRADEDRILL,INTERFACE_MENUITEM_UPGRADESCAN,
						 INTERFACE_MENUITEM_UPGRADECARRY);
	return;
}



void __cdecl
lego::front::Interface_AddMenuItem(InterfaceMenuType interfaceMenuType,int numParams,...)
{
	MenuIcon MVar1;
	MenuIcon *pMVar2;
	MenuIcon *pMVar3;
	uint uVar4;
	int iVar5;
	MenuIcon *pMVar6;
	MenuIcon local_78 [30];
	
	globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].numIcons = numParams;
	pMVar2 = (MenuIcon *)std::malloc(numParams * 4);
	globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].iconList = pMVar2;
	pMVar3 = (MenuIcon *)&stack0x0000000c;
	if (numParams != 0) {
		pMVar6 = local_78;
		do {
			MVar1 = *pMVar3;
			pMVar3 = pMVar3 + 1;
			*pMVar6 = MVar1;
			pMVar6 = pMVar6 + 1;
			numParams += -1;
		} while (numParams != 0);
	}
	pMVar3 = local_78;
	for (uVar4 = globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].numIcons & 0x3fffffff;
			uVar4 != 0; uVar4 -= 1) {
		*pMVar2 = *pMVar3;
		pMVar3 = pMVar3 + 1;
		pMVar2 = pMVar2 + 1;
	}
	for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
		*(undefined *)pMVar2 = *(undefined *)pMVar3;
		pMVar3 = (MenuIcon *)((int)pMVar3 + 1);
		pMVar2 = (MenuIcon *)((int)pMVar2 + 1);
	}
	return;
}



void __cdecl lego::front::Interface_FreeInterfaceIcons(void)
{
	InterfaceMenuItem *pIVar1;
	
	pIVar1 = globals::g_InterfaceMenuItemDefines_TABLE;
	do {
		if (pIVar1->iconList != NULL) {
			std::free(pIVar1->iconList);
		}
		pIVar1 = pIVar1 + 1;
	} while (pIVar1 < &globals::g_Interface_SelectedBlock);
	std::free(globals::g_InterfaceBuildImages_Vehicles_normal_TABLE);
	std::free(globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE);
	std::free(globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE);
	std::free(globals::g_SubmenuIcons_VehicleTypesClicked_TABLE);
	std::free(globals::g_InterfaceBuildKeys_Vehicles_TABLE);
	std::free(globals::g_SubmenuIcons_VehicleTypesFlags_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_normal_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_pressed_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_disabled_TABLE);
	std::free(globals::g_SubmenuIcons_BuildingTypesClicked_TABLE);
	std::free(globals::g_InterfaceBuildKeys_Buildings_TABLE);
	std::free(globals::g_SubmenuIcons_BuildingTypesFlags_TABLE);
	return;
}



void __cdecl lego::front::Interface_LevelFree_FUN_0041a850(void)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	uint *puVar4;
	int *piVar5;
	InterfaceIconFlags *pIVar6;
	undefined4 *puVar7;
	
	FLAGS_004df1f8 = 0;
	piVar5 = globals::g_Interface_Icons_Clicked;
	for (iVar1 = 0x4a; iVar1 != 0; iVar1 += -1) {
		*piVar5 = 0;
		piVar5 = piVar5 + 1;
	}
	puVar4 = UINT_ARRAY_004de60c;
	for (iVar1 = 0x4a; uVar2 = globs::legoGlobs.VehicleTypes_COUNT,
			piVar5 = globals::g_SubmenuIcons_VehicleTypesClicked_TABLE, iVar1 != 0; iVar1 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (; uVar3 = globs::legoGlobs.VehicleTypes_COUNT,
			pIVar6 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE, uVar2 != 0; uVar2 = uVar2 - 1) {
		*piVar5 = 0;
		piVar5 = piVar5 + 1;
	}
	for (; uVar2 = globs::legoGlobs.BuildingTypes_COUNT,
			piVar5 = globals::g_SubmenuIcons_BuildingTypesClicked_TABLE, uVar3 != 0; uVar3 = uVar3 - 1) {
		*pIVar6 = INTERFACE_MENUITEM_FLAG_NONE;
		pIVar6 = pIVar6 + 1;
	}
	for (; uVar3 = globs::legoGlobs.BuildingTypes_COUNT,
			pIVar6 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE, uVar2 != 0; uVar2 = uVar2 - 1) {
		*piVar5 = 0;
		piVar5 = piVar5 + 1;
	}
	for (; uVar3 != 0; uVar3 = uVar3 - 1) {
		*pIVar6 = INTERFACE_MENUITEM_FLAG_NONE;
		pIVar6 = pIVar6 + 1;
	}
	puVar7 = &DAT_004ded34;
	for (iVar1 = 300; iVar1 != 0; iVar1 += -1) {
		*puVar7 = 0;
		puVar7 = puVar7 + 1;
	}
	Interface_ResetUnkValues();
	return;
}



void __cdecl lego::front::Interface_ResetUnkValues(void)
{
	InterfaceMenuType_004deccc = INTERFACE_MENU_MAIN;
	Point2F_004decd0.x = Point2F_004dece8.x;
	FLAGS_004df1f8 = FLAGS_004df1f8 | 0x84;
	return;
}



BOOL __cdecl lego::front::Interface_GetMenuItemType(char *menuItemName,int *out_menuItemType)
{
	int iVar1;
	char **ppcVar2;
	int iVar3;
	
	iVar3 = 0;
	ppcVar2 = globals::g_InterfaceMenuItemNames_TABLE;
	do {
		iVar1 = std::_stricmp((char *)*ppcVar2,menuItemName);
		if (iVar1 == 0) {
			*out_menuItemType = iVar3;
			return 1;
		}
		ppcVar2 = (char **)((Image **)ppcVar2 + 1);
		iVar3 += 1;
	} while (ppcVar2 < PTRImageBMP_ARRAY_004ddff8);
	return 0;
}



void __cdecl lego::front::Interface_InitSubmenuIconTables(void)
{
	uint uVar1;
	uint uVar2;
	int *piVar3;
	undefined4 *puVar4;
	InterfaceIconFlags *pIVar5;
	
	globals::g_SubmenuIcons_VehicleTypesClicked_TABLE =
			 (int *)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	piVar3 = globals::g_SubmenuIcons_VehicleTypesClicked_TABLE;
	for (uVar1 = globs::legoGlobs.VehicleTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*piVar3 = 0;
		piVar3 = piVar3 + 1;
	}
	globals::g_InterfaceBuildKeys_Vehicles_TABLE =
			 (byte *)std::malloc(globs::legoGlobs.VehicleTypes_COUNT);
	uVar1 = globs::legoGlobs.VehicleTypes_COUNT;
	puVar4 = (undefined4 *)globals::g_InterfaceBuildKeys_Vehicles_TABLE;
	for (uVar2 = globs::legoGlobs.VehicleTypes_COUNT >> 2; uVar2 != 0; uVar2 -= 1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (uVar1 &= 3; uVar1 != 0; uVar1 -= 1) {
		*(undefined *)puVar4 = 0;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	globals::g_SubmenuIcons_VehicleTypesFlags_TABLE =
			 (InterfaceIconFlags *)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	pIVar5 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE;
	for (uVar1 = globs::legoGlobs.VehicleTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*pIVar5 = INTERFACE_MENUITEM_FLAG_NONE;
		pIVar5 = pIVar5 + 1;
	}
	globals::g_SubmenuIcons_BuildingTypesClicked_TABLE =
			 (int *)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	piVar3 = globals::g_SubmenuIcons_BuildingTypesClicked_TABLE;
	for (uVar1 = globs::legoGlobs.BuildingTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*piVar3 = 0;
		piVar3 = piVar3 + 1;
	}
	globals::g_InterfaceBuildKeys_Buildings_TABLE =
			 (byte *)std::malloc(globs::legoGlobs.BuildingTypes_COUNT);
	uVar1 = globs::legoGlobs.BuildingTypes_COUNT;
	puVar4 = (undefined4 *)globals::g_InterfaceBuildKeys_Buildings_TABLE;
	for (uVar2 = globs::legoGlobs.BuildingTypes_COUNT >> 2; uVar2 != 0; uVar2 -= 1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (uVar1 &= 3; uVar1 != 0; uVar1 -= 1) {
		*(undefined *)puVar4 = 0;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	globals::g_SubmenuIcons_BuildingTypesFlags_TABLE =
			 (InterfaceIconFlags *)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	pIVar5 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE;
	for (uVar1 = globs::legoGlobs.BuildingTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*pIVar5 = INTERFACE_MENUITEM_FLAG_NONE;
		pIVar5 = pIVar5 + 1;
	}
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceBuildImages(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	Image *pIVar2;
	BOOL BVar3;
	uint uVar4;
	KeysByte local_51;
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	
	globals::g_InterfaceBuildImages_Vehicles_normal_TABLE =
			 (Image **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE =
			 (Image **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE =
			 (Image **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	uVar4 = 0;
	if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBuildImages",
																 globs::legoGlobs.VehicleTypes_TABLE[uVar4],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == NULL) {
				globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[uVar4] = NULL;
			}
			else {
				util::Util_Tokenise(pcVar1,&local_50,":");
				pIVar2 = lego::image::Image_LoadBMPScaled(local_50,0,0);
				globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_4c,0,0);
				globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_48,0,0);
				globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[uVar4] = pIVar2;
				BVar3 = input::Key_Find(local_44,&local_51);
				if (BVar3 != 0) {
					globals::g_InterfaceBuildKeys_Vehicles_TABLE[uVar4] = local_51;
				}
			}
			uVar4 += 1;
		} while (uVar4 < globs::legoGlobs.VehicleTypes_COUNT);
	}
	globals::g_InterfaceBuildImages_Buildings_normal_TABLE =
			 (Image **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Buildings_pressed_TABLE =
			 (Image **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Buildings_disabled_TABLE =
			 (Image **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	uVar4 = 0;
	if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBuildImages",
																 globs::legoGlobs.BuildingTypes_TABLE[uVar4],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == NULL) {
				globals::g_InterfaceBuildImages_Buildings_normal_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[uVar4] = NULL;
			}
			else {
				util::Util_Tokenise(pcVar1,&local_50,":");
				pIVar2 = lego::image::Image_LoadBMPScaled(local_50,0,0);
				globals::g_InterfaceBuildImages_Buildings_normal_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_4c,0,0);
				globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_48,0,0);
				globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[uVar4] = pIVar2;
				BVar3 = input::Key_Find(local_44,&local_51);
				if (BVar3 != 0) {
					globals::g_InterfaceBuildKeys_Buildings_TABLE[uVar4] = local_51;
				}
			}
			uVar4 += 1;
		} while (uVar4 < globs::legoGlobs.BuildingTypes_COUNT);
	}
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceImages(CFGProperty *root,char *keyBasePath)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	BoolTri BVar5;
	Image *pIVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	KeysByte local_47d;
	int local_47c;
	char *local_478;
	char *local_474;
	char *local_450;
	char *local_44c;
	char *local_448;
	char *local_444;
	char *local_440;
	char *local_43c;
	char *local_438;
	undefined4 local_400 [256];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"InterfaceImages",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			Interface_LoadInterfaceBuildImages(root,keyBasePath);
			Interface_LoadInterfaceBackButton(root,keyBasePath);
			return;
		}
		BVar3 = Interface_GetMenuItemType(prop->key,&local_47c);
		if (BVar3 != 0) {
			uVar8 = 0xffffffff;
			uVar10 = 0;
			pcVar2 = prop->value;
			do {
				pcVar12 = pcVar2;
				if (uVar8 == 0) break;
				uVar8 -= 1;
				pcVar12 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar12;
			} while (cVar1 != '\0');
			uVar8 = ~uVar8;
			puVar11 = (undefined4 *)(pcVar12 + -uVar8);
			puVar13 = local_400;
			for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
				*puVar13 = *puVar11;
				puVar11 = puVar11 + 1;
				puVar13 = puVar13 + 1;
			}
			for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
				*(undefined *)puVar13 = *(undefined *)puVar11;
				puVar11 = (undefined4 *)((int)puVar11 + 1);
				puVar13 = (undefined4 *)((int)puVar13 + 1);
			}
			iVar4 = util::Util_Tokenise((char *)local_400,&local_450,":");
			if ((iVar4 == 7) && (BVar5 = util::Util_GetBoolFromString(local_438), BVar5 != BOOL3_ERROR)) {
				BVar5 = util::Util_GetBoolFromString(local_438);
				uVar10 = (uint)(BVar5 == BOOL3_TRUE);
			}
			BOOL_ARRAY_004deadc[local_47c] = uVar10;
			pIVar6 = lego::image::Image_LoadBMPScaled(local_450,0,0);
			PTRImageBMP_ARRAY_004ddff8[local_47c] = pIVar6;
			pIVar6 = lego::image::Image_LoadBMPScaled(local_44c,0,0);
			PTRImageBMP_ARRAY_004de120[local_47c] = pIVar6;
			pIVar6 = lego::image::Image_LoadBMPScaled(local_448,0,0);
			PTRImageBMP_ARRAY_004de248[local_47c] = pIVar6;
			iVar7 = util::Util_Tokenise(local_444,&local_478,"|");
			iVar4 = local_47c;
			pcVar2 = util::_strdup(local_478);
			PTRString_ARRAY_004de370[iVar4] = pcVar2;
			if (iVar7 == 2) {
				snd::SFX_GetType(local_474,SFXType_ARRAY_004de498 + iVar4);
			}
			iVar7 = util::Util_Tokenise(local_440,&local_478,"|");
			iVar4 = local_47c * 4;
			pcVar2 = util::_strdup(local_478);
			*(char **)(&DAT_004de74c + iVar4) = pcVar2;
			if (iVar7 == 2) {
				snd::SFX_GetType(local_474,(SFXType *)(&DAT_004de874 + iVar4));
			}
			BVar3 = input::Key_Find(local_43c,&local_47d);
			if (BVar3 != 0) {
				globals::g_InterfaceIcon_Keys_TABLE[local_47c] = local_47d;
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::front::Interface_LoadInterfaceSurroundImages(CFGProperty *root,char *keyBasePath)
{
	int value;
	char *pcVar1;
	int iVar2;
	Image *pIVar3;
	Image **ppIVar4;
	Image **ppIVar5;
	char local_64 [20];
	char *stringParts [20];
	
	value = 0;
	ppIVar4 = globals::g_InterfaceSurroundImages;
	ppIVar5 = (Image **)&Point2F_ARRAY_004ddd88[0].y;
	do {
		value += 1;
		std::itoa(value,local_64,10);
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceSurroundImages",local_64,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == NULL) {
			*ppIVar4 = NULL;
		}
		else {
			util::Util_Tokenise(pcVar1,stringParts,":");
			iVar2 = std::_stricmp(stringParts[0],"NULL");
			if (iVar2 != 0) {
				pIVar3 = lego::image::Image_LoadBMPScaled(stringParts[0],0,0);
				*ppIVar4 = pIVar3;
				if (pIVar3 != NULL) {
					lego::image::Image_SetupTrans(pIVar3,0.0,0.0,0.0,0.0,0.0,0.0);
				}
				iVar2 = std::atoi(stringParts[1]);
				ppIVar5[-1] = (Image *)(float)iVar2;
				iVar2 = std::atoi(stringParts[2]);
				*ppIVar5 = (Image *)(float)iVar2;
				iVar2 = std::atoi(stringParts[3]);
				ppIVar5[0x38] = (Image *)(float)iVar2;
				iVar2 = std::atoi(stringParts[4]);
				ppIVar5[0x39] = (Image *)(float)iVar2;
			}
			iVar2 = std::_stricmp(stringParts[5],"NULL");
			if (iVar2 != 0) {
				pIVar3 = lego::image::Image_LoadBMPScaled(stringParts[5],0,0);
				ppIVar4[0x21] = pIVar3;
				if (pIVar3 != NULL) {
					lego::image::Image_SetupTrans(pIVar3,0.0,0.0,0.0,0.0,0.0,0.0);
				}
				iVar2 = std::atoi(stringParts[6]);
				ppIVar5[0x20] = (Image *)(float)iVar2;
				iVar2 = std::atoi(stringParts[7]);
				ppIVar5[0x21] = (Image *)(float)iVar2;
			}
		}
		ppIVar5 = ppIVar5 + 2;
		ppIVar4 = ppIVar4 + 1;
	} while (ppIVar5 < globals::g_InterfaceSurroundImagesBack + 1);
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceBackButton(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	char *local_40;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBackButton",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,&local_50,":");
		globals::g_InterfaceBackButton_size.width = std::atoi(local_50);
		globals::g_InterfaceBackButton_size.height = std::atoi(local_4c);
		globals::g_InterfaceBackButton_bmp = lego::image::Image_LoadBMPScaled(local_48,0,0);
		globals::g_InterfaceBackButton_bmp_pressed = lego::image::Image_LoadBMPScaled(local_44,0,0);
		globals::g_InterfaceBackButton_text = util::Util_RemoveUnderscores(local_40);
		ToolTip_SetText(TOOLTIP_INTERFACEMENUBACKBUTTON,globals::g_InterfaceBackButton_text);
	}
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceDependencies_PlusMinus(char *plus,char *minus)
{
	globals::g_InterfaceDependencies_Plus_bmp = lego::image::Image_LoadBMPScaled(plus,0,0);
	if (globals::g_InterfaceDependencies_Plus_bmp != NULL) {
		lego::image::Image_SetupTrans(globals::g_InterfaceDependencies_Plus_bmp,0.0,0.0,0.0,0.0,0.0,0.0)
		;
	}
	globals::g_InterfaceDependencies_Minus_bmp = lego::image::Image_LoadBMPScaled(minus,0,0);
	if (globals::g_InterfaceDependencies_Minus_bmp != NULL) {
		lego::image::Image_SetupTrans
							(globals::g_InterfaceDependencies_Minus_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl
lego::front::Interface_OpenMenu_FUN_0041b200(InterfaceMenuType interfaceMenuType,Point2I *blockPos)
{
	lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
	Interface_SelectBlock(interfaceMenuType,blockPos);
	Interface_UnkSlideOffScreen_FUN_0041e980_internal(interfaceMenuType,blockPos);
	return;
}



void __cdecl
lego::front::Interface_SelectBlock(InterfaceMenuType interfaceMenuType,Point2I *blockPos)
{
	SurfaceMap *pSVar1;
	WallHighlightType WVar2;
	int iVar3;
	int iVar4;
	
	if ((((InterfaceMenuType_004decfc == INTERFACE_MENU_GROUND) ||
			 (InterfaceMenuType_004decfc == INTERFACE_MENU_ERODE)) ||
			(InterfaceMenuType_004decfc == INTERFACE_MENU_WALL)) ||
		 (((InterfaceMenuType_004decfc == INTERFACE_MENU_RUBBLE ||
			 (InterfaceMenuType_004decfc == INTERFACE_MENU_PLACEFENCE)) ||
			(InterfaceMenuType_004decfc == INTERFACE_MENU_CONSTRUCTION)))) {
		iVar3 = Point2IBlockPos_004decf4.x;
		iVar4 = Point2IBlockPos_004decf4.y;
		pSVar1 = lrr::Lego_GetMap();
		WVar2 = game::Map3D_Block_GetHighlightType(pSVar1,iVar3,iVar4);
		if (WVar2 == WALLHIGHLIGHT_NONE) {
			WallHighlightType_004df1f0 = WALLHIGHLIGHT_NONE;
		}
		else {
			iVar3 = Point2IBlockPos_004decf4.x;
			iVar4 = Point2IBlockPos_004decf4.y;
			WVar2 = WallHighlightType_004df1f0;
			pSVar1 = lrr::Lego_GetMap();
			game::Map3D_Block_SetHighlightType(pSVar1,iVar3,iVar4,WVar2);
		}
	}
	if (((interfaceMenuType == INTERFACE_MENU_GROUND) || (interfaceMenuType == INTERFACE_MENU_ERODE))
		 || ((interfaceMenuType == INTERFACE_MENU_WALL ||
				 (((interfaceMenuType == INTERFACE_MENU_RUBBLE ||
					 (interfaceMenuType == INTERFACE_MENU_PLACEFENCE)) ||
					(interfaceMenuType == INTERFACE_MENU_CONSTRUCTION)))))) {
		WVar2 = WALLHIGHLIGHT_SELECTED;
		iVar3 = blockPos->y;
		iVar4 = blockPos->x;
		pSVar1 = lrr::Lego_GetMap();
		WVar2 = game::Map3D_Block_SetHighlightType(pSVar1,iVar4,iVar3,WVar2);
		if (WVar2 != WALLHIGHLIGHT_SELECTED) {
			WallHighlightType_004df1f0 = WVar2;
		}
	}
	return;
}



int __cdecl lego::front::Interface_FUN_0041b2f0(InterfaceMenuType interfaceMenuType)
{
	ObjectStatsFlags2 OVar1;
	ObjectStatsFlags3 OVar2;
	uint uVar3;
	uint uVar4;
	
	if (interfaceMenuType == INTERFACE_MENU_BUILDBUILDING) {
		return globs::legoGlobs.BuildingTypes_COUNT;
	}
	if (interfaceMenuType == INTERFACE_MENU_BUILDSMALLVEHICLE) {
		uVar4 = 0;
		uVar3 = 0;
		if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
			do {
				OVar1 = stats::Stats_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
				if ((OVar1 & STATS2_USESMALLTELEPORTER) == STATS2_NONE) {
					OVar1 = stats::Stats_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
					if ((OVar1 & STATS2_USEWATERTELEPORTER) != STATS2_NONE) goto LAB_0041b335;
				}
				else {
LAB_0041b335:
					OVar2 = stats::Stats_GetStatsFlags3(OBJECT_VEHICLE,uVar3);
					if ((OVar2 & STATS3_CLASSASLARGE) == STATS3_NONE) {
						uVar4 += 1;
					}
				}
				uVar3 += 1;
				if (globs::legoGlobs.VehicleTypes_COUNT <= uVar3) {
					return uVar4;
				}
			} while( true );
		}
	}
	else {
		if (interfaceMenuType != INTERFACE_MENU_BUILDLARGEVEHICLE) {
			return globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].numIcons;
		}
		uVar4 = 0;
		uVar3 = 0;
		if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
			do {
				OVar1 = stats::Stats_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
				if ((OVar1 & STATS2_USEBIGTELEPORTER) == STATS2_NONE) {
					OVar2 = stats::Stats_GetStatsFlags3(OBJECT_VEHICLE,uVar3);
					if ((OVar2 & STATS3_CLASSASLARGE) != STATS3_NONE) goto LAB_0041b385;
				}
				else {
LAB_0041b385:
					uVar4 += 1;
				}
				uVar3 += 1;
			} while (uVar3 < globs::legoGlobs.VehicleTypes_COUNT);
		}
	}
	return uVar4;
}



BOOL __cdecl lego::front::Interface_NotMainOrFirstPersonMenu(InterfaceMenuType interfaceMenuType)
{
	if ((interfaceMenuType != INTERFACE_MENU_MAIN) &&
		 (interfaceMenuType != INTERFACE_MENU_FIRSTPERSON)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041b3c0(void)
{
	int iVar1;
	BOOL BVar2;
	Image *pIVar3;
	uint uVar4;
	Point2F local_8;
	
	if ((FLAGS_004df1f8 & 4) == 0) {
		return;
	}
	iVar1 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
	BVar2 = Interface_NotMainOrFirstPersonMenu(InterfaceMenuType_004deccc);
	if (BVar2 == 0) {
		if ((Image *)(&Point2F_ARRAY_004ddd88[10].y)[iVar1] != NULL) {
			local_8.x = (float)globals::g_InterfaceSurroundImagesBack[iVar1 * 2 + 9] + Point2F_004decd0.x;
			local_8.y = (float)globals::g_InterfaceSurroundImagesBack[iVar1 * 2 + 10] + Point2F_004decd0.y
			;
			lego::image::Image_DisplayScaled
								((Image *)(&Point2F_ARRAY_004ddd88[10].y)[iVar1],NULL,&local_8,NULL);
		}
		goto LAB_0041b52f;
	}
	if ((&PTRImageFont_004ddd58)[iVar1] != NULL) {
		local_8.x = (float)globals::g_InterfaceSurroundImages[iVar1 * 2 + 9] + Point2F_004decd0.x;
		local_8.y = (float)globals::g_InterfaceSurroundImages[iVar1 * 2 + 10] + Point2F_004decd0.y;
		lego::image::Image_DisplayScaled((Image *)(&PTRImageFont_004ddd58)[iVar1],NULL,&local_8,NULL);
	}
	uVar4 = UINT_ARRAY_004de60c[0] & 4;
	BVar2 = Interface_FUN_0041c990(INTERFACE_MENUITEM_BACKTODEFAULT);
	pIVar3 = globals::g_InterfaceBackButton_bmp;
	if (BVar2 == 0) {
		if ((FLAGS_004df1f8 & 0x4000) == 0) {
			if (uVar4 != 0) goto LAB_0041b47e;
LAB_0041b48e:
			pIVar3 = NULL;
		}
		else {
			if (uVar4 != 0) {
LAB_0041b47e:
				if (BOOL_004ded1c == 0) goto LAB_0041b48e;
			}
		}
	}
	else {
		pIVar3 = globals::g_InterfaceBackButton_bmp_pressed;
		if ((uVar4 != 0) && (BOOL_004ded1c != 0)) {
			pIVar3 = globals::g_InterfaceBackButton_bmp;
		}
	}
	if (pIVar3 != NULL) {
		local_8.x = (float)(&globals::g_InterfaceBackButton_bmp)[iVar1 * 2] + Point2F_004decd0.x;
		local_8.y = (float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar1 * 2] + Point2F_004decd0.y
		;
		lego::image::Image_DisplayScaled(pIVar3,NULL,&local_8,NULL);
	}
	Interface_FUN_0041c420(INTERFACE_MENUITEM_BACKTODEFAULT,OBJECT_NONE,0,NULL);
	Interface_FUN_0041c920(INTERFACE_MENUITEM_BACKTODEFAULT,0);
	Interface_FUN_0041c6e0(INTERFACE_MENUITEM_BACKTODEFAULT);
LAB_0041b52f:
	local_8.x = Point2F_004decd0.x;
	local_8.y = Point2F_004decd0.y;
	Interface_FUN_0041b5b0(InterfaceMenuType_004deccc,Interface_Callback_FUN_0041b730,&local_8);
	if ((FLAGS_004df1f8 & 0x1200) != 0) {
		Interface_Front_DrawLineListUnk_FUN_0041cc60(&Area2F_004ded0c);
	}
	if ((FLAGS_004df1f8 & 0x3000) != 0) {
		Interface_FUN_0041ebd0(Area2F_004ded0c.x,Area2F_004ded0c.y);
		return;
	}
	Interface_SetFloatTo25_004df1ec_AndUnsetFlags800_004df1f8();
	return;
}



BOOL __cdecl
lego::front::Interface_FUN_0041b5b0(InterfaceMenuType menuIcon,undefined *callback,void *context)
{
	int iVar1;
	ObjectStatsFlags2 OVar2;
	ObjectStatsFlags3 OVar3;
	MenuIcon MVar4;
	uint uVar5;
	
	uVar5 = 0;
	if (menuIcon == INTERFACE_MENU_BUILDBUILDING) {
		if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
			do {
				iVar1 = (*(code *)callback)(0x49,4,uVar5,context);
				if (iVar1 != 0) {
					return 1;
				}
				uVar5 += 1;
			} while (uVar5 < globs::legoGlobs.BuildingTypes_COUNT);
			return 0;
		}
	}
	else {
		if (menuIcon == INTERFACE_MENU_BUILDSMALLVEHICLE) {
			uVar5 = 0;
			if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
				while (((OVar2 = stats::Stats_GetStatsFlags2(OBJECT_VEHICLE,uVar5),
								(OVar2 & STATS2_USESMALLTELEPORTER) == STATS2_NONE &&
								(OVar2 = stats::Stats_GetStatsFlags2(OBJECT_VEHICLE,uVar5),
								(OVar2 & STATS2_USEWATERTELEPORTER) == STATS2_NONE)) ||
							 ((OVar3 = stats::Stats_GetStatsFlags3(OBJECT_VEHICLE,uVar5),
								(OVar3 & STATS3_CLASSASLARGE) != STATS3_NONE ||
								(iVar1 = (*(code *)callback)(0x49,1,uVar5,context), iVar1 == 0))))) {
					uVar5 += 1;
					if (globs::legoGlobs.VehicleTypes_COUNT <= uVar5) {
						return 0;
					}
				}
				return 1;
			}
		}
		else {
			if (menuIcon == INTERFACE_MENU_BUILDLARGEVEHICLE) {
				uVar5 = 0;
				if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
					while (((OVar2 = stats::Stats_GetStatsFlags2(OBJECT_VEHICLE,uVar5),
									(OVar2 & STATS2_USEBIGTELEPORTER) == STATS2_NONE &&
									(OVar3 = stats::Stats_GetStatsFlags3(OBJECT_VEHICLE,uVar5),
									(OVar3 & STATS3_CLASSASLARGE) == STATS3_NONE)) ||
								 (iVar1 = (*(code *)callback)(0x49,1,uVar5,context), iVar1 == 0))) {
						uVar5 += 1;
						if (globs::legoGlobs.VehicleTypes_COUNT <= uVar5) {
							return 0;
						}
					}
					return TRUE;
				}
			}
			else {
				if (globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].numIcons != 0) {
					while( true ) {
						MVar4 = globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].iconList[uVar5];
						if ((MVar4 == INTERFACE_MENUITEM_POWERON) || (MVar4 == INTERFACE_MENUITEM_POWEROFF)) {
							MVar4 = Interface_GetPrimaryUnit_PowerIcon
																(globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].iconList +
																 uVar5);
						}
						iVar1 = (*(code *)callback)(MVar4,0,0,context);
						if (iVar1 != 0) break;
						uVar5 += 1;
						if (globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].numIcons <= uVar5) {
							return 0;
						}
					}
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_Callback_FUN_0041b730
					(MenuIcon menuIcon,uint param_2,int param_3,float *param_4)
{
	MenuIcon MVar1;
	Image *image;
	InterfaceIconFlags IVar2;
	
	MVar1 = menuIcon;
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		Interface_FUN_0041c730(param_2,param_3);
		image = Interface_GetBuildImageByObjectType(param_2,param_3);
		if (param_2 == 1) {
			IVar2 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[param_3] &
							INTERFACE_MENUITEM_FLAG_FLASH;
		}
		else {
			IVar2 = param_2;
			if (param_2 == 4) {
				IVar2 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[param_3] &
								INTERFACE_MENUITEM_FLAG_FLASH;
			}
		}
		Interface_FUN_0041c950(param_2,param_3,0);
	}
	else {
		Interface_FUN_0041c6e0(menuIcon);
		image = Interface_FUN_0041c9e0(menuIcon);
		IVar2 = UINT_ARRAY_004de60c[menuIcon] & INTERFACE_MENUITEM_FLAG_FLASH;
		Interface_FUN_0041c920(menuIcon,0);
	}
	Interface_FUN_0041c420(menuIcon,param_2,param_3,param_4);
	if (image == NULL) {
		menuIcon = INTERFACE_MENUITEM_DELETEBUILDING;
	}
	else {
		menuIcon = image->height;
		if ((IVar2 == INTERFACE_MENUITEM_FLAG_NONE) || (BOOL_004ded1c != 0)) {
			lego::image::Image_DisplayScaled(image,NULL,(Point2F *)param_4,NULL);
		}
	}
	if (MVar1 == INTERFACE_MENUITEM_TELEPORTMAN) {
		param_3 = 0;
		param_2 = 2;
	}
	else {
		if (MVar1 != INTERFACE_MENUITEM_BUILD) goto LAB_0041b82e;
	}
	Interface_FUN_0041eb60(param_2,param_3,(Point2F *)param_4);
LAB_0041b82e:
	param_4[1] = (float)(ulonglong)menuIcon + param_4[1];
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041b860(float elapsedAbs)
{
	TIMER_004ded20 = TIMER_004ded20 - elapsedAbs;
	if (TIMER_004ded20 < 0.0) {
		BOOL_004ded1c = ZEXT14(BOOL_004ded1c == 0);
		TIMER_004ded20 = 15.0;
	}
	Interface_FUN_0041e9f0(elapsedAbs);
	if ((ushort)((ushort)(FLOAT_004df1ec < 0.0) << 8 | (ushort)(FLOAT_004df1ec == 0.0) << 0xe) == 0) {
		FLOAT_004df1ec = FLOAT_004df1ec - elapsedAbs;
		return;
	}
	FLAGS_004df1f8 = FLAGS_004df1f8 | 0x800;
	return;
}



BOOL __cdecl lego::front::Interface_GetBool_004ded1c(void)
{
	return BOOL_004ded1c;
}



// Result is same as final value of *ref_param_1 (param_1 may not be changed)

MenuIcon __cdecl lego::front::Interface_GetPrimaryUnit_PowerIcon(MenuIcon *ref_menuIcon)
{
	LiveObject *primaryUnit;
	
	primaryUnit = game::Message_GetPrimarySelectedUnit();
	if (((FLAGS_004df1f8 & 0x80) == 0) && ((FLAGS_004df1f8 & 0x100) != 0)) {
		return *ref_menuIcon;
	}
	if ((primaryUnit->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE) {
		*ref_menuIcon = INTERFACE_MENUITEM_POWERON;
		return INTERFACE_MENUITEM_POWERON;
	}
	*ref_menuIcon = INTERFACE_MENUITEM_POWEROFF;
	return INTERFACE_MENUITEM_POWEROFF;
}



void __cdecl lego::front::Interface_FUN_0041b940(float elapsedAbs)
{
	SFXType SVar1;
	
	SVar1 = SFXType_004df1f4;
	if (SFXType_004df1f4 != SFXType_004df1fc) {
		globals::g_Interface_TIMER_004a3b58 = 25.0;
		SFXType_004df1f4 = SFX_NULL;
		SFXType_004df1fc = SVar1;
		BOOLSFXPlaying_004df200 = 0;
		return;
	}
	globals::g_Interface_TIMER_004a3b58 = globals::g_Interface_TIMER_004a3b58 - elapsedAbs;
	if (((ushort)((ushort)(globals::g_Interface_TIMER_004a3b58 < 0.0) << 8 |
							 (ushort)(globals::g_Interface_TIMER_004a3b58 == 0.0) << 0xe) != 0) &&
		 (BOOLSFXPlaying_004df200 == 0)) {
		BOOLSFXPlaying_004df200 = snd::SFX_Sample_Random_SetAndPlayGlobalSample(SFXType_004df1f4,NULL);
	}
	SFXType_004df1f4 = SFX_NULL;
	return;
}



void __cdecl lego::front::Interface_SetDat_004df1f4(SFXType param_1)
{
	SFXType_004df1f4 = param_1;
	return;
}



BOOL __cdecl
lego::front::Interface_DoSomethingWithRenameReplace
					(uint param_1,uint param_2,int param_3,int param_4,int param_5)
{
	Image *pIVar1;
	char cVar2;
	BOOL BVar3;
	char *pcVar4;
	LiveObject *pLVar5;
	uint uVar6;
	undefined4 *puVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	char *pcVar11;
	char **ppcVar12;
	Font *image;
	undefined4 *puVar13;
	int iVar14;
	char *pcVar15;
	undefined4 *puVar16;
	longlong lVar17;
	SFXType SVar18;
	MenuIcon local_a78;
	int local_a74;
	uint local_a70;
	ObjectType local_a6c;
	int local_a68;
	ObjectType local_a64;
	int local_a60;
	int local_a5c;
	uint local_a58;
	uint local_a54;
	char *local_a50 [20];
	char local_a00 [512];
	undefined4 local_800;
	undefined4 local_600 [128];
	char local_400 [1024];
	
	pcVar11 = NULL;
	local_a70 = 0;
	local_a60 = 0;
	if (((FLAGS_004df1f8 & 4) == 0) || ((FLAGS_004df1f8 & 0x80) == 0)) {
		FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffff89ff;
		return 0;
	}
	FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffff89ff;
	BVar3 = Interface_FUN_0041edb0
										(param_1,param_2,Area2F_004ded0c.x,Area2F_004ded0c.y,&local_a64,&local_a68,
										 &local_a5c);
	if (BVar3 != 0) {
		FLAGS_004df1f8 |= 0x1000;
		if (((param_3 == 0) && (param_5 == 0)) && (local_a64 != 0x14)) {
			pcVar11 = globs::legoGlobs.UpgradeNames_TABLE[local_a5c];
			if (pcVar11 == NULL) {
				pcVar11 = game::Object_GetName(local_a64,local_a68);
				std::sprintf((char *)&local_800,"%s",pcVar11);
			}
			else {
				pcVar4 = game::Object_GetName(local_a64,local_a68);
				std::sprintf((char *)&local_800,"%s (%s)",pcVar4,pcVar11);
			}
			ToolTip_SetText(TOOLTIP_INTERFACEMENU,(char *)&local_800);
			ToolTip_AddFlag4(TOOLTIP_INTERFACEMENU);
			ToolTip_ResetTimer(TOOLTIP_INTERFACEMENU);
			if ((globs::legoGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
				Interface_SetDat_004df1f4(globs::liveGlobs.ObjTtSFX_TABLE[local_a64][local_a68]);
			}
		}
		Interface_FUN_0041c610(INTERFACE_MENUITEM_BACKTODEFAULT,0,0,param_3,param_4);
		return TRUE;
	}
	BVar3 = Interface_FUN_0041c0f0(param_1,param_2,&local_a78,&local_a6c,&local_a74);
	if (BVar3 == 0) {
		iVar14 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
		BVar3 = Interface_NotMainOrFirstPersonMenu(InterfaceMenuType_004deccc);
		if (BVar3 == 0) {
			image = (Font *)(&Point2F_ARRAY_004ddd88[10].y)[iVar14];
			lVar17 = __ftol((float10)(float)globals::g_InterfaceSurroundImagesBack[iVar14 * 2 + 9] +
											(float10)Point2F_004decd0.x);
			iVar8 = (int)lVar17;
			pIVar1 = globals::g_InterfaceSurroundImagesBack[iVar14 * 2 + 10];
		}
		else {
			image = (&PTRImageFont_004ddd58)[iVar14];
			lVar17 = __ftol((float10)(float)globals::g_InterfaceSurroundImages[iVar14 * 2 + 9] +
											(float10)Point2F_004decd0.x);
			iVar8 = (int)lVar17;
			pIVar1 = globals::g_InterfaceSurroundImages[iVar14 * 2 + 10];
		}
		lVar17 = __ftol((float10)(float)pIVar1 + (float10)Point2F_004decd0.y);
		if (image == NULL) {
			return local_a70;
		}
		BVar3 = lego::image::Image_GetPixel
											((Image *)image,param_1 - iVar8,param_2 - (int)lVar17,&local_a58);
		if (BVar3 == 0) {
			return local_a70;
		}
		if (local_a58 == 0) {
			return local_a70;
		}
		if (param_5 != 0) {
			game::Game_SetPointer_AndPlayEnumSFX(1);
		}
		return TRUE;
	}
	if (local_a78 == INTERFACE_MENUITEM_BACKTODEFAULT) {
		FLAGS_004df1f8 |= 0x4000;
		ToolTip_AddFlag4(TOOLTIP_INTERFACEMENUBACKBUTTON);
		goto LAB_0041bf5c;
	}
	if (local_a78 == INTERFACE_MENUITEM_BUILD) {
		FLAGS_004df1f8 =
				 FLAGS_004df1f8 & 0xffff0000 |
				 (uint)(ushort)(CONCAT11((char)((FLAGS_004df1f8 | 0x200) >> 8),(char)FLAGS_004df1f8) | 0x400
											 ) | 0x2000;
		pcVar11 = game::Object_GetName(local_a6c,local_a74);
		std::sprintf(local_a00,"%s",pcVar11);
		if ((globs::legoGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
			Interface_SetDat_004df1f4(globs::liveGlobs.ObjTtSFX_TABLE[local_a6c][local_a74]);
			pcVar4 = local_a00;
		}
		else {
LAB_0041bec2:
			pcVar4 = local_a00;
		}
	}
	else {
		if ((local_a78 == INTERFACE_MENUITEM_LAYPATH) ||
			 (uVar6 = FLAGS_004df1f8 | 0x200, local_a78 == INTERFACE_MENUITEM_PLACEFENCE)) {
			uVar6 = FLAGS_004df1f8 | 0x2200;
		}
		FLAGS_004df1f8 = uVar6;
		BVar3 = Interface_FUN_0041c820(local_a78,0);
		if (BVar3 == 0) {
			pcVar4 = PTRString_ARRAY_004de370[local_a78];
			if ((pcVar4 != NULL) &&
				 (pcVar11 = pcVar4, (globs::legoGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE)) {
				SVar18 = SFXType_ARRAY_004de498[local_a78];
LAB_0041bd3e:
				Interface_SetDat_004df1f4(SVar18);
				pcVar11 = pcVar4;
			}
		}
		else {
			if (*(int *)(&DAT_004de74c + local_a78 * 4) != 0) {
				pLVar5 = game::Message_GetPrimarySelectedUnit();
				if (((((pLVar5 == NULL) || (local_a78 != INTERFACE_MENUITEM_UPGRADEBUILDING)) ||
						 (uVar6 = stats::Stats_GetLevels(pLVar5->objType,pLVar5->objIndex),
						 uVar6 <= pLVar5->objLevel + 1)) ||
						((uVar6 = game::Level_GetOreCount(0),
						 (uint)globs::legoGlobs.BuildingUpgradeCostOre <= uVar6 ||
						 (uVar6 = game::Level_GetOreCount(1),
						 (uint)globs::legoGlobs.BuildingUpgradeCostStuds <= uVar6)))) ||
					 (globs::liveGlobs.ToolTipIcon_Ore == NULL)) {
					pcVar11 = *(char **)(&DAT_004de74c + local_a78 * 4);
				}
				else {
					if (globs::legoGlobs.OreRequiredText != NULL) {
						std::sprintf(local_400,"%s",globs::legoGlobs.OreRequiredText);
						pcVar11 = local_400;
					}
					local_a60 = game::Level_GetOreCount(0);
					local_a60 = globs::legoGlobs.BuildingUpgradeCostOre - local_a60;
				}
				if ((globs::legoGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
					SVar18 = *(SFXType *)(&DAT_004de874 + local_a78 * 4);
					pcVar4 = pcVar11;
					goto LAB_0041bd3e;
				}
			}
		}
		pcVar4 = NULL;
		if (((pcVar11 != NULL) && (pcVar4 = pcVar11, BOOL_ARRAY_004deadc[local_a78] != 0)) &&
			 ((uVar6 = game::Message_GetNumSelectedUnits(), uVar6 == 1 &&
				(((pLVar5 = game::Message_GetPrimarySelectedUnit(), pLVar5 != NULL &&
					(pLVar5 = game::Message_GetPrimarySelectedUnit(), pLVar5->customName != NULL)) &&
				 (pLVar5 = game::Message_GetPrimarySelectedUnit(), *pLVar5->customName != '\0')))))) {
			uVar6 = 0xffffffff;
			pcVar4 = globs::legoGlobs.RenameReplace;
			do {
				pcVar15 = pcVar4;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar15 = pcVar4 + 1;
				cVar2 = *pcVar4;
				pcVar4 = pcVar15;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar13 = (undefined4 *)(pcVar15 + -uVar6);
			puVar16 = &local_800;
			for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 -= 1) {
				*puVar16 = *puVar13;
				puVar13 = puVar13 + 1;
				puVar16 = puVar16 + 1;
			}
			for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
				*(undefined *)puVar16 = *(undefined *)puVar13;
				puVar13 = (undefined4 *)((int)puVar13 + 1);
				puVar16 = (undefined4 *)((int)puVar16 + 1);
			}
			uVar6 = 0xffffffff;
			do {
				pcVar4 = pcVar11;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar4 = pcVar11 + 1;
				cVar2 = *pcVar11;
				pcVar11 = pcVar4;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar13 = (undefined4 *)(pcVar4 + -uVar6);
			puVar16 = local_600;
			for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 -= 1) {
				*puVar16 = *puVar13;
				puVar13 = puVar13 + 1;
				puVar16 = puVar16 + 1;
			}
			puVar7 = &local_800;
			for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
				*(undefined *)puVar16 = *(undefined *)puVar13;
				puVar13 = (undefined4 *)((int)puVar13 + 1);
				puVar16 = (undefined4 *)((int)puVar16 + 1);
			}
			while ((char)local_800 != '\0') {
				if (*(char *)puVar7 == ' ') {
					*(char *)puVar7 = '_';
				}
				pcVar11 = (char *)((int)puVar7 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				local_800._0_1_ = *pcVar11;
			}
			local_a54 = util::Util_Tokenise((char *)local_600,local_a50,(char *)&local_800);
			uVar6 = 0;
			local_a00[0] = '\0';
			if (local_a54 != 0) {
				local_a70 = local_a54 - 1;
				ppcVar12 = local_a50;
				do {
					uVar9 = 0xffffffff;
					pcVar11 = *ppcVar12;
					do {
						pcVar4 = pcVar11;
						if (uVar9 == 0) break;
						uVar9 -= 1;
						pcVar4 = pcVar11 + 1;
						cVar2 = *pcVar11;
						pcVar11 = pcVar4;
					} while (cVar2 != '\0');
					uVar9 = ~uVar9;
					iVar14 = -1;
					pcVar11 = local_a00;
					do {
						pcVar15 = pcVar11;
						if (iVar14 == 0) break;
						iVar14 += -1;
						pcVar15 = pcVar11 + 1;
						cVar2 = *pcVar11;
						pcVar11 = pcVar15;
					} while (cVar2 != '\0');
					puVar13 = (undefined4 *)(pcVar4 + -uVar9);
					puVar16 = (undefined4 *)(pcVar15 + -1);
					for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
						*puVar16 = *puVar13;
						puVar13 = puVar13 + 1;
						puVar16 = puVar16 + 1;
					}
					for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
						*(undefined *)puVar16 = *(undefined *)puVar13;
						puVar13 = (undefined4 *)((int)puVar13 + 1);
						puVar16 = (undefined4 *)((int)puVar16 + 1);
					}
					if (uVar6 < local_a70) {
						pLVar5 = game::Message_GetPrimarySelectedUnit();
						uVar9 = 0xffffffff;
						pcVar11 = pLVar5->customName;
						do {
							pcVar4 = pcVar11;
							if (uVar9 == 0) break;
							uVar9 -= 1;
							pcVar4 = pcVar11 + 1;
							cVar2 = *pcVar11;
							pcVar11 = pcVar4;
						} while (cVar2 != '\0');
						uVar9 = ~uVar9;
						iVar14 = -1;
						pcVar11 = local_a00;
						do {
							pcVar15 = pcVar11;
							if (iVar14 == 0) break;
							iVar14 += -1;
							pcVar15 = pcVar11 + 1;
							cVar2 = *pcVar11;
							pcVar11 = pcVar15;
						} while (cVar2 != '\0');
						puVar13 = (undefined4 *)(pcVar4 + -uVar9);
						puVar16 = (undefined4 *)(pcVar15 + -1);
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
							*puVar16 = *puVar13;
							puVar13 = puVar13 + 1;
							puVar16 = puVar16 + 1;
						}
						for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
							*(undefined *)puVar16 = *(undefined *)puVar13;
							puVar13 = (undefined4 *)((int)puVar13 + 1);
							puVar16 = (undefined4 *)((int)puVar16 + 1);
						}
					}
					uVar6 += 1;
					ppcVar12 = ppcVar12 + 1;
				} while (uVar6 < local_a54);
			}
			goto LAB_0041bec2;
		}
	}
	if ((param_3 == 0) && (param_5 == 0)) {
		if (pcVar4 == NULL) {
			std::sprintf(local_a00,"Missing config for\n\'%s\'",
									 globals::g_InterfaceMenuItemNames_TABLE[local_a78]);
			ToolTip_SetText(TOOLTIP_INTERFACEMENU,local_a00);
		}
		else {
			ToolTip_SetText(TOOLTIP_INTERFACEMENU,pcVar4);
			for (iVar14 = local_a60; iVar14 != 0; iVar14 += -1) {
				ToolTip_AddIcon(TOOLTIP_INTERFACEMENU,globs::liveGlobs.ToolTipIcon_Ore);
			}
		}
		ToolTip_AddFlag4(TOOLTIP_INTERFACEMENU);
		ToolTip_ResetTimer(TOOLTIP_INTERFACEMENU);
	}
	else {
		Interface_SetDat_004df1f4(0);
	}
LAB_0041bf5c:
	BVar3 = Interface_FUN_0041c610(local_a78,local_a6c,local_a74,param_3,param_4);
	if ((BVar3 != 0) && (param_5 != 0)) {
		if (local_a78 == INTERFACE_MENUITEM_BUILD) {
			if ((InterfaceMenuType_004deccc == INTERFACE_MENU_BUILDSMALLVEHICLE) ||
				 (InterfaceMenuType_004deccc == INTERFACE_MENU_BUILDLARGEVEHICLE)) {
				globals::g_SubmenuIcons_VehicleTypesClicked_TABLE[local_a74] =
						 globals::g_SubmenuIcons_VehicleTypesClicked_TABLE[local_a74] + 1;
			}
			else {
				if (InterfaceMenuType_004deccc == INTERFACE_MENU_BUILDBUILDING) {
					globals::g_SubmenuIcons_BuildingTypesClicked_TABLE[local_a74] =
							 globals::g_SubmenuIcons_BuildingTypesClicked_TABLE[local_a74] + 1;
				}
			}
		}
		else {
			globals::g_Interface_Icons_Clicked[local_a78] =
					 globals::g_Interface_Icons_Clicked[local_a78] + 1;
		}
		BVar3 = Interface_DoAction_FUN_0041dbd0(local_a78);
		game::Game_SetPointer_AndPlayEnumSFX((uint)(BVar3 == 0));
	}
	return 1;
}



BOOL __cdecl
lego::front::Interface_FUN_0041c0f0
					(uint param_1,uint param_2,undefined4 *param_3,undefined4 *param_4,undefined4 *param_5)
{
	float fVar1;
	float fVar2;
	int iVar3;
	BOOL BVar4;
	uint local_1c;
	uint local_18;
	float local_14;
	float local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar3 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
	BVar4 = Interface_NotMainOrFirstPersonMenu(InterfaceMenuType_004deccc);
	if (BVar4 != 0) {
		fVar1 = (float)(ulonglong)param_1;
		if (((((float)(&globals::g_InterfaceBackButton_bmp)[iVar3 * 2] + Point2F_004decd0.x <= fVar1) &&
				 (fVar2 = (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.width +
									(float)(&globals::g_InterfaceBackButton_bmp)[iVar3 * 2] + Point2F_004decd0.x,
				 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
				(fVar1 = (float)(ulonglong)param_2,
				(float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar3 * 2] + Point2F_004decd0.y <=
				fVar1)) &&
			 (fVar2 = (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.height +
								(float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar3 * 2] + Point2F_004decd0.y
			 , (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) {
			*param_3 = 0;
			return TRUE;
		}
	}
	local_14 = Point2F_004decd0.x;
	local_1c = param_1;
	local_18 = param_2;
	local_10 = Point2F_004decd0.y;
	BVar4 = Interface_FUN_0041b5b0
										(InterfaceMenuType_004deccc,Interface_Callback_FUN_0041c240,&local_1c);
	if (BVar4 == 0) {
		return 0;
	}
	*param_3 = local_c;
	*param_4 = local_8;
	*param_5 = local_4;
	return TRUE;
}



BOOL __cdecl
lego::front::Interface_Callback_FUN_0041c240
					(MenuIcon in_menuIcon,ObjectType objType,int objIndex,uint *param_4)
{
	Point2F *point;
	float fVar1;
	float fVar2;
	MenuIcon menuIcon;
	Image *pIVar3;
	uint uVar4;
	
	menuIcon = in_menuIcon;
	if (in_menuIcon == INTERFACE_MENUITEM_BUILD) {
		pIVar3 = Interface_GetBuildImageByObjectType(objType,objIndex);
	}
	else {
		pIVar3 = Interface_FUN_0041c9e0(in_menuIcon);
	}
	if (pIVar3 == NULL) {
		uVar4 = 0x28;
		in_menuIcon = INTERFACE_MENUITEM_DELETEBUILDING;
	}
	else {
		in_menuIcon = pIVar3->width;
		uVar4 = pIVar3->height;
	}
	point = (Point2F *)(param_4 + 2);
	fVar1 = (float)(ulonglong)*param_4;
	if ((((point->x <= fVar1) &&
			 (fVar2 = (float)(ulonglong)in_menuIcon + point->x,
			 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
			(fVar1 = (float)(ulonglong)param_4[1], (float)param_4[3] <= fVar1)) &&
		 ((ushort)((ushort)(fVar1 < (float)(ulonglong)uVar4 + (float)param_4[3]) << 8 |
							(ushort)(fVar1 == (float)(ulonglong)uVar4 + (float)param_4[3]) << 0xe) != 0)) {
		param_4[4] = menuIcon;
		Interface_SetDat_004decd8_004decdc(menuIcon,objType,objIndex);
		if (menuIcon == INTERFACE_MENUITEM_BUILD) {
			param_4[5] = objType;
			param_4[6] = objIndex;
		}
		Interface_FUN_0041cc10(point,in_menuIcon + ~INTERFACE_MENUITEM_BACKTODEFAULT,uVar4 - 1);
		return TRUE;
	}
	param_4[3] = (uint)((float)(ulonglong)uVar4 + (float)param_4[3]);
	return 0;
}



void __cdecl lego::front::Interface_DoF2InterfaceKeyAction(void)
{
	if (((((byte)FLAGS_004df1f8 & 4) != 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) &&
		 (globs::INPUT.Key_Map[60] != false)) {
		Interface_FUN_0041b5b0(InterfaceMenuType_004deccc,Interface_CallbackDoMenuIconKeyAction,NULL);
	}
	return;
}



BOOL __cdecl
lego::front::Interface_CallbackDoMenuIconKeyAction
					(MenuIcon menuIcon,ObjectType objType,int objIndex)
{
	MenuIcon menuIcon_00;
	
	menuIcon_00 = menuIcon;
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		if (objType == OBJECT_VEHICLE) {
			menuIcon = (MenuIcon)globals::g_InterfaceBuildKeys_Vehicles_TABLE[objIndex];
		}
		else {
			if (objType == OBJECT_BUILDING) {
				menuIcon = (MenuIcon)globals::g_InterfaceBuildKeys_Buildings_TABLE[objIndex];
			}
		}
	}
	else {
		menuIcon = (MenuIcon)globals::g_InterfaceIcon_Keys_TABLE[menuIcon];
	}
	if ((globs::INPUT.Key_Map[menuIcon & 0xff] != false) &&
		 (globs::INPUT.prevKey_Map[menuIcon & 0xff] != globs::INPUT.Key_Map[menuIcon & 0xff])) {
		Interface_SetDat_004decd8_004decdc(menuIcon_00,objType,objIndex);
		Interface_DoAction_FUN_0041dbd0(menuIcon_00);
	}
	return 0;
}



void __cdecl
lego::front::Interface_FUN_0041c420
					(MenuIcon menuIcon,ObjectType objType,int objIndex,float *param_4)
{
	bool bVar1;
	bool bVar2;
	BOOL BVar3;
	int iVar4;
	float local_18;
	float fStack20;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 uStack4;
	
	bVar2 = false;
	if (((FLAGS_004df1f8 & 0x20) != 0) && (BVar3 = Advisor_GetFlag1(), BVar3 == 0)) {
		bVar1 = false;
		if (MenuIcon_004ded28 == INTERFACE_MENUITEM_BUILD) {
			if ((ObjectType_004ded2c == objType) && (INT_004ded30 == objIndex)) {
				objType = (ObjectType)Interface_GetBuildImageByObjectType(objType,objIndex);
				bVar1 = true;
			}
		}
		else {
			if (menuIcon == MenuIcon_004ded28) {
				if (menuIcon == INTERFACE_MENUITEM_BACKTODEFAULT) {
					bVar2 = true;
					bVar1 = true;
				}
				else {
					objType = (ObjectType)Interface_FUN_0041c9e0(menuIcon);
					bVar1 = true;
				}
			}
		}
		if (bVar1) {
			if (bVar2) {
				iVar4 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
				if ((FLAGS_004df1f8 & 0x80) == 0) {
					local_18 = (float)(&globals::g_InterfaceBackButton_bmp)[iVar4 * 2] + Point2F_004dece8.x;
				}
				else {
					local_18 = (float)(&globals::g_InterfaceBackButton_bmp)[iVar4 * 2] + Point2F_004decd0.x;
				}
				local_18 = local_18 -
									 (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.width * -0.5;
				fStack20 = ((float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar4 * 2] +
									 Point2F_004decd0.y) -
									 (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.height * -0.5;
			}
			else {
				if ((Image *)objType == NULL) {
					local_8 = 0x28;
				}
				else {
					local_8 = *(uint *)(objType + 8);
				}
				local_18 = *param_4;
				if ((FLAGS_004df1f8 & 0x80) == 0) {
					local_18 = Point2F_004dece8.x;
				}
				uStack4 = 0;
				fStack20 = (float)(ulonglong)local_8 * 0.5 + param_4[1];
			}
			Advisor_GetPoint2(AdvisorType_004ded24,&local_10,&local_c);
			Advisor_SetParameters
								(AdvisorType_004ded24,PANEL__COUNT,local_10 + local_18,local_c + fStack20);
			Advisor_SetCurrentAdvisor(AdvisorType_004ded24,FLAGS_004df1f8 & 0x40);
			FLAGS_004df1f8 &= 0xffffffdf;
		}
	}
	return;
}



BOOL __cdecl
lego::front::Interface_FUN_0041c610
					(MenuIcon menuIcon,int param_2,int param_3,int param_4,int param_5)
{
	MenuIcon MVar1;
	
	MVar1 = INTMenuIcon_004ded00;
	if (param_4 == 0) {
		INTMenuIcon_004ded00 = INTERFACE_MENUITEM__COUNT;
	}
	else {
		if ((FLAGS_004df1f8 & 0x1000) == 0) {
			if (INTMenuIcon_004ded00 == INTERFACE_MENUITEM__COUNT) {
				if (param_5 != 0) goto LAB_0041c6aa;
				INTMenuIcon_004ded00 = menuIcon;
				DAT_004ded04 = param_2;
				DAT_004ded08 = param_3;
				if (menuIcon == INTERFACE_MENUITEM_BUILD) {
					Interface_FUN_0041c950(param_2,param_3,TRUE);
					goto LAB_0041c6aa;
				}
			}
			else {
				if (INTMenuIcon_004ded00 != menuIcon) goto LAB_0041c6aa;
				if (menuIcon == INTERFACE_MENUITEM_BUILD) {
					if ((DAT_004ded04 == param_2) && (DAT_004ded08 == param_3)) {
						Interface_FUN_0041c950(param_2,param_3,TRUE);
					}
					goto LAB_0041c6aa;
				}
			}
			Interface_FUN_0041c920(menuIcon,TRUE);
		}
	}
LAB_0041c6aa:
	if (MVar1 == menuIcon) {
		if (menuIcon != INTERFACE_MENUITEM_BUILD) {
			return TRUE;
		}
		if ((DAT_004ded04 == param_2) && (DAT_004ded08 == param_3)) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041c6e0(MenuIcon menuIcon)
{
	BOOL BVar1;
	uint uVar2;
	
	uVar2 = UINT_ARRAY_004de60c[menuIcon];
	if (((uVar2 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
		BVar1 = Interface_HandleIcon_FUN_0041cf70(menuIcon);
		uVar2 = UINT_ARRAY_004de60c[menuIcon];
		if (BVar1 != 0) {
			UINT_ARRAY_004de60c[menuIcon] = uVar2 & 0xfffffffe;
			return;
		}
	}
	UINT_ARRAY_004de60c[menuIcon] = uVar2 | 1;
	return;
}



void __cdecl lego::front::Interface_FUN_0041c730(ObjectType objType,int objIndex)
{
	BOOL BVar1;
	int iVar2;
	int iVar3;
	InterfaceIconFlags IVar4;
	InterfaceIconFlags *pIVar5;
	
	if (objType == OBJECT_VEHICLE) {
		IVar4 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex];
		pIVar5 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE;
		if (((IVar4 & 2) == INTERFACE_MENUITEM_FLAG_NONE) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
			BVar1 = Interface_Object_FindTeleporter_FUN_0041f030(OBJECT_VEHICLE,objIndex);
			if ((BVar1 != 0) &&
				 (BVar1 = game::Dependencies_Object_FUN_0040add0(OBJECT_VEHICLE,objIndex,0), BVar1 != 0)) {
				iVar2 = stats::Stats_GetCostCrystal(OBJECT_VEHICLE,objIndex,0);
				iVar3 = game::Level_GetCrystalCount(1);
				if (iVar2 <= iVar3) {
					globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] =
							 globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] & 0xfffffffe;
					return;
				}
			}
			globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] =
					 globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] | 1;
			return;
		}
	}
	else {
		if (objType != OBJECT_BUILDING) {
			return;
		}
		IVar4 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex];
		pIVar5 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE;
		if (((IVar4 & 2) == INTERFACE_MENUITEM_FLAG_NONE) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
			BVar1 = Interface_Object_FindTeleporter_FUN_0041f030(OBJECT_BUILDING,objIndex);
			if ((BVar1 != 0) &&
				 (BVar1 = game::Dependencies_Object_FUN_0040add0(OBJECT_BUILDING,objIndex,0), BVar1 != 0)) {
				globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] =
						 globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] & 0xfffffffe;
				return;
			}
			globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] =
					 globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] | 1;
			return;
		}
	}
	pIVar5[objIndex] = IVar4 | 1;
	return;
}



BOOL __cdecl lego::front::Interface_FUN_0041c820(MenuIcon menuIcon,BOOL param_2)
{
	TutorialFlags TVar1;
	
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		return 0;
	}
	if ((globs::legoGlobs.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
		return 1;
	}
	if (param_2 != 0) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar1 & 1) != TUTORIAL_NONE) {
			return ~UINT_ARRAY_004de60c[menuIcon] >> 2 & 1;
		}
	}
	return UINT_ARRAY_004de60c[menuIcon] & 1;
}



BOOL __cdecl lego::front::Interface_FUN_0041c880(ObjectType objType,int objIndex,BOOL param_3)
{
	TutorialFlags TVar1;
	
	if ((globs::legoGlobs.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
		return TRUE;
	}
	if (param_3 != 0) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar1 & 1) != TUTORIAL_NONE) {
			if (objType == OBJECT_VEHICLE) {
				return ~globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] >> 2 & 1;
			}
			if (objType == OBJECT_BUILDING) {
				return ~globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] >> 2 & 1;
			}
		}
	}
	if (objType == OBJECT_VEHICLE) {
		return globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] & 1;
	}
	if (objType == OBJECT_BUILDING) {
		return globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] & 1;
	}
	return INTERFACE_MENUITEM_FLAG_NONE;
}



void __cdecl lego::front::Interface_FUN_0041c920(MenuIcon menuIcon,BOOL setFlag8)
{
	if (setFlag8 != 0) {
		UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] | 8;
		return;
	}
	UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] & 0xfffffff7;
	return;
}



void __cdecl lego::front::Interface_FUN_0041c950(ObjectType objType,int objIndex,BOOL param_3)
{
	InterfaceIconFlags *pIVar1;
	
	pIVar1 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE;
	if ((objType == OBJECT_VEHICLE) ||
		 (pIVar1 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE, objType == OBJECT_BUILDING)) {
		if (param_3 != 0) {
			pIVar1[objIndex] = pIVar1[objIndex] | 8;
			return;
		}
		pIVar1[objIndex] = pIVar1[objIndex] & 0xfffffff7;
	}
	return;
}



BOOL __cdecl lego::front::Interface_FUN_0041c990(MenuIcon menuIcon)
{
	return UINT_ARRAY_004de60c[menuIcon] & 8;
}



BOOL __cdecl lego::front::Interface_FUN_0041c9a0(ObjectType objType,int objIndex)
{
	if (objType == OBJECT_VEHICLE) {
		return globals::g_SubmenuIcons_VehicleTypesFlags_TABLE[objIndex] & 8;
	}
	if (objType == OBJECT_BUILDING) {
		return globals::g_SubmenuIcons_BuildingTypesFlags_TABLE[objIndex] & 8;
	}
	return INTERFACE_MENUITEM_FLAG_NONE;
}



Image * __cdecl lego::front::Interface_FUN_0041c9e0(MenuIcon menuIcon)
{
	BOOL BVar1;
	
	BVar1 = Interface_FUN_0041c820(menuIcon,FALSE);
	if (BVar1 != 0) {
		return PTRImageBMP_ARRAY_004de120[menuIcon];
	}
	BVar1 = Interface_FUN_0041c990(menuIcon);
	if (BVar1 != 0) {
		return PTRImageBMP_ARRAY_004de248[menuIcon];
	}
	return PTRImageBMP_ARRAY_004ddff8[menuIcon];
}



Image * __cdecl lego::front::Interface_GetBuildImageByObjectType(ObjectType objType,int objIndex)
{
	BOOL BVar1;
	
	BVar1 = Interface_FUN_0041c880(objType,objIndex,0);
	if (BVar1 == 0) {
		BVar1 = Interface_FUN_0041c9a0(objType,objIndex);
		if (BVar1 == 0) {
			if (objType == OBJECT_VEHICLE) {
				return globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[objIndex];
			}
			if (objType == OBJECT_BUILDING) {
				return globals::g_InterfaceBuildImages_Buildings_normal_TABLE[objIndex];
			}
		}
		else {
			if (objType == OBJECT_VEHICLE) {
				return globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[objIndex];
			}
			if (objType == OBJECT_BUILDING) {
				return globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[objIndex];
			}
		}
	}
	else {
		if (objType == OBJECT_VEHICLE) {
			return globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[objIndex];
		}
		if (objType == OBJECT_BUILDING) {
			return globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[objIndex];
		}
	}
	return NULL;
}



Image * __cdecl
lego::front::Interface_GetObjectBuildImage(ObjectType objType,int objIndex,BOOL param_3)
{
	if (param_3 == 0) {
		if (true) {
			switch(objType) {
			case OBJECT_VEHICLE:
				return globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[objIndex];
			case OBJECT_MINIFIGURE:
				return PTRImageBMP_ARRAY_004de120[1];
			case OBJECT_BUILDING:
				return globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[objIndex];
			case OBJECT_ELECTRICFENCE:
				return PTRImageBMP_ARRAY_004de120[14];
			case OBJECT_PATH:
				return PTRImageBMP_ARRAY_004de120[5];
			}
		}
	}
	else {
		if (true) {
			switch(objType) {
			case OBJECT_VEHICLE:
				return globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[objIndex];
			case OBJECT_MINIFIGURE:
				return PTRImageBMP_ARRAY_004ddff8[1];
			case OBJECT_BUILDING:
				return globals::g_InterfaceBuildImages_Buildings_normal_TABLE[objIndex];
			case OBJECT_ELECTRICFENCE:
				return PTRImageBMP_ARRAY_004ddff8[14];
			case OBJECT_PATH:
				return PTRImageBMP_ARRAY_004ddff8[5];
			}
		}
	}
	return NULL;
}



void __cdecl
lego::front::Interface_SetDat_004decd8_004decdc(MenuIcon menuIcon,ObjectType objType,int objIndex)
{
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		ObjectType_004decd8 = objType;
		INTObjectIndex_004decdc = objIndex;
		return;
	}
	if (menuIcon == INTERFACE_MENUITEM_LAYPATH) {
		ObjectType_004decd8 = OBJECT_PATH;
		INTObjectIndex_004decdc = 0;
		return;
	}
	if (menuIcon == INTERFACE_MENUITEM_PLACEFENCE) {
		ObjectType_004decd8 = OBJECT_ELECTRICFENCE;
		INTObjectIndex_004decdc = 0;
	}
	return;
}



void __cdecl lego::front::Interface_FUN_0041cc10(Point2F *point,uint unkWidth,uint unkHeight)
{
	Area2F_004ded0c.x = point->x;
	Area2F_004ded0c.y = point->y;
	Area2F_004ded0c.width = (float)(ulonglong)unkWidth;
	Area2F_004ded0c.height = (float)(ulonglong)unkHeight;
	return;
}



void __cdecl lego::front::Interface_Front_DrawLineListUnk_FUN_0041cc60(Area2F *rect)
{
	Point2F local_28;
	Point2F local_20 [4];
	
	if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		local_28.x = rect->x - 1.0;
		local_28.y = rect->y - 1.0;
		local_20[1].y = (rect->height + rect->y) - -1.0;
		local_20[0].x = (rect->x + rect->width) - -1.0;
		local_20[0].y = local_28.y;
		local_20[1].x = local_20[0].x;
		local_20[2].x = local_28.x;
		local_20[2].y = local_20[1].y;
		local_20[3].x = local_28.x;
		local_20[3].y = local_28.y;
		draw::Draw_LineListEx(&local_28,local_20,4,0.0,1.0,0.0,DRAWEFFECT_NONE);
		local_28.x = rect->x - 2.0;
		local_28.y = rect->y - 2.0;
		local_20[0].x = (rect->x + rect->width) - -2.0;
		local_20[1].y = (rect->height + rect->y) - -2.0;
		local_20[0].y = local_28.y;
		local_20[1].x = local_20[0].x;
		local_20[2].x = local_28.x;
		local_20[2].y = local_20[1].y;
		local_20[3].x = local_28.x;
		local_20[3].y = local_28.y;
		draw::Draw_LineListEx(&local_28,local_20,4,0.0,1.0,0.0,DRAWEFFECT_NONE);
	}
	return;
}



void __cdecl lego::front::Interface_ChangeMenu_IfVehicleMounted_IsLiveObject(LiveObject *liveObj)
{
	uint uVar1;
	LiveObject **ppLVar2;
	ObjectStatsFlags1 OVar3;
	uint uVar4;
	
	if (InterfaceMenuType_004deccc == INTERFACE_MENU_UNMANNEDVEHICLE) {
		uVar1 = game::Message_GetNumSelectedUnits();
		ppLVar2 = game::Message_GetSelectedUnits();
		for (uVar4 = uVar1; uVar4 != 0; uVar4 -= 1) {
			if (liveObj == *ppLVar2) {
				if (uVar1 == 1) {
					OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
					if (((OVar3 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_40) == 0)) {
						Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
					}
					else {
						Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
					}
				}
				else {
					Interface_BackToMain();
				}
			}
			ppLVar2 = ppLVar2 + 1;
		}
	}
	return;
}



void __cdecl
lego::front::Interface_ChangeMenu_IfPrimarySelectedVehicle_IsLiveObject(LiveObject *liveObj)
{
	uint count;
	LiveObject **ppUnit;
	uint i;
	
	if (((InterfaceMenuType_004deccc == INTERFACE_MENU_VEHICLE) ||
			(InterfaceMenuType_004deccc == INTERFACE_MENU_UPGRADEVEHICLE)) ||
		 (InterfaceMenuType_004deccc == INTERFACE_MENU_WATERVEHICLE)) {
		count = game::Message_GetNumSelectedUnits();
		ppUnit = game::Message_GetSelectedUnits();
		for (i = count; i != 0; i -= 1) {
			if (liveObj->drivenObject == *ppUnit) {
				if (count == 1) {
					Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_UNMANNEDVEHICLE,NULL);
				}
				else {
					Interface_BackToMain();
				}
			}
			ppUnit = ppUnit + 1;
		}
	}
	return;
}



void __cdecl lego::front::Interface_BackToMain_IfSelectedWall_IsBlockPos(Point2I *blockPos)
{
	if (((InterfaceMenuType_004deccc == INTERFACE_MENU_WALL) &&
			(globals::g_Interface_SelectedBlock.x == blockPos->x)) &&
		 (globals::g_Interface_SelectedBlock.y == blockPos->y)) {
		Interface_BackToMain();
		return;
	}
	return;
}



void __cdecl
lego::front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(Point2I *blockPos)
{
	if ((((InterfaceMenuType_004deccc == INTERFACE_MENU_GROUND) ||
			 (InterfaceMenuType_004deccc == INTERFACE_MENU_CONSTRUCTION)) &&
			(globals::g_Interface_SelectedBlock.x == blockPos->x)) &&
		 (globals::g_Interface_SelectedBlock.y == blockPos->y)) {
		Interface_BackToMain();
		return;
	}
	return;
}



void __cdecl lego::front::Interface_IfSelectedRubble_IsBlockPos(Point2I *blockPos)
{
	if (((InterfaceMenuType_004deccc == INTERFACE_MENU_RUBBLE) &&
			(globals::g_Interface_SelectedBlock.x == blockPos->x)) &&
		 (globals::g_Interface_SelectedBlock.y == blockPos->y)) {
		Interface_BackToMain();
		return;
	}
	return;
}



void __cdecl
lego::front::Interface_BackToMain_IfLiveObject_IsSelected_OrFlags3_200000(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if (globs::legoGlobs.viewMode != VIEW_FIRSTPERSON) {
		BVar1 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,NULL);
		if (BVar1 != 0) {
			Interface_BackToMain();
			return;
		}
	}
	return;
}



BOOL __cdecl lego::front::Interface_HandleIcon_FUN_0041cf70(MenuIcon menuIcon)
{
	TerrainType TVar1;
	LiveFlags5 LVar2;
	MenuIcon MVar3;
	LiveObject *liveObj;
	ObjectStatsFlags3 OVar4;
	ObjectStatsFlags1 OVar5;
	uint uVar6;
	BOOL BVar7;
	ObjectStatsFlags2 OVar8;
	float10 fVar9;
	ObjectType objType;
	code *callback;
	ToolType toolType;
	undefined4 uVar10;
	int iVar11;
	ObjectType local_8;
	int local_4;
	
	liveObj = game::Message_GetPrimarySelectedUnit();
	MVar3 = menuIcon;
	if (false) goto switchD_0041cf8b_caseD_2;
	switch(menuIcon) {
	case INTERFACE_MENUITEM_BACKTODEFAULT:
		if (InterfaceMenuType_004decfc == INTERFACE_MENU_FIRSTPERSON) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TELEPORTMAN:
		game::Object_GetObjectByName("Barracks",&local_8,(int *)&menuIcon,NULL);
		BVar7 = Interface_Object_FindTeleporter_FUN_0041f030(OBJECT_MINIFIGURE,0);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Dependencies_Object_FUN_0040add0(OBJECT_MINIFIGURE,0,0);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Object_DoOxygenCheck_FUN_0043c4c0(OBJECT_MINIFIGURE,0,local_8,menuIcon);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_LAYPATH:
		BVar7 = game::Construction_BlockCheck_FUN_00408fd0(&globals::g_Interface_SelectedBlock);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsPath(&globals::g_Interface_SelectedBlock);
		if (BVar7 != 0) {
			return 0;
		}
		objType = OBJECT_PATH;
		goto LAB_0041d8d5;
	case INTERFACE_MENUITEM_REMOVEPATH:
		BVar7 = game::Level_Block_IsPath(&globals::g_Interface_SelectedBlock);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_REPAIRLAVA:
		BVar7 = game::Construction_BlockCheck_FUN_00408fd0(&globals::g_Interface_SelectedBlock);
		if (BVar7 != 0) {
			return 0;
		}
		if ((globs::legoGlobs.level)->blocks
				[((globs::legoGlobs.level)->dimensions).width * globals::g_Interface_SelectedBlock.y +
				 globals::g_Interface_SelectedBlock.x].terrain == TERRAIN_LAVA) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_CLEARRUBBLE:
		BVar7 = game::Message_IsAnyUnitsSelected();
		if (BVar7 == 0) break;
		toolType = TOOL_SPADE;
		goto LAB_0041d17f;
	case INTERFACE_MENUITEM_DIG:
		BVar7 = Interface_Block_FUN_0041f670(&globals::g_Interface_SelectedBlock);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Message_IsAnyUnitsSelected();
		if (BVar7 == 0) {
			BVar7 = Interface_ReqestDigBlock(&globals::g_Interface_SelectedBlock);
			if (BVar7 == 0) {
				return 0;
			}
		}
		else {
			BVar7 = ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(TOOL_DRILL);
			if ((BVar7 == 0) && (BVar7 = Interface_FUN_0041f1e0(), BVar7 == 0)) {
				return 0;
			}
			BVar7 = game::Level_FindSelectedUnit_BlockCheck_FUN_00431960
												(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y,0
												);
			if (BVar7 == 0) {
				return 0;
			}
		}
		break;
	case INTERFACE_MENUITEM_REINFORCE:
		BVar7 = Interface_Block_FUN_0041f670(&globals::g_Interface_SelectedBlock);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsReinforced
											(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsCorner
											(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::LiveObject_CanReinforceBlock
											(NULL,globals::g_Interface_SelectedBlock.x,
											 globals::g_Interface_SelectedBlock.y);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Message_IsAnyUnitsSelected();
		if (BVar7 == 0) {
			BVar7 = Interface_RequestReinforceBlock(&globals::g_Interface_SelectedBlock);
			if (BVar7 == 0) {
				return 0;
			}
		}
		else {
			BVar7 = ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(TOOL_HAMMER);
			if ((BVar7 == 0) && (BVar7 = Interface_FUN_0041f1e0(), BVar7 == 0)) {
				return 0;
			}
			BVar7 = game::Level_FindSelectedLiveObject_BlockReinforce_FUN_004319e0
												(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y);
			if (BVar7 == 0) {
				return 0;
			}
		}
		break;
	case INTERFACE_MENUITEM_DYNAMITE:
		BVar7 = Interface_Block_FUN_0041f670(&globals::g_Interface_SelectedBlock);
		if (BVar7 == 0) {
			return 0;
		}
		TVar1 = (globs::legoGlobs.level)->blocks
						[((globs::legoGlobs.level)->dimensions).width * globals::g_Interface_SelectedBlock.y +
						 globals::g_Interface_SelectedBlock.x].terrain;
		if (TVar1 == TERRAIN_IMMOVABLE) {
			return 0;
		}
		if (TVar1 == TERRAIN_RECHARGESEAM) {
			return 0;
		}
		BVar7 = game::Level_Block_IsWall
											(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsBusy(&globals::g_Interface_SelectedBlock);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f1e0();
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f270(8);
		if (BVar7 != 0) break;
		BVar7 = Interface_FUN_0041f220(2,0);
		if (BVar7 == 0) {
			return 0;
		}
		uVar10 = 0x20;
		goto LAB_0041d599;
	case INTERFACE_MENUITEM_PLACEFENCE:
		BVar7 = game::Level_Block_IsFenceRequest
											(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::ElectricFence_CanPlaceFenceAtBlock
											(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = 0;
		objType = OBJECT_ELECTRICFENCE;
LAB_0041d8d5:
		BVar7 = game::Dependencies_Object_FUN_0040add0(objType,BVar7,BVar7);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_CANCELCONSTRUCTION:
		if (((globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * globals::g_Interface_SelectedBlock.y +
					globals::g_Interface_SelectedBlock.x].flags1 & (BLOCK1_FOUNDATION|BLOCK1_UNK_40000000)) ==
				BLOCK1_NONE) {
			return 0;
		}
		BVar7 = game::Level_Block_IsPathBuilding(&globals::g_Interface_SelectedBlock);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsPath(&globals::g_Interface_SelectedBlock);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsSolidBuilding
											(globals::g_Interface_SelectedBlock.x,globals::g_Interface_SelectedBlock.y,1);
		if (BVar7 != 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_VEHICLEPICKUP:
	case INTERFACE_MENUITEM_MINIFIGUREPICKUP:
		iVar11 = 0;
		callback = Interface_LiveObjectCallback_FUN_0041f400;
		goto LAB_0041d969;
	case INTERFACE_MENUITEM_UNLOADVEHICLE:
	case INTERFACE_MENUITEM_UNLOADMINIFIGURE:
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0]->objType == OBJECT_BARRIER)) {
			return 0;
		}
		OVar4 = stats::StatsObject_GetStatsFlags3(liveObj);
		if (((OVar4 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			 (BVar7 = game::LiveObject_UnkCarryingVehicle_FUN_00440080(liveObj), BVar7 == 0)) {
			return 0;
		}
		iVar11 = 0;
		callback = Interface_LiveObjectCallback_FUN_0041f3a0;
		goto LAB_0041d969;
	case INTERFACE_MENUITEM_GETIN:
		iVar11 = 2;
		uVar10 = 8;
		OVar4 = stats::StatsObject_GetStatsFlags3(liveObj);
		if ((OVar4 & STATS3_NEEDSPILOT) == STATS3_NONE) {
			OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
			if ((OVar5 & STATS1_CROSSLAND) != STATS1_NONE) {
				OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
				if ((OVar5 & STATS1_CROSSWATER) == STATS1_NONE) {
					iVar11 = 4;
					uVar10 = 0x10;
				}
				else {
					iVar11 = 1;
					uVar10 = 4;
				}
			}
		}
		else {
			iVar11 = 1;
			uVar10 = 4;
		}
		OVar4 = stats::StatsObject_GetStatsFlags3(liveObj);
		if (((OVar4 & STATS3_GETINATLAND) == STATS3_NONE) || ((*(byte *)&liveObj->flags4 & 0x40) != 0))
		{
			if ((iVar11 == 2) && ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
				return 0;
			}
		}
		else {
			BVar7 = game::LiveObject_CheckUnkGetInAtLand_FUN_0043a100(liveObj,NULL);
			if (BVar7 == 0) {
				return 0;
			}
		}
		if ((*(byte *)&liveObj->flags2 & LIVEOBJ2_UNK_10) != 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f270(iVar11);
		if (BVar7 != 0) break;
		BVar7 = Interface_FUN_0041f220(2,0);
		if (BVar7 == 0) {
			return 0;
		}
		goto LAB_0041d599;
	case INTERFACE_MENUITEM_GETOUT:
		if ((*(byte *)&liveObj->flags1 & 1) != 0) {
			return 0;
		}
		OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
			return 0;
		}
		OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
				(BVar7 = game::LiveObject_UnkGetTerrainGetOutAtLandBlock_FUN_0043a0d0(liveObj,NULL),
				BVar7 == 0)) && ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_40) == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOTODOCK:
		if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
			return 0;
		}
		OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
			return 0;
		}
		if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_40) != 0) {
			return 0;
		}
		iVar11 = game::LiveObject_FUN_00438ca0(liveObj,TRUE);
		if (iVar11 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_VEHICLEDIG:
		if ((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_2) == 0) {
			return 0;
		}
		if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_LEGOMANDIG:
		toolType = TOOL_DRILL;
LAB_0041d17f:
		BVar7 = ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(toolType);
		if ((BVar7 == 0) && (BVar7 = Interface_FUN_0041f1e0(), BVar7 == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOFEED:
		iVar11 = 0;
		callback = Interface_LiveObjectCallback_IsEnergyLessThan100;
		goto LAB_0041d969;
	case INTERFACE_MENUITEM_DROPBIRDSCARER:
		iVar11 = 6;
		callback = Interface_LiveObjectCallback_HasToolEquipped_2;
LAB_0041d969:
		BVar7 = Interface_DoSelectedUnits_Callback(callback,iVar11);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_POWERON:
	case INTERFACE_MENUITEM_POWEROFF:
		OVar8 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar8 & STATS2_SELFPOWERED) != STATS2_NONE) {
			return 0;
		}
		if ((liveObj->flags3 & LIVEOBJ3_HASPOWER) == LIVEOBJ3_NONE) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_REPAIR:
		BVar7 = Interface_DoSelectedUnits_Callback(Interface_LiveObjectCallback_IsHealthLessThan100,0);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f270(0x10);
		if (BVar7 != 0) break;
		BVar7 = Interface_FUN_0041f220(2,0);
		if (BVar7 == 0) {
			return 0;
		}
		uVar10 = 0x40;
LAB_0041d599:
		BVar7 = Interface_FUN_0041f1a0(uVar10);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_MAKETELEPORTERPRIMARY:
		BVar7 = game::LiveObject_IsSmallTeleporter(liveObj);
		if (((BVar7 == 0) && (BVar7 = game::LiveObject_IsBigTeleporter(liveObj), BVar7 == 0)) &&
			 (BVar7 = game::LiveObject_IsWaterTeleporter(liveObj), BVar7 == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_EJECTCRYSTAL:
		BVar7 = game::LiveObject_CanSpawnCarryableObject(liveObj,OBJECT_POWERCRYSTAL,0);
		if (BVar7 == 0) {
			return 0;
		}
	case INTERFACE_MENUITEM_EJECTORE:
		BVar7 = game::LiveObject_CanSpawnCarryableObject(liveObj,OBJECT_ORE,0);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_DELETEVEHICLE:
		game::LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_4);
		if ((liveObj->drivenObject != NULL) &&
			 (iVar11 = game::LiveObject_Routing_GetCrossTerrainType
													 (liveObj->drivenObject,local_8,local_4,local_8,local_4,1), iVar11 == 0))
		{
			return 0;
		}
		OVar4 = stats::StatsObject_GetStatsFlags3(liveObj);
		if (((((OVar4 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				(liveObj->carriedObjects[0] != NULL)) &&
			 (iVar11 = game::LiveObject_Routing_GetCrossTerrainType
													 (liveObj->carriedObjects[0],local_8,local_4,local_8,local_4,1),
			 iVar11 == 0)) {
			return 0;
		}
		OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
		if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOTOFIRSTPERSON:
		if ((liveObj == globs::legoGlobs.objectFP) &&
			 ((globs::legoGlobs.cameraFP)->trackFPCameraFrame == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOTOSECONDPERSON:
		if ((liveObj == globs::legoGlobs.objectFP) &&
			 ((globs::legoGlobs.cameraFP)->trackFPCameraFrame == 1)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GETTOOL:
		goto switchD_0041cf8b_caseD_30;
	case INTERFACE_MENUITEM_GETDRILL:
		iVar11 = TOOL_DRILL;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETSPADE:
		iVar11 = TOOL_SPADE;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETHAMMER:
		iVar11 = TOOL_HAMMER;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETSPANNER:
		iVar11 = TOOL_SPANNER;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETLASER:
		iVar11 = TOOL_LASER;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETPUSHERGUN:
		iVar11 = TOOL_PUSHERGUN;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETFREEZERGUN:
		iVar11 = TOOL_FREEZERGUN;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETBIRDSCARER:
		iVar11 = TOOL_BIRDSCARER;
LAB_0041d741:
		BVar7 = Interface_DoSelectedUnits_Callback
											(Interface_LiveObjectCallback_DoesNotHaveToolEquipped,iVar11);
		if (BVar7 == 0) {
			return 0;
		}
switchD_0041cf8b_caseD_30:
		BVar7 = Interface_FUN_0041f1e0();
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TRAINSKILL:
		BVar7 = Interface_FUN_0041f1a0(0xfc);
		if (BVar7 == 0) {
			return 0;
		}
		LVar2 = liveObj->flags5;
		if (((((LVar2 & LIVEOBJ5_ABILITY_PILOT) != LIVEOBJ5_NONE) &&
				 ((LVar2 & LIVEOBJ5_ABILITY_SAILOR) != LIVEOBJ5_NONE)) &&
				(((LVar2 & LIVEOBJ5_ABILITY_DRIVER) != LIVEOBJ5_NONE &&
				 (((LVar2 & LIVEOBJ5_ABILITY_DYNAMITE) != LIVEOBJ5_NONE &&
					((LVar2 & LIVEOBJ5_ABILITY_REPAIR) != LIVEOBJ5_NONE)))))) &&
			 ((LVar2 & LIVEOBJ5_ABILITY_SCANNER) != LIVEOBJ5_NONE)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TRAINDRIVER:
		BVar7 = Interface_FUN_0041f650(4);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x10;
		goto LAB_0041d829;
	case INTERFACE_MENUITEM_TRAINENGINEER:
		BVar7 = Interface_FUN_0041f650(0x10);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x40;
		goto LAB_0041d829;
	case INTERFACE_MENUITEM_TRAINGEOLOGIST:
		BVar7 = Interface_FUN_0041f650(0x20);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x80;
		goto LAB_0041d829;
	case INTERFACE_MENUITEM_TRAINPILOT:
		BVar7 = Interface_FUN_0041f650(1);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 4;
LAB_0041d829:
		iVar11 = Interface_FUN_0041f1a0(uVar10);
joined_r0x0041d86f:
		if (iVar11 == 0) {
			return 0;
		}
		fVar9 = lrr::Lego_GetTrainTime();
		if ((ushort)((ushort)(fVar9 < (float10)liveObj->elapsedTime1) << 8 |
								(ushort)(fVar9 == (float10)liveObj->elapsedTime1) << 0xe) == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TRAINSAILOR:
		BVar7 = Interface_FUN_0041f650(2);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 8;
		goto LAB_0041d865;
	case INTERFACE_MENUITEM_TRAINDYNAMITE:
		BVar7 = Interface_FUN_0041f650(8);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x20;
LAB_0041d865:
		iVar11 = Interface_FUN_0041f1a0(uVar10);
		goto joined_r0x0041d86f;
	case INTERFACE_MENUITEM_UPGRADEMAN:
		uVar6 = stats::Stats_GetLevels(liveObj->objType,liveObj->objIndex);
		if (uVar6 <= liveObj->objLevel + 1) {
			return 0;
		}
		if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
			return 0;
		}
		goto switchD_0041cf8b_caseD_30;
	case INTERFACE_MENUITEM_UPGRADEBUILDING:
		BVar7 = game::LiveObject_GetBuildingUpgradeCost(liveObj,NULL);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_UPGRADEVEHICLE:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = FUN_00438b70(liveObj,1);
		if (((BVar7 != 0) || (BVar7 = FUN_00438b70(liveObj,0), BVar7 != 0)) ||
			 (BVar7 = FUN_00438b70(liveObj,2), BVar7 != 0)) break;
		goto LAB_0041da08;
	case INTERFACE_MENUITEM_UPGRADEENGINE:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		iVar11 = 1;
		goto LAB_0041da0a;
	case INTERFACE_MENUITEM_UPGRADEDRILL:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		iVar11 = 0;
		goto LAB_0041da0a;
	case INTERFACE_MENUITEM_UPGRADESCAN:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		iVar11 = 2;
		goto LAB_0041da0a;
	case INTERFACE_MENUITEM_UPGRADECARRY:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
LAB_0041da08:
		iVar11 = 3;
LAB_0041da0a:
		BVar7 = FUN_00438b70(liveObj,iVar11);
		if (BVar7 == 0) {
			return 0;
		}
	}
switchD_0041cf8b_caseD_2:
	if (((byte)globs::legoGlobs.flags3 & 6) == 0) {
		if (((byte)globs::legoGlobs.flags3 & 0x18) == 0) {
			if ((((byte)globs::legoGlobs.flags3 & 0x60) != 0) &&
				 (MVar3 != INTERFACE_MENUITEM_BACKTODEFAULT)) {
				if ((int)MVar3 < 0x1d) {
					return 0;
				}
				if (0x1e < (int)MVar3) {
					return 0;
				}
			}
		}
		else {
			if (MVar3 != INTERFACE_MENUITEM_BACKTODEFAULT) {
				if ((int)MVar3 < 0x14) {
					return 0;
				}
				if (0x15 < (int)MVar3) {
					return 0;
				}
			}
		}
	}
	else {
		if ((MVar3 != INTERFACE_MENUITEM_BACKTODEFAULT) && (((int)MVar3 < 0x1b || (0x1c < (int)MVar3))))
		{
			return 0;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::front::Interface_DoAction_FUN_0041dbd0(MenuIcon menuIcon)
{
	ObjectType OVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	SurfaceMap *pSVar4;
	ObjectStatsFlags1 OVar5;
	LevelData *pLVar6;
	int iVar7;
	ObjectStatsFlags3 OVar8;
	GameFlags3 GVar9;
	int iVar10;
	WallHighlightType highlightType;
	undefined4 uVar11;
	
	pLVar2 = game::Message_GetPrimarySelectedUnit();
	BVar3 = Interface_FUN_0041c820(menuIcon,TRUE);
	if (BVar3 != 0) {
		return 0;
	}
	if (false) goto switchD_0041dbfa_caseD_8;
	switch(menuIcon) {
	case INTERFACE_MENUITEM_BACKTODEFAULT:
		if (0xf < (int)InterfaceMenuType_004deccc) {
			if ((int)InterfaceMenuType_004deccc < 0x12) {
				Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
				return TRUE;
			}
			if (InterfaceMenuType_004deccc == INTERFACE_MENU_UPGRADEVEHICLE) {
				OVar5 = stats::StatsObject_GetStatsFlags1(pLVar2);
				if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
					 ((*(byte *)&pLVar2->flags4 & LIVEOBJ4_UNK_40) == 0)) {
					Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
					return TRUE;
				}
				Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
				return TRUE;
			}
		}
		break;
	case INTERFACE_MENUITEM_TELEPORTMAN:
		game::Game_TryTeleportObject(OBJECT_MINIFIGURE,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_BUILDBUILDING:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDBUILDING,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_BUILDSMALLVEHICLE:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDSMALLVEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_BUILDLARGEVEHICLE:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDLARGEVEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_LAYPATH:
	case INTERFACE_MENUITEM_REPAIRLAVA:
		game::Construction_LayPath(&globals::g_Interface_SelectedBlock);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_REMOVEPATH:
		ai::AITask_DoClearTypeAction
							(&globals::g_Interface_SelectedBlock,MESSAGE_CLEARREMOVEPATH_COMPLETE);
		pLVar6 = lrr::Lego_GetLevel();
		iVar7 = (pLVar6->dimensions).width * globals::g_Interface_SelectedBlock.y +
						globals::g_Interface_SelectedBlock.x;
		pLVar6 = lrr::Lego_GetLevel();
		pLVar6->blocks[iVar7].flags1 = pLVar6->blocks[iVar7].flags1 & ~BLOCK1_PATH;
		game::Level_BlockUpdateSurface
							(globs::legoGlobs.level,globals::g_Interface_SelectedBlock.x,
							 globals::g_Interface_SelectedBlock.y,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_CLEARRUBBLE:
		ai::AITask_FUN_00401f40(AITASK_CLEAR,NULL,&globals::g_Interface_SelectedBlock);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DIG:
		ai::AITask_DoDig_AtBlockPos(&globals::g_Interface_SelectedBlock,FALSE,TRUE);
		goto LAB_0041de87;
	case INTERFACE_MENUITEM_REINFORCE:
		ai::AITask_DoReinforce_AtBlockPos(&globals::g_Interface_SelectedBlock);
		goto LAB_0041de87;
	case INTERFACE_MENUITEM_DYNAMITE:
		ai::AITask_DoDynamite_AtBlockPos(&globals::g_Interface_SelectedBlock,FALSE);
LAB_0041de87:
		iVar7 = globals::g_Interface_SelectedBlock.x;
		iVar10 = globals::g_Interface_SelectedBlock.y;
		pSVar4 = lrr::Lego_GetMap();
		WallHighlightType_004df1f0 = game::Map3D_Block_GetHighlightType(pSVar4,iVar7,iVar10);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_PLACEFENCE:
		ai::AITask_DoElecFence(&globals::g_Interface_SelectedBlock);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DESELECTDIG:
		ai::AITask_Block_FUN_00402a10(&globals::g_Interface_SelectedBlock,0);
		WallHighlightType_004df1f0 = WALLHIGHLIGHT_NONE;
		highlightType = WALLHIGHLIGHT_SELECTED;
		iVar7 = globals::g_Interface_SelectedBlock.x;
		iVar10 = globals::g_Interface_SelectedBlock.y;
		pSVar4 = lrr::Lego_GetMap();
		game::Map3D_Block_SetHighlightType(pSVar4,iVar7,iVar10,highlightType);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_CANCELCONSTRUCTION:
		if (((globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * globals::g_Interface_SelectedBlock.y +
					globals::g_Interface_SelectedBlock.x].flags1 & BLOCK1_UNK_40000000) == BLOCK1_NONE) {
			game::Construction_Cancel(&globals::g_Interface_SelectedBlock);
			Interface_BackToMain();
			return TRUE;
		}
		game::Construction_Cancel2(&globals::g_Interface_SelectedBlock);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_SELECTMAN:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		game::Message_AddMessageAction(MESSAGE_SELECT,pLVar2,0,NULL);
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_SELECTVEHICLE:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		game::Message_AddMessageAction(MESSAGE_SELECT,pLVar2,0,NULL);
		OVar5 = stats::StatsObject_GetStatsFlags1(pLVar2);
		if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&pLVar2->flags4 & 0x40) == 0)) {
			Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
			return TRUE;
		}
LAB_0041df4c:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_SELECTBUILDING:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		game::Message_AddMessageAction(MESSAGE_SELECT,pLVar2,0,NULL);
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDING,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_VEHICLEPICKUP:
		OVar8 = stats::StatsObject_GetStatsFlags3(pLVar2);
		if ((OVar8 & STATS3_CARRYVEHICLES) != STATS3_NONE) {
			ai::AITask_DoFindLoad(pLVar2);
			return TRUE;
		}
		GVar9 = GAME3_LOADVEHICLE;
		if ((globs::legoGlobs.flags3 & GAME3_LOADVEHICLE) != GAME3_NONE) {
			lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_MINIFIGUREPICKUP:
		GVar9 = GAME3_PICKUPOBJECT;
		if ((globs::legoGlobs.flags3 & GAME3_PICKUPOBJECT) != GAME3_NONE) {
			lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_UNLOADVEHICLE:
	case INTERFACE_MENUITEM_UNLOADMINIFIGURE:
		Interface_DoSelectedUnits_Callback(Interface_LiveObjectCallback_FUN_0041f5f0,0);
		return TRUE;
	case INTERFACE_MENUITEM_GETIN:
		game::Message_PTL_ClearSelection();
		ai::AITask_DoFindDriver_Target(pLVar2);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETOUT:
		game::LiveObject_FUN_00440470(pLVar2,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GOTODOCK:
		game::LiveObject_FUN_00440470(pLVar2,1);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_LEGOMANGOTO:
		GVar9 = GAME3_UNK_2;
		if ((globs::legoGlobs.flags3 & GAME3_UNK_2) != GAME3_NONE) {
			lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_VEHICLEGOTO:
		GVar9 = GAME3_UNK_4;
		if ((globs::legoGlobs.flags3 & GAME3_UNK_4) != GAME3_NONE) {
			lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_VEHICLEDIG:
		GVar9 = GAME3_UNK_40;
		goto LAB_0041e4a1;
	case INTERFACE_MENUITEM_LEGOMANDIG:
		GVar9 = GAME3_UNK_20;
LAB_0041e4a1:
		if (((byte)globs::legoGlobs.flags3 & (byte)GVar9) != 0) {
			lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
LAB_0041e4b7:
		lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
		globs::legoGlobs.flags3 = globs::legoGlobs.flags3 | GVar9;
		return TRUE;
	case INTERFACE_MENUITEM_GOFEED:
		Interface_DoSelectedUnits_Callback(Interface_LiveObjectCallback_GoEatIfEnergyIsLessThan100,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DELETEMAN:
	case INTERFACE_MENUITEM_DELETEBUILDING:
	case INTERFACE_MENUITEM_DELETEVEHICLE:
	case INTERFACE_MENUITEM_DELETEELECTRICFENCE:
		Interface_DoSelectedUnits_Callback(Interface_LiveObjectCallback_FUN_0041f520,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DROPBIRDSCARER:
		Interface_DoSelectedUnits_Callback(Interface_LiveObjectCallback_FUN_0041f770,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_POWERON:
		BVar3 = 1;
		goto LAB_0041e51b;
	case INTERFACE_MENUITEM_POWEROFF:
		BVar3 = 0;
LAB_0041e51b:
		game::LiveObject_SetFlag3_80000000(pLVar2,BVar3);
		break;
	case INTERFACE_MENUITEM_REPAIR:
		Interface_DoSelectedUnits_Callback(Interface_LiveObjectCallback_GoRepairIfHealthLessThan100,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_MAKETELEPORTERPRIMARY:
		BVar3 = game::LiveObject_IsSmallTeleporter(pLVar2);
		if (BVar3 != 0) {
			globs::legoGlobs.placeDestSmallTeleporter = pLVar2;
			Interface_BackToMain();
			return TRUE;
		}
		BVar3 = game::LiveObject_IsBigTeleporter(pLVar2);
		if (BVar3 != 0) {
			globs::legoGlobs.placeDestBigTeleporter = pLVar2;
			Interface_BackToMain();
			return TRUE;
		}
		BVar3 = game::LiveObject_IsWaterTeleporter(pLVar2);
		if (BVar3 != 0) {
			globs::legoGlobs.placeDestWaterTeleporter = pLVar2;
			Interface_BackToMain();
			return TRUE;
		}
		break;
	case INTERFACE_MENUITEM_EJECTCRYSTAL:
		game::LiveObject_FUN_0043a910(pLVar2,OBJECT_POWERCRYSTAL,0,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_EJECTORE:
		game::LiveObject_FUN_0043a910(pLVar2,OBJECT_ORE,ORE_NORMAL,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GOTOTOPVIEW:
		game::Message_AddMessageAction(MESSAGE_TOPVIEW,0,0,NULL);
		OVar1 = pLVar2->objType;
		if (OVar1 == OBJECT_VEHICLE) {
			OVar5 = stats::StatsObject_GetStatsFlags1(pLVar2);
			if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
				 ((*(byte *)&pLVar2->flags4 & LIVEOBJ4_UNK_40) == 0)) {
				Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
				return TRUE;
			}
			goto LAB_0041df4c;
		}
		if (OVar1 == OBJECT_MINIFIGURE) {
			Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
			return TRUE;
		}
		if (OVar1 == OBJECT_BUILDING) {
			Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDING,NULL);
			return TRUE;
		}
		break;
	case INTERFACE_MENUITEM_GOTOFIRSTPERSON:
		uVar11 = 0;
		goto LAB_0041deb2;
	case INTERFACE_MENUITEM_GOTOSECONDPERSON:
		uVar11 = 1;
LAB_0041deb2:
		game::Message_AddMessageAction(MESSAGE_FIRSTPERSON,0,uVar11,NULL);
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_FIRSTPERSON,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_TRACKOBJECT:
		game::Game_TrackObjectInRadar(pLVar2);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETTOOL:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_GETTOOL,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_GETDRILL:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_DRILL);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETSPADE:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_SPADE);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETHAMMER:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_HAMMER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETSPANNER:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_SPANNER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETLASER:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_LASER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETPUSHERGUN:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_PUSHERGUN);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETFREEZERGUN:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_FREEZERGUN);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETBIRDSCARER:
		Interface_DoSelectedUnits_Callback
							(Interface_LiveObjectCallback_GoGetToolIfNotEquipped,TOOL_BIRDSCARER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_TRAINSKILL:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_TRAINSKILL,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_TRAINDRIVER:
	case INTERFACE_MENUITEM_TRAINENGINEER:
	case INTERFACE_MENUITEM_TRAINGEOLOGIST:
	case INTERFACE_MENUITEM_TRAINPILOT:
	case INTERFACE_MENUITEM_TRAINSAILOR:
	case INTERFACE_MENUITEM_TRAINDYNAMITE:
		switch(menuIcon) {
		case INTERFACE_MENUITEM_TRAINDRIVER:
			menuIcon = TRAINED_DRIVER;
			break;
		case INTERFACE_MENUITEM_TRAINENGINEER:
			menuIcon = TRAINED_REPAIR;
			break;
		case INTERFACE_MENUITEM_TRAINGEOLOGIST:
			menuIcon = TRAINED_SCANNER;
			break;
		case INTERFACE_MENUITEM_TRAINPILOT:
			menuIcon = TRAINED_PILOT;
			break;
		case INTERFACE_MENUITEM_TRAINSAILOR:
			menuIcon = TRAINED_SAILOR;
			break;
		case INTERFACE_MENUITEM_TRAINDYNAMITE:
			menuIcon = TRAINED_DYNAMITE;
		}
		pLVar2 = (LiveObject *)FUN_00439110(pLVar2,NULL,menuIcon);
		if (pLVar2 == NULL) {
			return 0;
		}
		ai::AITask_DoTrain_Target(pLVar2,menuIcon,TRUE);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEMAN:
		ai::AITask_DoUpgrade(pLVar2,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEBUILDING:
		game::LiveObject_FUN_00438ab0(pLVar2);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEVEHICLE:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_UPGRADEVEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEENGINE:
		uVar11 = 1;
		goto LAB_0041e4f4;
	case INTERFACE_MENUITEM_UPGRADEDRILL:
		uVar11 = 0;
		goto LAB_0041e4f4;
	case INTERFACE_MENUITEM_UPGRADESCAN:
		uVar11 = 2;
		goto LAB_0041e4f4;
	case INTERFACE_MENUITEM_UPGRADECARRY:
		uVar11 = 3;
LAB_0041e4f4:
		ai::AITask_DoUpgrade(pLVar2,uVar11);
		pLVar2->elapsedTime2 = 0.0;
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_ENCYCLOPEDIA:
		if ((globs::legoGlobs.flags3 & GAME3_UNK_1) == GAME3_NONE) {
			lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
			globs::legoGlobs.flags3 |= GAME3_UNK_1;
			Encyclopedia_UnsetFlag1();
			Interface_BackToMain();
			return TRUE;
		}
		lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_CLEARSELECTION:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_BUILD:
		BVar3 = Interface_FUN_0041c880(ObjectType_004decd8,INTObjectIndex_004decdc,TRUE);
		if (BVar3 != 0) {
			return 0;
		}
		game::Game_TryTeleportObject(ObjectType_004decd8,INTObjectIndex_004decdc);
		if (ObjectType_004decd8 == OBJECT_BUILDING) {
			return TRUE;
		}
	}
switchD_0041dbfa_caseD_8:
	Interface_BackToMain();
	return TRUE;
}



void __cdecl lego::front::Interface_BackToMain(void)
{
	game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,FALSE,NULL);
	Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_MAIN,NULL);
	return;
}



void __cdecl lego::front::Interface_SetIconFlash(MenuIcon menuIcon,BOOL flash)
{
	if (flash != 0) {
		UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] | 4;
		return;
	}
	UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] & 0xfffffffb;
	return;
}



void __cdecl lego::front::Interface_SetSubmenuIconFlash(ObjectType objType,int objIndex,BOOL flash)
{
	InterfaceIconFlags *pIVar1;
	
	pIVar1 = globals::g_SubmenuIcons_VehicleTypesFlags_TABLE;
	if ((objType == OBJECT_VEHICLE) ||
		 (pIVar1 = globals::g_SubmenuIcons_BuildingTypesFlags_TABLE, objType == OBJECT_BUILDING)) {
		if (flash != 0) {
			pIVar1[objIndex] = pIVar1[objIndex] | INTERFACE_MENUITEM_FLAG_FLASH;
			return;
		}
		pIVar1[objIndex] = pIVar1[objIndex] & ~INTERFACE_MENUITEM_FLAG_FLASH;
	}
	return;
}



LiveObject * __cdecl lego::front::Interface_GetPrimarySelectedUnit(void)
{
	return (LiveObject *)
				 (-(uint)(globs::messageGlobs.selectedUnitCount != 0) &
				 (uint)globs::messageGlobs.selectedUnitList[0]);
}



// Sets click COUNT
//  returns previous COUNT

int __cdecl lego::front::Interface_SetIconClicked(MenuIcon menuIcon,int clickedCount)
{
	int lastCount;
	
	lastCount = globals::g_Interface_Icons_Clicked[menuIcon];
	globals::g_Interface_Icons_Clicked[menuIcon] = clickedCount;
	return lastCount;
}



// Gets click COUNT

int __cdecl lego::front::Interface_GetIconClicked(MenuIcon menuIcon)
{
	return globals::g_Interface_Icons_Clicked[menuIcon];
}



// Sets click COUNT
//  returns previous COUNT

int __cdecl
lego::front::Interface_SetSubmenuIconClicked(ObjectType objType,int objIndex,int clickedCount)
{
	int lastCount;
	
	lastCount = 0;
	if (objType == OBJECT_VEHICLE) {
		lastCount = globals::g_SubmenuIcons_VehicleTypesClicked_TABLE[objIndex];
		globals::g_SubmenuIcons_VehicleTypesClicked_TABLE[objIndex] = clickedCount;
		return lastCount;
	}
	if (objType == OBJECT_BUILDING) {
		lastCount = globals::g_SubmenuIcons_BuildingTypesClicked_TABLE[objIndex];
		globals::g_SubmenuIcons_BuildingTypesClicked_TABLE[objIndex] = clickedCount;
	}
	return lastCount;
}



// Gets click COUNT

int __cdecl lego::front::Interface_GetSubmenuIconClicked(ObjectType objType,int objIndex)
{
	if (objType == OBJECT_VEHICLE) {
		return globals::g_SubmenuIcons_VehicleTypesClicked_TABLE[objIndex];
	}
	if (objType == OBJECT_BUILDING) {
		return globals::g_SubmenuIcons_BuildingTypesClicked_TABLE[objIndex];
	}
	return 0;
}



// Always returns true

BOOL __cdecl lego::front::Interface_SetAdvisorPointToFashingIcon(MenuIcon menuIcon,BOOL setFlag40)
{
	uint uVar1;
	
	uVar1 = FLAGS_004df1f8 | 0x20;
	if (setFlag40 != 0) {
		uVar1 = FLAGS_004df1f8 | 0x60;
	}
	FLAGS_004df1f8 = uVar1;
	AdvisorType_004ded24 = Interface_GetAdvisorType_FromIcon(menuIcon);
	MenuIcon_004ded28 = menuIcon;
	return TRUE;
}



AdvisorType __cdecl lego::front::Interface_GetAdvisorType_FromIcon(MenuIcon menuIcon)
{
	if (true) {
		switch(menuIcon) {
		case INTERFACE_MENUITEM_BACKTODEFAULT:
			return ADVISOR_ICONPOINT_BACKBUTTON;
		case INTERFACE_MENUITEM_TELEPORTMAN:
		case INTERFACE_MENUITEM_BUILDBUILDING:
		case INTERFACE_MENUITEM_LAYPATH:
		case INTERFACE_MENUITEM_REMOVEPATH:
		case INTERFACE_MENUITEM_CLEARRUBBLE:
		case INTERFACE_MENUITEM_DIG:
		case INTERFACE_MENUITEM_REINFORCE:
		case INTERFACE_MENUITEM_PLACEFENCE:
		case INTERFACE_MENUITEM_VEHICLEPICKUP:
		case INTERFACE_MENUITEM_UNLOADVEHICLE:
		case INTERFACE_MENUITEM_UNLOADMINIFIGURE:
		case INTERFACE_MENUITEM_GETIN:
		case INTERFACE_MENUITEM_GOFEED:
		case INTERFACE_MENUITEM_POWERON:
		case INTERFACE_MENUITEM_REPAIR:
		case INTERFACE_MENUITEM_DELETEVEHICLE:
		case INTERFACE_MENUITEM_DELETEELECTRICFENCE:
		case INTERFACE_MENUITEM_ATTACK:
		case INTERFACE_MENUITEM_GOTOTOPVIEW:
		case INTERFACE_MENUITEM_GOTOSECONDPERSON:
		case INTERFACE_MENUITEM_TRACKOBJECT:
		case INTERFACE_MENUITEM_GETDRILL:
		case INTERFACE_MENUITEM_GETSPADE:
		case INTERFACE_MENUITEM_TRAINDRIVER:
		case INTERFACE_MENUITEM_TRAINENGINEER:
		case INTERFACE_MENUITEM_UPGRADEENGINE:
		case INTERFACE_MENUITEM_UPGRADEDRILL:
			return ADVISOR_ICONPOINT_TOPBUTTONS;
		}
	}
	return ADVISOR_ICONPOINT_NORMAL;
}



BOOL __cdecl lego::front::Interface_FUN_0041e8c0(ObjectType objType,int objIndex)
{
	TutorialFlags TVar1;
	
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar1 & TUTORIAL_UNK_4) != TUTORIAL_NONE) {
		return (&DAT_004ded34)[objIndex + objType * 0xf];
	}
	return TRUE;
}



void __cdecl
lego::front::Interface_SetUnkPositions1
					(uint x1_565,uint y1_18,uint x2_appWidthPlus10,uint y2_18,float param_5)
{
	Point2F_004dece0.x = (float)(ulonglong)x2_appWidthPlus10;
	Point2F_004dece0.y = (float)(ulonglong)y2_18;
	Point2F_004dece8.x = (float)(ulonglong)x1_565;
	Point2F_004dece8.y = (float)(ulonglong)y1_18;
	FLOAT_004decf0 = param_5 * 0.04;
	return;
}



void __cdecl
lego::front::Interface_UnkSlideOffScreen_FUN_0041e980_internal
					(InterfaceMenuType interfaceMenuType,Point2I *position)
{
	if (((FLAGS_004df1f8 & 0x80) == 0) || (InterfaceMenuType_004deccc != interfaceMenuType)) {
		FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffffff7f | 0x100;
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_INTERFACESLIDEOFFSCREEN,FALSE);
	}
	else {
		InterfaceMenuType_004deccc = interfaceMenuType;
		if (position == NULL) {
			InterfaceMenuType_004decfc = interfaceMenuType;
			return;
		}
		globals::g_Interface_SelectedBlock.x = position->x;
		globals::g_Interface_SelectedBlock.y = position->y;
	}
	if (position != NULL) {
		Point2IBlockPos_004decf4.x = position->x;
		Point2IBlockPos_004decf4.y = position->y;
	}
	InterfaceMenuType_004decfc = interfaceMenuType;
	return;
}



void __cdecl lego::front::Interface_FUN_0041e9f0(float elapsedAbs)
{
	if ((FLAGS_004df1f8 & 0x80) == 0) {
		if ((FLAGS_004df1f8 & 0x100) == 0) {
			if ((FLAGS_004df1f8 & 4) != 0) {
				Point2F_004decd0.x = Point2F_004decd0.x - elapsedAbs * FLOAT_004decf0;
				if ((ushort)((ushort)(Point2F_004decd0.x < Point2F_004dece8.x) << 8 |
										(ushort)(Point2F_004decd0.x == Point2F_004dece8.x) << 0xe) != 0) {
					FLAGS_004df1f8 |= 0x80;
					Point2F_004decd0.x = Point2F_004dece8.x;
				}
			}
		}
		else {
			Point2F_004decd0.x = elapsedAbs * FLOAT_004decf0 + Point2F_004decd0.x;
			if ((InterfaceMenuType_004deccc == 0x16) &&
				 (((byte)globs::panelGlobs.panelTable[8].flags & 2) != 0)) {
				Panel_ChangeFlags_BasedOnState(PANEL_PRIORITYLIST);
				Panel_Button_SetFlag_8_OrUnset_c(PANEL_TOPPANEL,1,0);
				Point2F_004decd0.x = Point2F_004dece0.x;
			}
			if (Point2F_004dece0.x <= Point2F_004decd0.x) {
				FLAGS_004df1f8 &= 0xfffffeff;
				Point2F_004decd0.x = Point2F_004dece0.x;
				snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_INTERFACESLIDEONSCREEN,0);
				if (InterfaceMenuType_004decfc == 0x16) {
					FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffffb | 0x80;
					Panel_ChangeFlags_BasedOnState(PANEL_PRIORITYLIST);
					unk::lego::front::Panel_UnsetFlag_6();
					globs::panelGlobs.flags |= 2;
				}
				else {
					if (InterfaceMenuType_004decfc == 0x17) {
						FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffffb | 0x80;
						Panel_ChangeFlags_BasedOnState(PANEL_ENCYCLOPEDIA);
						globs::legoGlobs.flags3 |= GAME3_UNK_1;
						Encyclopedia_UnsetFlag1();
					}
					else {
						FLAGS_004df1f8 |= 4;
					}
				}
				globals::g_Interface_SelectedBlock.x = Point2IBlockPos_004decf4.x;
				globals::g_Interface_SelectedBlock.y = Point2IBlockPos_004decf4.y;
				InterfaceMenuType_004deccc = InterfaceMenuType_004decfc;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::front::Interface_FUN_0041eb60(int param_1,int param_2,Point2F *param_3)
{
	ObjectType *pOVar1;
	int y;
	uint uVar2;
	int iVar3;
	longlong lVar4;
	char *msg;
	
	iVar3 = 0;
	if (globs::legoGlobs.objTeleportQueue_COUNT != 0) {
		pOVar1 = globs::legoGlobs.objTeleportQueueTypes_TABLE;
		uVar2 = globs::legoGlobs.objTeleportQueue_COUNT;
		do {
			if ((*pOVar1 == param_1) && (pOVar1[0x14] == param_2)) {
				iVar3 += 1;
			}
			pOVar1 = pOVar1 + 1;
			uVar2 -= 1;
		} while (uVar2 != 0);
	}
	if (iVar3 != 0) {
		msg = "%i";
		lVar4 = __ftol((float10)param_3->y);
		y = (int)lVar4 + 3;
		lVar4 = __ftol((float10)param_3->x);
		lego::image::Font_PrintF(PTRImageFont_004ddd58,(int)lVar4 + 3,y,msg,iVar3);
	}
	return;
}



void __cdecl lego::front::Interface_FUN_0041ebd0(float param_1,float param_2)
{
	BOOL BVar1;
	Image *image;
	int y;
	uint uVar2;
	longlong lVar3;
	char *msg;
	char *pcVar4;
	DependencyRequirement *local_10;
	uint local_c;
	Point2F local_8;
	
	if ((globals::g_Interface_UINT_004a3b5c != ObjectType_004decd8) ||
		 (INTObjectIndex_004ddd50 != INTObjectIndex_004decdc)) {
		Interface_SetFloatTo25_004df1ec_AndUnsetFlags800_004df1f8();
		globals::g_Interface_UINT_004a3b5c = ObjectType_004decd8;
		INTObjectIndex_004ddd50 = INTObjectIndex_004decdc;
	}
	if (((FLAGS_004df1f8 & 0x800) != 0) &&
		 (game::Dependencies_Object_GetRequirements
								(ObjectType_004decd8,INTObjectIndex_004decdc,0,&local_10,&local_c), local_c != 0)) {
		local_8.x = param_1 - 15.0;
		uVar2 = 0;
		local_8.y = param_2;
		if (local_c != 0) {
			do {
				if (uVar2 == 0) {
					if (globals::g_InterfaceDependencies_Minus_bmp == NULL) {
LAB_0041ecb4:
						local_8.x = local_8.x - 20.0;
					}
					else {
						local_8.x = local_8.x - (float)globals::g_InterfaceDependencies_Minus_bmp->width;
						lego::image::Image_DisplayScaled
											(globals::g_InterfaceDependencies_Minus_bmp,NULL,&local_8,NULL);
					}
				}
				else {
					if (globals::g_InterfaceDependencies_Plus_bmp == NULL) goto LAB_0041ecb4;
					local_8.x = local_8.x - (float)globals::g_InterfaceDependencies_Plus_bmp->width;
					lego::image::Image_DisplayScaled
										(globals::g_InterfaceDependencies_Plus_bmp,NULL,&local_8,NULL);
				}
				BVar1 = game::Search_LiveObjects_SkipIgnoreMes
													(game::Dependencies_LiveObject_CallbackCheck_FUN_0040ae70,local_10 + uVar2
													);
				image = Interface_GetObjectBuildImage
													(local_10[uVar2].objType,local_10[uVar2].objIndex,(uint)(BVar1 != 0));
				if (image == NULL) {
					local_8.x = local_8.x - 40.0;
				}
				else {
					local_8.x = local_8.x - (float)image->width;
					lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
					if ((local_10[uVar2].hasLevel != 0) && (local_10[uVar2].objLevel != 0)) {
						pcVar4 = globs::legoGlobs.UpgradeNames_TABLE[local_10[uVar2].objLevel];
						msg = "%s";
						lVar3 = __ftol((float10)local_8.y);
						y = (int)lVar3 + 3;
						lVar3 = __ftol((float10)local_8.x);
						lego::image::Font_PrintF(PTRImageFont_004ddd58,(int)lVar3 + 3,y,msg,pcVar4);
					}
				}
				uVar2 += 1;
			} while (uVar2 < local_c);
		}
	}
	return;
}



void __cdecl lego::front::Interface_SetFloatTo25_004df1ec_AndUnsetFlags800_004df1f8(void)
{
	FLOAT_004df1ec = 25.0;
	FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffff7ff;
	return;
}



BOOL __cdecl
lego::front::Interface_FUN_0041edb0
					(uint param_1,uint param_2,float param_3,float param_4,undefined4 *param_5,
					undefined4 *param_6,undefined4 *param_7)
{
	float fVar1;
	float fVar2;
	Image *pIVar3;
	uint uVar4;
	uint uVar5;
	uint local_40;
	DependencyRequirement *local_3c;
	float local_38;
	undefined4 uStack52;
	uint local_30;
	undefined4 uStack44;
	uint local_28;
	undefined4 uStack36;
	uint local_20;
	undefined4 uStack28;
	uint local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	if (((FLAGS_004df1f8 & 0x800) != 0) &&
		 (game::Dependencies_Object_GetRequirements
								(ObjectType_004decd8,INTObjectIndex_004decdc,0,&local_3c,&local_40), local_40 != 0))
	{
		local_38 = param_3 - 15.0;
		fVar2 = (float)(ulonglong)param_1;
		if ((local_38 <= fVar2) &&
			 ((((ushort)((ushort)(fVar2 < local_38 - -15.0) << 8 |
									(ushort)(fVar2 == local_38 - -15.0) << 0xe) != 0 &&
				 (fVar1 = (float)(ulonglong)param_2, param_4 <= fVar1)) &&
				((ushort)((ushort)(fVar1 < param_4 - -40.0) << 8 | (ushort)(fVar1 == param_4 - -40.0) << 0xe
								 ) != 0)))) {
			*param_5 = 0x14;
			return 1;
		}
		uStack52 = 0;
		uVar5 = 0;
		if (local_40 != 0) {
			do {
				pIVar3 = globals::g_InterfaceDependencies_Minus_bmp;
				if (uVar5 != 0) {
					pIVar3 = globals::g_InterfaceDependencies_Plus_bmp;
				}
				if (pIVar3 == NULL) {
					local_30 = 0x14;
					uVar4 = 0x28;
				}
				else {
					local_30 = pIVar3->width;
					uVar4 = pIVar3->height;
				}
				uStack44 = 0;
				local_38 = local_38 - (float)(ulonglong)local_30;
				if ((local_38 <= fVar2) &&
					 (fVar1 = local_38 + (float)(ulonglong)local_30,
					 (ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0)) {
					local_28 = param_2;
					uStack36 = 0;
					fVar1 = (float)(ulonglong)param_2;
					if ((param_4 <= fVar1) &&
						 (uStack28 = 0, local_20 = uVar4,
						 (ushort)((ushort)(fVar1 < (float)(ulonglong)uVar4 + param_4) << 8 |
										 (ushort)(fVar1 == (float)(ulonglong)uVar4 + param_4) << 0xe) != 0)) {
						*param_5 = 0x14;
						return 1;
					}
				}
				pIVar3 = Interface_GetObjectBuildImage(local_3c[uVar5].objType,local_3c[uVar5].objIndex,0);
				if (pIVar3 == NULL) {
					local_18 = 0x28;
					uVar4 = 0x28;
				}
				else {
					local_18 = pIVar3->width;
					uVar4 = pIVar3->height;
				}
				uStack20 = 0;
				local_38 = local_38 - (float)(ulonglong)local_18;
				if ((local_38 <= fVar2) &&
					 (fVar1 = local_38 + (float)(ulonglong)local_18,
					 (ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0)) {
					local_10 = param_2;
					uStack12 = 0;
					fVar1 = (float)(ulonglong)param_2;
					if ((param_4 <= fVar1) &&
						 (uStack4 = 0, local_8 = uVar4,
						 (ushort)((ushort)(fVar1 < (float)(ulonglong)uVar4 + param_4) << 8 |
										 (ushort)(fVar1 == (float)(ulonglong)uVar4 + param_4) << 0xe) != 0)) {
						*param_5 = local_3c[uVar5].objType;
						*param_6 = local_3c[uVar5].objIndex;
						*param_7 = local_3c[uVar5].objLevel;
						return 1;
					}
				}
				uVar5 += 1;
				if (local_40 <= uVar5) {
					return 0;
				}
			} while( true );
		}
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_Object_FindTeleporter_FUN_0041f030(ObjectType objType,int objIndex)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_18 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	OVar1 = stats::Stats_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USESMALLTELEPORTER) == STATS2_NONE) {
		if ((OVar1 & STATS2_USEBIGTELEPORTER) == STATS2_NONE) {
			if ((OVar1 & STATS2_USEWATERTELEPORTER) == STATS2_NONE) {
				if ((OVar1 & STATS2_USELEGOMANTELEPORTER) == STATS2_NONE) {
					return 1;
				}
				local_10 = 0x80000000;
			}
			else {
				local_10 = 0x40;
			}
		}
		else {
			local_10 = 0x20;
		}
	}
	else {
		local_10 = 0x10;
	}
	BVar2 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar2;
}



BOOL __cdecl
lego::front::Interface_LiveObject_CallbackCheck_FUN_0041f0c0(LiveObject *liveObj,ObjectType *search)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	ObjectStatsFlags2 OVar3;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 (BVar1 = game::LiveObject_CheckCondition_AndIsPowered(liveObj,FALSE), BVar1 == 0)) {
		return 0;
	}
	if ((search[5] & 1) != 0) {
		if (liveObj->objType != *search) {
			return 0;
		}
		if (liveObj->objIndex != search[1]) {
			return 0;
		}
	}
	if (((search[5] & 2) != 0) && ((search[4] & liveObj->flags5) == LIVEOBJ5_NONE)) {
		return 0;
	}
	if ((search[2] != OBJECT_NONE) &&
		 (OVar2 = stats::StatsObject_GetStatsFlags1(liveObj), (search[2] & OVar2) == STATS1_NONE)) {
		return 0;
	}
	if ((search[3] != OBJECT_NONE) &&
		 (OVar3 = stats::StatsObject_GetStatsFlags2(liveObj), (search[3] & OVar3) == STATS2_NONE)) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::front::Interface_FUN_0041f160(void)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_18 = 0;
	local_8 = 0;
	local_c = 2;
	local_4 = 0;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f1a0(undefined4 param_1)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_8 = 0;
	local_18 = 0;
	local_4 = 0;
	local_c = param_1;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f1e0(void)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_c = 0;
	local_18 = 0;
	local_8 = 0;
	local_10 = 0x100000;
	local_4 = 0;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f220(undefined4 param_1,undefined4 param_2)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 1;
	local_18 = param_1;
	local_14 = param_2;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f270(undefined4 param_1)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_c = 0;
	local_4 = 2;
	local_18 = 0;
	local_8 = param_1;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl
lego::front::Interface_LiveObject_Callback_FUN_0041f2c0(LiveObject *liveObj,Point2I *param_2)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_BlockCheck_FUN_004326a0(liveObj,param_2->x,param_2->y,FALSE,FALSE);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::front::Interface_ReqestDigBlock(Point2I *blockPos)
{
	BOOL BVar1;
	
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_Callback_FUN_0041f2c0,blockPos);
	return BVar1;
}



BOOL __cdecl
lego::front::Interface_LiveObjectCallback_RequestReinforceBlock
					(LiveObject *liveObj,Point2I *blockPos)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_CanReinforceBlock(liveObj,blockPos->x,blockPos->y);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::front::Interface_RequestReinforceBlock(Point2I *blockPos)
{
	BOOL BVar1;
	
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObjectCallback_RequestReinforceBlock,blockPos);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_DoSelectedUnits_Callback(undefined *callback,int lpContext)
{
	uint uVar1;
	LiveObject **ppLVar2;
	int iVar3;
	uint uVar4;
	
	uVar1 = game::Message_GetNumSelectedUnits();
	ppLVar2 = game::Message_GetSelectedUnits();
	uVar4 = 0;
	if (uVar1 == 0) {
		return 0;
	}
	do {
		iVar3 = (*(code *)callback)(*ppLVar2,lpContext);
		if (iVar3 != 0) {
			return 1;
		}
		uVar4 += 1;
		ppLVar2 = ppLVar2 + 1;
	} while (uVar4 < uVar1);
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_FUN_0041f3a0(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 ((liveObj->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_IsEnergyLessThan100(LiveObject *liveObj)
{
	if (liveObj->energy < 100.0) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_IsHealthLessThan100(LiveObject *liveObj)
{
	if (liveObj->health < 100.0) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_FUN_0041f400(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	int *out_bx;
	int *out_by;
	int local_14;
	int local_10;
	Vector3F local_c;
	
	OVar1 = stats::StatsObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CARRYVEHICLES) == STATS3_NONE) {
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
					((liveObj->flags3 & LIVEOBJ3_UNK_20) != LIVEOBJ3_NONE)) &&
				 ((liveObj->flags3 & LIVEOBJ3_UNK_40) != LIVEOBJ3_NONE)) {
				return 1;
			}
		}
		else {
			if (((liveObj->flags3 & LIVEOBJ3_UNK_20) != LIVEOBJ3_NONE) &&
				 ((liveObj->flags3 & LIVEOBJ3_UNK_40) != LIVEOBJ3_NONE)) {
				uVar5 = liveObj->field_328;
				uVar4 = stats::StatsObject_GetMaxCarry(liveObj);
				if (uVar4 <= uVar5) {
					uVar5 = stats::StatsObject_GetMaxCarry(liveObj);
				}
				if (liveObj->numCarriedObjects < uVar5) {
					return 1;
				}
			}
		}
	}
	else {
		if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
				((liveObj->flags4 & LIVEOBJ4_UNK_10000) == LIVEOBJ4_NONE)) &&
			 (cont = game::LiveObject_GetDepositNull(liveObj), cont != NULL)) {
			res::Container_GetPosition(cont,NULL,&local_c);
			out_by = &local_10;
			out_bx = &local_14;
			surfMap = lrr::Lego_GetMap();
			BVar2 = game::Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,out_bx,out_by);
			if ((BVar2 != 0) &&
				 (iVar3 = game::LiveObject_Routing_GetCrossTerrainType
														(NULL,local_14,local_10,local_14,local_10,1), iVar3 != 0)) {
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_FUN_0041f520(LiveObject *liveObj)
{
	liveObj->health = -1.0;
	liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_8;
	return 0;
}



BOOL __cdecl
lego::front::Interface_LiveObjectCallback_GoEatIfEnergyIsLessThan100(LiveObject *liveObj)
{
	if (liveObj->energy < 100.0) {
		game::LiveObject_GoEat_unk(liveObj);
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_LiveObjectCallback_GoRepairIfHealthLessThan100(LiveObject *liveObj)
{
	if (liveObj->health < 100.0) {
		ai::AITask_DoRepair_Target(liveObj,0);
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_LiveObjectCallback_DoesNotHaveToolEquipped
					(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,toolType);
	return (uint)(BVar1 == 0);
}



BOOL __cdecl
lego::front::Interface_LiveObjectCallback_GoGetToolIfNotEquipped
					(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,toolType);
	if (BVar1 == 0) {
		ai::AITask_DoGetTool(toolType);
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_FUN_0041f5f0(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CARRYVEHICLES) == STATS3_NONE) {
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) ||
			 (liveObj->carriedObjects[0]->objType != OBJECT_BARRIER)) {
			game::LiveObject_DropCarriedObject_FUN_0043a130(liveObj,0);
		}
	}
	else {
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0] != NULL)) {
			game::LiveObject_FUN_0043fee0(liveObj->carriedObjects[0]);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_FUN_0041f650(uint param_1)
{
	LiveObject *pLVar1;
	
	pLVar1 = game::Message_GetPrimarySelectedUnit();
	return (uint)((pLVar1->flags5 & param_1) != LIVEOBJ5_NONE);
}



BOOL __cdecl lego::front::Interface_Block_FUN_0041f670(Point2I *blockPos)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	int *piVar4;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[4] = 0xffffffff;
	local_4 = 0xffffffff;
	uVar2 = 0;
	local_20[0] = 1;
	local_20[1] = 0;
	local_20[2] = 0;
	local_20[3] = 1;
	local_c = 0;
	local_8 = 0;
	BVar1 = game::Level_Block_IsCorner(blockPos->x,blockPos->y);
	if (BVar1 == 0) {
		piVar4 = local_20;
		do {
			BVar1 = game::Level_Block_IsSolidBuilding(blockPos->x + *piVar4,piVar4[1] + blockPos->y,1);
			if (BVar1 != 0) {
				return 0;
			}
			uVar2 += 1;
			piVar4 = piVar4 + 2;
		} while (uVar2 < 4);
		return 1;
	}
	uVar2 = 0;
	piVar4 = local_20;
	iVar3 = 4;
	do {
		BVar1 = game::Level_Block_IsSolidBuilding(blockPos->x + *piVar4,piVar4[1] + blockPos->y,1);
		if (BVar1 != 0) {
			uVar2 += 1;
		}
		piVar4 = piVar4 + 2;
		iVar3 += -1;
	} while (iVar3 != 0);
	if (1 < uVar2) {
		return 0;
	}
	return 1;
}



BOOL __cdecl
lego::front::Interface_LiveObjectCallback_HasToolEquipped_2(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,toolType);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::front::Interface_LiveObjectCallback_FUN_0041f770(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,TOOL_BIRDSCARER);
	if (BVar1 != 0) {
		game::LiveObject_PlaceBirdScarer_AndTickDown(liveObj);
	}
	return 0;
}



void __cdecl lego::game::Level_IncCrystals(void)
{
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->numCrystals = (globs::legoGlobs.level)->numCrystals + 1;
	}
	return;
}



void __cdecl lego::game::Level_SubtractCrystals(int crystalCount)
{
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->numCrystals = (globs::legoGlobs.level)->numCrystals - crystalCount;
	}
	return;
}



void __cdecl lego::game::Level_AddDrainedCrystals(int drainedCrystalCount)
{
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->numUnusedCrystals =
				 (globs::legoGlobs.level)->numUnusedCrystals + drainedCrystalCount;
	}
	return;
}



int __cdecl lego::game::Level_GetCrystalCount(BOOL includeDrained)
{
	int in_EAX;
	
	if ((globs::legoGlobs.level != NULL) &&
		 (in_EAX = (globs::legoGlobs.level)->numCrystals, includeDrained == 0)) {
		in_EAX -= (globs::legoGlobs.level)->numUnusedCrystals;
	}
	return in_EAX;
}



int __cdecl lego::game::Level_GetOreCount(BOOL isProcessed)
{
	LevelData *pLVar1;
	
	pLVar1 = globs::legoGlobs.level;
	if (globs::legoGlobs.level != NULL) {
		if (isProcessed != 0) {
			return (int)(LevelData *)(globs::legoGlobs.level)->numProcessedOre;
		}
		pLVar1 = (LevelData *)(globs::legoGlobs.level)->numOre;
	}
	return (int)pLVar1;
}



void __cdecl lego::game::Level_AddToField9c(int value)
{
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->field_9c = (globs::legoGlobs.level)->field_9c + value;
	}
	return;
}



void __cdecl lego::game::Game_SetFlag1_20000_unkCameraRadarHasTrackObj(BOOL state)
{
	if (state != 0) {
		globs::legoGlobs.flags1 = globs::legoGlobs.flags1 | GAME1_UNK_20000;
		return;
	}
	globs::legoGlobs.flags1 = globs::legoGlobs.flags1 & ~GAME1_UNK_20000;
	return;
}



BOOL __cdecl lego::game::Game_IsNoclipOn(void)
{
	return globs::legoGlobs.flags1 & GAME1_DEBUG_NOCLIP_FPS;
}



void __cdecl lego::game::Level_IncField94(void)
{
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->field_94 = (globs::legoGlobs.level)->field_94 + 1;
	}
	return;
}



void __cdecl lego::game::Level_IncFieldA8(void)
{
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->field_a8 = (globs::legoGlobs.level)->field_a8 + 1;
	}
	return;
}



void __cdecl lego::game::Level_IncOre(OreType isProcessed)
{
	if (globs::legoGlobs.level != NULL) {
		if (isProcessed == ORE_NORMAL) {
			(globs::legoGlobs.level)->numOre = (globs::legoGlobs.level)->numOre + 1;
		}
		else {
			(globs::legoGlobs.level)->numProcessedOre = (globs::legoGlobs.level)->numProcessedOre + 1;
		}
	}
	if (isProcessed != ORE_NORMAL) {
		front::Panel_CryOreSideBar_ChangeOreMeter(TRUE,5);
		return;
	}
	front::Panel_CryOreSideBar_ChangeOreMeter(TRUE,1);
	return;
}



void __cdecl lego::game::Level_SubtractOre(BOOL isProcessed,int oreCount)
{
	if (globs::legoGlobs.level != NULL) {
		if (isProcessed == 0) {
			(globs::legoGlobs.level)->numOre = (globs::legoGlobs.level)->numOre - oreCount;
		}
		else {
			(globs::legoGlobs.level)->numProcessedOre =
					 (globs::legoGlobs.level)->numProcessedOre - oreCount;
		}
	}
	if (isProcessed != 0) {
		front::Panel_CryOreSideBar_ChangeOreMeter(FALSE,5);
		return;
	}
	front::Panel_CryOreSideBar_ChangeOreMeter(FALSE,oreCount);
	return;
}



BOOL __cdecl lego::lrr::Gods_Go(char *programName)
{
	BOOL BVar1;
	int iVar2;
	Lego_Globs *pLVar3;
	Main_State mainState;
	
						// std::memset(&legoGlobs, 0, sizeof(legoGlobs)); // 0xef8
	pLVar3 = &globs::legoGlobs;
	for (iVar2 = 0x3be; iVar2 != 0; iVar2 += -1) {
		pLVar3->config = NULL;
		pLVar3 = (Lego_Globs *)&pLVar3->gameName;
	}
	globs::legoGlobs.gameName = programName;
	main::Main_SetTitle(programName);
	mainState.Initialise = Lego_Initialise;
	mainState.MainLoop = Lego_MainLoop;
	mainState.Shutdown = Lego_Shutdown_Debug;
	if (globs::mainGlobs.programmerLevel != PROGRAMMER_MODE_10) {
		mainState.Shutdown = Lego_Shutdown;
	}
	BVar1 = main::Main_SetState(&mainState);
	return BVar1;
}



void __cdecl lego::lrr::Lego_SetLoadFlag_StartTeleporter(void)
{
	Lego_GetLevel();
	if ((globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE) {
						// table[REWARDTYPE_FIGURES]
		globals::g_RewardCur.items[5].numDestroyed =
				 nerps::NERPsRuntime_GetPreviousLevelObjectsBuilt("Pilot",0);
		globs::legoGlobs.flags1 |= GAME1_UNK_8000000;
		game::Game_DisableCryOreDrop(TRUE);
		game::LiveManager_SetFlag20(TRUE);
		unk::Teleporter_Start(TELEPORT_SERVIVE_VEHICLE,1,1);
		unk::Teleporter_Start(TELEPORT_SERVIVE_MINIFIGURE,1,1);
		unk::Teleporter_Start(TELEPORT_SERVIVE_BUILDING,1,1);
		unk::Teleporter_Start(TELEPORT_SERVIVE_ELECTRICFENCE,1,1);
		game::Game_SetPaused(FALSE,FALSE);
		front::Interface_BackToMain();
		if (((byte)globs::panelGlobs.panelTable[0].flags & 2) != 0) {
			front::Panel_ChangeFlags_BasedOnState(PANEL_RADAR);
			front::Panel_ChangeFlags_BasedOnState(PANEL_RADARFILL);
		}
	}
	return;
}



float10 __cdecl lego::game::Game_GetGameSpeed(void)
{
	return (float10)globs::legoGlobs.gameSpeed;
}



BOOL __cdecl lego::lrr::Lego_Initialise(void)
{
	char *pcVar1;
	BOOL BVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	ProgrammerMode PVar6;
	char *pcVar7;
	byte *input;
	BoolTri BVar8;
	int iVar9;
	CFGProperty *root;
	float10 fVar10;
	float10 fVar11;
	float10 fVar12;
	int iVar13;
	float *out_r;
	float red;
	ColourRGBF *pCVar14;
	float *pfVar15;
	float green;
	float *pfVar16;
	float blue;
	char *MinEnergyForEat_str;
	char *HighPolyRange_str;
	char *MedPolyRange_str;
	char *ReinforceHits_str;
	char *DrainTime_str;
	char *MiniFigureRunAway_str;
	char *HPBlocks_str;
	char *CDTracks_str;
	char *CDStartTrack_str;
	char *BirdScarerRadius_str;
	char *DynamiteWakeRadius_str;
	char *DynamiteMaxDamage_str;
	char *DynamiteDamageRadius_str;
	char *tvclipdist_str;
	char *maxdist_str;
	char *mindist_str;
	char *MouseScrollBorder_str;
	char *MaxReturnedCrystals_str;
	char *RollOffFor3DSounds_str;
	char *MaxDistFor3DSounds_str;
	char *MinDistFor3DSoundsOnTopView_str;
	char *MouseScrollIndent_str;
	char *CameraAcceleration_str;
	char *CameraDropOff_str;
	char *CameraSpeed_str;
	char *LoaderProfile_filename;
	char *TextPauseTime_str;
	char *TextureUsage_str;
	char *BuildingUpgradeCostStuds_str;
	char *BuildingUpgradeCostOre_str;
	char *startLevelName;
	Point2F Dialog_center;
	char *Window_stringParts [4];
	int Window_numParts;
	Area2F Window_rect;
	CFGProperty *Pointers_cfgProp;
	float CameraDropOff;
	float CameraSpeed;
	float MaxDistFor3DSounds;
	float RollOffFor3DSounds;
	int MouseScrollIndent;
	float CameraAcceleration;
	float MinDistFor3DSoundsOnTopView;
	char *Button_lpstr;
	char *Button_stringParts [10];
	char Button_buffer [128];
	char *Button_filename;
	char *SharedSizes_str;
	char *LoadScreen;
	char *ProgressBar;
	char *ProgressWindow;
	char *LoadingText;
	char *ShutdownScreen;
	Direction ProgressBar_direction;
	Area2F ProgressWindow_rect;
	char *ProgressWindow_stringParts [10];
	char *StartMessage;
	char *Version;
	Area2F MsgPanel_rect1;
	Area2F MsgPanel_rect2;
	float local_5c;
	Area2F fontRender84_rect;
	Area2F fontRender80_rect;
	uint TextureUsage;
	uint videoMemFree;
	uint videoMemTotal;
	char *RenameReplace_ptr;
	float ToolTipRGB_g;
	float ToolTipRGB_r;
	float ToolTipRGB_b;
	float maxdist;
	float mindist;
	CFGProperty *legoCfgRoot;
	uint surfaceIdx_unused;
	float maxtilt;
	float mintilt;
	
	globs::legoGlobs.DragBoxRGB.red = 0.2;
	globs::legoGlobs.DragBoxRGB.green = 0.7;
	globs::legoGlobs.DragBoxRGB.blue = 1.0;
	globs::legoGlobs.SurfaceTypes_TABLE[0] = "Lego_SurfaceType_Tunnel";
	globs::legoGlobs.SurfaceTypes_TABLE[1] = "Lego_SurfaceType_Immovable";
	globs::legoGlobs.SurfaceTypes_TABLE[2] = "Lego_SurfaceType_Hard";
	globs::legoGlobs.SurfaceTypes_TABLE[3] = "Lego_SurfaceType_Medium";
	globs::legoGlobs.SurfaceTypes_TABLE[4] = "Lego_SurfaceType_Loose";
	globs::legoGlobs.SurfaceTypes_TABLE[5] = "Lego_SurfaceType_Soil";
	globs::legoGlobs.SurfaceTypes_TABLE[6] = "Lego_SurfaceType_Lava";
	globs::legoGlobs.SurfaceTypes_TABLE[7] = "Lego_SurfaceType_Water";
	globs::legoGlobs.SurfaceTypes_TABLE[8] = "Lego_SurfaceType_OreSeam";
	globs::legoGlobs.SurfaceTypes_TABLE[9] = "Lego_SurfaceType_Lake";
	globs::legoGlobs.SurfaceTypes_TABLE[10] = "Lego_SurfaceType_CrystalSeam";
	globs::legoGlobs.SurfaceTypes_TABLE[11] = "Lego_SurfaceType_RechargeSeam";
	globs::legoGlobs.SurfaceTypes_TABLE[12] = "Lego_SurfaceType_Rubble";
	globs::legoGlobs.SurfaceTypes_TABLE[13] = "Lego_SurfaceType_Reinforcement";
	globs::legoGlobs.SurfaceTypes_TABLE[14] = "Lego_SurfaceType_Path";
	globs::legoGlobs.SurfaceTypes_TABLE[15] = "Lego_SurfaceType_SlugHole";
	globs::legoGlobs.SurfaceTypes_TABLE[16] = "Lego_SurfaceType_Undiscovered";
	globs::legoGlobs.SurfaceTypes_TABLE[17] = "Lego_SurfaceType_Cavern";
	for (surfaceIdx_unused = 0; surfaceIdx_unused < 0x12; surfaceIdx_unused += 1) {
	}
	game::Game_SetGameSpeed(1.0);
	lego::input::Keys_Initialise();
	lego::view::Viewport_Initialise();
	game::LiveManager_Initialise();
	lego::image::Image_Initialise();
						// No argument actually passed, just problem with variadic functions not allowing zero
						// args
	util::logf_removed();
	game::RadarMap_Initialise();
	front::Panel_Initialise();
	ai::AITask_Initialise();
	game::Message_Initialise();
	effect::Smoke_Initialise();
	front::Pointer_Initialise();
	front::Bubble_Initialise();
	globs::legoGlobs.bmpFONT5_HI = lego::image::Font_Load("Interface\\Fonts\\FONT5_HI.bmp");
	globs::legoGlobs.bmpToolTipFont = lego::image::Font_Load("Interface\\Fonts\\ToolTipFont.bmp");
	globs::legoGlobs.bmpDeskTopFont = lego::image::Font_Load("Interface\\Fonts\\DeskTopFont.bmp");
	globs::legoGlobs.bmpfont5_HI = lego::image::Font_Load("Interface\\Fonts\\font5_HI.bmp");
	globs::legoGlobs.bmpMbriefFONT = lego::image::Font_Load("Interface\\Fonts\\MBriefFONT.bmp");
	globs::legoGlobs.bmpMbriefFONT2 = lego::image::Font_Load("Interface\\Fonts\\MBriefFONT2.bmp");
	globs::legoGlobs.bmpRSFont = lego::image::Font_Load("Interface\\Fonts\\RSFont.bmp");
	front::Info_Initialise(globs::legoGlobs.bmpFONT5_HI);
	front::Interface_Initialise(565,18,globs::legoGlobs.bmpToolTipFont);
	globs::legoGlobs.contRoot = res::Container_Initialise(globs::legoGlobs.gameName);
	if (globs::legoGlobs.contRoot == NULL) {
		return 0;
	}
	res::Container_SetTriggerFrameCallback(game::Game_Container_TriggerFrameCallback,NULL);
	globs::legoGlobs.config = cfg::CFG_Open("Lego.cfg");
	legoCfgRoot = globs::legoGlobs.config;
	if (globs::legoGlobs.config == NULL) goto LAB_0042274b;
	pfVar16 = &ToolTipRGB_b;
	pfVar15 = &ToolTipRGB_g;
	out_r = &ToolTipRGB_r;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ToolTipRGB",0);
	BVar2 = cfg::CFG_ReadRGBF(legoCfgRoot,pcVar1,out_r,pfVar15,pfVar16);
	if (BVar2 == 0) {
		ToolTipRGB_b = 0.3254902;
		ToolTipRGB_g = 0.3254902;
		ToolTipRGB_r = 0.3254902;
	}
	iVar13 = 32;
	red = ToolTipRGB_r;
	green = ToolTipRGB_g;
	blue = ToolTipRGB_b;
	uVar3 = main::appHeight();
	uVar4 = main::appWidth();
	front::ToolTip_Initialise
						(globs::legoGlobs.bmpToolTipFont,2,1,1.0,uVar4,uVar3,iVar13,red,green,blue);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CreditsTextFile",0);
	globs::legoGlobs.CreditsTextFile = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CreditsBackAVI",0);
	globs::legoGlobs.CreditsBackAVI = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BuildingUpgradeCostOre",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		BuildingUpgradeCostOre_str = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BuildingUpgradeCostOre",0);
		BuildingUpgradeCostOre_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	}
	globs::legoGlobs.BuildingUpgradeCostOre = std::atoi(BuildingUpgradeCostOre_str);
	if (globs::legoGlobs.BuildingUpgradeCostOre == 0) {
		globs::legoGlobs.BuildingUpgradeCostOre = 5;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BuildingUpgradeCostStuds",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		BuildingUpgradeCostStuds_str = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BuildingUpgradeCostStuds",0);
		BuildingUpgradeCostStuds_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	}
	globs::legoGlobs.BuildingUpgradeCostStuds = std::atoi(BuildingUpgradeCostStuds_str);
	if (globs::legoGlobs.BuildingUpgradeCostStuds == 0) {
		globs::legoGlobs.BuildingUpgradeCostStuds = 1;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","RenameReplace",0);
	globs::legoGlobs.RenameReplace = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
	pcVar1 = globs::legoGlobs.RenameReplace;
	if (globs::legoGlobs.RenameReplace != NULL) {
		while (RenameReplace_ptr = pcVar1, *RenameReplace_ptr != '\0') {
			if (*RenameReplace_ptr == '_') {
				*RenameReplace_ptr = ' ';
			}
			pcVar1 = RenameReplace_ptr + 1;
		}
	}
	BVar2 = ddraw::DirectDraw_GetAvailTextureMem(&videoMemTotal,&videoMemFree);
	if (BVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","TextureUsage",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			TextureUsage_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","TextureUsage",0);
			TextureUsage_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		TextureUsage = std::atoi(TextureUsage_str);
		if ((TextureUsage != 0) &&
			 (ddraw::DirectDraw_AdjustTextureUsage(&TextureUsage), TextureUsage <= videoMemFree)) {
			main::Main_DisableTextureManagement();
		}
	}
	fontRender80_rect.x = 55.0;
	fontRender80_rect.y = 435.0;
	fontRender80_rect.width = 325.0;
	fontRender80_rect.height = 42.0;
	globs::legoGlobs.textWnd_80 =
			 front::TextWindow_Create(globs::legoGlobs.bmpfont5_HI,&fontRender80_rect,0x400);
	fontRender84_rect.x = 55.0;
	fontRender84_rect.y = 435.0;
	fontRender84_rect.width = 260.0;
	fontRender84_rect.height = 42.0;
	globs::legoGlobs.textWnd_84 =
			 front::TextWindow_Create(globs::legoGlobs.bmpfont5_HI,&fontRender84_rect,0x400);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","TextPauseTime",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		TextPauseTime_str = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","TextPauseTime",0);
		TextPauseTime_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	}
	fVar10 = std::atof(TextPauseTime_str);
	front::Text_Load(globs::legoGlobs.textWnd_80,globs::legoGlobs.textWnd_84,316,425,
									 (float)(fVar10 * (float10)25.0));
	MsgPanel_rect1.x = 55.0;
	MsgPanel_rect1.y = 435.0;
	MsgPanel_rect1.width = 325.0;
	MsgPanel_rect1.height = 42.0;
	MsgPanel_rect2.x = 55.0;
	MsgPanel_rect2.y = 363.0;
	MsgPanel_rect2.width = 325.0;
	MsgPanel_rect2.height = 140.0;
	front::Text_Initialise
						("Interface\\MessagePanel\\MsgPanel.bmp",0x2a,409,338,&MsgPanel_rect1,&MsgPanel_rect2,
						 20.0);
	if ((globs::mainGlobs.flags & CMD_SHOWVERSION) != CMD_NONE) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","StartMessage",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","Version",0);
		pcVar5 = cfg::CFG_ReadString(legoCfgRoot,pcVar5);
		if (pcVar1 != NULL) {
			pcVar1 = util::stringReplaceChar(pcVar1,'_',' ');
			if (pcVar5 == NULL) {
				front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\n%s",pcVar1);
			}
			else {
				front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\n%s (%s)",pcVar1,pcVar5);
			}
			util::free2(pcVar1);
		}
	}
	BVar2 = front::Front_IsFrontEndEnabled();
	if ((BVar2 != 0) && (BVar2 = front::FrontEnd_IsIntrosEnabled(), BVar2 != 0)) {
		PVar6 = main::Main_ProgrammerMode();
		front::Front_ShowIntroMovie("LegoAvi",(uint)(PVar6 != PROGRAMMER_OFF));
		front::Front_ShowIntroSplash("DDILogo",TRUE,"DDILogoTime");
		front::Front_ShowIntroMovie("DDIAvi",TRUE);
		front::Front_ShowIntroMovie("RRAvi",TRUE);
		pcVar1 = "LMILogoTime";
		PVar6 = main::Main_ProgrammerMode();
		front::Front_ShowIntroSplash("LMILogo",(uint)(PVar6 != PROGRAMMER_OFF),pcVar1);
	}
	snd::SFX_InitHashNames();
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ProgressBar",0);
	ProgressBar = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","LoadScreen",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	pcVar5 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ShutdownScreen",0);
	pcVar5 = cfg::CFG_ReadString(legoCfgRoot,pcVar5);
	pcVar7 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ProgressWindow",0);
	input = (byte *)cfg::CFG_CopyString(legoCfgRoot,pcVar7);
	pcVar7 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","LoadingText",0);
	pcVar7 = cfg::CFG_ReadString(legoCfgRoot,pcVar7);
	if (input == NULL) {
		ProgressBar = NULL;
	}
	else {
		iVar13 = std::toupper((uint)*input);
		*input = (byte)iVar13;
		if (false) {
LAB_004203f0:
			ProgressBar_direction = DIRECTION__COUNT;
		}
		else {
			switch(*input) {
			case 0x44:
				ProgressBar_direction = DIRECTION_DOWN;
				break;
			default:
				goto LAB_004203f0;
			case 0x4c:
				ProgressBar_direction = DIRECTION_LEFT;
				break;
			case 0x52:
				ProgressBar_direction = DIRECTION_RIGHT;
				break;
			case 0x55:
				ProgressBar_direction = DIRECTION_UP;
			}
		}
		iVar13 = util::Util_Tokenise((char *)input,ProgressWindow_stringParts,",");
		if (((iVar13 == 4) && (input[1] == 0x3a)) && (ProgressBar_direction != DIRECTION__COUNT)) {
			iVar13 = std::atoi(ProgressWindow_stringParts[0] + 2);
			ProgressWindow_rect.x = (float)iVar13;
			iVar13 = std::atoi(ProgressWindow_stringParts[1]);
			ProgressWindow_rect.y = (float)iVar13;
			iVar13 = std::atoi(ProgressWindow_stringParts[2]);
			ProgressWindow_rect.width = (float)iVar13;
			iVar13 = std::atoi(ProgressWindow_stringParts[3]);
			ProgressWindow_rect.height = (float)iVar13;
		}
	}
	util::free2(input);
	BVar2 = snd::Sound_IsInitialised();
	if (BVar2 == 0) {
		LoaderProfile_filename = "LoaderProfileNoSound.txt";
	}
	else {
		LoaderProfile_filename = "LoaderProfile.txt";
	}
	front::Loader_Initialise
						(pcVar1,pcVar5,globs::legoGlobs.bmpFONT5_HI,LoaderProfile_filename,ProgressBar_direction
						 ,ProgressBar,&ProgressWindow_rect,pcVar7);
	front::Loader_display_loading_bar("Game Data");
	globs::legoGlobs.cameraMain =
			 lego::view::Camera_Create(globs::legoGlobs.contRoot,CAMERATYPE_TOPDOWN);
	if (((globs::legoGlobs.cameraMain == NULL) ||
			(globs::legoGlobs.cameraFP =
						lego::view::Camera_Create(globs::legoGlobs.contRoot,CAMERATYPE_FIRSTPERSON),
			globs::legoGlobs.cameraFP == NULL)) ||
		 ((globs::legoGlobs.cameraRadar =
						lego::view::Camera_Create(globs::legoGlobs.contRoot,CAMERATYPE_RADAR),
			globs::legoGlobs.cameraRadar == NULL ||
			((globs::legoGlobs.viewMain =
						 lego::view::Viewport_Create(0.0,0.0,1.0,1.0,(globs::legoGlobs.cameraMain)->contCam),
			 globs::legoGlobs.viewMain == NULL ||
			 (globs::legoGlobs.viewRadar =
						 lego::view::Viewport_CreatePixel
											 (0x10,0xd,0x97,0x97,(globs::legoGlobs.cameraRadar)->contCam),
			 globs::legoGlobs.viewRadar == NULL)))))) goto LAB_0042274b;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","StreamNERPSSpeach",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if (BVar8 == BOOL3_TRUE) {
		globs::legoGlobs.flags1 |= GAME1_STREAMNERPSSPEACH;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ShowDebugToolTips",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = main::Main_ProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globs::legoGlobs.flags2 |= GAME2_SHOWDEBUGTOOLTIPS;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","AllowDebugKeys",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = main::Main_ProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globs::legoGlobs.flags2 |= GAME2_ALLOWDEBUGKEYS;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","AllowEditMode",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = main::Main_ProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globs::legoGlobs.flags2 |= GAME2_ALLOWEDITMODE;
	}
	pfVar15 = &globs::legoGlobs.PowerCrystalRGB.blue;
	pfVar16 = &globs::legoGlobs.PowerCrystalRGB.green;
	pCVar14 = &globs::legoGlobs.PowerCrystalRGB;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","PowerCrystalRGB",0);
	cfg::CFG_ReadRGBF(legoCfgRoot,pcVar1,&pCVar14->red,pfVar16,pfVar15);
	pfVar15 = &globs::legoGlobs.UnpoweredCrystalRGB.blue;
	pfVar16 = &globs::legoGlobs.UnpoweredCrystalRGB.green;
	pCVar14 = &globs::legoGlobs.UnpoweredCrystalRGB;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","UnpoweredCrystalRGB",0);
	cfg::CFG_ReadRGBF(legoCfgRoot,pcVar1,&pCVar14->red,pfVar16,pfVar15);
	Lego_LoadSamples(legoCfgRoot,(uint)((globs::mainGlobs.flags & CMD_REDUCESAMPLES) == CMD_NONE));
	Lego_LoadSurfaceTypeDescriptions_sound(legoCfgRoot,globs::legoGlobs.gameName);
	ai::Priorities_InitialisePositions(legoCfgRoot,globs::legoGlobs.gameName);
	ai::Priorities_InitialiseImages(legoCfgRoot,globs::legoGlobs.gameName);
	Lego_LoadToolTipInfos(legoCfgRoot,globs::legoGlobs.gameName);
	main::Main_LoadToolNames(legoCfgRoot,globs::legoGlobs.gameName);
	front::Panel_RotationControl_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","SharedObjects",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	res::Lws_Initialise(pcVar1,snd::SFX_GetType,snd::SFX_Sample_Random_Play_OrInitSoundUnk,
											snd::SFX_IsSoundOn);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","SharedTextures",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		res::Container_SetSharedTextureDirectory(pcVar1);
	}
	res::Mesh_Initialise(pcVar1);
	iVar13 = main::appHeight();
	iVar9 = main::appWidth();
	std::sprintf(Button_buffer,"NextButton%ix%i",iVar9,iVar13);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",Button_buffer,0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globs::legoGlobs.NextButtonImage = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
		 globs::legoGlobs.NextButtonImage != NULL)) {
		lego::image::Image_SetupTrans(globs::legoGlobs.NextButtonImage,0.0,0.0,0.0,0.0,0.0,0.0);
		iVar13 = main::appHeight();
		iVar9 = main::appWidth();
		std::sprintf(Button_buffer,"NextButtonPos%ix%i",iVar9,iVar13);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",Button_buffer,0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			iVar13 = util::Util_Tokenise(pcVar1,Button_stringParts,",");
			if (iVar13 == 2) {
				fVar10 = std::atof(Button_stringParts[0]);
				globs::legoGlobs.NextButtonPos.x = (float)fVar10;
				fVar10 = std::atof(Button_stringParts[1]);
				globs::legoGlobs.NextButtonPos.y = (float)fVar10;
			}
			util::free2(pcVar1);
		}
	}
	iVar13 = main::appHeight();
	iVar9 = main::appWidth();
	std::sprintf(Button_buffer,"BackButton%ix%i",iVar9,iVar13);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",Button_buffer,0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globs::legoGlobs.BackButtonImage = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
		 globs::legoGlobs.BackButtonImage != NULL)) {
		lego::image::Image_SetupTrans(globs::legoGlobs.BackButtonImage,0.0,0.0,0.0,0.0,0.0,0.0);
		iVar13 = main::appHeight();
		iVar9 = main::appWidth();
		std::sprintf(Button_buffer,"BackButtonPos%ix%i",iVar9,iVar13);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main",Button_buffer,0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			iVar13 = util::Util_Tokenise(pcVar1,Button_stringParts,",");
			if (iVar13 == 2) {
				fVar10 = std::atof(Button_stringParts[0]);
				globs::legoGlobs.BackButtonPos.x = (float)fVar10;
				fVar10 = std::atof(Button_stringParts[1]);
				globs::legoGlobs.BackButtonPos.y = (float)fVar10;
			}
			util::free2(pcVar1);
		}
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BackArrow",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globs::legoGlobs.BackArrowImage = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
		 globs::legoGlobs.BackArrowImage != NULL)) {
		lego::image::Image_SetupTrans(globs::legoGlobs.BackArrowImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	nerps::NERPs_SetHasNextButton((uint)(globs::legoGlobs.NextButtonImage != NULL));
	BVar2 = Lego_LoadLighting();
	if (((((BVar2 != 0) && (BVar2 = Lego_LoadGraphicsSettings(), BVar2 != 0)) &&
			 (BVar2 = Lego_LoadUpgradeTypes(), BVar2 != 0)) &&
			((BVar2 = Lego_LoadVehicleTypes(), BVar2 != 0 &&
			 (BVar2 = Lego_LoadMiniFigureTypes(), BVar2 != 0)))) &&
		 ((BVar2 = Lego_LoadRockMonsterTypes(), BVar2 != 0 &&
			(BVar2 = Lego_LoadBuildingTypes(), BVar2 != 0)))) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CameraSpeed",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CameraSpeed_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CameraSpeed",0);
			CameraSpeed_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(CameraSpeed_str);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CameraDropOff",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CameraDropOff_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CameraDropOff",0);
			CameraDropOff_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar11 = std::atof(CameraDropOff_str);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CameraAcceleration",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CameraAcceleration_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CameraAcceleration",0);
			CameraAcceleration_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar12 = std::atof(CameraAcceleration_str);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MouseScrollIndent",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MouseScrollIndent_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MouseScrollIndent",0);
			MouseScrollIndent_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		iVar13 = std::atoi(MouseScrollIndent_str);
		lego::view::Camera_SetCameraMovements((float)fVar10,(float)fVar11,(float)fVar12,iVar13);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MinDistFor3DSoundsOnTopView",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MinDistFor3DSoundsOnTopView_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MinDistFor3DSoundsOnTopView",0);
			MinDistFor3DSoundsOnTopView_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MinDistFor3DSoundsOnTopView_str);
		globs::legoGlobs.MinDistFor3DSoundsOnTopView = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globs::legoGlobs.MinDistFor3DSoundsOnTopView = 150.0;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MaxDistFor3DSounds",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MaxDistFor3DSounds_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MaxDistFor3DSounds",0);
			MaxDistFor3DSounds_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MaxDistFor3DSounds_str);
		if (fVar10 != (float10)0.0) {
			snd::Sound3D_SetMaxDist((float)fVar10);
		}
		snd::Sound3D_SetRollOffFactor(1.0);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","RollOffFor3DSounds",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			RollOffFor3DSounds_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","RollOffFor3DSounds",0);
			RollOffFor3DSounds_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(RollOffFor3DSounds_str);
		if (fVar10 != (float10)0.0) {
			snd::Sound3D_SetRollOffFactor((float)fVar10);
		}
		globs::legoGlobs.selectPlace = res::SelectPlace_Create(globs::legoGlobs.contRoot,5.0);
		res::SelectPlace_Hide(globs::legoGlobs.selectPlace,TRUE);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MaxReturnedCrystals",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MaxReturnedCrystals_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MaxReturnedCrystals",0);
			MaxReturnedCrystals_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globs::legoGlobs.MaxReturnedCrystals = std::atoi(MaxReturnedCrystals_str);
		if (globs::legoGlobs.MaxReturnedCrystals == 0) {
			globs::legoGlobs.MaxReturnedCrystals = 10;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MouseScrollBorder",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MouseScrollBorder_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MouseScrollBorder",0);
			MouseScrollBorder_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globs::legoGlobs.MouseScrollBorder = std::atoi(MouseScrollBorder_str);
		if (globs::legoGlobs.MouseScrollBorder == 0) {
			globs::legoGlobs.MouseScrollBorder = 5;
		}
		Lego_LoadObjectNames(legoCfgRoot);
		Lego_LoadObjectTheNames(legoCfgRoot);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","HelpWindowOn",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			front::HelpWindow_SetFont(globs::legoGlobs.bmpMbriefFONT2);
			front::HelpWindow_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		}
		front::ObjInfo_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		light::LightEffects_Load(legoCfgRoot,globs::legoGlobs.gameName);
		stats::Stats_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		game::Dependencies_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		front::Bubble_LoadCFG(legoCfgRoot);
		front::Encyclopedia_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		front::ObjTts_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		tools::Weapon_Initialise(legoCfgRoot,globs::legoGlobs.gameName);
		globs::legoGlobs.viewMode = VIEW_TOPDOWN;
		snd::Sound3D_MakeListener((globs::legoGlobs.cameraMain)->contListener->masterFrame);
		snd::Sound3D_SetMinDistForAtten(globs::legoGlobs.MinDistFor3DSoundsOnTopView);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","mindist",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			mindist_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","mindist",0);
			mindist_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(mindist_str);
		mindist = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","maxdist",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			maxdist_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","maxdist",0);
			maxdist_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(maxdist_str);
		maxdist = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","mintilt",0);
		fVar10 = cfg::CFG_ReadRadians(legoCfgRoot,pcVar1);
		mintilt = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","maxtilt",0);
		fVar10 = cfg::CFG_ReadRadians(legoCfgRoot,pcVar1);
		maxtilt = (float)fVar10;
		lego::view::Camera_SetDistRange(globs::legoGlobs.cameraMain,mindist,maxdist);
		lego::view::Camera_SetTiltRange(globs::legoGlobs.cameraMain,mintilt,maxtilt);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","tvclipdist",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			tvclipdist_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","tvclipdist",0);
			tvclipdist_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(tvclipdist_str);
		globs::legoGlobs.TVClipDist = (float)fVar10;
		lego::view::Viewport_SetBackClip(globs::legoGlobs.viewMain,globs::legoGlobs.TVClipDist);
		lego::view::Viewport_SetBackClip(globs::legoGlobs.viewRadar,globs::legoGlobs.TVClipDist);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamiteDamageRadius",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteDamageRadius_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamiteDamageRadius",0);
			DynamiteDamageRadius_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DynamiteDamageRadius_str);
		globs::legoGlobs.DynamiteDamageRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamiteMaxDamage",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteMaxDamage_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamiteMaxDamage",0);
			DynamiteMaxDamage_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DynamiteMaxDamage_str);
		globs::legoGlobs.DynamiteMaxDamage = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamiteWakeRadius",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteWakeRadius_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamiteWakeRadius",0);
			DynamiteWakeRadius_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DynamiteWakeRadius_str);
		globs::legoGlobs.DynamiteWakeRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BirdScarerRadius",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			BirdScarerRadius_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","BirdScarerRadius",0);
			BirdScarerRadius_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(BirdScarerRadius_str);
		globs::legoGlobs.BirdScarerRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MusicOn",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::legoGlobs.flags2 |= GAME2_MUSICON;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CDStartTrack",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CDStartTrack_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CDStartTrack",0);
			CDStartTrack_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globs::legoGlobs.CDStartTrack = std::atoi(CDStartTrack_str);
		if (globs::legoGlobs.CDStartTrack == 0) {
			globs::legoGlobs.CDStartTrack = 2;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CDTracks",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CDTracks_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","CDTracks",0);
			CDTracks_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globs::legoGlobs.CDTracks = std::atoi(CDTracks_str);
		if (globs::legoGlobs.CDTracks == 0) {
			globs::legoGlobs.flags2 &= ~GAME2_MUSICON;
			globs::legoGlobs.CDTracks = 1;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","SoundOn",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::legoGlobs.flags1 |= GAME1_SOUNDON;
		}
		globs::legoGlobs.flags1 |= GAME1_WALLPROMESHES|GAME1_CLEAR|GAME1_PANELS|GAME1_DYNAMICPM;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","Clear",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::legoGlobs.flags1 &= ~GAME1_CLEAR;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","Panels",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::legoGlobs.flags1 &= ~GAME1_PANELS;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","WallProMeshes",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::legoGlobs.flags1 &= ~GAME1_WALLPROMESHES;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DynamicPM",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::legoGlobs.flags1 &= ~GAME1_DYNAMICPM;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","HPBlocks",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			HPBlocks_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","HPBlocks",0);
			HPBlocks_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globs::legoGlobs.HPBlocks = std::atoi(HPBlocks_str);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","OnlyBuildOnPaths",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::legoGlobs.flags1 |= GAME1_ONLYBUILDONPATHS;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","AlwaysRockFall",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::legoGlobs.flags1 |= GAME1_ALWAYSROCKFALL;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MiniFigureRunAway",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MiniFigureRunAway_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MiniFigureRunAway",0);
			MiniFigureRunAway_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MiniFigureRunAway_str);
		globs::legoGlobs.MiniFigureRunAway = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globs::legoGlobs.MiniFigureRunAway = 10.0;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DrainTime",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DrainTime_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DrainTime",0);
			DrainTime_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DrainTime_str);
		globs::legoGlobs.DrainTime = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globs::legoGlobs.DrainTime = 10.0;
		}
		globs::legoGlobs.DrainTime = globs::legoGlobs.DrainTime * 25.0;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ReinforceHits",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			ReinforceHits_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ReinforceHits",0);
			ReinforceHits_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globs::legoGlobs.ReinforceHits = std::atoi(ReinforceHits_str);
		if (globs::legoGlobs.ReinforceHits == 0) {
			globs::legoGlobs.ReinforceHits = 4;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MedPolyRange",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MedPolyRange_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MedPolyRange",0);
			MedPolyRange_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MedPolyRange_str);
		globs::legoGlobs.MedPolyRange = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","HighPolyRange",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			HighPolyRange_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","HighPolyRange",0);
			HighPolyRange_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(HighPolyRange_str);
		globs::legoGlobs.HighPolyRange = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MinEnergyForEat",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MinEnergyForEat_str = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MinEnergyForEat",0);
			MinEnergyForEat_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MinEnergyForEat_str);
		globs::legoGlobs.MinEnergyForEat = (float)fVar10;
		Lego_LoadMiscObjects(legoCfgRoot);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Pointers",0);
		root = cfg::CFG_GetChildren(legoCfgRoot,pcVar1);
		front::Pointer_LoadPointers(root);
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_STANDARD);
		if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_ONE,MESSAGE_FIRSTPERSON,NULL,FALSE,NULL);
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_TWO,MESSAGE_FIRSTPERSON,NULL,TRUE,NULL);
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_FOUR,MESSAGE_TRACKOBJECT,NULL,FALSE,NULL);
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_THREE,MESSAGE_TOPVIEW,NULL,FALSE,NULL);
		}
		effect::Smoke_LoadTextures("MiscAnims\\Smoke","Smoke",3);
		effect::DamageFont_LoadFrames("Interface\\FONTS\\HealthFont","a000_");
		Dialog_center.x = 0.0;
		Dialog_center.y = 0.0;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Dialog","Image",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (globs::legoGlobs.DialogImage = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
			 globs::legoGlobs.DialogImage != NULL)) {
			lego::image::Image_SetupTrans(globs::legoGlobs.DialogImage,0.0,0.0,0.0,0.0,0.0,0.0);
			iVar13 = main::appWidth();
			Dialog_center.x = (float)(iVar13 / 2) - (float)((globs::legoGlobs.DialogImage)->width >> 1);
			iVar13 = main::appHeight();
			Dialog_center.y = (float)(iVar13 / 2) - (float)((globs::legoGlobs.DialogImage)->height >> 1);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Dialog","TitleWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar13 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar13 == 4)) {
			iVar13 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar13 + Dialog_center.x;
			iVar13 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar13 + Dialog_center.y;
			iVar13 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar13;
			iVar13 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar13;
			globs::legoGlobs.DialogTextWndTitle =
					 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT2,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Dialog","TextWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar13 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar13 == 4)) {
			iVar13 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar13 + Dialog_center.x;
			iVar13 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar13 + Dialog_center.y;
			iVar13 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar13;
			iVar13 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar13;
			globs::legoGlobs.DialogTextWndMessage =
					 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Dialog","OkWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar13 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar13 == 4)) {
			iVar13 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar13 + Dialog_center.x;
			iVar13 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar13 + Dialog_center.y;
			iVar13 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar13;
			iVar13 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar13;
			globs::legoGlobs.DialogTextWndOK =
					 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Dialog","CancelWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar13 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar13 == 4)) {
			iVar13 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar13 + Dialog_center.x;
			iVar13 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar13 + Dialog_center.y;
			iVar13 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar13;
			iVar13 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar13;
			globs::legoGlobs.DialogTextWndCancel =
					 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Dialog","ContrastOverlay",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (globs::legoGlobs.DialogContrastOverlay = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
			 globs::legoGlobs.DialogContrastOverlay != NULL)) {
			lego::image::Image_SetupTrans(globs::legoGlobs.DialogContrastOverlay,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		globs::legoGlobs.flags1 |= GAME1_RADARON|GAME1_RADAR_TRACKOBJECTVIEW;
		util::logf_removed((char *)globs::legoGlobs.contRoot,"animtex\\dirt");
		globs::legoGlobs.tvTiltOrZoom_334 = 15.0;
		globs::legoGlobs.radarScreenRect.x = 16.0;
		globs::legoGlobs.radarScreenRect.y = 13.0;
		globs::legoGlobs.radarScreenRect.width = 151.0;
		globs::legoGlobs.radarScreenRect.height = 151.0;
		effect::Effect_Load_RockFallStylesAll
							(legoCfgRoot,globs::legoGlobs.gameName,globs::legoGlobs.contRoot);
		Lego_LoadToolTips(legoCfgRoot);
		game::LiveManager_LoadToolTipIcons(legoCfgRoot);
		Lego_LoadUpgradeNames(legoCfgRoot);
		Lego_LoadInfoMessages(legoCfgRoot);
		front::Info_SetOverFlowImageFile("Interface\\MessageTabs\\infoOverFlow.bmp");
		Lego_LoadTextMessages(legoCfgRoot);
		uVar3 = main::appHeight();
		uVar4 = main::appWidth();
		Lego_LoadPanels(legoCfgRoot,uVar4,uVar3);
		front::Panel_Crystals_Initialise
							("Interface\\RightPanel\\SmallCrystal.bmp","Interface\\RightPanel\\UsedCrystal.bmp",
							 "Interface\\RightPanel\\NoSmallCrystal.bmp");
		front::Panel_AirMeter_Initialise
							("Interface\\AirMeter\\msgpanel_air_juice.bmp",85,6,236,
							 "Interface\\AirMeter\\msgpanel_noair.bmp",21,0);
		front::Panel_CryOreSideBar_Initialise
							("Interface\\RightPanel\\crystalsidebar_ore.bmp",615,434,423);
		uVar3 = main::appHeight();
		uVar4 = main::appWidth();
		Lego_LoadPanelButtons(legoCfgRoot,uVar4,uVar3);
		Lego_LoadTutorialIcon(legoCfgRoot);
		front::Interface_InitSubmenuIconTables();
		front::Interface_LoadInterfaceImages(legoCfgRoot,globs::legoGlobs.gameName);
		front::Interface_LoadInterfaceSurroundImages(legoCfgRoot,globs::legoGlobs.gameName);
		front::Interface_LoadInterfaceDependencies_PlusMinus
							("Interface\\Dependencies\\+.bmp","Interface\\Dependencies\\=.bmp");
		reward::Reward_LoadGraphics(legoCfgRoot,globs::legoGlobs.gameName);
		reward::Reward_Initialise();
		front::Panel_LoadInterfaceButtons_ScrollInfo();
		front::Panel_Button_SetFlags_10(PANEL_RADAR,2,TRUE);
		front::Panel_Button_SetFlags_10(PANEL_RADAR,3,TRUE);
		save::Save_ClearSaveNumber();
		BVar2 = front::Front_IsFrontEndEnabled();
		if (BVar2 != 0) {
			front::Menu_LoadMenus(globs::legoGlobs.config);
		}
		front::Advisor_Initialise
							(globs::legoGlobs.gameName,globs::legoGlobs.cameraMain,globs::legoGlobs.viewMain);
		front::Advisor_InitViewport(200.0);
		front::Advisor_LoadAdvisorAnims(legoCfgRoot,globs::legoGlobs.gameName);
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","DisplayAdvisor",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			iVar13 = main::appHeight();
			iVar9 = main::appWidth();
			front::Advisor_LoadAdvisorPositions(legoCfgRoot,globs::legoGlobs.gameName,iVar9,iVar13);
		}
		if ((globs::legoGlobs.flags1 & GAME1_SOUNDON) != GAME1_NONE) {
			Lego_SetSoundEnabled(TRUE);
		}
		PVar6 = main::Main_ProgrammerMode();
		if (PVar6 < PROGRAMMER_MODE_3) {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","FrontEnd",0);
			BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
			if (BVar8 != BOOL3_TRUE) goto LAB_004226cc;
			front::Loader_display_loading_bar(NULL);
			front::Front_RunScreenMenuType(MENU_SCREEN_TITLE);
			iVar13 = front::Front_IsTriggerAppQuit();
			if (iVar13 != 0) {
				return 0;
			}
			startLevelName = front::Front_GetSelectedLevel();
		}
		else {
LAB_004226cc:
			startLevelName = main::Main_GetStartLevel();
			if (startLevelName == NULL) {
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","startlevel",0);
				startLevelName = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
			}
		}
		front::Front_SetOptionParameters(TRUE,FALSE);
		BVar2 = Lego_LoadLevel(startLevelName);
		if (BVar2 != 0) {
			snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENTLOOP,TRUE);
			return TRUE;
		}
	}
	cfg::CFG_Close(legoCfgRoot);
LAB_0042274b:
	res::Container_Shutdown();
	return 0;
}



void __cdecl lego::lrr::Lego_LoadMiscObjects(CFGProperty *root)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Boulder",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contBoulder = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWO",TRUE);
	if (globs::legoGlobs.contBoulder == NULL) {
		globs::legoGlobs.contBoulder = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"MESH",TRUE)
		;
	}
	res::Container_Hide(globs::legoGlobs.contBoulder,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","BoulderExplodeIce",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contBoulderExplodeIce =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contBoulderExplodeIce,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","BoulderExplode",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contBoulderExplode =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contBoulderExplode,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","SmashPath",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contSmashPath = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contSmashPath,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Explosion",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	effect::Effect_Load_Explosion(globs::legoGlobs.contRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Crystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contCrystal = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWO",TRUE);
	if (globs::legoGlobs.contCrystal == NULL) {
		globs::legoGlobs.contCrystal = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"MESH",TRUE)
		;
	}
	res::Container_Hide(globs::legoGlobs.contCrystal,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contDynamite = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::legoGlobs.contDynamite,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contOohScary = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::legoGlobs.contOohScary,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contBarrier = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::legoGlobs.contBarrier,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contOresTable[0] =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWO",TRUE);
	if (globs::legoGlobs.contOresTable[0] == NULL) {
		globs::legoGlobs.contOresTable[0] =
				 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"MESH",TRUE);
	}
	res::Container_Hide(globs::legoGlobs.contOresTable[0],TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contOresTable[1] =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWO",TRUE);
	if (globs::legoGlobs.contOresTable[1] == NULL) {
		globs::legoGlobs.contOresTable[1] =
				 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"MESH",TRUE);
	}
	res::Container_Hide(globs::legoGlobs.contOresTable[1],TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contElectricFence =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWO",TRUE);
	res::Container_Hide(globs::legoGlobs.contElectricFence,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","ElectricFenceStud",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contElectricFenceStud =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contElectricFenceStud,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","ShortElectricFenceBeam",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	effect::Effect_Load_ElectricFenceBeam(globs::legoGlobs.contRoot,pcVar1,FALSE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","LongElectricFenceBeam",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	effect::Effect_Load_ElectricFenceBeam(globs::legoGlobs.contRoot,pcVar1,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contSpiderWeb = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::legoGlobs.contSpiderWeb,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","RechargeSparkle",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contRechargeSparkle =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contRechargeSparkle,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","MiniTeleportUp",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contMiniTeleportUp =
			 res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",FALSE);
	res::Container_Hide(globs::legoGlobs.contMiniTeleportUp,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","IceCube",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contIceCube = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::legoGlobs.contIceCube,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Pusher",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contPusher = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contPusher,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","Freezer",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contFreezer = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contFreezer,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiscObjects","LaserShot",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::legoGlobs.contLaserShot = res::Container_Load(globs::legoGlobs.contRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::legoGlobs.contLaserShot,TRUE);
	effect::Effect_Initialise(root,globs::legoGlobs.gameName,globs::legoGlobs.contRoot);
	return;
}



Container * __cdecl lego::lrr::Lego_GetCurrentCamera_Container(void)
{
	Container *cont;
	
	if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
		return (globs::legoGlobs.cameraMain)->contCam;
	}
	cont = (Container *)globs::legoGlobs.viewMode;
	if (globs::legoGlobs.viewMode == VIEW_FIRSTPERSON) {
		cont = (globs::legoGlobs.cameraFP)->contCam;
	}
	return cont;
}



float10 __cdecl lego::lrr::Lego_GetElapsedAbs(void)
{
	return (float10)globs::legoGlobs.elapsedAbs;
}



void __cdecl lego::lrr::Lego_RenameInputUnk(float elapsedAbs)
{
	uint uVar1;
	uint uVar2;
	LiveObject *pLVar3;
	char *pcVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	int iVar8;
	longlong lVar9;
	
	globs::updateGlobs.renameInputTimer = globs::updateGlobs.renameInputTimer - elapsedAbs;
	if ((ushort)((ushort)(globs::updateGlobs.renameInputTimer < 0.0) << 8 |
							(ushort)(globs::updateGlobs.renameInputTimer == 0.0) << 0xe) != 0) {
		globs::updateGlobs.renameInputTimer = globs::updateGlobs.renameInputTimer - -12.5;
		globs::gamectrlGlobs.renameUseQuotes = ZEXT14(globs::gamectrlGlobs.renameUseQuotes == 0);
	}
	if (globs::legoGlobs.renameInput != NULL) {
		lVar9 = __ftol((float10)globs::legoGlobs.renamePosition.x);
		iVar8 = (int)lVar9;
		uVar1 = lego::image::Font_GetHeight(globs::legoGlobs.bmpToolTipFont);
		lVar9 = __ftol((float10)globs::legoGlobs.renamePosition.y);
		uVar2 = lego::image::Font_GetCharWidth(globs::legoGlobs.bmpToolTipFont,'\"');
		pcVar4 = globs::legoGlobs.renameInput;
		if ((*globs::legoGlobs.renameInput == '\0') &&
			 (pLVar3 = game::Message_GetPrimarySelectedUnit(), pcVar4 = globs::legoGlobs.renameInput,
			 pLVar3 != NULL)) {
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			pcVar4 = game::LiveObject_GetName(pLVar3);
		}
		uVar5 = lego::image::Font_GetStringWidth(globs::legoGlobs.bmpToolTipFont,"\"%s\"",pcVar4);
		if (globs::mainGlobs.appWidth - 40 < iVar8 + uVar5) {
			iVar8 -= uVar5;
		}
		pcVar7 = "\"";
		if (globs::gamectrlGlobs.renameUseQuotes == 0) {
			pcVar7 = ____EMPTYSTR__;
		}
		pcVar6 = "\"";
		if (globs::gamectrlGlobs.renameUseQuotes == 0) {
			pcVar6 = ____EMPTYSTR__;
		}
		lego::image::Font_PrintF
							(globs::legoGlobs.bmpToolTipFont,
							 (~-(uint)(globs::gamectrlGlobs.renameUseQuotes != 0) & uVar2) + iVar8,
							 (int)lVar9 - (uVar1 >> 1),"%s%s%s",pcVar6,pcVar4,pcVar7);
	}
	return;
}



void __cdecl lego::lrr::Lego_Input_UpdateTyping(void)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (globs::legoGlobs.renameInput != NULL) {
		uVar2 = 0xffffffff;
		pcVar6 = globs::legoGlobs.renameInput;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		uVar3 = ~uVar2 - 1;
						// 1 = DIK_ESCAPE, 14 = DIK_BACK (backspace), 28 = DIK_RETURN (enter)
		if ((globs::INPUT.Key_Map[14] == false) ||
			 (globs::gamectrlGlobs.typingState_Map[14] == globs::INPUT.Key_Map[14])) {
			if (((globs::INPUT.Key_Map[28] == false) &&
					(globs::gamectrlGlobs.typingState_Map[28] != false)) ||
				 ((globs::INPUT.Key_Map[1] == false && (globs::gamectrlGlobs.typingState_Map[1] != false))))
			{
				globs::legoGlobs.renameInput = NULL;
				game::Game_SetPaused(0,0);
			}
			else {
				uVar2 = 0;
				do {
					if ((((uVar3 < 0xb) && (globs::INPUT.Key_Map[uVar2] != false)) &&
							(globs::gamectrlGlobs.typingState_Map[uVar2] != globs::INPUT.Key_Map[uVar2])) &&
						 (iVar4 = input::Input_GetKeyCharacter(uVar2), iVar4 != 0)) {
						iVar4 = std::toupper(iVar4);
						globs::legoGlobs.renameInput[uVar3] = (char)iVar4;
						uVar3 += 1;
						globs::legoGlobs.renameInput[uVar3] = '\0';
					}
					uVar2 += 1;
				} while (uVar2 < 0x100);
			}
		}
		else {
			if (uVar3 != 0) {
				globs::legoGlobs.renameInput[~uVar2 - 2] = '\0';
			}
		}
		puVar5 = (undefined4 *)globs::INPUT.Key_Map;
		puVar7 = (undefined4 *)globs::gamectrlGlobs.typingState_Map;
		for (iVar4 = 0x40; iVar4 != 0; iVar4 += -1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		puVar5 = (undefined4 *)globs::INPUT.Key_Map;
		for (iVar4 = 0x40; iVar4 != 0; iVar4 += -1) {
			*puVar5 = 0;
			puVar5 = puVar5 + 1;
		}
	}
	return;
}



BOOL __cdecl lego::lrr::Lego_MainLoop(float elapsed)
{
	float fVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	LevelData *level;
	char *pcVar4;
	uint uVar5;
	LiveObject **ppLVar6;
	ObjectUpgradesData *pOVar7;
	float crystals;
	float elapsedGame_00;
	uint objLevel;
	int iVar8;
	float10 fVar9;
	longlong lVar10;
	TextType textType;
	float fVar12;
	ulonglong uVar11;
	float local_34;
	SFXType local_30;
	float elapsedGame;
	Vector4F local_28;
	int local_18;
	BOOL local_14;
	BOOL local_10;
	Vector3F local_c;
	
	fVar1 = elapsed;
	local_30 = SFX_NULL;
	if ((globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_10) &&
		 (BVar3 = Lego_EndLevel(), BVar3 == 0)) {
		return 0;
	}
	if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
		elapsed = 0.0;
	}
	Lego_Input_UpdateTyping();
	globs::legoGlobs.elapsedAbs = elapsed;
	if ((globs::legoGlobs.viewMode == VIEW_FIRSTPERSON) &&
		 (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_2)) {
						// In first person view, game speed is locked at 100%
		elapsedGame = elapsed;
	}
	else {
		fVar9 = game::Game_GetGameSpeed();
		elapsedGame = (float)(fVar9 * (float10)elapsed);
	}
	elapsedGame_00 = elapsedGame;
	unk::Teleporter_Update(elapsedGame);
	LegoGame_UnkTeleporterInit_FUN_00435980();
	fVar12 = elapsed;
	level = Lego_GetLevel();
	game::Level_FUN_0042c370(level,fVar12);
	game::Game_UpdateFallins(elapsedGame_00);
	unk::Lego_UpdateSlug_FUN_004260f0(elapsedGame_00);
	if ((globs::legoGlobs.flags2 & GAME2_CALLTOARMS) == GAME2_NONE) {
		if (((globs::legoGlobs.cameraFP != NULL) && ((globs::legoGlobs.cameraFP)->contCam != NULL)) &&
			 (globs::legoGlobs.contFPRotLightDefault != NULL)) {
			res::Container_Hide(globs::legoGlobs.contFPRotLightDefault,1);
		}
	}
	else {
		if (((globs::legoGlobs.cameraFP != NULL) && ((globs::legoGlobs.cameraFP)->contCam != NULL)) &&
			 ((globs::legoGlobs.contFPRotLightDefault != NULL &&
				((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)))) {
			res::Container_Hide(globs::legoGlobs.contFPRotLightDefault,0);
			res::Container_AddRotation
								(globs::legoGlobs.contFPRotLightDefault,D3DRMCOMBINE_AFTER,0.0,1.0,0.0,elapsed * 0.1
								);
		}
	}
	if (((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
		 (((globs::legoGlobs.flags1 & GAME1_UNK_200000) != GAME1_NONE ||
			(globs::legoGlobs.gotoBool_98 != 0)))) {
		if (globs::legoGlobs.gotoBool_98 != 0) {
			local_28.x = (1.0 / elapsed) * 5.0;
			res::Container_GetPosition((globs::legoGlobs.cameraMain)->cont3,NULL,&local_c);
			globs::legoGlobs.gotoPositions_88[0].x =
					 (local_28.x * local_c.x + globs::legoGlobs.gotoPositions_88[1].x) / (local_28.x - -1.0);
			globs::legoGlobs.gotoPositions_88[0].y =
					 (local_28.x * local_c.y + globs::legoGlobs.gotoPositions_88[1].y) / (local_28.x - -1.0);
			local_28.x = globs::legoGlobs.gotoPositions_88[0].x - local_c.x;
			local_28.y = globs::legoGlobs.gotoPositions_88[0].y - local_c.y;
			if (SQRT(local_28.y * local_28.y + local_28.x * local_28.x) < 2.0) {
				globs::legoGlobs.gotoBool_98 = 0;
			}
		}
		lego::view::Camera_SetTopdownPosition
							(globs::legoGlobs.cameraMain,globs::legoGlobs.gotoPositions_88[0].x,
							 globs::legoGlobs.gotoPositions_88[0].y);
		globs::legoGlobs.flags1 &= ~GAME1_UNK_200000;
	}
	if ((globs::legoGlobs.flags1 & GAME1_LEVELSTART) != GAME1_NONE) {
		elapsedGame = 1.0;
		globs::legoGlobs.flags1 &= ~GAME1_LEVELSTART;
		elapsedGame_00 = 1.0;
	}
	BVar3 = Lego_HandleKeys(elapsedGame_00,elapsed,&local_10,&local_14,&local_18);
	if (BVar3 == 0) {
		return 0;
	}
	if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		Lego_Unk_HasRadarCtrl_FUN_00425cc0();
	}
	ai::AITask_Update(elapsedGame_00);
	game::Level_FUN_00424530(globs::legoGlobs.level,elapsedGame_00);
	effect::DamageFont_UpdateAll(elapsed);
	game::LiveManager_UpdateAll(elapsedGame_00);
	tools::Weapon_Struct2B0_Update_Table_FUN_0046f810(elapsedGame_00);
	game::Erode_Update(elapsedGame_00);
	game::Level_LevelStruct1C_FUN_004312e0(globs::legoGlobs.level,elapsedGame_00);
	game::Message_PTL_Update();
	lego::view::Camera_Update
						(globs::legoGlobs.cameraMain,globs::legoGlobs.level,elapsed,elapsedGame_00);
	lego::view::Camera_Update
						(globs::legoGlobs.cameraRadar,globs::legoGlobs.level,elapsed,elapsedGame_00);
	lego::view::Camera_Update(globs::legoGlobs.cameraFP,globs::legoGlobs.level,elapsed,elapsedGame_00)
	;
	game::Construction_Update(elapsedGame_00);
	front::Interface_FUN_0041b940(fVar1);
	Lego_UnkUpdateMapsWorldUnk_FUN_004290d0(elapsed,FALSE);
	game::LiveManager_AllCallback_FUN_00449ec0();
	game::ElectricFence_Update(elapsedGame_00);
	game::Game_unkGameLoop_FUN_00426450(fVar1,elapsed,local_10,local_14,local_18);
	game::Map3D_Update((globs::legoGlobs.level)->surfaceMap,elapsedGame_00);
	game::Water_Update(globs::legoGlobs.level,elapsedGame_00);
	snd::Sound3D_UpdateListener();
	effect::Smoke_Update(elapsedGame_00);
	game::SpiderWeb_Update(elapsedGame_00);
	light::LightEffects_Update(elapsedGame_00);
	front::Info_FUN_0041a1f0(fVar1);
	if (globs::legoGlobs.IsFallinsEnabled != 0) {
		game::Fallin_Update(elapsedGame_00);
	}
	if ((((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) &&
			(globs::INPUT.Key_Map[64] != false)) &&
		 (globs::INPUT.prevKey_Map[64] != globs::INPUT.Key_Map[64])) {
		globs::legoGlobs.IsFallinsEnabled = ZEXT14(globs::legoGlobs.IsFallinsEnabled == 0);
		pcVar4 = "On";
		if (globs::legoGlobs.IsFallinsEnabled == 0) {
			pcVar4 = "Off";
		}
		front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\nFallin Mode %s",pcVar4);
	}
	res::Container_Hide(globs::legoGlobs.contAmbientLight,FALSE);
	if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
		if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
			res::Container_Hide(globs::legoGlobs.contRootSpotlight,FALSE);
		}
		res::Container_Hide(globs::legoGlobs.contTopSpotlight,FALSE);
		lego::view::Viewport_Clear(globs::legoGlobs.viewMain,TRUE);
		lego::view::Viewport_Render(globs::legoGlobs.viewMain,globs::legoGlobs.contRoot,elapsed);
		res::Container_Hide(globs::legoGlobs.contTopSpotlight,TRUE);
		res::Container_Hide(globs::legoGlobs.contRootSpotlight,TRUE);
	}
	else {
		if (globs::legoGlobs.viewMode == VIEW_FIRSTPERSON) {
			game::Roof_Hide(0);
			game::Roof_Update();
			game::LiveObject_FP_SetRanges
								(globs::legoGlobs.objectFP,(globs::legoGlobs.cameraFP)->contCam,
								 globs::legoGlobs.MedPolyRange,globs::legoGlobs.HighPolyRange,1);
			BVar3 = 1;
			iVar8 = lego::view::Camera_GetFPCameraFrame(globs::legoGlobs.cameraFP);
			game::LiveObject_SwapPolyFP(globs::legoGlobs.objectFP,iVar8,BVar3);
			game::Game_UpdateSceneFog(TRUE,elapsedGame_00);
			if (((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
				 (res::Container_Hide(globs::legoGlobs.contFPLight,0),
				 globs::legoGlobs.contFPRotLight != NULL)) {
				res::Container_AddRotation
									(globs::legoGlobs.contFPRotLight,D3DRMCOMBINE_AFTER,0.0,1.0,0.0,elapsed * 0.01);
				res::Container_Hide(globs::legoGlobs.contFPRotLight,FALSE);
			}
			lego::view::Viewport_Clear(globs::legoGlobs.viewMain,TRUE);
			lego::view::Viewport_Render(globs::legoGlobs.viewMain,globs::legoGlobs.contRoot,elapsed);
			res::Container_Hide(globs::legoGlobs.contFPLight,TRUE);
			if (globs::legoGlobs.contFPRotLight != NULL) {
				res::Container_Hide(globs::legoGlobs.contFPRotLight,TRUE);
			}
			game::Game_UpdateSceneFog(0,elapsedGame_00);
			BVar3 = 0;
			iVar8 = lego::view::Camera_GetFPCameraFrame(globs::legoGlobs.cameraFP);
			game::LiveObject_SwapPolyFP(globs::legoGlobs.objectFP,iVar8,BVar3);
			game::LiveObject_FP_SetRanges(globs::legoGlobs.objectFP,NULL,0,0,0);
			game::Roof_HideAllVisibleBlocks();
			game::Roof_Hide(TRUE);
			game::Level_RemoveAll_ProMeshes();
		}
	}
	res::Container_Hide(globs::legoGlobs.contAmbientLight,1);
	BVar3 = front::Panel_IsFlags_2_Not8(PANEL_RADAR);
	if (BVar3 == 0) {
		globs::legoGlobs.flags1 &= ~GAME1_RADARON;
	}
	else {
		globs::legoGlobs.flags1 |= GAME1_RADARON;
	}
	if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
		game::Game_DrawSelectedUnitBoxes(globs::legoGlobs.viewMain);
		game::Game_DrawRedBoxes_AroundUnitsWithFlags4_1(globs::legoGlobs.viewMain);
		front::Encyclopedia_DrawSelectBox(globs::legoGlobs.viewMain);
	}
	game::Level_DrawDragSelectionBox(globs::legoGlobs.level);
	if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		front::Bubble_Unk_DrawObjectUIs_FUN_004074d0(elapsed);
	}
	if ((((globs::legoGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
			((globs::legoGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) &&
		 (lego::view::Viewport_Clear(globs::legoGlobs.viewRadar,TRUE),
		 (globs::legoGlobs.flags1 & GAME1_UNK_20000) == GAME1_NONE)) {
		Lego_UnkUpdateMapsWorldUnk_FUN_004290d0(elapsedGame_00,TRUE);
		game::LiveManager_AllCallback_FUN_00449ec0();
		res::Container_Hide(globs::legoGlobs.contTrackSpotlight,FALSE);
		if (((globs::legoGlobs.cameraFP != NULL) && ((globs::legoGlobs.cameraFP)->contCam != NULL)) &&
			 (globs::legoGlobs.contFPRotLightDefault != NULL)) {
			res::Container_Hide(globs::legoGlobs.contFPRotLightDefault,TRUE);
		}
		lego::view::Viewport_Render(globs::legoGlobs.viewRadar,globs::legoGlobs.contRoot,elapsed);
		res::Container_Hide(globs::legoGlobs.contTrackSpotlight,TRUE);
		game::Map3D_DoForCoordsAndClear_Mesh_FUN_00474df0((globs::legoGlobs.level)->surfaceMap);
	}
	main::Main_Finalise3D();
	effect::Smoke_HideAll(TRUE);
	snd::SFX_Update(fVar1);
	if ((globs::legoGlobs.viewMode == VIEW_TOPDOWN) &&
		 ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)) {
		game::Level_UpdateTutorialBlockFlashing
							(globs::legoGlobs.level,globs::legoGlobs.viewMain,elapsedGame_00,elapsed);
		nerps::NERPsRuntime_DrawTutorialIcon
							(globs::legoGlobs.level,globs::legoGlobs.viewMain,elapsedGame_00,elapsed);
	}
	game::Map3D_DoForCoordsAndClear_Mesh_FUN_00474df0((globs::legoGlobs.level)->surfaceMap);
	if (((globs::legoGlobs.flags1 & GAME1_RADARON) == GAME1_NONE) ||
		 ((globs::legoGlobs.flags1 & GAME1_RADAR_MAPVIEW) == GAME1_NONE)) {
		iVar8 = 0;
	}
	else {
		iVar8 = 1;
	}
	if (iVar8 != 0) {
		Lego_UnkCameraTrack_InRadar_FUN_00426180();
	}
	game::LiveManager_UnkRadar_FUN_0043c570(elapsedGame_00,iVar8);
	if ((globs::legoGlobs.flags1 & GAME1_PANELS) != GAME1_NONE) {
		if ((globs::legoGlobs.flags1 & GAME1_RADARON) == GAME1_NONE) {
			front::Panel_FUN_0045a9f0(PANEL_RADARFILL,elapsed);
		}
		front::Panel_FUN_0045a9f0(PANEL_RADAR,elapsed);
		if ((((globs::legoGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
				((globs::legoGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) &&
			 ((globs::legoGlobs.flags1 & GAME1_UNK_20000) == GAME1_NONE)) {
			front::Panel_FUN_0045a9f0(PANEL_RADAROVERLAY,elapsed);
		}
		front::Panel_FUN_0045a9f0(PANEL_MESSAGESIDE,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_CAMERACONTROL,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_TOPPANEL,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_PRIORITYLIST,elapsed);
		ai::Priorities_Update();
		front::Panel_FUN_0045a9f0(PANEL_ENCYCLOPEDIA,elapsed);
		front::Encyclopedia_Update(elapsed);
		if ((globs::legoGlobs.flags2 & GAME2_INMENU) == GAME2_NONE) {
			front::Interface_FUN_0041b3c0();
		}
		front::Interface_FUN_0041b860(elapsed);
		front::Panel_FUN_0045a9f0(PANEL_CRYSTALSIDEBAR,elapsed);
		crystals = elapsed;
		fVar12 = elapsed;
		if (globs::legoGlobs.level != NULL) {
			crystals = (float)(globs::legoGlobs.level)->numCrystals;
			fVar12 = (float)((globs::legoGlobs.level)->numCrystals -
											(globs::legoGlobs.level)->numUnusedCrystals);
		}
		front::Panel_Crystals_Draw((uint)crystals,(uint)fVar12,elapsedGame_00);
		front::Panel_CryOreSideBar_Draw();
		front::Panel_PrintF(5,globs::legoGlobs.bmpToolTipFont,0x10,0x1d5,1,"%i",
												(globs::legoGlobs.level)->numOre +
												(globs::legoGlobs.level)->numProcessedOre * 5);
		front::Panel_FUN_0045a9f0(PANEL_INFORMATION,elapsed);
		front::ScrollInfo_FUN_00463fe0(0);
		front::Info_DrawPanel(elapsed);
		front::Panel_FUN_0045a9f0(PANEL_INFODOCK,elapsed);
		front::Info_Draw(elapsed);
	}
	front::HelpWindow_FUN_00418930();
	BVar3 = game::Objective_IsObjectiveFinished();
	fVar12 = elapsed;
	if (BVar3 != 0) {
		fVar12 = fVar1;
	}
	front::Advisor_Update(fVar12);
	snd::Sound_Update(globs::legoGlobs.flags1 & GAME1_MUSICON);
	if ((globs::legoGlobs.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
		nerps::NERPsRuntime_Execute(elapsed);
	}
	game::Objective_Update(globs::legoGlobs.textWnd_80,globs::legoGlobs.level,elapsedGame_00,fVar1);
	if (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_2) {
		if (((globs::legoGlobs.level)->MaxStolen != 0.0) &&
			 ((uint)(globs::legoGlobs.level)->MaxStolen <= (uint)(globs::legoGlobs.level)->field_9c)) {
			game::Objective_SetCompleteStatus(LEVELSTATUS_FAILED_CRYSTALS);
		}
		uVar5 = game::LiveObject_GetLevelObjectsBuilt(OBJECT_PATH,0,0,1);
		if (uVar5 == 0) {
			objLevel = 0;
			iVar8 = 0;
			uVar5 = stats::Stats_GetLevels(OBJECT_MINIFIGURE,0);
			if (uVar5 != 0) {
				do {
					uVar5 = game::LiveObject_GetLevelObjectsBuilt(OBJECT_MINIFIGURE,0,objLevel,1);
					iVar8 += uVar5;
					objLevel += 1;
					uVar5 = stats::Stats_GetLevels(OBJECT_MINIFIGURE,0);
				} while (objLevel < uVar5);
			}
			if ((iVar8 == 0) && (level = Lego_GetLevel(), level->status == LEVELSTATUS_NONE)) {
				game::Objective_SetCompleteStatus(LEVELSTATUS_FAILED);
			}
		}
	}
	front::Text_Update(elapsed);
	if (((globs::legoGlobs.flags2 & GAME2_MENU_HASNEXT) != GAME2_NONE) &&
		 (globs::legoGlobs.NextButtonImage != NULL)) {
		lego::image::Image_DisplayScaled
							(globs::legoGlobs.NextButtonImage,NULL,&globs::legoGlobs.menuNextPoint,NULL);
	}
	if (((globs::legoGlobs.flags2 & GAME2_MENU_HASPREVIOUS) != GAME2_NONE) &&
		 (globs::legoGlobs.BackArrowImage != NULL)) {
		lego::image::Image_DisplayScaled
							(globs::legoGlobs.BackArrowImage,NULL,&globs::legoGlobs.menuPrevPoint,NULL);
	}
	if ((((globs::legoGlobs.flags2 & GAME2_UNK_40) != GAME2_NONE) &&
			(globs::legoGlobs.NextButtonImage != NULL)) &&
		 (((globs::legoGlobs.flags2 & GAME2_CAMERAMOVING) == GAME2_NONE ||
			(BVar3 = front::Interface_GetBool_004ded1c(), BVar3 != 0)))) {
		lego::image::Image_DisplayScaled
							(globs::legoGlobs.NextButtonImage,NULL,&globs::legoGlobs.NextButtonPos,NULL);
	}
	if (((globs::legoGlobs.flags2 & GAME2_UNK_80) != GAME2_NONE) &&
		 (globs::legoGlobs.BackButtonImage != NULL)) {
		lego::image::Image_DisplayScaled
							(globs::legoGlobs.BackButtonImage,NULL,&globs::legoGlobs.BackButtonPos,NULL);
	}
	if ((((globs::legoGlobs.flags2 & GAME2_INOPTIONSMENU) != GAME2_NONE) &&
			(BVar3 = front::Front_IsFrontEndEnabled(), BVar3 != 0)) &&
		 (BVar3 = front::Front_FUN_004152a0(elapsed,1), BVar3 != 0)) {
		globs::legoGlobs.flags2 &= ~GAME2_INOPTIONSMENU;
		BVar3 = game::Objective_IsObjectiveFinished();
		if (BVar3 == 0) {
			game::Game_SetPaused(0,0);
		}
		else {
			globs::legoGlobs.flags1 |= GAME1_PAUSED;
		}
	}
	Lego_RenameInputUnk(fVar1);
	if ((globs::legoGlobs.flags1 & GAME1_PAUSED) == GAME1_NONE) {
		front::Pointer_Update(fVar1);
		if (globs::legoGlobs.renameInput == NULL) goto LAB_00423e04;
	}
	else {
		BVar3 = front::Front_IsFrontEndEnabled();
		if ((BVar3 == 0) || (BVar3 = front::Front_FUN_004152a0(elapsed,0), BVar3 == 0)) {
			front::Pointer_Update(fVar1);
LAB_00423e04:
			front::Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
		}
		else {
			globs::legoGlobs.flags1 ^= GAME1_PAUSED;
			BVar3 = front::Front_IsTriggerMissionQuit();
			if (BVar3 == 0) {
				BVar3 = game::Objective_IsObjectiveFinished();
				if (BVar3 == 0) {
					game::Game_SetPaused(0,0);
				}
			}
			else {
				Lego_SetLoadFlag_StartTeleporter();
				level = Lego_GetLevel();
				level->status = LEVELSTATUS_FAILED_CRYSTALS;
				reward::Reward_CountUnits();
				if ((globs::legoGlobs.flags1 & GAME1_MUSICON) != GAME1_NONE) {
					globs::legoGlobs.flags2 |= GAME2_MUSICON;
					snd::Music_PlayNext(FALSE);
				}
			}
		}
	}
	BVar3 = front::Front_IsTriggerMissionRestart();
	if ((BVar3 == 1) || (globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_11)) {
		debug::Debug_ProgrammerMode11_LoadLevel();
	}
	if ((globs::legoGlobs.flags1 & GAME1_UNK_20000000) != GAME1_NONE) {
		pcVar4 = "Vertex";
		if ((globs::legoGlobs.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
			pcVar4 = "Block";
		}
		lego::image::Font_PrintF(globs::legoGlobs.bmpDeskTopFont,10,10,"%s mode",pcVar4);
	}
	if (((globs::legoGlobs.flags1 & GAME1_UNK_40000) != GAME1_NONE) && (globs::legoGlobs.bool_c8 != 0)
		 ) {
		game::Map3D_FUN_00450320
							((globs::legoGlobs.level)->surfaceMap,globs::legoGlobs.pointi_c0.x,
							 globs::legoGlobs.pointi_c0.y,&local_c);
		lego::view::Viewport_Transform(globs::legoGlobs.viewMain,&local_28,&local_c);
		local_28.x = local_28.x / local_28.w;
		local_28.y = local_28.y / local_28.w;
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_DRILL);
		lVar10 = __ftol((float10)local_28.y);
		uVar5 = (uint)lVar10;
		lVar10 = __ftol((float10)local_28.x);
		front::Pointer_DrawPointer((uint)lVar10,uVar5);
		globs::legoGlobs.flags1 &= ~GAME1_UNK_80000000;
	}
	front::ToolTip_Update(globs::INPUT.msx,globs::INPUT.msy,fVar1);
	if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
						// IsKeyPressed(KEY_FIVE) (6)
						//  "Set selected unit model to first upgrade code."
						// IsKeyPressed(KEY_SIX)   (7)
						//  "Set selected unit model to second upgrade code."
						// IsKeyPressed(KEY_SEVEN) (8)
						//  "Set selected unit model to third upgrade code."
						// IsKeyPressed(KEY_EIGHT) (9)
						//  "Set selected unit model to fourth upgrade code."
		if (((((globs::INPUT.Key_Map[6] != false) &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) ||
				 ((globs::INPUT.Key_Map[7] != false &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])))) ||
				((globs::INPUT.Key_Map[8] != false &&
				 (globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])))) ||
			 ((globs::INPUT.Key_Map[9] != false &&
				(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])))) {
			globs::gamectrlGlobs.dbgUpgradeChangeTimer = 1.0;
		}
		if ((ushort)((ushort)(globs::gamectrlGlobs.dbgUpgradeChangeTimer < 0.0) << 8 |
								(ushort)(globs::gamectrlGlobs.dbgUpgradeChangeTimer == 0.0) << 0xe) == 0) {
			ppLVar6 = game::Message_GetSelectedUnits2((uint *)&local_28);
			if (local_28.x != 0.0) {
				pLVar2 = *ppLVar6;
				if (pLVar2->objType == OBJECT_BUILDING) {
					pOVar7 = &pLVar2->building->upgrades;
				}
				else {
					if (pLVar2->objType == OBJECT_VEHICLE) {
						pOVar7 = &pLVar2->vehicle->upgrades;
					}
					else {
						pOVar7 = NULL;
					}
				}
				if (pOVar7 != NULL) {
					uVar5 = pOVar7->currentLevel;
					uVar11 = CONCAT44(uVar5,uVar5 >> 1) & 0x100000001;
					lego::image::Font_PrintF
										(globs::legoGlobs.bmpFONT5_HI,0,0,"Upgrade - (%i%i%i%i)",uVar5 >> 3 & 1,
										 uVar5 >> 2 & 1,(uint)uVar11,(uint)(uVar11 >> 0x20));
				}
			}
			globs::gamectrlGlobs.dbgUpgradeChangeTimer = globs::gamectrlGlobs.dbgUpgradeChangeTimer - 0.1;
		}
	}
	if (globs::updateGlobs.dripSFXTimer < 0.0) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_DRIP,0);
		fVar9 = math::Maths_RandRange(75.0,125.0);
		globs::updateGlobs.dripSFXTimer = (float)fVar9;
	}
	if (globs::updateGlobs.ambientSFXTimer < 0.0) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENT,0);
		fVar9 = math::Maths_RandRange(250.0,750.0);
		globs::updateGlobs.ambientSFXTimer = (float)fVar9;
	}
	globs::updateGlobs.dripSFXTimer = globs::updateGlobs.dripSFXTimer - elapsed;
	globs::updateGlobs.ambientSFXTimer = globs::updateGlobs.ambientSFXTimer - elapsed;
	if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
						// IsKeyUp(KEYPAD_9) (73)
		if (globs::INPUT.Key_Map[73] == false) {
			local_34 = -1.0;
						// IsKeyUp(KEYPAD_8) (72)
			if (globs::INPUT.Key_Map[72] == false) {
				local_34 = 0.0;
			}
		}
		else {
			local_34 = 1.0;
		}
		if (local_34 != 0.0) {
			globs::gamectrlGlobs.dbgSpeedChangeTimer = 25.0;
			fVar9 = game::Game_GetGameSpeed();
			game::Game_SetGameSpeed((float)((float10)local_34 * (float10)elapsed * (float10)0.01 + fVar9))
			;
			fVar9 = game::Game_GetGameSpeed();
			if ((ushort)((ushort)(fVar9 < (float10)3.0) << 8 | (ushort)(fVar9 == (float10)3.0) << 0xe) ==
					0) {
				game::Game_SetGameSpeed(3.0);
			}
			fVar9 = game::Game_GetGameSpeed();
			if (fVar9 < (float10)0.0) {
				game::Game_SetGameSpeed(0.0);
			}
		}
		if ((ushort)((ushort)(globs::gamectrlGlobs.dbgSpeedChangeTimer < 0.0) << 8 |
								(ushort)(globs::gamectrlGlobs.dbgSpeedChangeTimer == 0.0) << 0xe) == 0) {
			fVar9 = game::Game_GetGameSpeed();
			lego::image::Font_PrintF
								(globs::legoGlobs.bmpFONT5_HI,10,0x50,"Game Speed %0.0f%%",
								 (double)(fVar9 * (float10)100.0));
		}
		globs::gamectrlGlobs.dbgSpeedChangeTimer = globs::gamectrlGlobs.dbgSpeedChangeTimer - elapsed;
	}
	if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) == GAME2_NONE) goto LAB_0042427c;
	if (globs::updateGlobs.dbgRollOffFactorValue == -1.0) {
		fVar9 = snd::Sound3D_SetRollOffFactor(-1.0);
		globs::updateGlobs.dbgRollOffFactorValue = (float)fVar9;
	}
	if (globs::INPUT.Key_Map[10] == false) {
		if (globs::INPUT.Key_Map[11] != false) {
			globs::updateGlobs.dbgRollOffFactorValue = globs::updateGlobs.dbgRollOffFactorValue - -0.05;
			goto LAB_0042421e;
		}
	}
	else {
		globs::updateGlobs.dbgRollOffFactorValue = globs::updateGlobs.dbgRollOffFactorValue - 0.05;
LAB_0042421e:
		fVar9 = snd::Sound3D_SetRollOffFactor(globs::updateGlobs.dbgRollOffFactorValue);
		globs::updateGlobs.dbgRollOffFactorValue = (float)fVar9;
		globs::gamectrlGlobs.dbgRollOffChangeTimer = 25.0;
	}
	if ((ushort)((ushort)(globs::gamectrlGlobs.dbgRollOffChangeTimer < 0.0) << 8 |
							(ushort)(globs::gamectrlGlobs.dbgRollOffChangeTimer == 0.0) << 0xe) == 0) {
		lego::image::Font_PrintF
							(globs::legoGlobs.bmpFONT5_HI,10,0x50,"3D sound fall off: %f",
							 (double)globs::updateGlobs.dbgRollOffFactorValue);
	}
	globs::gamectrlGlobs.dbgRollOffChangeTimer = globs::gamectrlGlobs.dbgRollOffChangeTimer - elapsed;
LAB_0042427c:
	if ((globs::legoGlobs.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
		nerps::NERPsRuntime_UpdateTimers(elapsed);
	}
	else {
		lego::image::Font_PrintF(globs::legoGlobs.bmpFONT5_HI,0,0,"NoNERPS");
	}
	if ((ushort)((ushort)((globs::legoGlobs.level)->oxygenLevel < 0.0) << 8 |
							(ushort)((globs::legoGlobs.level)->oxygenLevel == 0.0) << 0xe) == 0) {
		fVar1 = (globs::legoGlobs.level)->oxygenLevel;
		if ((globs::legoGlobs.level)->float_204 - 5.0 <= (globs::legoGlobs.level)->oxygenLevel) {
			if ((ushort)((ushort)(fVar1 < (globs::legoGlobs.level)->float_204) << 8 |
									(ushort)(fVar1 == (globs::legoGlobs.level)->float_204) << 0xe) == 0) {
				if ((undefined *)(globs::legoGlobs.level)->oxygenLevel == &DAT_42c80000) {
					front::Info_Send(INFO_AIRRESTORED,NULL,NULL,NULL);
				}
				(globs::legoGlobs.level)->float_204 = (globs::legoGlobs.level)->oxygenLevel;
			}
		}
		else {
			if ((ushort)((ushort)(fVar1 < 10.0) << 8 | (ushort)(fVar1 == 10.0) << 0xe) == 0) {
				front::Info_Send(INFO_AIRDEPLETING,NULL,NULL,NULL);
				textType = TEXT_AIRSUPPLYRUNNINGOUT;
			}
			else {
				front::Info_Send(INFO_AIRLOW,NULL,NULL,NULL);
				textType = TEXT_AIRSUPPLYLOW;
			}
			front::Text_DisplayMessage(textType,1,0);
			(globs::legoGlobs.level)->float_204 = (globs::legoGlobs.level)->oxygenLevel;
		}
	}
	else {
		front::Info_Send(INFO_AIROUT,NULL,NULL,NULL);
	}
	if ((ushort)((ushort)((globs::legoGlobs.level)->oxygenLevel < 10.0) << 8 |
							(ushort)((globs::legoGlobs.level)->oxygenLevel == 10.0) << 0xe) == 0) {
		if ((globs::panelGlobs.airMeterUnkBeatBool != 0) &&
			 (BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30), BVar3 != 0)) {
			iVar8 = snd::SFX_Sample_Random_GetSoundHandle(local_30);
			snd::SFX_Sample_Sound3D_StopSound(iVar8);
		}
		BVar3 = 0;
	}
	else {
		if ((globs::panelGlobs.airMeterUnkBeatBool == 0) &&
			 (BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30), BVar3 != 0)) {
			snd::SFX_Sample_Random_Play_OrAddToQueue(local_30,1);
		}
		BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30);
		if (BVar3 != 0) {
			iVar8 = snd::Sound3D_MinVolume();
			lVar10 = __ftol((float10)(globs::legoGlobs.level)->oxygenLevel * (float10)0.1 *
											(float10)iVar8 * (float10)0.1);
			iVar8 = snd::SFX_Sample_Random_GetBufferVolume(local_30);
			if ((int)lVar10 != iVar8) {
				snd::SFX_Sample_Random_SetBufferVolume(local_30,(int)lVar10);
			}
		}
		BVar3 = 1;
	}
	front::Panel_AirMeter_SetAirBeat_UnkBool(BVar3);
	globs::legoGlobs.timerGame_e3c = globs::legoGlobs.timerGame_e3c - elapsedGame;
	return TRUE;
}



void __cdecl lego::game::LiveObject_ConsumeOxygen(LiveObject *liveObj,float elapsed)
{
	LevelData *pLVar1;
	float10 fVar2;
	
	pLVar1 = globs::legoGlobs.level;
	fVar2 = stats::StatsObject_GetOxygenCoef(liveObj);
	if ((liveObj->objType != OBJECT_BUILDING) ||
		 ((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE)) {
		fVar2 = (float10)elapsed * (float10)0.04 * (float10)pLVar1->OxygenRate * fVar2 +
						(float10)pLVar1->oxygenLevel;
		pLVar1->oxygenLevel = (float)fVar2;
		if ((ushort)((ushort)(fVar2 < (float10)100.0) << 8 | (ushort)(fVar2 == (float10)100.0) << 0xe)
				== 0) {
			pLVar1->oxygenLevel = (float)&DAT_42c80000;
		}
		if (((ushort)((ushort)(pLVar1->oxygenLevel < 0.0) << 8 |
								 (ushort)(pLVar1->oxygenLevel == 0.0) << 0xe) != 0) &&
			 (pLVar1->oxygenLevel = 0.0, (globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE)) {
			Objective_SetCompleteStatus(LEVELSTATUS_FAILED);
			return;
		}
	}
	return;
}



void __cdecl lego::game::Level_FUN_00424530(LevelData *level,float elapsedGame)
{
	LevelBlockFlags1 *pLVar1;
	uint numRockFalls;
	int iVar2;
	uint uVar3;
	uint local_14;
	uint *local_10;
	uint *local_c;
	Point2I local_8;
	
	numRockFalls = effect::Effect_UpdateAll(elapsedGame,&local_c,&local_10);
	uVar3 = 0;
	if (numRockFalls != 0) {
		do {
			effect::Effect_GetBlockPos_RockFall
								(local_c[uVar3],local_10[uVar3],&local_14,(uint *)&elapsedGame);
			local_8.x = local_14;
			local_8.y = (int)elapsedGame;
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * (int)elapsedGame + local_14;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_800;
			if (((globs::legoGlobs.level)->blocks
					 [((globs::legoGlobs.level)->dimensions).width * (int)elapsedGame + local_14].flags1 &
					BLOCK1_UNK_1000) == BLOCK1_NONE) {
				Message_AddMessageAction(MESSAGE_ROCKFALL_COMPLETE,0,0,&local_8);
			}
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * (int)elapsedGame + local_14;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_1000;
			pLVar1 = &(globs::legoGlobs.level)->blocks
								[((globs::legoGlobs.level)->dimensions).width * local_8.y + local_8.x].flags1;
			uVar3 += 1;
			*pLVar1 = *pLVar1 & ~BLOCK1_BUSY;
		} while (uVar3 < numRockFalls);
	}
	return;
}



void __cdecl lego::game::Game_UpdateSceneFog(BOOL isFogEnabled,float elapsed)
{
	uint uVar1;
	uint uVar2;
	float10 fVar3;
	float10 fVar4;
	ColourRGBF local_c;
	
	if ((globs::legoGlobs.flags1 & GAME1_FOGCOLOURRGB) != GAME1_NONE) {
		res::Container_EnableFog(isFogEnabled);
		if ((isFogEnabled != 0) && ((globs::legoGlobs.flags1 & GAME1_HIGHFOGCOLOURRGB) != GAME1_NONE)) {
			fVar3 = ((float10)6.283185 / (float10)globs::legoGlobs.FogRate) * (float10)elapsed +
							(float10)globs::gamectrlGlobs.float_12c;
			globs::gamectrlGlobs.float_12c = (float)fVar3;
			fVar3 = (float10)fsin(fVar3);
			uVar1 = 0;
			do {
				uVar2 = uVar1 + 4;
				fVar4 = ((float10)*(float *)((int)globs::legoGlobs.objTeleportQueueTypes_TABLE +
																		(uVar1 - 0x5c)) -
								(float10)*(float *)((int)globs::legoGlobs.recordObjs + uVar1 + 0x54)) * (float10)0.5
				;
				*(float *)((int)&local_c.red + uVar1) =
						 (float)(fVar4 + (float10)*(float *)((int)globs::legoGlobs.recordObjs + uVar1 + 0x54) +
										fVar4 * fVar3);
				uVar1 = uVar2;
			} while (uVar2 < 0xc);
			res::Container_SetFogColour(local_c.red,local_c.green,local_c.blue);
		}
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_DrawRedBox_IfFlags4_1(LiveObject *liveObj,Viewport *viewMain)
{
	if ((liveObj->flags4 & LIVEOBJ4_UNK_1) != LIVEOBJ4_NONE) {
		LiveObject_DrawSelectedBox(liveObj,viewMain,1.0,0.0,0.0);
	}
	return 0;
}



BOOL __cdecl lego::game::Game_DrawRedBoxes_AroundUnitsWithFlags4_1(Viewport *viewMain)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_DrawRedBox_IfFlags4_1,viewMain);
	return BVar1;
}



void __cdecl lego::game::Game_DrawSelectedUnitBoxes(Viewport *viewMain)
{
	uint uVar1;
	LiveObject **ppLVar2;
	uint index;
	
	uVar1 = Message_GetNumSelectedUnits();
	ppLVar2 = Message_GetSelectedUnits();
	for (index = 0; index < uVar1; index += 1) {
		if (index == 0) {
						// Primary selected unit has a green box
			LiveObject_DrawSelectedBox(*ppLVar2,viewMain,0.0,1.0,0.0);
		}
		else {
						// All remaining selected units have a yellow box
			LiveObject_DrawSelectedBox(ppLVar2[index],viewMain,1.0,1.0,0.0);
		}
	}
	return;
}



void __cdecl
lego::game::LiveObject_DrawSelectedBox
					(LiveObject *liveObj,Viewport *param_2,float r,float g,float b)
{
	float fVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	int iVar3;
	uint uVar4;
	float10 fVar5;
	longlong lVar6;
	char *msg;
	Point2F linePts1 [8];
	Vector3F local_a8;
	Vector3F local_9c;
	Point2F linePts2 [8];
	Vector3F local_4c;
	Point2F local_40 [2];
	Vector4F local_30;
	Vector3F local_20;
	Vector3F local_14;
	float local_8;
	
	local_4c.x = 0.0;
	local_4c.y = 1.0;
	local_4c.z = 0.0;
	BVar2 = LiveObject_IsHidden(liveObj);
	if (BVar2 == 0) {
		if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
			r = r * 0.3;
			g = g * 0.3;
			b = b * 0.3;
		}
		LiveObject_GetPosition(liveObj,&local_a8.x,&local_a8.y);
		surfMap = lrr::Lego_GetMap();
		fVar5 = Map3D_GetWorldZ(surfMap,local_a8.x,local_a8.y);
		local_a8.z = (float)fVar5;
		fVar5 = stats::StatsObject_GetCollHeight(liveObj);
		local_a8.z = (float)((float10)local_a8.z - fVar5 / (float10)2.0);
		lego::view::Viewport_WorldToScreen(param_2,(Point2F *)&local_30,&local_a8);
		if ((0.0 <= local_30.x) && (0.0 <= local_30.y)) {
			iVar3 = main::appWidth();
			if (local_30.x <= (float)iVar3) {
				iVar3 = main::appHeight();
				if (local_30.y <= (float)iVar3) {
					local_30.z = 0.0;
					local_30.w = 1.0;
					lego::view::Viewport_InverseTransform(param_2,&local_9c,&local_30);
					math::Maths_Vector3DSubtract(&local_14,&local_a8,&local_9c);
					math::Maths_Vector3DNormalize(&local_14);
					math::Maths_Vector3DCrossProduct(&local_20,&local_14,&local_4c);
					math::Maths_Vector3DNormalize(&local_20);
					fVar5 = stats::StatsObject_GetPickSphere(liveObj);
					math::Maths_Vector3DScale(&local_20,&local_20,(float)fVar5);
					math::Maths_Vector3DAdd(&local_a8,&local_a8,&local_20);
					lego::view::Viewport_WorldToScreen(param_2,local_40,&local_a8);
					fVar5 = math::Maths_Vector2DDistance((Point2F *)&local_30,local_40);
					fVar1 = (float)(fVar5 / (float10)2.5);
					local_8 = (float)((fVar5 / (float10)2.5) / (float10)5.0 + (float10)3.0);
					linePts1[0].x = local_30.x - fVar1;
					linePts1[0].y = (local_30.y - fVar1) + local_8;
					linePts2[0].x = local_30.x - fVar1;
					linePts2[0].y = local_30.y - fVar1;
					linePts1[1].x = (local_30.x - fVar1) + 1.0;
					linePts1[1].y = local_30.y - fVar1;
					linePts2[1].x = (local_30.x - fVar1) + local_8;
					linePts2[1].y = local_30.y - fVar1;
					linePts1[2].x = (local_30.x + fVar1) - local_8;
					linePts1[2].y = local_30.y - fVar1;
					linePts2[2].x = local_30.x + fVar1;
					linePts2[2].y = local_30.y - fVar1;
					linePts1[3].x = local_30.x + fVar1;
					linePts1[3].y = (local_30.y - fVar1) + 1.0;
					linePts2[3].x = local_30.x + fVar1;
					linePts2[3].y = (local_30.y - fVar1) + local_8;
					linePts1[4].x = local_30.x + fVar1;
					linePts1[4].y = (local_30.y + fVar1) - local_8;
					linePts2[4].x = local_30.x + fVar1;
					linePts2[4].y = local_30.y + fVar1;
					linePts1[5].x = (local_30.x + fVar1) - 1.0;
					linePts1[5].y = local_30.y + fVar1;
					linePts2[5].x = (local_30.x + fVar1) - local_8;
					linePts2[5].y = local_30.y + fVar1;
					linePts1[6].x = (local_30.x - fVar1) + local_8;
					linePts1[6].y = local_30.y + fVar1;
					linePts2[6].x = local_30.x - fVar1;
					linePts2[6].y = local_30.y + fVar1;
					linePts1[7].x = local_30.x - fVar1;
					linePts1[7].y = (local_30.y + fVar1) - 1.0;
					linePts2[7].x = local_30.x - fVar1;
					linePts2[7].y = (local_30.y + fVar1) - local_8;
					draw::Draw_LineListEx(linePts1,linePts2,8,r,g,b,DRAWEFFECT_NONE);
					if ((((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
							(liveObj->customName != NULL)) && (*liveObj->customName != '\0')) {
						msg = liveObj->customName;
						lVar6 = __ftol((float10)local_30.y - (float10)fVar1);
						uVar4 = lego::image::Font_GetHeight(globs::legoGlobs.bmpToolTipFont);
						iVar3 = (int)lVar6 - uVar4;
						lVar6 = __ftol((float10)local_30.x - (float10)fVar1);
						lego::image::Font_PrintF(globs::legoGlobs.bmpToolTipFont,(int)lVar6,iVar3,msg);
					}
				}
			}
		}
	}
	return;
}



// Simply halts music playback, then calls std::exit(0);

void __cdecl lego::lrr::Lego_Shutdown(void)
{
	Lego_Exit();
	return;
}



// This is only called as a ProgrammerMode_10 setting,
//  where proper cleanup is performed.

void __cdecl lego::lrr::Lego_Shutdown_Debug(void)
{
	BOOL BVar1;
	char *filename;
	uint uVar2;
	char *unaff_EDI;
	int iVar3;
	
	front::Loader_display_shutdown();
	reward::Reward_Shutdown();
	snd::Music_PlayNext(0);
	Lego_SetSoundEnabled(0);
	game::Level_Free();
	front::Interface_FreeInterfaceIcons();
	cfg::CFG_Close(globs::legoGlobs.config);
	lego::view::Viewport_Remove(globs::legoGlobs.viewMain);
	res::Container_Remove(globs::legoGlobs.contRoot);
	lego::view::Camera_Free(globs::legoGlobs.cameraMain);
	lego::view::Camera_Free(globs::legoGlobs.cameraRadar);
	lego::view::Camera_Free(globs::legoGlobs.cameraFP);
	uVar2 = 0;
	if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Vehicle_Destroy
								((VehicleData *)
								 ((int)(globs::legoGlobs.VehicleData_TABLE)->WheelMeshes + iVar3 + -0x10));
			std::free(globs::legoGlobs.VehicleTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x1ec;
		} while (uVar2 < globs::legoGlobs.VehicleTypes_COUNT);
	}
	std::free(globs::legoGlobs.VehicleTypes_TABLE);
	std::free(globs::legoGlobs.ObjectNames_VehicleTypes_TABLE);
	std::free(globs::legoGlobs.VehicleData_TABLE);
	uVar2 = 0;
	if (globs::legoGlobs.MiniFigureTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Creature_Destroy
								((CreatureData *)
								 ((int)(globs::legoGlobs.MiniFigureData_TABLE)->cameraFramesTable_54 + iVar3 + -0x54
								 ));
			std::free(globs::legoGlobs.MiniFigureTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x74;
		} while (uVar2 < globs::legoGlobs.MiniFigureTypes_COUNT);
	}
	std::free(globs::legoGlobs.MiniFigureTypes_TABLE);
	std::free(globs::legoGlobs.ObjectNames_MiniFigureTypes_TABLE);
	std::free(globs::legoGlobs.MiniFigureData_TABLE);
	uVar2 = 0;
	if (globs::legoGlobs.RockMonsterTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Creature_Destroy
								((CreatureData *)
								 ((int)(globs::legoGlobs.RockMonsterData_TABLE)->cameraFramesTable_54 +
								 iVar3 + -0x54));
			std::free(globs::legoGlobs.RockMonsterTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x74;
		} while (uVar2 < globs::legoGlobs.RockMonsterTypes_COUNT);
	}
	std::free(globs::legoGlobs.RockMonsterTypes_TABLE);
	std::free(globs::legoGlobs.ObjectNames_RockMonsterTypes_TABLE);
	std::free(globs::legoGlobs.RockMonsterData_TABLE);
	uVar2 = 0;
	if (globs::legoGlobs.UpgradeTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Upgrade_Destroy
								((UpgradeData *)((int)&(globs::legoGlobs.UpgradeData_TABLE)->objectIndex + iVar3));
			std::free(globs::legoGlobs.UpgradeTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x10;
		} while (uVar2 < globs::legoGlobs.UpgradeTypes_COUNT);
	}
	std::free(globs::legoGlobs.UpgradeTypes_TABLE);
	std::free(globs::legoGlobs.ObjectNames_UpgradeTypes_TABLE);
	std::free(globs::legoGlobs.UpgradeData_TABLE);
	uVar2 = 0;
	if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Building_Destroy
								((BuildingData *)
								 ((int)(globs::legoGlobs.BuildingData_TABLE)->carryFramesTable_28 + iVar3 + -0x28));
			std::free(globs::legoGlobs.BuildingTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x14c;
		} while (uVar2 < globs::legoGlobs.BuildingTypes_COUNT);
	}
	std::free(globs::legoGlobs.BuildingTypes_TABLE);
	std::free(globs::legoGlobs.ObjectNames_BuildingTypes_TABLE);
	std::free(globs::legoGlobs.BuildingData_TABLE);
	std::free(globs::legoGlobs.ObjectNames_PowerCrystal);
	std::free(globs::legoGlobs.ObjectNames_Ore);
	std::free(globs::legoGlobs.ObjectNames_ProcessedOre);
	std::free(globs::legoGlobs.ObjectNames_Dynamite);
	std::free(globs::legoGlobs.ObjectNames_Barrier);
	std::free(globs::legoGlobs.ObjectNames_ElectricFence);
	std::free(globs::legoGlobs.ObjectNames_SpiderWeb);
	std::free(globs::legoGlobs.ObjectNames_OohScary);
	std::free(globs::legoGlobs.ObjectNames_Path);
	front::TextWindow_Remove(globs::legoGlobs.textWnd_80);
	lego::image::Font_Remove(globs::legoGlobs.bmpFONT5_HI);
	lego::image::Font_Remove(globs::legoGlobs.bmpToolTipFont);
	effect::Effect_RemoveAll_RockFall();
	ai::AITask_Shutdown();
	game::LiveManager_Shutdown();
	res::Container_Shutdown();
	lego::view::Viewport_Shutdown();
	if (globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_10) {
		BVar1 = snd::Sound_IsInitialised();
		filename = "LoaderProfile.txt";
		if (BVar1 == 0) {
			filename = "LoaderProfileNoSound.txt";
		}
	}
	else {
		filename = NULL;
	}
	front::Loader_Shutdown(filename);
	util::logf_removed(unaff_EDI);
	lego::image::Image_Shutdown();
	res::Lws_Shutdown();
	snd::Sound3D_ShutDown();
	ddraw::DirectDraw_Clear(NULL,0);
	return;
}



void __cdecl lego::lrr::Lego_Exit(void)
{
	snd::Music_PlayNext(0);
	std::exit(0);
	return;
}



BOOL __cdecl
lego::lrr::Lego_HandleKeys(float elapsedGame,float param_2,BOOL *out_t,BOOL *put_r,BOOL *out_shift)
{
	BOOL *pBVar1;
	BOOL *pBVar2;
	BOOL *pBVar3;
	LiveObject *pLVar4;
	Container *cont;
	BOOL BVar5;
	TutorialFlags TVar6;
	char *pcVar7;
	BOOL spaceKeyHeld;
	BoolTri BVar8;
	bool bVar9;
	float10 fVar10;
	ActivityType actType;
	undefined4 unkbool2d8;
	Point2F local_14;
	Vector3F local_c;
	
						// IsKeyReleased(KEY_RETURN) (28)
						//  "Submit unit rename input."
	if ((((((globs::legoGlobs.flags2 & GAME2_ALLOWRENAME) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[28] == false)) && (globs::INPUT.prevKey_Map[28] != false)) &&
			(((globs::legoGlobs.viewMode == VIEW_TOPDOWN &&
				((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)) &&
			 ((pLVar4 = game::Message_GetPrimarySelectedUnit(), pLVar4 != NULL &&
				(pLVar4->objType == OBJECT_MINIFIGURE)))))) &&
		 ((pLVar4->flags5 != LIVEOBJ5_NONE || (pLVar4->objLevel != 0)))) {
		cont = game::LiveObject_GetContainer(pLVar4);
		res::Container_GetPosition(cont,NULL,&local_c);
		fVar10 = stats::StatsObject_GetCollHeight(pLVar4);
		local_c.z = (float)((float10)local_c.z - fVar10 * (float10)0.5);
		lego::view::Viewport_WorldToScreen(globs::legoGlobs.viewMain,&local_14,&local_c);
		if ((40.0 <= local_14.x) &&
			 (((40.0 <= local_14.y &&
				 ((ushort)((ushort)(local_14.x < (float)globs::mainGlobs.appWidth - 40.0) << 8 |
									(ushort)(local_14.x == (float)globs::mainGlobs.appWidth - 40.0) << 0xe) != 0)) &&
				((ushort)((ushort)(local_14.y < (float)globs::mainGlobs.appHeight - 80.0) << 8 |
								 (ushort)(local_14.y == (float)globs::mainGlobs.appHeight - 80.0) << 0xe) != 0)))) {
			game::Game_SetPaused(FALSE,TRUE);
			if (pLVar4->customName == NULL) {
				game::LiveObject_SetCustomName(pLVar4,"Object");
				*pLVar4->customName = '\0';
			}
			globs::legoGlobs.renameInput = pLVar4->customName;
			globs::legoGlobs.renamePosition.x = local_14.x;
			globs::legoGlobs.renamePosition.y = local_14.y;
		}
	}
						// IsKeyDown(KEY_ESCAPE) (1)
	if (globs::INPUT.Key_Map[1] != false) {
		if ((((globs::legoGlobs.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE) &&
				(BVar5 = front::HelpWindow_IsEnabled_AndFlags_3_AndNoTutorialFlags(), BVar5 == 0)) &&
			 ((BVar5 = game::Objective_IsObjectiveFinished(), BVar5 == 0 &&
				((globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE)))) {
			if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
						// IsKeyUp(KEY_SPACE) (57)
				if (globs::INPUT.Key_Map[57] == false) {
						// IsKeyDown(KEY_RETURN) (28)
					if (globs::INPUT.Key_Map[28] != false) {
						return 0;
					}
				}
				else {
					snd::Sound3D_ShutDown();
					Lego_Exit();
				}
			}
			game::Game_SetPaused(FALSE,TRUE);
			globs::legoGlobs.flags1 |= GAME1_PAUSED;
		}
		else {
						// IsKeyDown(KEY_ESCAPE) (1)
			if (((globs::INPUT.Key_Map[1] != false) &&
					((globs::legoGlobs.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE)) &&
				 ((BVar5 = front::HelpWindow_IsEnabled_AndFlags_3_AndNoTutorialFlags(), BVar5 == 0 &&
					((BVar5 = game::Objective_IsObjectiveFinished(), BVar5 == 0 &&
					 ((globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE)))))) {
				snd::Sound3D_ShutDown();
				Lego_Exit();
			}
		}
	}
	if ((globs::legoGlobs.flags2 & GAME2_UNK_2) != GAME2_NONE) {
		BVar5 = front::Front_IsFrontEndEnabled();
						// IsKeyDown(KEY_SPACE) (57)
		if ((BVar5 == 0) || (globs::INPUT.Key_Map[57] != false)) {
			snd::Sound3D_ShutDown();
			Lego_Exit();
		}
		else {
						// IsKeyDown(KEY_RETURN) (28)
			if (globs::INPUT.Key_Map[28] != false) {
				return 0;
			}
			BVar5 = Lego_EndLevel();
			if (BVar5 == 0) {
				return 0;
			}
		}
	}
	pBVar3 = out_shift;
	pBVar2 = put_r;
	pBVar1 = out_t;
	*out_t = 0;
	*put_r = 0;
	*out_shift = 0;
	if ((globs::legoGlobs.flags1 & (GAME1_CAMERADISABLED|GAME1_UNK_8000000)) == GAME1_NONE) {
		front::Interface_DoF2InterfaceKeyAction();
						// IsKeyPressed(KEY_SPACE) (57)
						//  "Toggle unit info bubbles/HUDs visibility."
		if ((globs::INPUT.Key_Map[57] != false) &&
			 (globs::INPUT.prevKey_Map[57] != globs::INPUT.Key_Map[57])) {
			front::Bubble_ToggleObjectUIsAlwaysVisible();
		}
						// IsKeyDown(KEY_LEFTSHIFT) (42) || IsKeyDown(KEY_RIGHTSHIFT) (54)
		if ((globs::INPUT.Key_Map[42] != false) || (globs::INPUT.Key_Map[54] != false)) {
			*pBVar3 = 1;
		}
		if ((globs::legoGlobs.viewMode == VIEW_TOPDOWN) &&
			 (TVar6 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
			 (TVar6 & TUTORIAL_UNK_1000) == TUTORIAL_NONE)) {
						// IsKeyDown(KEY_CURSORDOWN) (208)
						//  "Topdown view: Pitch lower (around center)."
			if (globs::INPUT.Key_Map[208] != false) {
				lego::view::Camera_AddTilt(globs::legoGlobs.cameraMain,param_2 * 0.02);
			}
						// IsKeyDown(KEY_CURSORUP) (200)
						//  "Topdown view: Pitch raise (around center)."
			if (globs::INPUT.Key_Map[200] != false) {
				lego::view::Camera_AddTilt(globs::legoGlobs.cameraMain,param_2 * -0.02);
			}
						// IsKeyDown(KEY_CURSORLEFT) (203)
						//  "Topdown view: Rotate clockwise (around center)."
			if (globs::INPUT.Key_Map[203] != false) {
				lego::view::Camera_AddYaw(globs::legoGlobs.cameraMain,param_2 * 0.02);
			}
						// IsKeyDown(KEY_CURSORRIGHT) (205)
						//  "Topdown view: Rotate counter-clockwise (around center)."
			if (globs::INPUT.Key_Map[205] != false) {
				lego::view::Camera_AddYaw(globs::legoGlobs.cameraMain,param_2 * -0.02);
			}
						// IsKeyDown(KEY_MINUS) (12)
						//  "Topdown view: Zoom out."
			if (globs::INPUT.Key_Map[12] != false) {
				lego::view::Camera_AddDist(globs::legoGlobs.cameraMain,param_2 * 3.0);
			}
						// IsKeyDown(KEY_EQUALS) (13)  "+""Topdown view: Zoom in."
			if (globs::INPUT.Key_Map[13] != false) {
				lego::view::Camera_AddDist(globs::legoGlobs.cameraMain,param_2 * -3.0);
			}
		}
		if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
						// IsKeyDown(KEYPAD_7) (71)
						//  "Set game speed to 300%."
			if (globs::INPUT.Key_Map[71] != false) {
				game::Game_SetGameSpeed(3.0);
			}
						// IsKeyDown(KEY_T) (20)
			if (globs::INPUT.Key_Map[20] != false) {
				*pBVar1 = 1;
			}
						// IsKeyDown(KEY_R) (19)
			if (globs::INPUT.Key_Map[19] != false) {
				*pBVar2 = 1;
			}
						// IsKeyPressed(KEY_L) (38)
			if (((globs::INPUT.Key_Map[38] != false) &&
					(globs::INPUT.prevKey_Map[38] != globs::INPUT.Key_Map[38])) &&
				 (BVar5 = Lego_EndLevel(), BVar5 == 0)) {
				return 0;
			}
						// IsKeyDown(KEY_LEFTCTRL) (29) && IsKeyPressed(KEY_F) (33)
						//  "Toggle framerate monitor."
			if (((globs::INPUT.Key_Map[29] != false) && (globs::INPUT.Key_Map[33] != false)) &&
				 (globs::INPUT.prevKey_Map[33] != globs::INPUT.Key_Map[33])) {
				if ((globs::legoGlobs.flags1 & GAME1_FRAMERATEMONITOR) == GAME1_NONE) {
					globs::legoGlobs.flags1 |= GAME1_FRAMERATEMONITOR;
				}
				else {
					globs::legoGlobs.flags1 &= ~GAME1_FRAMERATEMONITOR;
				}
				pcVar7 = "ON";
				if ((globs::legoGlobs.flags1 & GAME1_FRAMERATEMONITOR) == GAME1_NONE) {
					pcVar7 = "OFF";
				}
				front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\nFrame Rate Monitor: %s",pcVar7);
			}
						// IsKeyPressed(KEY_TAB) (15)
						//  "Toggle between Radar Map/Track Object View."
			if ((((globs::legoGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
					(globs::INPUT.Key_Map[15] != false)) &&
				 (globs::INPUT.prevKey_Map[15] != globs::INPUT.Key_Map[15])) {
				bVar9 = (globs::legoGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) == GAME1_NONE;
				if (bVar9) {
					globs::legoGlobs.flags1 =
							 globs::legoGlobs.flags1 &
							 (GAME1_HIGHFOGCOLOURRGB|GAME1_UNK_20000|GAME1_UNK_40000|GAME1_DYNAMICPM|
								GAME1_CAMERADISABLED|GAME1_UNK_200000|GAME1_ONLYBUILDONPATHS|GAME1_ALWAYSROCKFALL|
								GAME1_DEBUG_NONERPS|GAME1_PAUSED|GAME1_STREAMNERPSSPEACH|GAME1_UNK_8000000|
								GAME1_LASERTRACKER|GAME1_UNK_20000000|GAME1_DEBUG_NOCLIP_FPS|GAME1_UNK_80000000) |
							 (ushort)((ushort)globs::legoGlobs.flags1 | 0x2000) & ~GAME1_RADAR_MAPVIEW;
					front::Panel_Button_SetFlags_10(PANEL_RADAR,2,TRUE);
				}
				else {
					globs::legoGlobs.flags1 =
							 globs::legoGlobs.flags1 & ~GAME1_RADAR_TRACKOBJECTVIEW | GAME1_RADAR_MAPVIEW;
					front::Panel_Button_SetFlags_10(PANEL_RADAR,2,FALSE);
				}
				front::Panel_Button_SetFlags_10(PANEL_RADAR,3,(uint)bVar9);
			}
						// IsKeyDown(KEY_LEFTCTRL) (29)
			if (globs::INPUT.Key_Map[29] != false) {
						// IsKeyPressed(KEY_G) (34)
						//  "Toggle memory monitor."
				if ((globs::INPUT.Key_Map[34] != false) &&
					 (globs::INPUT.prevKey_Map[34] != globs::INPUT.Key_Map[34])) {
					if ((globs::legoGlobs.flags1 & GAME1_MEMORYMONITOR) == GAME1_NONE) {
						globs::legoGlobs.flags1 |= GAME1_MEMORYMONITOR;
					}
					else {
						globs::legoGlobs.flags1 &= ~GAME1_MEMORYMONITOR;
					}
					pcVar7 = "ON";
					if ((globs::legoGlobs.flags1 & GAME1_MEMORYMONITOR) == GAME1_NONE) {
						pcVar7 = "OFF";
					}
					front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\nMemory Monitor: %s",pcVar7);
				}
						// IsKeyDown(KEY_LEFTCTRL) (29) && IsKeyPressed(KEY_RETURN) (28)
						//  "Toggle Noclip in first/second person view."
				if (((globs::INPUT.Key_Map[29] != false) && (globs::INPUT.Key_Map[28] != false)) &&
					 (globs::INPUT.prevKey_Map[28] != globs::INPUT.Key_Map[28])) {
					if ((globs::legoGlobs.flags1 & GAME1_DEBUG_NOCLIP_FPS) == GAME1_NONE) {
						globs::legoGlobs.flags1 |= GAME1_DEBUG_NOCLIP_FPS;
					}
					else {
						globs::legoGlobs.flags1 &= ~GAME1_DEBUG_NOCLIP_FPS;
					}
				}
			}
		}
		if ((globs::legoGlobs.viewMode == VIEW_FIRSTPERSON) &&
			 ((*(byte *)&(globs::legoGlobs.objectFP)->flags2 & LIVEOBJ2_UNK_1) == 0)) {
						// First person view controls
						// IsKeyDown(KEY_CURSORUP) (200)
						//  "First person view: Move forward."
			if (globs::INPUT.Key_Map[200] != false) {
				game::LiveObject_FPMove(globs::legoGlobs.objectFP,1,0,0.0);
			}
						// IsKeyDown(KEY_CURSORDOWN) (208)
						//  "First person view: Move back."
			if (globs::INPUT.Key_Map[208] != false) {
				game::LiveObject_FPMove(globs::legoGlobs.objectFP,-1,0,0.0);
			}
						// IsKeyDown(KEY_CURSORLEFT) (203)
						//  "First person view: Turn left."
			if (globs::INPUT.Key_Map[203] != false) {
				game::LiveObject_FPMove(globs::legoGlobs.objectFP,0,0,-0.05);
			}
						// IsKeyDown(KEY_CURSORRIGHT) (205)
						//  "First person view: Turn right."
			if (globs::INPUT.Key_Map[205] != false) {
				game::LiveObject_FPMove(globs::legoGlobs.objectFP,0,0,0.05);
			}
						// IsKeyDown(KEY_Z) (44)
						//  "First person view: Strafe left."
			if (globs::INPUT.Key_Map[44] != false) {
				game::LiveObject_FPMove(globs::legoGlobs.objectFP,0,-1,0.0);
			}
						// IsKeyDown(KEY_X) (45)
						//  "First person view: Strafe right."
			if (globs::INPUT.Key_Map[45] != false) {
				game::LiveObject_FPMove(globs::legoGlobs.objectFP,0,1,0.0);
			}
		}
		if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
						// IsKeyPressed(KEY_S) (31)
						//  "Toggle sound On/Off."
			if ((globs::INPUT.Key_Map[31] != false) &&
				 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
				if ((globs::legoGlobs.flags1 & GAME1_SOUNDON) == GAME1_NONE) {
					Lego_SetSoundEnabled(TRUE);
					snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENTLOOP,TRUE);
				}
				else {
					Lego_SetSoundEnabled(0);
				}
				pcVar7 = "ON";
				if ((globs::legoGlobs.flags1 & GAME1_SOUNDON) == GAME1_NONE) {
					pcVar7 = "OFF";
				}
				front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\nSound Effects: %s",pcVar7);
			}
						// IsKeyPressed(KEY_M) (55)
						//  "Toggle music On/Off."
			if ((globs::INPUT.Key_Map[50] != false) &&
				 (globs::INPUT.prevKey_Map[50] != globs::INPUT.Key_Map[50])) {
				snd::Music_PlayNext((uint)((globs::legoGlobs.flags1 & GAME1_MUSICON) == GAME1_NONE));
				pcVar7 = "ON";
				if ((globs::legoGlobs.flags1 & GAME1_MUSICON) == GAME1_NONE) {
					pcVar7 = "OFF";
				}
				front::TextWindow_PrintF(globs::legoGlobs.textWnd_80,"\nMusic: %s",pcVar7);
			}
		}
						// IsKeyPressed(KEYPAD_0) (82)
		if ((((globs::legoGlobs.flags2 & GAME2_ALLOWEDITMODE) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[82] != false)) &&
			 (globs::INPUT.prevKey_Map[82] != globs::INPUT.Key_Map[82])) {
			lego::view::Camera_Debug_EnableFreeMovement(globs::legoGlobs.cameraMain,FALSE);
			res::SelectPlace_Hide(globs::legoGlobs.selectPlace,TRUE);
		}
						// IsKeyPressed(KEY_Z) (44)
						//  "Make primary selected unit eat."
		if ((((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[44] != false)) &&
			 (globs::INPUT.prevKey_Map[44] != globs::INPUT.Key_Map[44])) {
			lego::view::Camera_Shake(globs::legoGlobs.cameraMain,5.0,25.0);
			pLVar4 = game::Message_GetPrimarySelectedUnit();
			if (pLVar4 != NULL) {
				pLVar4 = game::Message_GetPrimarySelectedUnit();
				unkbool2d8 = 0;
				actType = ACTIVITY_EAT;
				pLVar4->flags1 = pLVar4->flags1 | LIVEOBJ1_EATING;
				pLVar4 = game::Message_GetPrimarySelectedUnit();
				game::LiveObject_SetActivityUnk(pLVar4,actType,unkbool2d8);
				pLVar4 = game::Message_GetPrimarySelectedUnit();
				game::LiveObject_Container_ActivityUpdate_Check(pLVar4);
				pLVar4 = game::Message_GetPrimarySelectedUnit();
				ai::AITask_DoAnimationWait(pLVar4);
			}
		}
	}
	BVar5 = 0;
	param_2 = 0.0;
	if ((globs::gamectrlGlobs.msbl_last_2_unknum != 0) && (globs::INPUT.mslb == 0)) {
		BVar5 = 1;
	}
						// IsKeyUp(KEY_SPACE) && !IsKeyReleased(KEY_SPACE) (57)
	if ((globs::INPUT.Key_Map[57] == false) ||
		 (globs::INPUT.prevKey_Map[57] == globs::INPUT.Key_Map[57])) {
		spaceKeyHeld = 0;
	}
	else {
		spaceKeyHeld = 1;
	}
	BVar5 = game::Objective_HandleKeys(spaceKeyHeld,BVar5,(BOOL *)&param_2);
	if ((((BVar5 == 0) &&
			 (BVar5 = front::HelpWindow_IsEnabled_AndFlags_3_AndNoTutorialFlags(), BVar5 == 0)) &&
			(BVar5 = game::Objective_IsObjectiveFinished(), BVar5 == 0)) &&
		 (((globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE &&
			((globs::legoGlobs.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE)))) {
						// IsKeyPressed(KEY_P) (25)
						//  "Pause/unpause the game."
		if ((globs::INPUT.Key_Map[25] != false) &&
			 (globs::INPUT.prevKey_Map[25] != globs::INPUT.Key_Map[25])) {
			game::Game_SetPaused(TRUE,FALSE);
			globs::legoGlobs.flags1 ^= GAME1_PAUSED;
		}
		if (globs::mainGlobs.active == 0) {
			pcVar7 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","LoseFocusAndPause",0);
			BVar8 = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar7);
			if (((BVar8 == BOOL3_TRUE) && ((globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE))
				 && (game::Game_SetPaused(0,1), (globs::legoGlobs.flags1 & GAME1_PAUSED) == GAME1_NONE)) {
				globs::legoGlobs.flags1 |= GAME1_PAUSED;
			}
		}
	}
	globs::gamectrlGlobs.msbl_last_2_unknum = globs::INPUT.mslb;
	if (param_2 != 0.0) {
		return 0;
	}
	if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
						// IsKeyUp(KEY_LEFTSHIFT) (42)
		if (globs::INPUT.Key_Map[42] == false) {
						// IsKeyDown(KEY_FIVE) (6)
			if (globs::INPUT.Key_Map[6] != false) {
				globs::updateGlobs.currentBaseLightLevel = globs::updateGlobs.currentBaseLightLevel - 0.02;
				res::Container_Light_SetSpotPenumbra
									(globs::legoGlobs.contRootSpotlight,globs::updateGlobs.currentBaseLightLevel);
			}
						// IsKeyDown(KEY_SIX) (7)
			if (globs::INPUT.Key_Map[7] != false) {
				globs::gamectrlGlobs.dbgCursorLightLevel = globs::gamectrlGlobs.dbgCursorLightLevel - 0.02;
				goto LAB_004259b9;
			}
		}
		else {
						// IsKeyDown(KEY_FIVE) (6)
			if (globs::INPUT.Key_Map[6] != false) {
				globs::updateGlobs.currentBaseLightLevel = globs::updateGlobs.currentBaseLightLevel - -0.02;
				res::Container_Light_SetSpotPenumbra
									(globs::legoGlobs.contRootSpotlight,globs::updateGlobs.currentBaseLightLevel);
			}
						// IsKeyDown(KEY_SIX) (7)
			if (globs::INPUT.Key_Map[7] != false) {
				globs::gamectrlGlobs.dbgCursorLightLevel = globs::gamectrlGlobs.dbgCursorLightLevel - -0.02;
LAB_004259b9:
				res::Container_Light_SetSpotUmbra
									(globs::legoGlobs.contRootSpotlight,globs::gamectrlGlobs.dbgCursorLightLevel);
			}
		}
		if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) goto LAB_004259d8;
	}
	if ((globs::mainGlobs.flags & CMD_DEBUGCOMPLETE) == CMD_NONE) {
		return 1;
	}
LAB_004259d8:
						// IsKeyDown(KEY_LEFTCTRL) (29)
	if (globs::INPUT.Key_Map[29] != false) {
						// IsKeyPressed(KEY_D) (32)
						//  "Instantly fails the current level."
		if ((globs::INPUT.Key_Map[32] != false) &&
			 (globs::INPUT.prevKey_Map[32] != globs::INPUT.Key_Map[32])) {
			nerps::funcs::NERPFunc__SetLevelFail(NULL);
		}
						// IsKeyPressed(KEY_S) (31)
						//  "Instantly completes the current level."
		if ((globs::INPUT.Key_Map[31] != false) &&
			 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
			nerps::funcs::NERPFunc__SetLevelCompleted(NULL);
		}
	}
						// IsKeyDown(KEY_RIGHTCTRL) (157)  && IsKeyPressed(KEY_S) (31)
						//  "Instantly fails the current level with reason, too many crystals stolen."
	if (((globs::INPUT.Key_Map[157] != false) && (globs::INPUT.Key_Map[31] != false)) &&
		 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
		game::Objective_SetCompleteStatus(LEVELSTATUS_FAILED_CRYSTALS);
	}
						// IsKeyDown(KEY_O) (24)
						//  "Decreases oxygen level."
	if (globs::INPUT.Key_Map[24] != false) {
		(globs::legoGlobs.level)->oxygenLevel = (globs::legoGlobs.level)->oxygenLevel - 1.0;
	}
	return TRUE;
}



BOOL __cdecl lego::lrr::Lego_UpdateAll3DSounds(BOOL stopAll)
{
	BOOL BVar1;
	
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes(Lego_LiveObjectCallback_UpdateAll3DSounds,&stopAll)
	;
	return BVar1;
}



BOOL __cdecl
lego::lrr::Lego_LiveObjectCallback_UpdateAll3DSounds(LiveObject *liveObj,BOOL *pStopAll)
{
	Container *cont;
	SFXType SVar1;
	BOOL loop;
	BOOL sound3D;
	Vector3F *opt_position;
	
	cont = game::LiveObject_GetContainer(liveObj);
	if (cont != NULL) {
		if ((liveObj->flags4 & LIVEOBJ4_UNK_20000) == LIVEOBJ4_NONE) {
			if (*pStopAll != 0) {
				snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_350);
			}
			if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_UNK_8) != 0) {
				opt_position = NULL;
				sound3D = TRUE;
				loop = TRUE;
				SVar1 = stats::StatsObject_GetDrillSoundType(liveObj,FALSE);
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SVar1,loop,sound3D,opt_position);
				liveObj->soundHandle_350 = SVar1;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_100000;
			}
		}
		if (*pStopAll != 0) {
			snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_354);
		}
		SVar1 = stats::StatsObject_GetEngineSound(liveObj);
		if (SVar1 != SFX_NULL) {
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SVar1,TRUE,TRUE,NULL);
			liveObj->soundHandle_354 = SVar1;
			liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80000;
		}
	}
	return 0;
}



void __cdecl lego::game::Game_SetPaused(BOOL checkCamDisableFlag,BOOL paused)
{
	if ((globs::legoGlobs.flags2 & GAME2_UNK_2) == GAME2_NONE) {
		if (checkCamDisableFlag != 0) {
						// param_2 = (gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE;
			paused = ~globs::legoGlobs.flags1 >> 20 & 1;
		}
		if (paused != 0) {
			if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
				snd::Sound3D_StopAllSounds();
			}
			globs::legoGlobs.flags1 = globs::legoGlobs.flags1 | GAME1_CAMERADISABLED;
			globs::legoGlobs.flags2 = globs::legoGlobs.flags2 | GAME2_INMENU;
			return;
		}
		lrr::Lego_UpdateAll3DSounds(FALSE);
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENTLOOP,TRUE);
		globs::legoGlobs.flags1 &= ~GAME1_CAMERADISABLED;
		globs::legoGlobs.flags2 &= ~GAME2_INMENU;
	}
	return;
}



// When set to TRUE, game speed can only be lowered, not raised.

void __cdecl lego::game::Game_LockGameSpeed(BOOL locked)
{
	globs::gamectrlGlobs.isGameSpeedLocked = locked;
	return;
}



// Set new game speed and update front end speed slider.
//  If GameSpeedLocked global is true, game speed can only be lowered, not raised.

void __cdecl lego::game::Game_SetGameSpeed(float newGameSpeed)
{
	if ((globs::legoGlobs.gameSpeed <= newGameSpeed) || (globs::gamectrlGlobs.isGameSpeedLocked == 0))
	{
		front::FrontEnd_UpdateSliderGameSpeed();
		globs::legoGlobs.gameSpeed = newGameSpeed;
		if (newGameSpeed < 0.0) {
			globs::legoGlobs.gameSpeed = 0.0;
		}
						// Debug mode allows game speeds up to 300%
						// 
						// if (gameGlobs.gameSpeed > 3.0f)
						//   gameGlobs.gameSpeed = 3.0f;
		if ((ushort)((ushort)(globs::legoGlobs.gameSpeed < 3.0) << 8 |
								(ushort)(globs::legoGlobs.gameSpeed == 3.0) << 0xe) == 0) {
			globs::legoGlobs.gameSpeed = 3.0;
		}
	}
	return;
}



void __cdecl lego::game::Game_TrackObjectInRadar(LiveObject *liveObj)
{
	float10 fVar1;
	float trackTilt;
	float trackRotationSpeed;
	
	trackRotationSpeed = 0.01;
	trackTilt = 0.7;
	fVar1 = stats::StatsObject_GetTrackDist(liveObj);
	lego::view::Camera_TrackObject
						(globs::legoGlobs.cameraRadar,liveObj,2.0,(float)fVar1,trackTilt,trackRotationSpeed);
	return;
}



BOOL __cdecl lego::game::Game_IsFirstPersonView(void)
{
	return (uint)(globs::legoGlobs.viewMode == VIEW_FIRSTPERSON);
}



void __cdecl lego::lrr::Lego_Unk_HasRadarCtrl_FUN_00425cc0(void)
{
	TutorialFlags TVar1;
	BOOL BVar2;
	float fVar3;
	int iVar4;
	char *pcVar5;
	SFXType sfxType;
	LevelBlockFlags1 LVar6;
	float10 fVar7;
	float trackRotationSpeed;
	ToolTipType toolTipType;
	LiveObject *local_30;
	Point2F local_2c;
	int local_24;
	int local_20;
	Point2I local_1c;
	Point2F local_10;
	Point2F local_8;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	if ((globs::legoGlobs.flags1 & GAME1_RADARON) == GAME1_NONE) {
		return;
	}
	if ((globs::legoGlobs.flags1 & GAME1_RADAR_MAPVIEW) == GAME1_NONE) {
		return;
	}
	if ((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) != GAME1_NONE) {
		return;
	}
	local_1c.x = (int)((float)globs::INPUT.msx - (float)globs::gamectrlGlobs.msx_Last_1);
	local_10.x = (float)globs::gamectrlGlobs.msy_Last_1;
	local_10.y = 0.0;
	local_1c.y = (int)((float)globs::INPUT.msy - (float)globs::gamectrlGlobs.msy_Last_1);
	front::Pointer_SetCurrent_IfTimerFinished(POINTER_STANDARD);
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar1 & TUTORIAL_UNK_1000) == TUTORIAL_NONE) {
		globs::gamectrlGlobs.mslb_Last_3 =
				 (BOOL)(SQRT((float)local_1c.y * (float)local_1c.y + (float)local_1c.x * (float)local_1c.x)
							 + (float)globs::gamectrlGlobs.mslb_Last_3);
	}
	if ((((globs::gamectrlGlobs.mslb_Last_5 != 0) && (globs::INPUT.mslb != 0)) &&
			(4.0 <= (float)globs::gamectrlGlobs.mslb_Last_3)) &&
		 (BVar2 = game::RadarMap_ScreenToWorldBlockPos
												(level->radarMap,globs::INPUT.msx,globs::INPUT.msy,&local_10,
												 (int *)&local_2c,(int *)&local_2c.y), BVar2 != 0)) {
		lego::view::Camera_GetTopdownPosition(globs::legoGlobs.cameraMain,&local_1c);
		fVar3 = (float)lego::view::Camera_GetMouseScrollIndent();
		if (((uint)local_2c.x < (uint)fVar3) ||
			 (iVar4 = lego::view::Camera_GetMouseScrollIndent(),
			 (uint)((level->surfaceMap->smallDimensions).width - iVar4) <= (uint)local_2c.x)) {
			local_10.x = (float)local_1c.x;
		}
		fVar3 = (float)lego::view::Camera_GetMouseScrollIndent();
		if (((uint)local_2c.y < (uint)fVar3) ||
			 (iVar4 = lego::view::Camera_GetMouseScrollIndent(),
			 (uint)((level->surfaceMap->smallDimensions).height - iVar4) <= (uint)local_2c.y)) {
			local_10.y = (float)local_1c.y;
		}
		if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
			lego::view::Camera_SetTopdownPosition(globs::legoGlobs.cameraMain,local_10.x,local_10.y);
		}
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_RADARPAN);
		globs::legoGlobs.flags1 |= GAME1_UNK_200;
	}
	BVar2 = game::RadarMap_InsideRadarScreen(level->radarMap,globs::INPUT.msx,globs::INPUT.msy);
	if (((BVar2 != 0) && (globs::INPUT.mslb != 0)) && (globs::gamectrlGlobs.mslb_Last_4 == 0)) {
		globs::gamectrlGlobs.mslb_Last_5 = 1;
	}
	if (4.0 <= (float)globs::gamectrlGlobs.mslb_Last_3) goto LAB_004260b6;
	BVar2 = game::RadarMap_TrySelectObject
										(level->radarMap,globs::INPUT.msx,globs::INPUT.msy,&local_30,&local_8);
	if (BVar2 == 0) {
		if (globs::INPUT.mslb != 0) goto LAB_004260b6;
		if (globs::gamectrlGlobs.mslb_Last_4 != 0) {
			BVar2 = game::RadarMap_ScreenToWorldBlockPos
												(level->radarMap,globs::INPUT.msx,globs::INPUT.msy,
												 &globs::legoGlobs.tvFaceDirection_338,&local_20,&local_24);
			if (BVar2 != 0) {
				globs::legoGlobs.flags1 |= GAME1_UNK_4000;
			}
			goto LAB_004260b6;
		}
		if ((false) ||
			 (BVar2 = game::RadarMap_ScreenToWorldBlockPos
													(level->radarMap,globs::INPUT.msx,globs::INPUT.msy,NULL,(int *)&local_2c,
													 (int *)&local_2c.y), BVar2 == 0)) goto LAB_004260b6;
		if ((globs::gamectrlGlobs.pointf_144.x == local_2c.x) &&
			 (globs::gamectrlGlobs.pointf_144.y == local_2c.y)) {
			iVar4 = ((globs::legoGlobs.level)->dimensions).width;
			if (((uint)local_2c.x < iVar4 - 1U) &&
				 ((uint)local_2c.y < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
				LVar6 = (globs::legoGlobs.level)->blocks[(int)local_2c.y * iVar4 + (int)local_2c.x].flags1 &
								BLOCK1_SURVEYED;
			}
			else {
				LVar6 = BLOCK1_NONE;
			}
			if (LVar6 != BLOCK1_NONE) {
				local_1c.x = (int)local_2c.x;
				local_1c.y = (int)local_2c.y;
				Lego_ShowBlockToolTip(&local_1c,FALSE,TRUE,TRUE);
			}
			goto LAB_004260b6;
		}
		globs::gamectrlGlobs.pointf_144.x = local_2c.x;
		globs::gamectrlGlobs.pointf_144.y = local_2c.y;
		toolTipType = TOOLTIP_NULL;
	}
	else {
		if (globs::INPUT.mslb != 0) goto LAB_004260b6;
		if (globs::gamectrlGlobs.mslb_Last_4 != 0) {
			if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
				lego::view::Camera_SetTopdownPosition(globs::legoGlobs.cameraMain,local_8.x,local_8.y);
			}
			trackRotationSpeed = 0.01;
			fVar3 = 0.7;
			fVar7 = stats::StatsObject_GetTrackDist(local_30);
			lego::view::Camera_TrackObject
								(globs::legoGlobs.cameraRadar,local_30,2.0,(float)fVar7,fVar3,trackRotationSpeed);
			globs::legoGlobs.flags1 &= ~GAME1_UNK_4000;
			goto LAB_004260b6;
		}
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_TRACKOBJECT);
		pcVar5 = game::LiveObject_GetName(local_30);
		front::ToolTip_SetText(TOOLTIP_UNITSELECTED,"%s",pcVar5);
		sfxType = game::LiveObject_GetObjTtSFX(local_30);
		front::ToolTip_SetSFX(TOOLTIP_UNITSELECTED,sfxType);
		toolTipType = TOOLTIP_UNITSELECTED;
	}
	front::ToolTip_AddFlag4(toolTipType);
LAB_004260b6:
	if (globs::INPUT.mslb == 0) {
		globs::gamectrlGlobs.mslb_Last_3 = globs::INPUT.mslb;
		globs::gamectrlGlobs.mslb_Last_5 = globs::INPUT.mslb;
	}
	globs::gamectrlGlobs.msy_Last_1 = globs::INPUT.msy;
	globs::gamectrlGlobs.msx_Last_1 = globs::INPUT.msx;
	globs::gamectrlGlobs.mslb_Last_4 = globs::INPUT.mslb;
	return;
}



void __cdecl lego::unk::Lego_UpdateSlug_FUN_004260f0(float elapsedGame)
{
	int iVar1;
	
						// 20 == OBJECTS_SUBTYPES_COUNT, meaning Slug objIndex is invalid
	if (((globs::legoGlobs.level)->Slug != 0x14) &&
		 (globs::legoGlobs.InitialSlugTime = globs::legoGlobs.InitialSlugTime - elapsedGame,
		 globs::legoGlobs.InitialSlugTime < 0.0)) {
		iVar1 = FUN_00438c20(NULL,FALSE);
		if (iVar1 != 0) {
			game::LiveObject_TryGenerateSlug(NULL,(globs::legoGlobs.level)->Slug);
		}
		globs::legoGlobs.InitialSlugTime = (globs::legoGlobs.level)->SlugTime;
	}
	return;
}



void __cdecl lego::game::Game_GetVector_45c(Vector3F *out_vector)
{
	out_vector->x = globs::legoGlobs.vector_45c.x;
	out_vector->y = globs::legoGlobs.vector_45c.y;
	out_vector->z = globs::legoGlobs.vector_45c.z;
	return;
}



void __cdecl lego::lrr::Lego_UnkCameraTrack_InRadar_FUN_00426180(void)
{
	Point2F position;
	
	if ((globs::legoGlobs.cameraRadar)->trackObj == NULL) {
		globs::legoGlobs.flags1 |= GAME1_UNK_4000;
	}
	if ((globs::legoGlobs.flags1 & GAME1_UNK_4000) == GAME1_NONE) {
		game::LiveObject_GetPosition((globs::legoGlobs.cameraRadar)->trackObj,&position.x,&position.y);
	}
	else {
		position.x = globs::legoGlobs.tvFaceDirection_338.x;
		position.y = globs::legoGlobs.tvFaceDirection_338.y;
	}
	game::RadarMap_SetTVTiltOrZoom
						((globs::legoGlobs.level)->radarMap,globs::legoGlobs.tvTiltOrZoom_334);
	game::RadarMap_Draw_FUN_0045de80((globs::legoGlobs.level)->radarMap,&position);
	return;
}



void __cdecl lego::game::Game_SetMenuNextPosition(Point2F *position)
{
	if (position != NULL) {
		globs::legoGlobs.flags2 = globs::legoGlobs.flags2 | GAME2_MENU_HASNEXT;
		globs::legoGlobs.menuNextPoint.x = position->x;
		globs::legoGlobs.menuNextPoint.y = position->y;
		return;
	}
	globs::legoGlobs.flags2 = globs::legoGlobs.flags2 & ~GAME2_MENU_HASNEXT;
	return;
}



void __cdecl lego::game::Game_SetMenuPreviousPosition(Point2F *position)
{
	if (position != NULL) {
		globs::legoGlobs.flags2 = globs::legoGlobs.flags2 | GAME2_MENU_HASPREVIOUS;
		globs::legoGlobs.menuPrevPoint.x = position->x;
		globs::legoGlobs.menuPrevPoint.y = position->y;
		return;
	}
	globs::legoGlobs.flags2 = globs::legoGlobs.flags2 & ~GAME2_MENU_HASPREVIOUS;
	return;
}



void __cdecl lego::game::Game_SetFlags2_40_And_2_unkCamera(BOOL onFlag40,BOOL onFlag2)
{
	GameFlags2 flags2;
	
	if (onFlag40 == 0) {
		flags2 = globs::legoGlobs.flags2 & ~GAME2_UNK_40;
	}
	else {
		flags2 = globs::legoGlobs.flags2 | GAME2_UNK_40;
	}
	if (onFlag2 != 0) {
		globs::legoGlobs.flags2 = flags2 | GAME2_CAMERAMOVING;
		return;
	}
	globs::legoGlobs.flags2 = flags2 & ~GAME2_CAMERAMOVING;
	return;
}



void __cdecl lego::game::Game_SetFlags2_80(BOOL state)
{
	if (state != 0) {
		globs::legoGlobs.flags2 = globs::legoGlobs.flags2 | GAME2_UNK_80;
		return;
	}
	globs::legoGlobs.flags2 = globs::legoGlobs.flags2 & ~GAME2_UNK_80;
	return;
}



void __cdecl lego::lrr::Lego_UnkObjective_CompleteSub_FUN_004262f0(void)
{
	int local_4;
	
	local_4 = 1;
	globs::textGlobs.textFlags = 0;
	nerps::funcs::NERPFunc__SetMessagePermit(&local_4);
	globs::textGlobs.float_488 = 0.0;
	front::TextWindow_Clear(globs::legoGlobs.textWnd_80);
	game::Game_SetFlags2_40_And_2_unkCamera(0,0);
	game::Game_SetFlags2_80(0);
	return;
}



void __cdecl lego::game::Game_UpdateTopdownCamera(float elapsedAbs)
{
	TutorialFlags tutFlags;
	Vector3F mouseWorldPos;
	Vector3F camWorldPos;
	Vector3F mouseCamWorldPos;
	
	if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
		tutFlags = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((tutFlags & TUTORIAL_UNK_1000) == TUTORIAL_NONE) {
			if ((((globs::legoGlobs.MouseScrollBorder <= globs::INPUT.msx) &&
					 (globs::legoGlobs.MouseScrollBorder <= globs::INPUT.msy)) &&
					(globs::INPUT.msx <= (int)(globs::mainGlobs.appWidth - globs::legoGlobs.MouseScrollBorder)
					)) && (globs::INPUT.msy <=
								 (int)(globs::mainGlobs.appHeight - globs::legoGlobs.MouseScrollBorder))) {
						// Stop camera moving if mouse isn't in the scroll indent region around the window
						// border.;
				lego::view::Camera_StopMovement(globs::legoGlobs.cameraMain);
				return;
			}
			lego::view::Camera_GetTopdownWorldPos
								(globs::legoGlobs.cameraMain,(globs::legoGlobs.level)->surfaceMap,&camWorldPos);
			Game_MainView_MouseTransform
								(globs::INPUT.msx,globs::INPUT.msy,&mouseWorldPos.x,&mouseWorldPos.y);
			mouseCamWorldPos.x = mouseWorldPos.x - camWorldPos.x;
			mouseCamWorldPos.y = mouseWorldPos.y - camWorldPos.y;
			camWorldPos.z = 0.0;
			mouseWorldPos.z = 0.0;
			mouseCamWorldPos.z = 0.0;
			lego::view::Camera_Move(globs::legoGlobs.cameraMain,&mouseCamWorldPos,elapsedAbs);
		}
	}
	return;
}



void __cdecl
lego::game::Game_unkGameLoop_FUN_00426450
					(float elapsedGame,float elapsedAbs,undefined4 param_3,undefined4 param_4,int param_5)
{
	char cVar1;
	ObjectType OVar2;
	float fVar3;
	LevelData *pLVar4;
	PointerType PVar5;
	LiveObject *pLVar6;
	ObjectStatsFlags3 OVar7;
	ObjectStatsFlags1 OVar8;
	LiveObject *pLVar9;
	LevelBlockFlags1 LVar10;
	TutorialFlags TVar11;
	float fVar12;
	LiveFlags5 LVar13;
	BOOL BVar14;
	bool bVar15;
	uint uVar16;
	uint uVar17;
	uint uVar18;
	InterfaceMenuType interfaceMenuType;
	uint uVar19;
	PointerType pointerType;
	int iVar20;
	Point2F *opt_blockPos;
	float fVar21;
	BOOL leftReleased;
	LiveObject *local_3c;
	int mouseBlockY;
	int mouseBlockX;
	BOOL rightReleased;
	int local_2c;
	int local_28;
	Point2F local_24;
	Point2F local_1c;
	Point2F local_14;
	Vector3F mouseWorldPos;
	
	pLVar4 = globs::legoGlobs.level;
	globs::legoGlobs.flags2 &= ~GAME2_MOUSE_INSIDEGAMEVIEW;
	BVar14 = 0;
	local_3c = NULL;
	local_28 = 0;
	local_2c = 0;
	leftReleased = 0;
	rightReleased = 0;
	res::SelectPlace_Hide(globs::legoGlobs.selectPlace,TRUE);
	if ((globs::INPUT.mslb == 0) && (globs::INPUT.msrb == 0)) {
		globs::gamectrlGlobs.elapsed_15c = globs::gamectrlGlobs.elapsed_15c + elapsedGame;
	}
	else {
		globs::gamectrlGlobs.elapsed_15c = 0.0;
	}
	if (globs::gamectrlGlobs.mslb_Last_0 != 0) {
		if (globs::INPUT.mslb == 0) {
			if ((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) {
				BVar14 = 1;
				leftReleased = 1;
			}
		}
		else {
			globs::gamectrlGlobs.mslb_Last_6 = TRUE;
		}
	}
	if (globs::INPUT.mslb == 0) {
		globs::gamectrlGlobs.mslb_Last_6 = 0;
	}
	if ((globs::gamectrlGlobs.mslr_Last_0 != 0) && (globs::INPUT.msrb == 0)) {
		rightReleased = 1;
	}
	if (globs::gamectrlGlobs.mslb_Last_6 == 0) {
		globs::gamectrlGlobs.pointf_8.y = 0.0;
		globs::gamectrlGlobs.pointf_8.x = 0.0;
	}
	else {
		globs::gamectrlGlobs.pointf_8.x =
				 (float)((globs::INPUT.diffx ^ globs::INPUT.diffx >> 0x1f) - (globs::INPUT.diffx >> 0x1f)) +
				 globs::gamectrlGlobs.pointf_8.x;
		local_24.x = (float)((globs::INPUT.diffy ^ globs::INPUT.diffy >> 0x1f) -
												(globs::INPUT.diffy >> 0x1f));
		globs::gamectrlGlobs.pointf_8.y = (float)(int)local_24.x + globs::gamectrlGlobs.pointf_8.y;
	}
	front::HelpWindow_FUN_00418cd0
						(globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,globs::gamectrlGlobs.mslb_Last_0,
						 BVar14,elapsedGame);
	if ((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_STANDARD);
		globs::gamectrlGlobs.mslb_Last_0 = globs::INPUT.mslb;
		globs::gamectrlGlobs.mslr_Last_0 = globs::INPUT.msrb;
		globs::gamectrlGlobs.bool_160 = 1;
		globs::legoGlobs.flags1 = globs::legoGlobs.flags1 & ~(GAME1_DRAGGINGBOX_UNK|GAME1_UNK_200);
		return;
	}
	if (globs::gamectrlGlobs.bool_160 != 0) {
		globs::gamectrlGlobs.mslb_Last_0 = 0;
		globs::gamectrlGlobs.mslr_Last_0 = 0;
		globs::gamectrlGlobs.mslb_Last_6 = 0;
		leftReleased = 0;
		rightReleased = 0;
		globs::gamectrlGlobs.bool_160 = 0;
	}
	BVar14 = Map3D_GetIntersections
										 ((globs::legoGlobs.level)->surfaceMap,globs::legoGlobs.viewMain,
											globs::INPUT.msx,globs::INPUT.msy,(uint *)&mouseBlockX,(uint *)&mouseBlockY,
											&mouseWorldPos);
	bVar15 = BVar14 == 0;
	if (!bVar15) {
		elapsedGame = (float)(pLVar4->blocks + (pLVar4->dimensions).width * mouseBlockY + mouseBlockX);
		res::Container_SetPosition
							(globs::legoGlobs.contRootLight,NULL,mouseWorldPos.x,mouseWorldPos.y,
							 mouseWorldPos.z - 250.0);
	}
	light::LightEffects_SetDimmerMode((uint)bVar15);
	if ((globs::legoGlobs.flags1 & GAME1_UNK_8000000) != GAME1_NONE) {
		Game_UpdateTopdownCamera(elapsedAbs);
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_STANDARD);
		globs::legoGlobs.flags1 = globs::legoGlobs.flags1 & ~(GAME1_DRAGGINGBOX_UNK|GAME1_UNK_200);
		return;
	}
	PVar5 = front::Pointer_GetCurrentType();
	if (((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
		 (BVar14 = Message_IsAnyUnitsSelected(), BVar14 != 0)) {
		pointerType = POINTER_SELECTED;
	}
	else {
		pointerType = POINTER_STANDARD;
	}
	front::Pointer_SetCurrent_IfTimerFinished(pointerType);
	if (((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
		 (BVar14 = front::Panel_UnkUpdate_FUN_0045b070
												 (elapsedAbs,globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
													globs::gamectrlGlobs.mslb_Last_0,&local_2c), BVar14 != 0)) {
		Game_UpdateTopdownCamera(elapsedAbs);
		globs::legoGlobs.flags1 |= GAME1_UNK_200;
		goto LAB_00427c9c;
	}
	Game_UpdateTopdownCamera(elapsedAbs);
	if ((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) {
		BVar14 = ai::Priorities_UnkUpdate_FUN_0045d3d0
											 (globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
												globs::gamectrlGlobs.mslb_Last_0,leftReleased);
		if (BVar14 != 0) {
			globs::legoGlobs.flags1 |= GAME1_UNK_200;
			goto LAB_00427c9c;
		}
		if ((((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
				((globs::legoGlobs.flags2 & GAME2_INMENU) == GAME2_NONE)) &&
			 (BVar14 = front::Interface_DoSomethingWithRenameReplace
													 (globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
														globs::gamectrlGlobs.mslb_Last_0,leftReleased), BVar14 != 0)) {
			globs::legoGlobs.flags1 |= GAME1_UNK_200;
			goto LAB_00427c9c;
		}
		if (((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) != GAME1_NONE) ||
			 (BVar14 = front::Info_Update_FUN_0041a0d0(globs::INPUT.msx,globs::INPUT.msy,leftReleased),
			 BVar14 == 0)) goto LAB_0042682b;
		globs::legoGlobs.flags1 |= GAME1_UNK_200;
		if (leftReleased == 0) goto LAB_00427c9c;
		iVar20 = 0;
LAB_00427c94:
		Game_SetPointer_AndPlayEnumSFX(iVar20);
		goto LAB_00427c9c;
	}
LAB_0042682b:
	if (globs::legoGlobs.viewMode == VIEW_FIRSTPERSON) {
		globs::legoGlobs.flags1 |= GAME1_UNK_200;
		goto LAB_00427c9c;
	}
	if ((((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
			((globs::legoGlobs.flags1 & GAME1_RADARON) != GAME1_NONE)) &&
		 (BVar14 = RadarMap_InsideRadarScreen(pLVar4->radarMap,globs::INPUT.msx,globs::INPUT.msy),
		 BVar14 != 0)) {
		if (leftReleased != 0) {
			Game_SetPointer_AndPlayEnumSFX(0);
		}
		if ((globs::legoGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) == GAME1_NONE) {
			front::Pointer_SetCurrent_IfTimerFinished(PVar5);
		}
		goto LAB_00427c9c;
	}
	if (local_2c != 0) {
		bVar15 = false;
		if ((globs::legoGlobs.NextButtonImage != NULL) &&
			 ((globs::legoGlobs.flags2 & GAME2_UNK_40) != GAME2_NONE)) {
			fVar21 = (float)globs::INPUT.msx;
			fVar12 = (float)(globs::legoGlobs.NextButtonImage)->height;
			if ((((ushort)((ushort)(fVar21 < globs::legoGlobs.NextButtonPos.x) << 8 |
										(ushort)(fVar21 == globs::legoGlobs.NextButtonPos.x) << 0xe) == 0) &&
					(((fVar3 = (float)globs::INPUT.msy,
						(ushort)((ushort)(fVar3 < globs::legoGlobs.NextButtonPos.y) << 8 |
										(ushort)(fVar3 == globs::legoGlobs.NextButtonPos.y) << 0xe) == 0 &&
						(local_24.y = 0.0, local_24.x = (float)(globs::legoGlobs.NextButtonImage)->width,
						fVar21 < (float)(ulonglong)(globs::legoGlobs.NextButtonImage)->width +
										 globs::legoGlobs.NextButtonPos.x)) &&
					 (local_24.y = 0.0, local_24.x = fVar12,
					 fVar3 < (float)(ulonglong)(uint)fVar12 + globs::legoGlobs.NextButtonPos.y)))) &&
				 (front::ToolTip_AddFlag4(TOOLTIP_NEXTMESSAGE), leftReleased != 0)) {
				nerps::NERPsRuntime_AdvanceMessage();
				bVar15 = true;
			}
		}
		if ((globs::legoGlobs.BackButtonImage != NULL) &&
			 ((globs::legoGlobs.flags2 & GAME2_UNK_80) != GAME2_NONE)) {
			fVar21 = (float)globs::INPUT.msx;
			fVar12 = (float)(globs::legoGlobs.BackButtonImage)->height;
			if ((((ushort)((ushort)(fVar21 < globs::legoGlobs.BackButtonPos.x) << 8 |
										(ushort)(fVar21 == globs::legoGlobs.BackButtonPos.x) << 0xe) == 0) &&
					((fVar3 = (float)globs::INPUT.msy,
					 (ushort)((ushort)(fVar3 < globs::legoGlobs.BackButtonPos.y) << 8 |
									 (ushort)(fVar3 == globs::legoGlobs.BackButtonPos.y) << 0xe) == 0 &&
					 (local_24.y = 0.0, local_24.x = (float)(globs::legoGlobs.BackButtonImage)->width,
					 fVar21 < (float)(ulonglong)(globs::legoGlobs.BackButtonImage)->width +
										globs::legoGlobs.BackButtonPos.x)))) &&
				 (local_24.y = 0.0, local_24.x = fVar12,
				 fVar3 < (float)(ulonglong)(uint)fVar12 + globs::legoGlobs.BackButtonPos.y)) {
				front::ToolTip_AddFlag4(TOOLTIP_PREVIOUSMESSAGE);
				if (leftReleased == 0) goto LAB_00427c9c;
				nerps::NERPs_PlayUnkSampleIndex_IfDat_004a773c();
				bVar15 = true;
			}
		}
		if ((leftReleased == 0) || (bVar15)) goto LAB_00427c9c;
		iVar20 = 1;
		goto LAB_00427c94;
	}
	if (bVar15) goto LAB_00427c9c;
	globs::legoGlobs.vector_45c.y = mouseWorldPos.y;
	globs::legoGlobs.vector_45c.x = mouseWorldPos.x;
	globs::legoGlobs.vector_45c.z = mouseWorldPos.z;
	globs::legoGlobs.flags2 |= GAME2_MOUSE_INSIDEGAMEVIEW;
	globs::legoGlobs.s_mouseBlockPos_ef8.x = mouseBlockX;
	globs::legoGlobs.s_mouseBlockPos_ef8.y = mouseBlockY;
	if (((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) ||
		 ((globs::legoGlobs.flags3 & (GAME3_UNK_1|GAME3_PLACEBUILDING)) != GAME3_NONE)) {
		if ((globs::legoGlobs.flags3 & GAME3_PLACEBUILDING) == GAME3_NONE) {
			iVar20 = LiveManager_DoPickSphereCallbacks_MouseXY
												 (globs::INPUT.msx,globs::INPUT.msy,&local_3c);
			if (iVar20 == 0) {
				if ((globs::legoGlobs.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
					iVar20 = ((globs::legoGlobs.level)->dimensions).width;
					if ((((uint)mouseBlockX < iVar20 - 1U) &&
							((uint)mouseBlockY < ((globs::legoGlobs.level)->dimensions).height - 1U)) &&
						 ((LVar10 = (globs::legoGlobs.level)->blocks[mouseBlockY * iVar20 + mouseBlockX].flags1,
							(LVar10 & BLOCK1_WALL_UNK) != BLOCK1_NONE && ((LVar10 & BLOCK1_GROUND) == BLOCK1_NONE)
							))) {
						bVar15 = true;
					}
					else {
						bVar15 = false;
					}
					if (bVar15) {
						Level_SetPointer_FromSurfaceType((uint)*(byte *)((int)elapsedGame + 2));
					}
					goto LAB_0042797a;
				}
				if (leftReleased != 0) {
					*(int *)((int)elapsedGame + 0x28) = *(int *)((int)elapsedGame + 0x28) + 1;
				}
				if (((globs::legoGlobs.flags3 & GAME3_PICKUPOBJECT) != GAME3_NONE) ||
					 ((globs::legoGlobs.flags3 & GAME3_LOADVEHICLE) != GAME3_NONE)) {
					if ((globs::legoGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
						PVar5 = POINTER_VEHICLECANTPICKUP;
					}
					else {
						PVar5 = POINTER_LEGOMANCANTPICKUP;
					}
					goto LAB_00427972;
				}
				if (((globs::legoGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) &&
					 ((globs::legoGlobs.flags3 & GAME3_UNK_40) == GAME3_NONE)) {
					if (((globs::legoGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) &&
						 ((globs::legoGlobs.flags3 & GAME3_UNK_4) == GAME3_NONE)) {
						if ((globs::legoGlobs.flags3 & GAME3_UNK_1) == GAME3_NONE) {
							iVar20 = ((globs::legoGlobs.level)->dimensions).width;
							if (((uint)mouseBlockX < iVar20 - 1U) &&
								 ((uint)mouseBlockY < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
								LVar10 = (globs::legoGlobs.level)->blocks[mouseBlockY * iVar20 + mouseBlockX].flags1
												 & BLOCK1_SURVEYED;
							}
							else {
								LVar10 = BLOCK1_NONE;
							}
							if (LVar10 != BLOCK1_NONE) {
								iVar20 = ((globs::legoGlobs.level)->dimensions).width;
								if (((((uint)mouseBlockX < iVar20 - 1U) &&
										 ((uint)mouseBlockY < ((globs::legoGlobs.level)->dimensions).height - 1U)) &&
										(LVar10 = (globs::legoGlobs.level)->blocks[mouseBlockY * iVar20 + mouseBlockX].
															flags1, (LVar10 & BLOCK1_WALL_UNK) != BLOCK1_NONE)) &&
									 ((LVar10 & BLOCK1_GROUND) == BLOCK1_NONE)) {
									bVar15 = true;
								}
								else {
									bVar15 = false;
								}
								if ((bVar15) &&
									 (((globs::legoGlobs.level)->blocks
										 [((globs::legoGlobs.level)->dimensions).width *
											globs::legoGlobs.s_mouseBlockPos_ef8.y +
											globs::legoGlobs.s_mouseBlockPos_ef8.x].terrain == TERRAIN_IMMOVABLE ||
										((globs::legoGlobs.level)->blocks
										 [((globs::legoGlobs.level)->dimensions).width *
											globs::legoGlobs.s_mouseBlockPos_ef8.y +
											globs::legoGlobs.s_mouseBlockPos_ef8.x].terrain == TERRAIN_RECHARGESEAM)))) {
									if ((*(byte *)((int)elapsedGame + 8) & 8) == 0) {
										Level_SetPointer_FromSurfaceType((uint)*(byte *)((int)elapsedGame + 2));
									}
									if (globs::gamectrlGlobs.mslb_Last_6 == 0) {
										lrr::Lego_ShowBlockToolTip
															(&globs::legoGlobs.s_mouseBlockPos_ef8,TRUE,TRUE,FALSE);
									}
									if (leftReleased != 0) {
										Game_SetPointer_AndPlayEnumSFX(2);
									}
								}
								else {
									fVar12 = 0.0;
									elapsedAbs = 0.0;
									if ((*(byte *)((int)elapsedGame + 8) & 8) == 0) {
										Level_SetPointer_FromSurfaceType((uint)*(byte *)((int)elapsedGame + 2));
									}
									if (globs::gamectrlGlobs.mslb_Last_6 == 0) {
										lrr::Lego_ShowBlockToolTip
															(&globs::legoGlobs.s_mouseBlockPos_ef8,TRUE,TRUE,FALSE);
									}
									BVar14 = Message_IsAnyUnitsSelected();
									if (BVar14 != 0) {
										if ((globs::legoGlobs.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
											if (((*(byte *)((int)elapsedGame + 8) & 8) == 0) &&
												 (BVar14 = Level_FindSelectedUnit_BlockCheck_FUN_00431960
																						 (mouseBlockX,mouseBlockY,0), BVar14 != 0)) {
												pLVar9 = Message_GetPrimarySelectedUnit();
												if (pLVar9->objType == OBJECT_MINIFIGURE) {
													PVar5 = POINTER_LEGOMANCANTDIG;
												}
												else {
													PVar5 = POINTER_VEHICLECANTDIG;
												}
												front::Pointer_SetCurrent_IfTimerFinished(PVar5);
												front::Text_DisplayMessage(TEXT_NODRILL,0,0);
												cVar1 = *(char *)((int)elapsedGame + 2);
												if ((((cVar1 != '\x01') && (cVar1 != '\t')) && (cVar1 != '\v')) &&
													 ((*(byte *)((int)elapsedGame + 8) & 0x40) == 0)) {
													fVar12 = 1.401298e-45;
													elapsedAbs = 1.401298e-45;
													pLVar9 = Message_GetPrimarySelectedUnit();
													if (pLVar9->objType == OBJECT_MINIFIGURE) {
														PVar5 = POINTER_LEGOMANDIG;
													}
													else {
														PVar5 = POINTER_VEHICLEDIG;
													}
													front::Pointer_SetCurrent_IfTimerFinished(PVar5);
													front::Text_DisplayMessage(TEXT_DRILL,FALSE,FALSE);
													if ((leftReleased != 0) &&
														 (BVar14 = Level_BlockPointerCheck
																								 (&globs::legoGlobs.s_mouseBlockPos_ef8),
														 BVar14 == 0)) {
														ai::AITask_DoDig_AtBlockPos
																			(&globs::legoGlobs.s_mouseBlockPos_ef8,0,TRUE);
														ai::AITask_FUN_00401f40
																			(AITASK_DIG,NULL,&globs::legoGlobs.s_mouseBlockPos_ef8);
														goto LAB_004271d4;
													}
												}
											}
										}
										else {
											if ((*(char *)elapsedGame == '\x01') ||
												 (BVar14 = Level_FindSelectedUnit_BlockCheck_FUN_00431960
																						 (mouseBlockX,mouseBlockY,1), BVar14 == 0)) {
												globs::legoGlobs.bool_c8 = 0;
											}
											else {
												globs::legoGlobs.pointi_c0.y = mouseBlockY;
												fVar12 = 1.401298e-45;
												globs::legoGlobs.pointi_c0.x = mouseBlockX;
												elapsedAbs = 1.401298e-45;
												globs::legoGlobs.bool_c8 = 1;
												if ((leftReleased != 0) &&
													 (BVar14 = Level_BlockPointerCheck(&globs::legoGlobs.s_mouseBlockPos_ef8),
													 BVar14 == 0)) {
													ai::AITask_DoDig_AtBlockPos(&globs::legoGlobs.s_mouseBlockPos_ef8,1,1);
LAB_004271d4:
													elapsedAbs = 1.401298e-45;
													fVar12 = 1.401298e-45;
													Game_SetPointer_AndPlayEnumSFX(0);
													front::Interface_BackToMain();
												}
											}
										}
										if ((fVar12 == 0.0) && ((*(uint *)((int)elapsedGame + 8) & 8) != 0)) {
											if ((((globs::legoGlobs.level)->blocks
														[((globs::legoGlobs.level)->dimensions).width * mouseBlockY +
														 mouseBlockX].flags1 & BLOCK1_BUILDINGSOLID) == BLOCK1_NONE) &&
												 ((*(byte *)&(globs::legoGlobs.level)->blocks
																		 [((globs::legoGlobs.level)->dimensions).width * mouseBlockY +
																			mouseBlockX].flags2 & 4) == 0)) {
												bVar15 = false;
											}
											else {
												bVar15 = true;
											}
											if ((!bVar15) && ((*(byte *)((int)elapsedGame + 0xc) & 0x20) == 0)) {
												if ((*(uint *)((int)elapsedGame + 8) & 0x200000) == 0) {
													pLVar9 = Message_GetPrimarySelectedUnit();
													OVar8 = stats::StatsObject_GetStatsFlags1(pLVar9);
													if ((OVar8 & STATS1_CANCLEARRUBBLE) != STATS1_NONE) {
														BVar14 = 0;
														uVar16 = mouseBlockX;
														uVar17 = mouseBlockY;
														uVar18 = mouseBlockX;
														uVar19 = mouseBlockY;
														pLVar9 = Message_GetPrimarySelectedUnit();
														iVar20 = LiveObject_Routing_GetCrossTerrainType
																							 (pLVar9,uVar16,uVar17,uVar18,uVar19,BVar14);
														if (iVar20 != 0) {
															fVar12 = 1.401298e-45;
															elapsedAbs = 1.401298e-45;
															pLVar9 = Message_GetPrimarySelectedUnit();
															if (pLVar9->objType == OBJECT_MINIFIGURE) {
																PVar5 = POINTER_LEGOMANCLEAR;
															}
															else {
																PVar5 = POINTER_VEHICLECLEAR;
															}
															front::Pointer_SetCurrent_IfTimerFinished(PVar5);
															if ((leftReleased != 0) &&
																 (BVar14 = Level_BlockPointerCheck
																										 (&globs::legoGlobs.s_mouseBlockPos_ef8),
																 BVar14 == 0)) {
																Message_AddMessageAction
																					(MESSAGE_USERGOTO,0,0,
																					 &globs::legoGlobs.s_mouseBlockPos_ef8);
																ai::AITask_FUN_00401f40
																					(AITASK_CLEAR,NULL,&globs::legoGlobs.s_mouseBlockPos_ef8);
																Game_SetPointer_AndPlayEnumSFX(0);
																front::Interface_BackToMain();
															}
														}
													}
												}
												if (fVar12 != 0.0) goto LAB_0042797a;
												uVar16 = mouseBlockX;
												uVar17 = mouseBlockY;
												uVar18 = mouseBlockX;
												uVar19 = mouseBlockY;
												fVar21 = fVar12;
												pLVar9 = Message_GetPrimarySelectedUnit();
												iVar20 = LiveObject_Routing_GetCrossTerrainType
																					 (pLVar9,uVar16,uVar17,uVar18,uVar19,(BOOL)fVar21);
												if (iVar20 != 0) {
													fVar12 = 1.401298e-45;
													elapsedAbs = 1.401298e-45;
													pLVar9 = Message_GetPrimarySelectedUnit();
													if (pLVar9->objType == OBJECT_MINIFIGURE) {
														PVar5 = POINTER_LEGOMANGO;
													}
													else {
														PVar5 = POINTER_VEHICLEGO;
													}
													front::Pointer_SetCurrent_IfTimerFinished(PVar5);
													front::Text_DisplayMessage(TEXT_WALK,FALSE,FALSE);
													if ((leftReleased != 0) &&
														 (BVar14 = Level_BlockPointerCheck
																								 (&globs::legoGlobs.s_mouseBlockPos_ef8),
														 BVar14 == 0)) {
														Message_AddMessageAction
																			(MESSAGE_USERGOTO,0,0,&globs::legoGlobs.s_mouseBlockPos_ef8);
														Game_SetPointer_AndPlayEnumSFX(0);
														front::Interface_BackToMain();
													}
												}
											}
										}
									}
									if (fVar12 == 0.0) {
										if ((((globs::legoGlobs.level)->blocks
													[((globs::legoGlobs.level)->dimensions).width * mouseBlockY + mouseBlockX]
													.flags1 & BLOCK1_BUILDINGSOLID) == BLOCK1_NONE) &&
											 ((*(byte *)&(globs::legoGlobs.level)->blocks
																	 [((globs::legoGlobs.level)->dimensions).width * mouseBlockY +
																		mouseBlockX].flags2 & 4) == 0)) {
											bVar15 = false;
										}
										else {
											bVar15 = true;
										}
										if ((((!bVar15) && (cVar1 = *(char *)((int)elapsedGame + 2), cVar1 != '\x06'))
												&& (cVar1 != '\t')) && ((*(byte *)((int)elapsedGame + 0xc) & 0x20) == 0)) {
											if ((*(uint *)((int)elapsedGame + 8) & 8) != 0) {
												if (((globs::legoGlobs.level)->blocks
														 [((globs::legoGlobs.level)->dimensions).width *
															globs::legoGlobs.s_mouseBlockPos_ef8.y +
															globs::legoGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_80000000)
														!= BLOCK1_NONE) {
													fVar12 = 1.401298e-45;
													elapsedAbs = 1.401298e-45;
													if ((leftReleased != 0) &&
														 (BVar14 = Level_BlockPointerCheck
																								 (&globs::legoGlobs.s_mouseBlockPos_ef8),
														 BVar14 == 0)) {
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														Game_SetPointer_AndPlayEnumSFX(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_ERODE,&globs::legoGlobs.s_mouseBlockPos_ef8);
													}
												}
												if (((fVar12 == 0.0) && ((*(uint *)((int)elapsedGame + 8) & 0x8000) != 0))
													 && (elapsedAbs = 1.401298e-45, leftReleased != 0)) {
													Game_SetPointer_AndPlayEnumSFX(1);
												}
												if ((((*(uint *)((int)elapsedGame + 8) & 0x100000) != 0) ||
														(((globs::legoGlobs.level)->blocks
															[((globs::legoGlobs.level)->dimensions).width *
															 globs::legoGlobs.s_mouseBlockPos_ef8.y +
															 globs::legoGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_40000000)
														 != BLOCK1_NONE)) &&
													 (((globs::legoGlobs.level)->blocks
														 [((globs::legoGlobs.level)->dimensions).width *
															globs::legoGlobs.s_mouseBlockPos_ef8.y +
															globs::legoGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_BUILDINGPATH)
														== BLOCK1_NONE)) {
													if (((globs::legoGlobs.s_mouseBlockPos_ef8.x < 0) ||
															(globs::legoGlobs.s_mouseBlockPos_ef8.y < 0)) ||
														 ((iVar20 = ((globs::legoGlobs.level)->dimensions).width,
															iVar20 <= globs::legoGlobs.s_mouseBlockPos_ef8.x ||
															(((globs::legoGlobs.level)->dimensions).height <=
															 globs::legoGlobs.s_mouseBlockPos_ef8.y)))) {
														LVar10 = BLOCK1_NONE;
													}
													else {
														LVar10 = (globs::legoGlobs.level)->blocks
																		 [globs::legoGlobs.s_mouseBlockPos_ef8.y * iVar20 +
																			globs::legoGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_PATH;
													}
													if (((LVar10 == BLOCK1_NONE) &&
															(elapsedAbs = 1.401298e-45, leftReleased != 0)) &&
														 (BVar14 = Level_BlockPointerCheck
																								 (&globs::legoGlobs.s_mouseBlockPos_ef8),
														 BVar14 == 0)) {
														Game_SetPointer_AndPlayEnumSFX(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_CONSTRUCTION,
																			 &globs::legoGlobs.s_mouseBlockPos_ef8);
													}
												}
												if (elapsedAbs != 0.0) goto LAB_0042797a;
												if (((globs::legoGlobs.level)->blocks
														 [((globs::legoGlobs.level)->dimensions).width *
															globs::legoGlobs.s_mouseBlockPos_ef8.y +
															globs::legoGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_40000000)
														== BLOCK1_NONE) {
													if (((globs::legoGlobs.s_mouseBlockPos_ef8.x < 0) ||
															(globs::legoGlobs.s_mouseBlockPos_ef8.y < 0)) ||
														 ((iVar20 = ((globs::legoGlobs.level)->dimensions).width,
															iVar20 <= globs::legoGlobs.s_mouseBlockPos_ef8.x ||
															(((globs::legoGlobs.level)->dimensions).height <=
															 globs::legoGlobs.s_mouseBlockPos_ef8.y)))) {
														LVar10 = BLOCK1_NONE;
													}
													else {
														LVar10 = (globs::legoGlobs.level)->blocks
																		 [globs::legoGlobs.s_mouseBlockPos_ef8.y * iVar20 +
																			globs::legoGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_PATH;
													}
													fVar12 = elapsedAbs;
													if (LVar10 != BLOCK1_NONE) goto LAB_004275d9;
												}
												else {
LAB_004275d9:
													fVar12 = 1.401298e-45;
													if ((leftReleased != 0) &&
														 (BVar14 = Level_BlockPointerCheck
																								 (&globs::legoGlobs.s_mouseBlockPos_ef8),
														 BVar14 == 0)) {
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														Game_SetPointer_AndPlayEnumSFX(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_GROUND,&globs::legoGlobs.s_mouseBlockPos_ef8);
													}
												}
												if (fVar12 == 0.0) {
													if ((((*(uint *)((int)elapsedGame + 8) & 0x200000) != 0) &&
															(fVar12 = 1.401298e-45, leftReleased != 0)) &&
														 (BVar14 = Level_BlockPointerCheck
																								 (&globs::legoGlobs.s_mouseBlockPos_ef8),
														 BVar14 == 0)) {
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														Game_SetPointer_AndPlayEnumSFX(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_GROUND,&globs::legoGlobs.s_mouseBlockPos_ef8);
													}
													if (fVar12 == 0.0) {
														if ((((*(uint *)((int)elapsedGame + 8) & 0x200000) != 0) ||
																(fVar12 = 1.401298e-45, leftReleased == 0)) ||
															 (BVar14 = Level_BlockPointerCheck
																									 (&globs::legoGlobs.s_mouseBlockPos_ef8),
															 BVar14 != 0)) goto LAB_00427713;
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														Game_SetPointer_AndPlayEnumSFX(5);
														interfaceMenuType = INTERFACE_MENU_RUBBLE;
														goto LAB_0042770b;
													}
												}
												goto LAB_0042797a;
											}
											if (((cVar1 == '\x01') || ((*(uint *)((int)elapsedGame + 8) & 0x40) != 0)) ||
												 ((fVar12 = 1.401298e-45, leftReleased == 0 ||
													(BVar14 = Level_BlockPointerCheck(&globs::legoGlobs.s_mouseBlockPos_ef8),
													BVar14 != 0)))) goto LAB_00427713;
											Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
											Game_SetPointer_AndPlayEnumSFX(4);
											interfaceMenuType = INTERFACE_MENU_WALL;
LAB_0042770b:
											fVar12 = 1.401298e-45;
											front::Interface_OpenMenu_FUN_0041b200
																(interfaceMenuType,&globs::legoGlobs.s_mouseBlockPos_ef8);
										}
LAB_00427713:
										if (fVar12 == 0.0) goto LAB_0042771b;
									}
								}
								goto LAB_0042797a;
							}
						}
						else {
							globs::legoGlobs.flags1 |= GAME1_UNK_200;
							front::Pointer_SetCurrent_IfTimerFinished(POINTER_CANTHELP);
							front::Text_DisplayMessage(TEXT_ENCYCLOPEDIA,FALSE,FALSE);
						}
LAB_0042771b:
						if (leftReleased != 0) {
LAB_00427727:
							Game_SetPointer_AndPlayEnumSFX(1);
						}
					}
					else {
						if ((globs::legoGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) {
							PVar5 = POINTER_VEHICLECANTGO;
						}
						else {
							PVar5 = POINTER_LEGOMANCANTGO;
						}
						front::Pointer_SetCurrent_IfTimerFinished(PVar5);
						if (((*(byte *)((int)elapsedGame + 8) & 8) != 0) &&
							 (BVar14 = Message_IsAnyUnitsSelected(), BVar14 != 0)) {
							BVar14 = 0;
							uVar16 = mouseBlockX;
							uVar17 = mouseBlockY;
							uVar18 = mouseBlockX;
							uVar19 = mouseBlockY;
							pLVar9 = Message_GetPrimarySelectedUnit();
							iVar20 = LiveObject_Routing_GetCrossTerrainType
																 (pLVar9,uVar16,uVar17,uVar18,uVar19,BVar14);
							if (iVar20 != 0) {
								if ((globs::legoGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) {
									PVar5 = POINTER_VEHICLEGO;
								}
								else {
									PVar5 = POINTER_LEGOMANGO;
								}
								front::Pointer_SetCurrent_IfTimerFinished(PVar5);
								front::Text_DisplayMessage(TEXT_WALK,0,0);
								if ((leftReleased != 0) &&
									 (BVar14 = Level_BlockPointerCheck(&globs::legoGlobs.s_mouseBlockPos_ef8),
									 BVar14 == 0)) {
									Message_AddMessageAction
														(MESSAGE_USERGOTO,0,0,&globs::legoGlobs.s_mouseBlockPos_ef8);
									Game_SetPointer_AndPlayEnumSFX(0);
									front::Interface_BackToMain();
								}
							}
						}
					}
				}
				else {
					if ((globs::legoGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) {
						PVar5 = POINTER_VEHICLECANTDIG;
					}
					else {
						PVar5 = POINTER_LEGOMANCANTDIG;
					}
					front::Pointer_SetCurrent_IfTimerFinished(PVar5);
					front::Text_DisplayMessage(TEXT_NODRILL,0,0);
					if ((globs::legoGlobs.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
						if ((((((*(uint *)((int)elapsedGame + 8) & 8) == 0) &&
									(cVar1 = *(char *)((int)elapsedGame + 2), cVar1 != '\x01')) && (cVar1 != '\t')) &&
								((cVar1 != '\v' && ((*(uint *)((int)elapsedGame + 8) & 0x40) == 0)))) &&
							 ((BVar14 = Message_IsAnyUnitsSelected(), BVar14 == 0 ||
								(BVar14 = Level_FindSelectedUnit_BlockCheck_FUN_00431960(mouseBlockX,mouseBlockY,0),
								BVar14 != 0)))) {
							if ((globs::legoGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) {
								PVar5 = POINTER_VEHICLEDIG;
							}
							else {
								PVar5 = POINTER_LEGOMANDIG;
							}
							front::Pointer_SetCurrent_IfTimerFinished(PVar5);
							front::Text_DisplayMessage(TEXT_DRILL,0,0);
							if ((leftReleased != 0) &&
								 (BVar14 = Level_BlockPointerCheck(&globs::legoGlobs.s_mouseBlockPos_ef8),
								 BVar14 == 0)) {
								ai::AITask_DoDig_AtBlockPos(&globs::legoGlobs.s_mouseBlockPos_ef8,0,1);
								goto LAB_00427954;
							}
						}
					}
					else {
						if ((*(char *)elapsedGame == '\x01') ||
							 ((BVar14 = Message_IsAnyUnitsSelected(), BVar14 != 0 &&
								(BVar14 = Level_FindSelectedUnit_BlockCheck_FUN_00431960(mouseBlockX,mouseBlockY,1),
								BVar14 == 0)))) {
							globs::legoGlobs.bool_c8 = 0;
						}
						else {
							globs::legoGlobs.pointi_c0.y = mouseBlockY;
							globs::legoGlobs.pointi_c0.x = mouseBlockX;
							globs::legoGlobs.bool_c8 = 1;
							if ((leftReleased != 0) &&
								 (BVar14 = Level_BlockPointerCheck(&globs::legoGlobs.s_mouseBlockPos_ef8),
								 BVar14 == 0)) {
								ai::AITask_DoDig_AtBlockPos(&globs::legoGlobs.s_mouseBlockPos_ef8,1,1);
								Game_SetPointer_AndPlayEnumSFX(0);
								front::Interface_BackToMain();
							}
						}
					}
				}
			}
			else {
				if ((local_3c->objType == OBJECT_MINIFIGURE) && (local_3c->drivenObject != NULL)) {
					local_3c = local_3c->drivenObject;
				}
				if (local_3c->carryingThisObject != NULL) {
					local_3c = local_3c->carryingThisObject;
				}
				if (((local_3c->objType == OBJECT_VEHICLE) &&
						(BVar14 = Message_IsAnyUnitsSelected(), BVar14 != 0)) &&
					 (pLVar6 = Message_GetPrimarySelectedUnit(), pLVar9 = local_3c,
					 pLVar6->objType == OBJECT_MINIFIGURE)) {
					pLVar6 = Message_GetPrimarySelectedUnit();
					LVar13 = LIVEOBJ5_ABILITY_SAILOR;
					OVar7 = stats::StatsObject_GetStatsFlags3(pLVar9);
					if ((OVar7 & STATS3_NEEDSPILOT) == STATS3_NONE) {
						OVar8 = stats::StatsObject_GetStatsFlags1(pLVar9);
						if ((OVar8 & STATS1_CROSSLAND) != STATS1_NONE) {
							OVar8 = stats::StatsObject_GetStatsFlags1(pLVar9);
							LVar13 = (-(uint)((OVar8 & STATS1_CROSSWATER) != STATS1_NONE) & 0xfffffffd) +
											 LIVEOBJ5_ABILITY_DRIVER;
						}
					}
					else {
						LVar13 = LIVEOBJ5_ABILITY_PILOT;
					}
					if ((pLVar6->flags5 & LVar13) != LIVEOBJ5_NONE) {
						if (leftReleased == 0) {
							PVar5 = POINTER_GETIN;
							goto LAB_00427972;
						}
						ai::AITask_DoFindDriver_Target(pLVar9);
						Game_SetPointer_AndPlayEnumSFX(0);
						front::Interface_BackToMain();
					}
				}
				else {
					if (((globs::legoGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) &&
						 ((globs::legoGlobs.flags3 & GAME3_UNK_40) == GAME3_NONE)) {
						if (((globs::legoGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) &&
							 ((globs::legoGlobs.flags3 & GAME3_LOADVEHICLE) == GAME3_NONE)) {
							if (((globs::legoGlobs.flags3 & GAME3_UNK_2) != GAME3_NONE) ||
								 ((globs::legoGlobs.flags3 & GAME3_UNK_4) != GAME3_NONE)) {
								if ((globs::legoGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) {
									PVar5 = POINTER_VEHICLECANTGO;
								}
								else {
									PVar5 = POINTER_LEGOMANCANTGO;
								}
								goto LAB_00427972;
							}
							if ((globs::legoGlobs.flags3 & GAME3_UNK_1) == GAME3_NONE) {
								BVar14 = LiveObject_CheckCondition_AndIsPowered(local_3c,TRUE);
								if (BVar14 != 0) {
									front::Pointer_SetCurrent_IfTimerFinished(POINTER_SELECTED);
									if (globs::gamectrlGlobs.mslb_Last_6 == 0) {
										lrr::Lego_ShowObjectToolTip(local_3c);
									}
									if (leftReleased == 0) {
										pLVar9 = Message_GetPrimarySelectedUnit();
										if ((pLVar9 != NULL) &&
											 ((local_3c->objType == OBJECT_POWERCRYSTAL ||
												(local_3c->objType == OBJECT_ORE)))) {
											LiveObject_GetBlockPos(local_3c,(int *)&local_24,(int *)&local_24.y);
											iVar20 = LiveObject_Routing_GetCrossTerrainType
																				 (pLVar9,(int)local_24.x,(int)local_24.y,(int)local_24.x,
																					(int)local_24.y,0);
											if (iVar20 != 0) {
												if (local_3c->objType == OBJECT_ORE) {
													PVar5 = POINTER_PICKUPORE;
												}
												else {
													if (pLVar9->objType == OBJECT_MINIFIGURE) {
														PVar5 = POINTER_LEGOMANPICKUP;
													}
													else {
														if (pLVar9->objType != OBJECT_VEHICLE) goto LAB_0042797a;
														PVar5 = POINTER_VEHICLEPICKUP;
													}
												}
LAB_00427972:
												front::Pointer_SetCurrent_IfTimerFinished(PVar5);
											}
										}
									}
									else {
										TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
										if (((TVar11 & TUTORIAL_UNK_8) != TUTORIAL_NONE) ||
											 ((TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
												TVar11 != TUTORIAL_NONE && (local_3c->field_3f8 == 0)))) goto LAB_00427727;
										BVar14 = front::Interface_FUN_0041e8c0(local_3c->objType,local_3c->objIndex);
										if (((BVar14 != 0) &&
												(((local_3c->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE &&
												 ((OVar2 = local_3c->objType, OVar2 != OBJECT_VEHICLE ||
													((local_3c->flags1 & LIVEOBJ1_CLEARING) == LIVEOBJ1_NONE)))))) &&
											 (((globs::legoGlobs.flags1 & GAME1_LASERTRACKER) == GAME1_NONE ||
												((*(byte *)&local_3c->flags4 & 1) != 0)))) {
											if ((((OVar2 == OBJECT_VEHICLE) || (OVar2 == OBJECT_BUILDING)) ||
													(OVar2 == OBJECT_MINIFIGURE)) ||
												 ((OVar2 == OBJECT_ELECTRICFENCE &&
													((local_3c->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE)))) {
												Game_SetPointer_AndPlayEnumSFX(0);
												if (((param_5 == 0) &&
														(Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL), true)) ||
													 (BVar14 = Message_LiveObject_Check_IsSelected_OrFlags3_200000
																							 (local_3c,NULL), BVar14 == 0)) {
													Message_AddMessageAction(MESSAGE_SELECT,local_3c,0,NULL);
													Message_AddMessageAction(MESSAGE_REDUCESELECTION,0,0,NULL);
												}
											}
											else {
												if ((OVar2 == OBJECT_POWERCRYSTAL) || (OVar2 == OBJECT_ORE)) {
													pLVar9 = Message_GetPrimarySelectedUnit();
													if (pLVar9 != NULL) {
														LiveObject_GetBlockPos(local_3c,(int *)&local_24,(int *)&local_24.y);
														iVar20 = LiveObject_Routing_GetCrossTerrainType
																							 (pLVar9,(int)local_24.x,(int)local_24.y,
																								(int)local_24.x,(int)local_24.y,0);
														if (iVar20 != 0) {
															opt_blockPos = &local_24;
															goto LAB_00426def;
														}
													}
												}
												else {
													Game_SetPointer_AndPlayEnumSFX(1);
												}
											}
										}
									}
								}
							}
							else {
								globs::legoGlobs.flags1 |= GAME1_UNK_200;
								front::Pointer_SetCurrent_IfTimerFinished(POINTER_HELP);
								front::Text_DisplayMessage(TEXT_ENCYCLOPEDIA,FALSE,FALSE);
								if (leftReleased != 0) {
									Game_SetPointer_AndPlayEnumSFX(0);
									front::Encyclopedia_SetObject(local_3c);
								}
							}
						}
						else {
							if ((globs::legoGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
								PVar5 = POINTER_VEHICLECANTPICKUP;
							}
							else {
								PVar5 = POINTER_LEGOMANCANTPICKUP;
							}
							front::Pointer_SetCurrent_IfTimerFinished(PVar5);
							OVar2 = local_3c->objType;
							if ((((OVar2 == OBJECT_ORE) || (OVar2 == OBJECT_POWERCRYSTAL)) ||
									((OVar2 == OBJECT_ELECTRICFENCE &&
									 ((local_3c->flags2 & LIVEOBJ2_UNK_2000000) == LIVEOBJ2_NONE)))) ||
								 ((OVar2 == OBJECT_DYNAMITE &&
									((local_3c->flags3 & LIVEOBJ3_UNK_10000) == LIVEOBJ3_NONE)))) {
								BVar14 = 0;
								uVar16 = mouseBlockX;
								uVar17 = mouseBlockY;
								uVar18 = mouseBlockX;
								uVar19 = mouseBlockY;
								pLVar9 = Message_GetPrimarySelectedUnit();
								iVar20 = LiveObject_Routing_GetCrossTerrainType
																	 (pLVar9,uVar16,uVar17,uVar18,uVar19,BVar14);
								if (iVar20 != 0) {
									if (local_3c->objType == OBJECT_ORE) {
										PVar5 = POINTER_PICKUPORE;
									}
									else {
										if ((globs::legoGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
											PVar5 = POINTER_VEHICLEPICKUP;
										}
										else {
											PVar5 = POINTER_LEGOMANPICKUP;
										}
									}
									front::Pointer_SetCurrent_IfTimerFinished(PVar5);
									if (leftReleased != 0) {
										opt_blockPos = (Point2F *)&globs::legoGlobs.s_mouseBlockPos_ef8;
LAB_00426def:
										Message_AddMessageAction(MESSAGE_USERGOTO,0,0,(Point2I *)opt_blockPos);
										ai::AITask_LiveObject_FUN_004025f0(local_3c);
										ai::AITask_FUN_00401f40(AITASK_COLLECT,local_3c,NULL);
LAB_00427954:
										Game_SetPointer_AndPlayEnumSFX(0);
										front::Interface_BackToMain();
									}
								}
							}
						}
					}
					else {
						if ((globs::legoGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) {
							PVar5 = POINTER_VEHICLECANTDIG;
						}
						else {
							PVar5 = POINTER_LEGOMANCANTDIG;
						}
						front::Pointer_SetCurrent_IfTimerFinished(PVar5);
						front::Text_DisplayMessage(TEXT_NODRILL,FALSE,FALSE);
					}
				}
			}
		}
		else {
			local_1c.x = mouseWorldPos.x;
			local_1c.y = mouseWorldPos.y;
			local_28 = 1;
			BVar14 = Game_UnkBuildingPlaceDirection
												 (globs::legoGlobs.placeObjType,globs::legoGlobs.placeObjIndex,leftReleased,
													FALSE,&local_1c,mouseBlockX,mouseBlockY,TRUE,globs::legoGlobs.selectPlace)
			;
			if (BVar14 == 0) {
				globs::legoGlobs.flags3 &= ~GAME3_PLACEBUILDING;
			}
			if (leftReleased != 0) {
				*(int *)((int)elapsedGame + 0x28) = *(int *)((int)elapsedGame + 0x28) + 1;
			}
		}
	}
LAB_0042797a:
	if ((((globs::legoGlobs.flags3 & GAME3_PLACEBUILDING) == GAME3_NONE) &&
			((globs::legoGlobs.flags1 & GAME1_LASERTRACKER) == GAME1_NONE)) &&
		 (TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
		 (TVar11 & TUTORIAL_UNK_200) == TUTORIAL_NONE)) {
		if (globs::INPUT.mslb == 0) {
			if ((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) {
				globs::legoGlobs.vectorDragStartUnk_a4.x = mouseWorldPos.x;
				globs::legoGlobs.vectorDragStartUnk_a4.y = mouseWorldPos.y;
				globs::legoGlobs.vectorDragStartUnk_a4.z = mouseWorldPos.z;
			}
			else {
				local_24.x = (float)globs::INPUT.msx;
				local_24.y = (float)globs::INPUT.msy;
				TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
				if ((TVar11 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
					if (param_5 == 0) {
						Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
					}
					lego::view::Viewport_WorldToScreen
										(globs::legoGlobs.viewMain,&local_14,&globs::legoGlobs.vectorDragStartUnk_a4);
					LiveManager_DoSelection(globs::legoGlobs.viewMain,&local_14,&local_24);
					Game_SetPointer_AndPlayEnumSFX(0);
				}
			}
			globs::legoGlobs.float_b0 = (float)(ulonglong)(uint)mouseBlockX;
			local_24.x = (float)mouseBlockY;
			local_24.y = 0.0;
			globs::legoGlobs.float_b4 = (float)(ulonglong)(uint)mouseBlockY;
		}
		if (((globs::gamectrlGlobs.mslb_Last_6 != 0) &&
				((globs::legoGlobs.flags2 & GAME2_NOMULTISELECT) == GAME2_NONE)) &&
			 ((globs::legoGlobs.flags1 & GAME1_UNK_200) == GAME1_NONE)) {
			if (((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
				 (fVar12 = SQRT(globs::gamectrlGlobs.pointf_8.y * globs::gamectrlGlobs.pointf_8.y +
												globs::gamectrlGlobs.pointf_8.x * globs::gamectrlGlobs.pointf_8.x),
				 (ushort)((ushort)(fVar12 < 10.0) << 8 | (ushort)(fVar12 == 10.0) << 0xe) == 0)) {
				globs::legoGlobs.flags1 |= GAME1_DRAGGINGBOX_UNK;
			}
			globs::legoGlobs.float_b8 = (float)(ulonglong)(uint)mouseBlockX;
			local_24.x = (float)mouseBlockY;
			local_24.y = 0.0;
			globs::legoGlobs.float_bc = (float)(ulonglong)(uint)mouseBlockY;
		}
	}
	if ((globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
		lrr::Lego_HandleDebugKeys(mouseBlockX,mouseBlockY,local_3c);
	}
LAB_00427c9c:
	if (((local_28 == 0) && ((globs::legoGlobs.flags3 & GAME3_PLACEBUILDING) != GAME3_NONE)) &&
		 (BVar14 = Game_UnkBuildingPlaceDirection
												 (globs::legoGlobs.placeObjType,globs::legoGlobs.placeObjIndex,leftReleased,
													rightReleased,NULL,mouseBlockX,mouseBlockY,0,globs::legoGlobs.selectPlace)
		 , BVar14 == 0)) {
		globs::legoGlobs.flags3 &= ~GAME3_PLACEBUILDING;
	}
	if (globs::gamectrlGlobs.mslb_Last_6 == 0) {
		globs::legoGlobs.flags1 &= ~(GAME1_DRAGGINGBOX_UNK|GAME1_UNK_200);
	}
	globs::gamectrlGlobs.mslb_Last_0 = globs::INPUT.mslb;
	globs::gamectrlGlobs.mslr_Last_0 = globs::INPUT.msrb;
	return;
}



void __cdecl lego::lrr::Lego_LoadToolTipInfos(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","HealthText",0);
	globs::legoGlobs.HealthText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","EnergyText",0);
	globs::legoGlobs.EnergyText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","CrystalsText",0);
	globs::legoGlobs.CrystalsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","OreText",0);
	globs::legoGlobs.OreText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","StudsText",0);
	globs::legoGlobs.StudsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","ToolsText",0);
	globs::legoGlobs.ToolsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","CarryObjectText",0);
	globs::legoGlobs.CarryObjectText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","DrivenByText",0);
	globs::legoGlobs.DrivenByText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipInfo","OreRequiredText",0);
	globs::legoGlobs.OreRequiredText = cfg::CFG_CopyString(root,pcVar1);
	return;
}



void __cdecl lego::lrr::Lego_LoadUpgradeNames(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	int iVar3;
	uint uVar4;
	
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"UpgradeNames",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		uVar4 = 0xffffffff;
		pcVar2 = "Level";
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar2 + 1;
		} while (cVar1 != '\0');
		iVar3 = std::_strnicmp("Level",prop->key,~uVar4 - 1);
		if (iVar3 == 0) {
			uVar4 = 0xffffffff;
			pcVar2 = "Level";
			do {
				if (uVar4 == 0) break;
				uVar4 -= 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			uVar4 = std::atoi(prop->key + (~uVar4 - 1));
			if (uVar4 < 0x10) {
				pcVar2 = util::_strdup(prop->value);
				globs::legoGlobs.UpgradeNames_TABLE[uVar4] = pcVar2;
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::lrr::Lego_ShowObjectToolTip(LiveObject *liveObj)
{
	char cVar1;
	ObjectType OVar2;
	Image *image;
	char *pcVar3;
	BOOL BVar4;
	undefined4 uVar5;
	SFXType sfxType;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	Image **ppIVar10;
	byte bVar11;
	char *pcVar12;
	char *pcVar13;
	undefined4 *puVar14;
	ToolType *pTVar15;
	longlong lVar16;
	char buff2 [128];
	char buff1 [256];
	
	pcVar3 = game::LiveObject_GetName(liveObj);
	if (pcVar3 != NULL) {
		pcVar3 = game::LiveObject_GetName(liveObj);
		iVar6 = -1;
		do {
			if (iVar6 == 0) break;
			iVar6 += -1;
			cVar1 = *pcVar3;
			pcVar3 = pcVar3 + 1;
		} while (cVar1 != '\0');
		if (iVar6 != -2) {
			if (globs::gamectrlGlobs.object_164 != liveObj) {
				globs::gamectrlGlobs.object_164 = liveObj;
				return;
			}
			if ((liveObj->customName != NULL) && (*liveObj->customName == '\0')) {
				game::LiveObject_SetCustomName(liveObj,NULL);
			}
			pcVar3 = liveObj->customName;
			if (pcVar3 == NULL) {
				pcVar3 = game::LiveObject_GetName(liveObj);
			}
			uVar7 = 0xffffffff;
			do {
				pcVar12 = pcVar3;
				if (uVar7 == 0) break;
				uVar7 -= 1;
				pcVar12 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar12;
			} while (cVar1 != '\0');
			uVar7 = ~uVar7;
			puVar9 = (undefined4 *)(pcVar12 + -uVar7);
			puVar14 = (undefined4 *)buff1;
			for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
				*puVar14 = *puVar9;
				puVar9 = puVar9 + 1;
				puVar14 = puVar14 + 1;
			}
			OVar2 = liveObj->objType;
			for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
				*(undefined *)puVar14 = *(undefined *)puVar9;
				puVar9 = (undefined4 *)((int)puVar9 + 1);
				puVar14 = (undefined4 *)((int)puVar14 + 1);
			}
			if ((OVar2 == OBJECT_BUILDING) &&
				 (globs::legoGlobs.UpgradeNames_TABLE[liveObj->objLevel] != NULL)) {
				std::sprintf(buff2," (%s)",globs::legoGlobs.UpgradeNames_TABLE[liveObj->objLevel]);
				uVar7 = 0xffffffff;
				pcVar3 = buff2;
				do {
					pcVar12 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar12 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar12;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				iVar6 = -1;
				pcVar3 = buff1;
				do {
					pcVar13 = pcVar3;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar13 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar13;
				} while (cVar1 != '\0');
				puVar9 = (undefined4 *)(pcVar12 + -uVar7);
				puVar14 = (undefined4 *)(pcVar13 + -1);
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar14 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar14 = puVar14 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar14 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar14 = (undefined4 *)((int)puVar14 + 1);
				}
			}
			if (((((liveObj->flags3 & LIVEOBJ3_UNK_40000) != LIVEOBJ3_NONE) &&
					 (BVar4 = front::DamageFont_LiveObject_CheckCanShowDamage_Unk(liveObj), BVar4 != 0)) &&
					(liveObj->objType != OBJECT_MINIFIGURE)) && (liveObj->objType != OBJECT_ROCKMONSTER)) {
				if (0.0 <= liveObj->health) {
					lVar16 = __ftol((float10)liveObj->health);
					uVar5 = (undefined4)lVar16;
				}
				else {
					uVar5 = 0;
				}
				std::sprintf(buff2,"\n%s: %i",globs::legoGlobs.EnergyText,uVar5);
				uVar7 = 0xffffffff;
				pcVar3 = buff2;
				do {
					pcVar12 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar12 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar12;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				iVar6 = -1;
				pcVar3 = buff1;
				do {
					pcVar13 = pcVar3;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar13 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar13;
				} while (cVar1 != '\0');
				puVar9 = (undefined4 *)(pcVar12 + -uVar7);
				puVar14 = (undefined4 *)(pcVar13 + -1);
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar14 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar14 = puVar14 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar14 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar14 = (undefined4 *)((int)puVar14 + 1);
				}
			}
			if (((liveObj->objType == OBJECT_VEHICLE) && (liveObj->drivenObject != NULL)) &&
				 ((pcVar3 = liveObj->drivenObject->customName, pcVar3 != NULL &&
					((*pcVar3 != '\0' && (globs::legoGlobs.DrivenByText != NULL)))))) {
				std::sprintf(buff2,"\n%s: %s",globs::legoGlobs.DrivenByText,pcVar3);
				uVar7 = 0xffffffff;
				pcVar3 = buff2;
				do {
					pcVar12 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar12 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar12;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				iVar6 = -1;
				pcVar3 = buff1;
				do {
					pcVar13 = pcVar3;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar13 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar13;
				} while (cVar1 != '\0');
				puVar9 = (undefined4 *)(pcVar12 + -uVar7);
				puVar14 = (undefined4 *)(pcVar13 + -1);
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar14 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar14 = puVar14 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar14 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar14 = (undefined4 *)((int)puVar14 + 1);
				}
			}
			front::ToolTip_SetText(TOOLTIP_UNITSELECTED,buff1);
			sfxType = game::LiveObject_GetObjTtSFX(liveObj);
			front::ToolTip_SetSFX(TOOLTIP_UNITSELECTED,sfxType);
			if (liveObj->objType == OBJECT_MINIFIGURE) {
				uVar7 = 0;
				if (liveObj->numCarriedTools != 0) {
					pTVar15 = liveObj->carriedTools;
					do {
						if (globs::liveGlobs.ToolTipIcons_Tools_TABLE[*pTVar15] != NULL) {
							front::ToolTip_AddIcon
												(TOOLTIP_UNITSELECTED,globs::liveGlobs.ToolTipIcons_Tools_TABLE[*pTVar15]);
						}
						uVar7 += 1;
						pTVar15 = pTVar15 + 1;
					} while (uVar7 < liveObj->numCarriedTools);
				}
				uVar8 = stats::StatsObject_GetNumOfToolsCanCarry(liveObj);
				if (uVar7 < uVar8) {
					do {
						if (globs::liveGlobs.ToolTipIcon_Blank != NULL) {
							front::ToolTip_AddIcon(TOOLTIP_UNITSELECTED,globs::liveGlobs.ToolTipIcon_Blank);
						}
						uVar7 += 1;
						uVar8 = stats::StatsObject_GetNumOfToolsCanCarry(liveObj);
					} while (uVar7 < uVar8);
				}
				if (liveObj->flags5 != LIVEOBJ5_NONE) {
					front::ToolTip_AddIcon(TOOLTIP_UNITSELECTED,NULL);
					bVar11 = 0;
					ppIVar10 = globs::liveGlobs.ToolTipIcons_Abilities;
					do {
						image = globs::liveGlobs.ToolTipIcon_Blank;
						if ((liveObj->flags5 & 1 << (bVar11 & 0x1f)) != LIVEOBJ5_NONE) {
							image = *ppIVar10;
						}
						if (image != NULL) {
							front::ToolTip_AddIcon(TOOLTIP_UNITSELECTED,image);
						}
						ppIVar10 = ppIVar10 + 1;
						bVar11 += 1;
					} while (ppIVar10 < globs::liveGlobs.ToolTipIcons_Tools_TABLE);
				}
			}
			front::ToolTip_AddFlag4(TOOLTIP_UNITSELECTED);
		}
	}
	return;
}



void __cdecl
lego::lrr::Lego_ShowBlockToolTip
					(Point2I *mouseBlockPos,BOOL showConstruction,BOOL silent,BOOL showCavern)
{
	char cVar1;
	LevelBlockFlags1 LVar2;
	bool bVar3;
	char *pcVar4;
	int iVar5;
	int iVar6;
	int iVar7;
	int iVar8;
	int iVar9;
	int iVar10;
	char *pcVar11;
	LevelBlockFlags1 LVar12;
	uint uVar13;
	uint uVar14;
	uint uVar15;
	undefined4 *puVar16;
	char *pcVar17;
	undefined4 *puVar18;
	SurfaceType SVar19;
	char buff2 [128];
	char buff1 [128];
	LevelBlock *block;
	BlockConstruction *construct;
	
	iVar7 = mouseBlockPos->y;
	iVar8 = mouseBlockPos->x;
	block = (globs::legoGlobs.level)->blocks +
					((globs::legoGlobs.level)->dimensions).width * iVar7 + iVar8;
	if ((globs::s_ShowBlockToolTip_MousePos.x != iVar8) ||
		 (globs::s_ShowBlockToolTip_MousePos.y != iVar7)) {
		globs::s_ShowBlockToolTip_MousePos.x = mouseBlockPos->x;
		globs::s_ShowBlockToolTip_MousePos.y = mouseBlockPos->y;
		return;
	}
	LVar2 = block->flags1;
	pcVar4 = (char *)(LVar2 & BLOCK1_FOUNDATION);
	if ((((pcVar4 != NULL) &&
			 (((globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * iVar7 + iVar8].flags1 &
				BLOCK1_BUILDINGSOLID) == BLOCK1_NONE)) &&
			((*(byte *)&(globs::legoGlobs.level)->blocks
									[((globs::legoGlobs.level)->dimensions).width * iVar7 + iVar8].flags2 &
			 BLOCK2_TOOLSTORE_UNK) == 0)) && ((LVar2 & BLOCK1_BUILDINGPATH) == BLOCK1_NONE)) {
		construct = block->construct;
		uVar15 = construct->flags;
		pcVar4 = game::Object_GetName(OBJECT_BUILDING,construct->objIndex);
		uVar13 = 0xffffffff;
		do {
			pcVar11 = pcVar4;
			if (uVar13 == 0) break;
			uVar13 -= 1;
			pcVar11 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar11;
		} while (cVar1 != '\0');
		uVar13 = ~uVar13;
		puVar16 = (undefined4 *)(pcVar11 + -uVar13);
		puVar18 = (undefined4 *)buff1;
		for (uVar14 = uVar13 >> 2; uVar14 != 0; uVar14 -= 1) {
			*puVar18 = *puVar16;
			puVar16 = puVar16 + 1;
			puVar18 = puVar18 + 1;
		}
		for (uVar13 &= 3; uVar13 != 0; uVar13 -= 1) {
			*(undefined *)puVar18 = *(undefined *)puVar16;
			puVar16 = (undefined4 *)((int)puVar16 + 1);
			puVar18 = (undefined4 *)((int)puVar18 + 1);
		}
		if (showConstruction != 0) {
			iVar5 = game::Construction_FUN_00408d40(construct,OBJECT_POWERCRYSTAL,0);
			iVar6 = stats::Stats_GetCostCrystal(OBJECT_BUILDING,construct->objIndex,0);
			iVar7 = game::Construction_FUN_00408d40(construct,OBJECT_ORE,ORE_NORMAL);
			iVar8 = stats::Stats_GetCostOre(OBJECT_BUILDING,construct->objIndex,0);
			iVar9 = game::Construction_FUN_00408d40(construct,OBJECT_ORE,ORE_PROCESSED);
			iVar10 = stats::Stats_GetCostRefinedOre(OBJECT_BUILDING,construct->objIndex,0);
			if (iVar6 != 0) {
				std::sprintf(buff2,"\n%s: %i/%i",globs::legoGlobs.CrystalsText,iVar5,iVar6);
				uVar13 = 0xffffffff;
				pcVar4 = buff2;
				do {
					pcVar11 = pcVar4;
					if (uVar13 == 0) break;
					uVar13 -= 1;
					pcVar11 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar11;
				} while (cVar1 != '\0');
				uVar13 = ~uVar13;
				iVar5 = -1;
				pcVar4 = buff1;
				do {
					pcVar17 = pcVar4;
					if (iVar5 == 0) break;
					iVar5 += -1;
					pcVar17 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar17;
				} while (cVar1 != '\0');
				puVar16 = (undefined4 *)(pcVar11 + -uVar13);
				puVar18 = (undefined4 *)(pcVar17 + -1);
				for (uVar14 = uVar13 >> 2; uVar14 != 0; uVar14 -= 1) {
					*puVar18 = *puVar16;
					puVar16 = puVar16 + 1;
					puVar18 = puVar18 + 1;
				}
				for (uVar13 &= 3; uVar13 != 0; uVar13 -= 1) {
					*(undefined *)puVar18 = *(undefined *)puVar16;
					puVar16 = (undefined4 *)((int)puVar16 + 1);
					puVar18 = (undefined4 *)((int)puVar18 + 1);
				}
			}
			pcVar4 = globs::legoGlobs.OreText;
			if ((uVar15 & 8) != 0) {
				iVar7 = iVar9;
				iVar8 = iVar10;
				pcVar4 = globs::legoGlobs.StudsText;
			}
			if (iVar8 != 0) {
				std::sprintf(buff2,"\n%s: %i/%i",pcVar4,iVar7,iVar8);
				uVar15 = 0xffffffff;
				pcVar4 = buff2;
				do {
					pcVar11 = pcVar4;
					if (uVar15 == 0) break;
					uVar15 -= 1;
					pcVar11 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar11;
				} while (cVar1 != '\0');
				uVar15 = ~uVar15;
				iVar7 = -1;
				pcVar4 = buff1;
				do {
					pcVar17 = pcVar4;
					if (iVar7 == 0) break;
					iVar7 += -1;
					pcVar17 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar17;
				} while (cVar1 != '\0');
				puVar16 = (undefined4 *)(pcVar11 + -uVar15);
				puVar18 = (undefined4 *)(pcVar17 + -1);
				for (uVar13 = uVar15 >> 2; uVar13 != 0; uVar13 -= 1) {
					*puVar18 = *puVar16;
					puVar16 = puVar16 + 1;
					puVar18 = puVar18 + 1;
				}
				for (uVar15 &= 3; uVar15 != 0; uVar15 -= 1) {
					*(undefined *)puVar18 = *(undefined *)puVar16;
					puVar16 = (undefined4 *)((int)puVar16 + 1);
					puVar18 = (undefined4 *)((int)puVar18 + 1);
				}
			}
		}
		front::ToolTip_SetText(TOOLTIP_CONSTRUCTION,buff1);
		front::ToolTip_SetSFX(TOOLTIP_CONSTRUCTION,SFX_NULL);
		front::ToolTip_AddFlag4(TOOLTIP_CONSTRUCTION);
		return;
	}
	bVar3 = false;
	if ((LVar2 & BLOCK1_GROUND) == BLOCK1_NONE) {
		if (((LVar2 & BLOCK1_WALL_UNK) == BLOCK1_NONE) && ((LVar2 & BLOCK1_HIDDEN) != BLOCK1_NONE)) {
			pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_UNDISCOVERED);
			SVar19 = SURFACE_UNDISCOVERED;
		}
		else {
			if ((LVar2 & BLOCK1_REINFORCED) == BLOCK1_NONE) {
				SVar19 = (SurfaceType)block->terrain;
				goto LAB_00428649;
			}
			pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_REINFORCEMENT);
			SVar19 = SURFACE_REINFORCEMENT;
		}
	}
	else {
		if ((LVar2 & BLOCK1_UNK_80000000) == BLOCK1_NONE) {
			if ((LVar2 & BLOCK1_CLEARED_UNK) == BLOCK1_NONE) {
				pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_RUBBLE);
				pcVar11 = (char *)game::Game_GetSurfaceTypeSFX(SURFACE_RUBBLE);
				bVar3 = true;
			}
			else {
				if ((*(byte *)&block->flags2 & BLOCK2_SLUGHOLE_EXPOSED) == 0) {
					if (((iVar8 < 0) || (iVar7 < 0)) ||
						 ((iVar5 = ((globs::legoGlobs.level)->dimensions).width, iVar5 <= iVar8 ||
							(((globs::legoGlobs.level)->dimensions).height <= iVar7)))) {
						LVar12 = BLOCK1_NONE;
					}
					else {
						LVar12 = (globs::legoGlobs.level)->blocks[iVar5 * iVar7 + iVar8].flags1 & BLOCK1_PATH;
					}
					if ((LVar12 == BLOCK1_NONE) && ((LVar2 & BLOCK1_BUILDINGPATH) == BLOCK1_NONE)) {
						pcVar11 = pcVar4;
						if (((((globs::legoGlobs.level)->blocks
									 [((globs::legoGlobs.level)->dimensions).width * iVar7 + iVar8].flags1 &
									BLOCK1_BUILDINGSOLID) == BLOCK1_NONE) &&
								((*(byte *)&(globs::legoGlobs.level)->blocks
														[((globs::legoGlobs.level)->dimensions).width * iVar7 + iVar8].flags2 &
								 BLOCK2_TOOLSTORE_UNK) == 0)) && (pcVar4 == NULL)) {
							if (showCavern == 0) goto LAB_004285a8;
							pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_CAVERN);
							pcVar11 = (char *)game::Game_GetSurfaceTypeSFX(SURFACE_CAVERN);
							bVar3 = true;
						}
					}
					else {
						pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_PATH);
						pcVar11 = (char *)game::Game_GetSurfaceTypeSFX(SURFACE_PATH);
						bVar3 = true;
					}
				}
				else {
					pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_SLUGHOLE);
					pcVar11 = (char *)game::Game_GetSurfaceTypeSFX(SURFACE_SLUGHOLE);
					bVar3 = true;
				}
			}
		}
		else {
LAB_004285a8:
			pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_TUNNEL);
			pcVar11 = (char *)game::Game_GetSurfaceTypeSFX(SURFACE_TUNNEL);
			bVar3 = true;
		}
		if (block->terrain == TERRAIN_LAKE) {
			SVar19 = SURFACE_LAKE;
LAB_00428649:
			pcVar4 = game::Game_GetSurfaceTypeDescription(SVar19);
			SVar19 = (SurfaceType)block->terrain;
		}
		else {
			if (block->terrain != TERRAIN_LAVA) goto LAB_00428668;
			pcVar4 = game::Game_GetSurfaceTypeDescription(SURFACE_LAVA);
			SVar19 = (SurfaceType)block->terrain;
		}
	}
	pcVar11 = (char *)game::Game_GetSurfaceTypeSFX(SVar19);
	bVar3 = true;
LAB_00428668:
	if (bVar3) {
		front::ToolTip_SetText(TOOLTIP_MAPBLOCK,"%s",pcVar4);
		if (silent == 0) {
			pcVar11 = NULL;
		}
		front::ToolTip_SetSFX(TOOLTIP_MAPBLOCK,(SFXType)pcVar11);
		front::ToolTip_AddFlag4(TOOLTIP_MAPBLOCK);
	}
	return;
}



BOOL __cdecl lego::game::Level_BlockPointerCheck(Point2I *blockPos)
{
	int iVar1;
	int iVar2;
	int iVar3;
	TutorialFlags TVar4;
	LevelData *level;
	
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar4 != TUTORIAL_NONE) {
		TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar4 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
			TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
			if ((TVar4 & TUTORIAL_UNK_4) == TUTORIAL_NONE) {
				return TRUE;
			}
		}
	}
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar4 & TUTORIAL_UNK_2) != TUTORIAL_NONE) {
		level = lrr::Lego_GetLevel();
		iVar1 = (level->dimensions).width;
		iVar2 = blockPos->y;
		iVar3 = blockPos->x;
		level = lrr::Lego_GetLevel();
		if (level->blocks[iVar1 * iVar2 + iVar3].blockpointer == 0) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::Game_SetPointer_AndPlayEnumSFX(int unkEnum)
{
	BOOL oldSFXFlag8;
	SFXType sfxType;
	
	oldSFXFlag8 = snd::SFX_GetFlag8();
	snd::SFX_SetFlag8To_AndOptPlayQueuedInstances(FALSE,FALSE);
	switch(unkEnum) {
	case 0:
		front::Pointer_SetCurrent(POINTER_OKAY,12.5);
		sfxType = SFX_OKAY;
		break;
	case 1:
		front::Pointer_SetCurrent(POINTER_NOTOKAY,12.5);
		sfxType = SFX_NOTOKAY;
		break;
	case 2:
		front::Pointer_SetCurrent(POINTER_NOTOKAY,12.5);
		sfxType = SFX_IMMOVABLEROCK;
		break;
	case 3:
		front::Pointer_SetCurrent(POINTER_OKAY,12.5);
		sfxType = SFX_TOPPRIORITY;
		break;
	case 4:
		front::Pointer_SetCurrent(POINTER_OKAY,12.5);
		sfxType = SFX_WALL;
		break;
	case 5:
		front::Pointer_SetCurrent(POINTER_OKAY,12.5);
		sfxType = SFX_FLOOR;
		break;
	default:
		goto switchD_00428751_caseD_6;
	}
	snd::SFX_Sample_Random_Play_OrAddToQueue(sfxType,FALSE);
switchD_00428751_caseD_6:
	snd::SFX_SetFlag8To_AndOptPlayQueuedInstances(oldSFXFlag8,FALSE);
	return;
}



void __cdecl lego::lrr::Lego_HandleDebugKeys(int bx,int by,LiveObject *liveObj)
{
	LevelData *pLVar1;
	BOOL BVar2;
	LiveObject *pLVar3;
	BOOL BVar4;
	BOOL BVar5;
	BOOL BVar6;
	LiveObject *liveObj_00;
	Container_Texture *contTexture;
	LiveObject **ppLVar7;
	ObjectUpgradesData *pOVar8;
	uint uVar9;
	float in_stack_00000010;
	float dirz;
	int iVar10;
	uint local_18;
	LiveObject **local_14;
	Point2F local_10;
	Point2I mouseBlockPos;
	
	mouseBlockPos.x = bx;
	mouseBlockPos.y = by;
						// IsKeyPressed(KEY_A) (30)
						// "Creates a landslide at mousepoint."
	if (((globs::INPUT.Key_Map[30] != false) &&
			(globs::INPUT.prevKey_Map[30] != globs::INPUT.Key_Map[30])) &&
		 (game::Fallin_Block_FUN_0040f260(&mouseBlockPos,1,TRUE), liveObj != NULL)) {
		ai::AI_LiveObject_DoSlip(liveObj);
	}
						// IsKeyPressed(KEY_END) (207)
						// "Toggles power Off/On for currently selected building"
	if (((globs::INPUT.Key_Map[207] != false) &&
			(globs::INPUT.prevKey_Map[207] != globs::INPUT.Key_Map[207])) &&
		 (BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) {
		pLVar3 = game::Message_GetPrimarySelectedUnit();
		debug::StatsObject_Debug_ToggleObjectPower(pLVar3);
	}
						// IsKeyPressed(KEY_E) (18)
						//  "Makes a monster emerge from a diggable wall at mousepoint."
	if ((globs::INPUT.Key_Map[18] != false) &&
		 (globs::INPUT.prevKey_Map[18] != globs::INPUT.Key_Map[18])) {
		game::Game_TryGeneratedRockMonsterLiveObject
							((int **)(globs::legoGlobs.RockMonsterData_TABLE +
											 (globs::legoGlobs.level)->EmergeCreature),OBJECT_ROCKMONSTER,
							 (globs::legoGlobs.level)->EmergeCreature,bx,by);
	}
						// IsKeyDown(KEY_W) (17)
	if (globs::INPUT.Key_Map[17] != false) {
		debug::Level_Debug_WKey_NeedsBlockFlags1_8_FUN_004303a0(globs::legoGlobs.level,0,bx,by);
	}
						// IsKeyPressed(KEY_C) (46)
						//  "Tell selected unit to carried dynamite drop where they are and set it off."
	if (globs::INPUT.Key_Map[46] != false) {
		if ((globs::INPUT.prevKey_Map[46] != globs::INPUT.Key_Map[46]) &&
			 (BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) {
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			debug::LiveObject_Debug_DropActivateDynamite(pLVar3);
		}
						// IsKeyPressed(KEY_C) (46)
						//  "Simply calling the same debug C key function again... no idea why."
		if (((globs::INPUT.Key_Map[46] != false) &&
				(globs::INPUT.prevKey_Map[46] != globs::INPUT.Key_Map[46])) &&
			 (BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) {
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			debug::LiveObject_Debug_DropActivateDynamite(pLVar3);
		}
	}
						// IsKeyPressed(KEY_F12) (88)
						// "Disables all NERPs functions."
	if ((globs::INPUT.Key_Map[88] != false) &&
		 (globs::INPUT.prevKey_Map[88] != globs::INPUT.Key_Map[88])) {
		if ((globs::legoGlobs.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
			local_14 = NULL;
			globs::legoGlobs.flags1 |= GAME1_DEBUG_NONERPS;
			nerps::funcs::NERPFunc__SetTutorialFlags((int *)&local_14);
		}
		else {
			globs::legoGlobs.flags1 &= ~GAME1_DEBUG_NONERPS;
		}
	}
						// IsKeyPressed(KEY_F11) (87)
						// "Disables all building and vehicle prerequisites."
	if ((globs::INPUT.Key_Map[87] != false) &&
		 (globs::INPUT.prevKey_Map[87] != globs::INPUT.Key_Map[87])) {
		debug::Dependencies_Debug_SetBuildingPrerequisits(FALSE);
	}
						// IsKeyPressed(KEY_F10) (68)
						// "Inverts the direction of lighting."
	if ((globs::INPUT.Key_Map[68] != false) &&
		 (globs::INPUT.prevKey_Map[68] != globs::INPUT.Key_Map[68])) {
		globs::gamectrlGlobs.dbgF10InvertLighting =
				 ZEXT14(globs::gamectrlGlobs.dbgF10InvertLighting == 0);
		if (globs::gamectrlGlobs.dbgF10InvertLighting == 0) {
			res::Container_SetPosition
								(globs::legoGlobs.contTopSpotlight,(globs::legoGlobs.cameraMain)->cont3,200.0,140.0,
								 -130.0);
			dirz = 0.75;
		}
		else {
			res::Container_SetPosition
								(globs::legoGlobs.contTopSpotlight,(globs::legoGlobs.cameraMain)->cont3,250.0,190.0,
								 20.0);
			dirz = 0.0;
		}
		res::Container_SetOrientation
							(globs::legoGlobs.contTopSpotlight,(globs::legoGlobs.cameraMain)->cont3,-1.0,-0.8,dirz
							 ,0.0,1.0,0.0);
		light::LightEffects_InvalidatePosition();
	}
						// IsKeyPressed(KEY_F9) (67)
	if ((globs::INPUT.Key_Map[67] != false) &&
		 (globs::INPUT.prevKey_Map[67] != globs::INPUT.Key_Map[67])) {
		globs::gamectrlGlobs.dbgF9CameraEditMode = ZEXT14(globs::gamectrlGlobs.dbgF9CameraEditMode == 0)
		;
		light::LightEffects_SetDisabled(globs::gamectrlGlobs.dbgF9CameraEditMode);
	}
	BVar2 = game::Message_IsAnyUnitsSelected();
						// IsKeyPressed(KEY_FIVE) (6) || IsKeyPressed(KEY_SIX) (7) ||
						// IsKeyPressed(KEY_SEVEN) (8) || IsKeyPressed(KEY_EIGHT) (9)
						// "Change selected unit visual upgrade parts"
	if ((BVar2 != 0) &&
		 ((((((globs::INPUT.Key_Map[6] != false &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) ||
				 ((globs::INPUT.Key_Map[7] != false &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])))) ||
				((globs::INPUT.Key_Map[8] != false &&
				 (globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])))) ||
			 ((globs::INPUT.Key_Map[9] != false &&
				(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])))) &&
			(local_14 = game::Message_GetSelectedUnits2((uint *)&local_10), local_10.x != 0.0)))) {
		pLVar3 = *local_14;
		if (pLVar3->objType == OBJECT_BUILDING) {
			BVar2 = FALSE;
			iVar10 = 0;
			pOVar8 = &pLVar3->building->upgrades;
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			BVar4 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
			BVar2 = FALSE;
			iVar10 = 1;
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			BVar5 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
			BVar2 = FALSE;
			iVar10 = 2;
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			BVar6 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
			BVar2 = FALSE;
			iVar10 = 3;
			pLVar3 = game::Message_GetPrimarySelectedUnit();
			BVar2 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
		}
		else {
			if (pLVar3->objType == OBJECT_VEHICLE) {
				BVar2 = 0;
				iVar10 = 0;
				pOVar8 = &pLVar3->vehicle->upgrades;
				pLVar3 = game::Message_GetPrimarySelectedUnit();
				BVar4 = res::Vehicle_HasUpgradeLevelMask(pLVar3->vehicle,iVar10,BVar2);
				BVar2 = 0;
				iVar10 = 1;
				pLVar3 = game::Message_GetPrimarySelectedUnit();
				BVar5 = res::Vehicle_HasUpgradeLevelMask(pLVar3->vehicle,iVar10,BVar2);
				BVar2 = 0;
				iVar10 = 2;
				pLVar3 = game::Message_GetPrimarySelectedUnit();
				BVar6 = res::Vehicle_HasUpgradeLevelMask(pLVar3->vehicle,iVar10,BVar2);
				BVar2 = 0;
				iVar10 = 3;
				pLVar3 = game::Message_GetPrimarySelectedUnit();
				BVar2 = res::Vehicle_HasUpgradeLevelMask(pLVar3->vehicle,iVar10,BVar2);
			}
			else {
				pOVar8 = NULL;
				BVar2 = bx;
				BVar5 = bx;
				BVar6 = bx;
				BVar4 = bx;
			}
		}
		if (pOVar8 != NULL) {
			local_18 = pOVar8->currentLevel;
			uVar9 = local_18;
						// IsKeyPressed(KEY_FIVE) (6)
						// "Change selected unit visual upgrade parts (level bit 3)"
			if (((globs::INPUT.Key_Map[6] != false) &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) && (BVar4 != 0)) {
				uVar9 = local_18 ^ 8;
			}
						// IsKeyPressed(KEY_SIX) (7)
						// "Change selected unit visual upgrade parts (level bit 2)"
			if (((globs::INPUT.Key_Map[7] != false) &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])) && (BVar5 != 0)) {
				uVar9 ^= 4;
			}
						// IsKeyPressed(KEY_SEVEN) (8)
						// "Change selected unit visual upgrade parts (level bit 1)"
			if (((globs::INPUT.Key_Map[8] != false) &&
					(globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])) && (BVar6 != 0)) {
				uVar9 ^= 2;
			}
						// IsKeyPressed(KEY_EIGHT) (9)
						// "Change selected unit visual upgrade parts (level bit 0)"
			if (((globs::INPUT.Key_Map[9] != false) &&
					(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])) && (BVar2 != 0)) {
				uVar9 ^= 1;
			}
			if (uVar9 != local_18) {
				if ((*local_14)->objType == OBJECT_BUILDING) {
					pLVar3 = game::Message_GetPrimarySelectedUnit();
					res::Building_ChangeUpgradeParts(pLVar3->building,uVar9);
				}
				else {
					if ((*local_14)->objType == OBJECT_VEHICLE) {
						pLVar3 = game::Message_GetPrimarySelectedUnit();
						res::Vehicle_ChangeUpgradeParts(pLVar3->vehicle,uVar9);
					}
				}
			}
		}
	}
						// IsKeyPressed(KEY_BACKSPACE) (14)
	if ((globs::INPUT.Key_Map[14] != false) &&
		 (globs::INPUT.prevKey_Map[14] != globs::INPUT.Key_Map[14])) {
		ai::AITask_DoGather_Count(5);
	}
						// IsKeyPressed(KEYPAD_DELETE) (83)
						// "Destroys any walls at mousepoint, except border rock"
	if ((globs::INPUT.Key_Map[83] != false) &&
		 (globs::INPUT.prevKey_Map[83] != globs::INPUT.Key_Map[83])) {
		game::Level_DestroyWall(globs::legoGlobs.level,bx,by,0);
	}
						// IsKeyDown(KEYPAD_3) (81)
						// "Destroys connections between any walls at mousepoint, except border rock."
	if (globs::INPUT.Key_Map[81] != false) {
		game::Level_DestroyWallConnection(globs::legoGlobs.level,bx,by);
	}
						// IsKeyPressed(KEY_W) (17)
						//  "Tell selected monster to immediately carry a created boulder."
	if ((((globs::INPUT.Key_Map[17] != false) &&
			 (globs::INPUT.prevKey_Map[17] != globs::INPUT.Key_Map[17])) &&
			(BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) &&
		 (pLVar3 = game::Message_GetPrimarySelectedUnit(), pLVar1 = globs::legoGlobs.level,
		 pLVar3->objType == OBJECT_ROCKMONSTER)) {
		game::LiveObject_FUN_0044a890(pLVar3,(int *)&local_18,(int *)&local_14,1,0,0);
		liveObj_00 = game::LiveObject_Create((int **)globs::legoGlobs.contBoulder,OBJECT_BOULDER,0);
		game::LiveObject_HideAll(liveObj_00,TRUE);
		game::LiveObject_RoutingNoCarry_FUN_00447470(pLVar3,local_18,(uint)local_14,liveObj_00);
		contTexture = res::DynamicPM_SurfaceTextureGrid_GetTexture
														(pLVar1->surfTextGrid,
														 pLVar1->blocks[(pLVar1->dimensions).width * (int)local_14 + local_18].
														 texture);
		game::LiveObject_InitBoulderMesh_FUN_00440eb0(liveObj_00,contTexture);
	}
						// IsKeyPressed(KEY_N) (49)
	if (((globs::INPUT.Key_Map[49] != false) &&
			(globs::INPUT.prevKey_Map[49] != globs::INPUT.Key_Map[49])) &&
		 (BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) {
		BVar2 = FALSE;
		pLVar3 = game::Message_GetPrimarySelectedUnit();
		game::LiveObject_UnkDoRouting_FUN_00441c00(pLVar3,BVar2);
	}
						// IsKeyUp(KEY_LEFTSHIFT) (42) && IsKeyPressed(KEY_A) (30)
						// "Tells a Rock Raider to get a Sonic Blaster from Tool Store and place at mousepoint."
	if (((globs::INPUT.Key_Map[42] != false) && (globs::INPUT.Key_Map[30] != false)) &&
		 (globs::INPUT.prevKey_Map[30] != globs::INPUT.Key_Map[30])) {
		ai::AITask_DoBirdScarer_AtPosition(&mouseBlockPos);
	}
						// IsKeyPressed(KEY_B) (48)
						// "Pushes any Rock Raider or Monster at mousepoint east-northeast."
	if ((globs::INPUT.Key_Map[48] != false) &&
		 (globs::INPUT.prevKey_Map[48] != globs::INPUT.Key_Map[48])) {
		local_10.x = 2.0;
		local_10.y = 1.0;
		if (liveObj != NULL) {
			game::LiveObject_Unk_AndSetVector3B4(liveObj,&local_10,40.0);
		}
	}
						// IsKeyPressed(KEY_H) (35)
						// "Creates a spider web at mousepoint."
	if ((globs::INPUT.Key_Map[35] != false) &&
		 (globs::INPUT.prevKey_Map[35] != globs::INPUT.Key_Map[35])) {
		game::SpiderWeb_SpawnAt(bx,by);
	}
						// IsKeyPressed(KEY_F) (33)
						//  "Take 40 health points off all units selected."
	if ((((globs::INPUT.Key_Map[33] != false) &&
			 (globs::INPUT.prevKey_Map[33] != globs::INPUT.Key_Map[33])) &&
			(BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) &&
		 (uVar9 = game::Message_GetNumSelectedUnits(), uVar9 != 0)) {
		ppLVar7 = game::Message_GetSelectedUnits();
		for (; uVar9 != 0; uVar9 -= 1) {
			game::LiveObject_AddDamage2(*ppLVar7,40.0,1,in_stack_00000010);
			ppLVar7 = ppLVar7 + 1;
		}
	}
						// IsKeyPressed(KEY_H) (35)
	if (((globs::INPUT.Key_Map[35] != false) &&
			(globs::INPUT.prevKey_Map[35] != globs::INPUT.Key_Map[35])) &&
		 ((BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0 &&
			(pLVar3 = game::Message_GetPrimarySelectedUnit(), pLVar3->objType == OBJECT_BUILDING)))) {
		game::ElectricFence_FUN_0040d420(pLVar3,0,0);
	}
						// IsKeyPressed(KEY_J) (36)
	if ((globs::INPUT.Key_Map[36] != false) &&
		 (globs::INPUT.prevKey_Map[36] != globs::INPUT.Key_Map[36])) {
		BVar2 = game::ElectricFence_Block_IsFence(bx,by);
		if (BVar2 == 0) {
			game::ElectricFence_Debug_PlaceFence(bx,by);
		}
		else {
			game::ElectricFence_Debug_RemoveFence(bx,by);
		}
	}
						// IsKeyPressed(KEY_Y) (21)
						// "Triggers the CrystalFound InfoMessage."
	if ((globs::INPUT.Key_Map[21] != false) &&
		 (globs::INPUT.prevKey_Map[21] != globs::INPUT.Key_Map[21])) {
		local_10.x = 1.401298e-45;
		local_10.y = 1.401298e-45;
		front::Info_Send(INFO_CRYSTALFOUND,NULL,NULL,(Point2I *)&local_10);
	}
						// IsKeyUp(KEY_LEFTSHIFT) (42)
	if (globs::INPUT.Key_Map[42] == false) {
						// IsKeyPressed(KEY_U) (22)
						// "Ends Advisor_Anim_Point_N."
		if ((globs::INPUT.Key_Map[22] != false) &&
			 (globs::INPUT.prevKey_Map[22] != globs::INPUT.Key_Map[22])) {
			front::Advisor_ClearFlag2();
		}
	}
	else {
						// IsKeyPressed(KEY_U) (22)
						// "Begins Advisor_Anim_Point_N."
		if ((globs::INPUT.Key_Map[22] != false) &&
			 (globs::INPUT.prevKey_Map[22] != globs::INPUT.Key_Map[22])) {
			front::Panel_SetCurrentAdvisorFromButton(PANEL_RADAR,0,1);
		}
	}
						// IsKeyPressed(KEY_K) (37)
						//  "Pt.1 Registers a selected vehicle as a get-in target.""Pt.2 Tells a selected
						// minifigure to get in a registered vehicle."
	if (((globs::INPUT.Key_Map[37] != false) &&
			(globs::INPUT.prevKey_Map[37] != globs::INPUT.Key_Map[37])) &&
		 (BVar2 = game::Message_IsAnyUnitsSelected(), BVar2 != 0)) {
		pLVar3 = game::Message_GetPrimarySelectedUnit();
		if (pLVar3->objType == OBJECT_VEHICLE) {
			globs::gamectrlGlobs.dbgGetInVehicle = game::Message_GetPrimarySelectedUnit();
			return;
		}
		pLVar3 = game::Message_GetPrimarySelectedUnit();
		if ((pLVar3->objType == OBJECT_MINIFIGURE) && (globs::gamectrlGlobs.dbgGetInVehicle != NULL)) {
			pLVar3 = globs::gamectrlGlobs.dbgGetInVehicle;
			liveObj_00 = game::Message_GetPrimarySelectedUnit();
			game::LiveObject_TryFindDriver_FUN_00440690(liveObj_00,pLVar3);
		}
	}
	return;
}



void __cdecl lego::game::SurfaceMap_LevelXYCallback_FUN_00429040(int x,int y)
{
	if (((globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * y + x].flags1
			& BLOCK1_UNK_4000) != BLOCK1_NONE) {
		effect::Smoke_Hide((globs::legoGlobs.level)->blocks
											 [((globs::legoGlobs.level)->dimensions).width * y + x].smokeptr_1c,0);
	}
	return;
}



Container_Texture * __cdecl
lego::lrr::Lego_DynamicPM_GatherRockSurfaceTexture_FUN_00429090(Point2I *textCoord)
{
	Container_Texture *pCVar1;
	
	pCVar1 = res::DynamicPM_SurfaceTextureGrid_GetTexture
										 ((globs::legoGlobs.level)->surfTextGrid,
											(globs::legoGlobs.level)->blocks
											[((globs::legoGlobs.level)->dimensions).width * textCoord->y + textCoord->x].
											texture);
	return pCVar1;
}



void __cdecl lego::lrr::Lego_UnkUpdateMapsWorldUnk_FUN_004290d0(float elapsedAbs,BOOL pass2)
{
	SurfaceMap *surfMap;
	float highPolyBlocksMult;
	float10 fVar1;
	longlong lVar2;
	Vector3F local_18;
	Vector3F local_c;
	
	if (pass2 == 0) {
		if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
			res::Container_GetPosition((globs::legoGlobs.cameraMain)->cont2,NULL,&local_18);
			game::Map3D_WorldToBlockPos_NoZ
								((globs::legoGlobs.level)->surfaceMap,local_18.x,local_18.y,&pass2,
								 (int *)&elapsedAbs);
			res::Container_GetOrientation((globs::legoGlobs.cameraMain)->contCam,NULL,&local_c,NULL);
			surfMap = Lego_GetMap();
			fVar1 = game::Map3D_GetBlockSize(surfMap);
			fVar1 = fVar1 * (float10)3.0;
			local_c.x = (float)(fVar1 * (float10)local_c.x);
			local_c.y = (float)(fVar1 * (float10)local_c.y);
			local_c.z = (float)(fVar1 * (float10)local_c.z);
			local_18.x = local_c.x + local_18.x;
			local_18.y = local_c.y + local_18.y;
			local_18.z = local_c.z + local_18.z;
			game::Map3D_WorldToBlockPos_NoZ
								((globs::legoGlobs.level)->surfaceMap,local_18.x,local_18.y,&pass2,
								 (int *)&elapsedAbs);
			game::Map3D_AddCoordsInRadius_AndDoCallbacks
								((globs::legoGlobs.level)->surfaceMap,pass2,(int)elapsedAbs,8,
								 game::SurfaceMap_LevelXYCallback_FUN_00429040);
			return;
		}
		if (globs::legoGlobs.viewMode == VIEW_FIRSTPERSON) {
			pass2 = (BOOL)((globs::legoGlobs.level)->surfaceMap->BlockSize * globs::legoGlobs.FPClipBlocks
										);
			highPolyBlocksMult = (float)globs::legoGlobs.HPBlocks;
			if (((globs::legoGlobs.flags1 & GAME1_DYNAMICPM) != GAME1_NONE) && (elapsedAbs != 0.0)) {
				local_18.x = (float)globs::legoGlobs.HPBlocks;
				local_18.y = 0.0;
				lVar2 = __ftol((float10)(ulonglong)(uint)globs::legoGlobs.HPBlocks / (float10)elapsedAbs);
				highPolyBlocksMult = (float)lVar2;
			}
			unk::Lego_FPHighPolyBlocks_FUN_00433db0
								((globs::legoGlobs.cameraFP)->contCam,globs::legoGlobs.viewMain,(float)pass2,
								 highPolyBlocksMult);
			return;
		}
	}
	else {
		if (((globs::legoGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
			 ((globs::legoGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) {
			res::Container_GetPosition((globs::legoGlobs.cameraRadar)->cont2,NULL,&local_c);
			game::Map3D_WorldToBlockPos_NoZ
								((globs::legoGlobs.level)->surfaceMap,local_c.x,local_c.y,&pass2,(int *)&elapsedAbs)
			;
			game::Map3D_AddCoordsInRadius_AndDoCallbacks
								((globs::legoGlobs.level)->surfaceMap,pass2,(int)elapsedAbs,2,NULL);
		}
	}
	return;
}



void __cdecl lego::game::Level_DrawDragSelectionBox(LevelData *level)
{
	Point2F local_38;
	Point2F mousePos;
	Point2F lineList [5];
	
	if ((globs::legoGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) != GAME1_NONE) {
		mousePos.y = (float)globs::INPUT.msy;
		mousePos.x = (float)globs::INPUT.msx;
		lego::view::Viewport_WorldToScreen
							(globs::legoGlobs.viewMain,&local_38,&globs::legoGlobs.vectorDragStartUnk_a4);
		lineList[0].x = local_38.x;
		lineList[0].y = local_38.y;
		lineList[1].x = mousePos.x;
		lineList[1].y = local_38.y;
		lineList[2].x = mousePos.x;
		lineList[2].y = mousePos.y;
		lineList[3].x = local_38.x;
		lineList[3].y = mousePos.y;
		lineList[4].x = local_38.x;
		lineList[4].y = local_38.y;
		draw::Draw_LineListEx
							(lineList,lineList + 1,4,globs::legoGlobs.DragBoxRGB.red,
							 globs::legoGlobs.DragBoxRGB.green,globs::legoGlobs.DragBoxRGB.blue,
							 DRAWEFFECT_HALFTRANS);
	}
	return;
}



void __cdecl
lego::game::Game_MainView_MouseTransform(uint mouseX,uint mouseY,float *out_x,float *out_y)
{
	BOOL BVar1;
	Vector3F local_4c;
	Vector3F local_40;
	Vector3F local_34;
	Vector3F local_28;
	Vector3F local_1c;
	Vector4F local_10;
	
	local_28.x = 0.0;
	local_4c.x = (float)mouseY;
	local_4c.y = 0.0;
	local_28.y = 0.0;
	local_28.z = 0.0;
	local_34.x = 0.0;
	local_34.y = 0.0;
	local_34.z = -1.0;
	local_10.z = 0.0;
	local_10.w = 1.0;
	local_10.x = (float)(ulonglong)mouseX;
	local_10.y = (float)(ulonglong)mouseY;
	lego::view::Viewport_InverseTransform(globs::legoGlobs.viewMain,&local_40,&local_10);
	local_10.z = 1.0;
	local_10.w = 1.0;
	local_10.x = (float)(ulonglong)mouseX;
	local_10.y = (float)(ulonglong)mouseY;
	lego::view::Viewport_InverseTransform(globs::legoGlobs.viewMain,&local_4c,&local_10);
	local_4c.x = local_4c.x - local_40.x;
	local_4c.y = local_4c.y - local_40.y;
	local_4c.z = local_4c.z - local_40.z;
	BVar1 = math::Maths_RayPlaneIntersection(&local_1c,&local_40,&local_4c,&local_28,&local_34);
	if (BVar1 != 0) {
		*out_x = local_1c.x;
		*out_y = local_1c.y;
	}
	return;
}



Container * __cdecl lego::lrr::Lego_GetCurrentViewLight(void)
{
	Container *light;
	
	light = globs::legoGlobs.contFPLight;
	if (globs::legoGlobs.viewMode != VIEW_FIRSTPERSON) {
		light = globs::legoGlobs.contRootSpotlight;
	}
	return light;
}



BOOL __cdecl lego::game::LiveObject_Check_FUN_004294f0(LiveObject *liveObj)
{
	if (((globs::legoGlobs.viewMode != VIEW_FIRSTPERSON) || (liveObj != globs::legoGlobs.objectFP)) &&
		 ((liveObj->drivenObject == NULL || (liveObj->drivenObject != globs::legoGlobs.objectFP)))) {
		return 0;
	}
	return 1;
}



void __cdecl lego::lrr::Lego_SetViewMode(ViewMode viewMode,LiveObject *liveObj,int fpCameraFrame)
{
	ViewMode VVar1;
	
	VVar1 = viewMode;
	if (viewMode == VIEW_FIRSTPERSON) {
		viewMode = 1063675494;
		if (fpCameraFrame != 0) {
			viewMode = 1058642330;
		}
		lego::view::Camera_SetFPObject(globs::legoGlobs.cameraFP,liveObj,fpCameraFrame);
		debug::Water_Debug_LogContainerMesh(TRUE);
		game::Map3D_Coords_SetEmissive((globs::legoGlobs.level)->surfaceMap,TRUE);
		globs::legoGlobs.objectFP = liveObj;
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			game::LiveObject_DropCarriedObject_FUN_0043a130(liveObj,FALSE);
		}
		lego::view::Viewport_SetCamera(globs::legoGlobs.viewMain,(globs::legoGlobs.cameraFP)->contCam);
		snd::Sound3D_MakeListener((globs::legoGlobs.cameraFP)->contCam->masterFrame);
		snd::Sound3D_SetMinDistForAtten(50.0);
		lego::view::Viewport_SmoothSetField(globs::legoGlobs.viewMain,(float)viewMode);
		lego::view::Viewport_SetBackClip
							(globs::legoGlobs.viewMain,
							 (globs::legoGlobs.level)->BlockSize * globs::legoGlobs.FPClipBlocks);
		globs::legoGlobs.viewMode = VVar1;
		return;
	}
	if (viewMode == VIEW_TOPDOWN) {
		if (globs::legoGlobs.objectFP != NULL) {
			Lego_GotoInfo(globs::legoGlobs.objectFP,NULL,FALSE);
		}
		(globs::legoGlobs.cameraFP)->trackObj = NULL;
		globs::legoGlobs.objectFP = NULL;
		debug::Water_Debug_LogContainerMesh(FALSE);
		game::Map3D_Coords_SetEmissive((globs::legoGlobs.level)->surfaceMap,FALSE);
		lego::view::Viewport_SetCamera(globs::legoGlobs.viewMain,(globs::legoGlobs.cameraMain)->contCam)
		;
		snd::Sound3D_MakeListener((globs::legoGlobs.cameraMain)->contListener->masterFrame);
		snd::Sound3D_SetMinDistForAtten(globs::legoGlobs.MinDistFor3DSoundsOnTopView);
		lego::view::Viewport_SetField(globs::legoGlobs.viewMain,0.5);
		lego::view::Viewport_SetBackClip(globs::legoGlobs.viewMain,globs::legoGlobs.TVClipDist);
	}
	globs::legoGlobs.viewMode = viewMode;
	return;
}



void __cdecl lego::snd::Music_CDAudio_PlayNextCallback(void)
{
	Sound_StopCD();
	Music_PlayNext(1);
	return;
}



void __cdecl lego::snd::Music_PlayNext(BOOL isMusicOn)
{
	short sVar1;
	
	if (isMusicOn != 0) {
		sVar1 = math::Maths_Rand();
		globs::legoGlobs.flags1 |= GAME1_MUSICON;
		Sound_PlayCDTrack(((uint)(int)sVar1 % globs::legoGlobs.CDTracks - 1) +
											globs::legoGlobs.CDStartTrack,SOUND_ONCE,Music_CDAudio_PlayNextCallback);
		return;
	}
	globs::legoGlobs.flags1 &= ~GAME1_MUSICON;
	Sound_StopCD();
	Sound_Update(0);
	return;
}



void __cdecl lego::lrr::Lego_SetSoundEnabled(BOOL isSoundOn)
{
	if (isSoundOn != 0) {
		globs::legoGlobs.flags1 |= GAME1_SOUNDON;
		snd::SFX_StopAll_AndSetSoundState_IsOn(isSoundOn);
		return;
	}
	globs::legoGlobs.flags1 &= ~GAME1_SOUNDON;
	snd::SFX_StopAll_AndSetSoundState_IsOn(0);
	return;
}



int __cdecl lego::lrr::Lego_GetEmergeCreature(void)
{
	return (globs::legoGlobs.level)->EmergeCreature;
}



float10 __cdecl lego::lrr::Lego_GetObjectUpgradeTime(ObjectType objType)
{
	return (float10)(globs::legoGlobs.level)->UpgradeTimes[objType];
}



float10 __cdecl lego::lrr::Lego_GetTrainTime(void)
{
	return (float10)(globs::legoGlobs.level)->TrainTime;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::lrr::Lego_LoadLevel(char *levelName)
{
	float fVar1;
	CFGProperty *root;
	char cVar2;
	SaveData *pSVar3;
	SaveStruct_18 *saveStruct18;
	BOOL BVar4;
	int iVar5;
	LevelData *level;
	char *pcVar6;
	uint uVar7;
	BoolTri BVar8;
	float fVar9;
	LiveObject *pLVar10;
	LiveObject **ppLVar11;
	LevelData *pLVar12;
	float *pfVar13;
	uint uVar14;
	float10 fVar15;
	ColourRGBF *pCVar16;
	float *pfVar17;
	float local_1c0;
	float local_1bc;
	float local_1b8;
	char *nameEmergeCreature;
	ObjectType local_1b0;
	char *local_1ac;
	char *local_1a8;
	char *local_1a4;
	char *local_1a0;
	char *local_19c;
	char *local_198;
	char *local_194;
	char *local_190;
	char *local_18c;
	char *local_188;
	char *local_184;
	Point2F filenameObjectList;
	char *local_178;
	char *filenameIntroAVI;
	char *filenameNERPMessage;
	char *filenameNERP;
	char *filenamePTL;
	uint local_164;
	char *local_160;
	char *local_15c;
	SearchAddCryOre_c searchAddCryOre;
	LiveObject *local_12c [10];
	char local_104 [260];
	
	root = globs::legoGlobs.config;
	game::Level_DoVideo__004158c0(levelName,1);
	unk::Teleporter_RemoveAll();
	front::Front_UpdatePausedMenuSliders();
	front::HelpWindow_IfFlag4_AndParam_Clear1_Set2_Else_Clear3(FALSE);
	game::Game_DisableCryOreDrop(FALSE);
	game::LiveManager_SetFlag20(FALSE);
	pSVar3 = save::Save_GetCurrentSaveData();
	if (pSVar3 == NULL) {
		saveStruct18 = NULL;
	}
	else {
		saveStruct18 = &pSVar3->saveStruct18_1c;
	}
	save::Save_OverwriteStruct18(saveStruct18);
	BVar4 = save::ObjectRecall_IsLoaded();
	if ((BVar4 == 0) && (iVar5 = save::Save_GetSaveNumber(), iVar5 != -1)) {
		std::sprintf(local_104,"%s\\%i.osf","Saves",iVar5);
		save::ObjectRecall_LoadRROSFile(local_104);
	}
	level = (LevelData *)std::malloc(0x284);
	if (level == NULL) goto LAB_0042b198;
	pLVar12 = level;
	for (iVar5 = 0xa1; iVar5 != 0; iVar5 += -1) {
		pLVar12->levelName = NULL;
		pLVar12 = (LevelData *)&pLVar12->surfaceMap;
	}
	globs::legoGlobs.flags1 |= GAME1_LEVELSTART;
	globs::legoGlobs.level = level;
	front::Loader_display_loading_bar(levelName);
	ai::Priorities_LoadLevel(root,globs::legoGlobs.gameName,levelName);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"Seed",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"Seed",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	uVar7 = std::atoi(pcVar6);
	if (uVar7 != 0) {
		std::srand(uVar7);
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BoulderAnimation",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if ((pcVar6 == NULL) || (iVar5 = std::_stricmp(pcVar6,"Rock"), iVar5 == 0)) {
LAB_00429989:
		level->BoulderAnimation = TEXTURES_ROCK;
	}
	else {
		iVar5 = std::_stricmp(pcVar6,"Lava");
		if (iVar5 == 0) {
			level->BoulderAnimation = TEXTURES_LAVA;
		}
		else {
			iVar5 = std::_stricmp(pcVar6,"Ice");
			if (iVar5 != 0) goto LAB_00429989;
			level->BoulderAnimation = TEXTURES_ICE;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FallinMultiplier",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FallinMultiplier",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	globs::legoGlobs.FallinMultiplier = std::atoi(pcVar6);
	if (globs::legoGlobs.FallinMultiplier == 0) {
		globs::legoGlobs.FallinMultiplier = 1;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"blocksize",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"blocksize",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->BlockSize = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"digdepth",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"digdepth",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->DigDepth = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"useroof",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->UseRoof = BVar8;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"roofheight",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"roofheight",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->RoofHeight = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"roughlevel",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"roughlevel",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->RoughLevel = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"surfacemap",0);
	local_1a0 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"predugmap",0);
	local_1a8 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"terrainmap",0);
	local_194 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"blockPointersMap",0);
	local_198 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"CryOreMap",0);
	local_1ac = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeMap",0);
	local_18c = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"EmergeMap",0);
	local_184 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"AIMap",0);
	local_188 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"PathMap",0);
	local_1a4 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FallinMap",0);
	local_190 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"textureset",0);
	local_178 = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"EmergeTimeOut",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"EmergeTimeOut",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->EmergeTimeOut = (float)fVar15;
	if (fVar15 == (float10)0.0) {
		level->EmergeTimeOut = 1500.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"olistfile",0);
	filenameObjectList.x = (float)cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"elistfile",0);
	cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"selboxheight",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"selboxheight",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->SelBoxHeight = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"PTLFile",0);
	filenamePTL = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NERPFile",0);
	filenameNERP = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NERPMessageFile",0);
	filenameNERPMessage = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"EmergeCreature",0);
	nameEmergeCreature = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"SafeCaverns",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->SafeCaverns = BVar8;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"IntroAVI",0);
	filenameIntroAVI = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"StartFP",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->StartFP = (uint)(BVar8 == BOOL3_TRUE);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NoDrain",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->NoDrain = (uint)(BVar8 == BOOL3_TRUE);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"OxygenRate",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"OxygenRate",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->OxygenRate = (float)(fVar15 * (float10)0.001);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"UpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"UpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar9 = (float)(fVar15 * (float10)25.0);
	pfVar13 = level->UpgradeTimes;
	for (iVar5 = 0x14; iVar5 != 0; iVar5 += -1) {
		*pfVar13 = fVar9;
		pfVar13 = pfVar13 + 1;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"MinifigureUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"MinifigureUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar1 = (float)fVar15;
	level->UpgradeTimes[2] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[2] = fVar9;
	}
	else {
		level->UpgradeTimes[2] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"VehicleUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"VehicleUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar1 = (float)fVar15;
	level->UpgradeTimes[1] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[1] = fVar9;
	}
	else {
		level->UpgradeTimes[1] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BuildingUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BuildingUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar1 = (float)fVar15;
	level->UpgradeTimes[4] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[4] = fVar9;
	}
	else {
		level->UpgradeTimes[4] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"TrainTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"TrainTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->TrainTime = (float)(fVar15 * (float10)25.0);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NoMultiSelect",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::legoGlobs.flags2 |= GAME2_NOMULTISELECT;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NoAutoEat",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::legoGlobs.flags2 |= GAME2_NOAUTOEAT;
	}
	else {
		globs::legoGlobs.flags2 &= ~GAME2_NOAUTOEAT;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"EndGameAVI1",0);
	globs::legoGlobs.EndGameAVI1 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"EndGameAVI2",0);
	globs::legoGlobs.EndGameAVI2 = cfg::CFG_CopyString(root,pcVar6);
	if (globs::legoGlobs.RenameReplace != NULL) {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"AllowRename",0);
		BVar8 = cfg::CFG_ReadBool(root,pcVar6);
		if (BVar8 == BOOL3_TRUE) {
			globs::legoGlobs.flags2 |= GAME2_ALLOWRENAME;
		}
		else {
			globs::legoGlobs.flags2 &= ~GAME2_ALLOWRENAME;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"RecallOLObjects",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::legoGlobs.flags2 |= GAME2_RECALLOLOBJECTS;
	}
	else {
		globs::legoGlobs.flags2 &= ~GAME2_RECALLOLOBJECTS;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"GenerateSpiders",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::legoGlobs.flags2 |= GAME2_GENERATESPIDERS;
	}
	else {
		globs::legoGlobs.flags2 &= ~GAME2_GENERATESPIDERS;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"DisableToolTipSound",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::legoGlobs.flags2 |= GAME2_DISABLETOOLTIPSOUND;
	}
	else {
		globs::legoGlobs.flags2 &= ~GAME2_DISABLETOOLTIPSOUND;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"DisableEndTeleport",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	game::Objective_SetEndTeleportEnabled((uint)(BVar8 != BOOL3_TRUE));
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"DragBoxRGB",0);
	pcVar6 = cfg::CFG_CopyString(root,pcVar6);
	local_19c = pcVar6;
	if (pcVar6 != NULL) {
		iVar5 = util::Util_Tokenise(pcVar6,(char **)local_12c,":");
		if (iVar5 == 3) {
			uVar7 = 0;
			do {
				local_1b0 = std::atoi(*(char **)((int)local_12c + uVar7));
				uVar14 = uVar7 + 4;
				*(float *)((int)globs::legoGlobs.UpgradeNames_TABLE + (uVar7 - 0x2c)) =
						 (float)local_1b0 * 0.003921569;
				pcVar6 = local_19c;
				uVar7 = uVar14;
			} while (uVar14 < 0xc);
		}
		std::free(pcVar6);
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BuildingTolerance",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BuildingTolerance",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->BuildingTolerance = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BuildingMaxVariation",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"BuildingMaxVariation",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->BuildingMaxVariation = (float)fVar15;
	if (level->BuildingTolerance == 0.0) {
		level->BuildingTolerance = 4.0;
	}
	if ((float10)0.0 == fVar15) {
		level->BuildingMaxVariation = 6.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"MaxStolen",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"MaxStolen",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar9 = (float)std::atoi(pcVar6);
	level->MaxStolen = fVar9;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"Slug",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		level->Slug = 0x14;
	}
	else {
		BVar4 = game::Object_GetObjectByName(pcVar6,&local_1b0,&level->Slug,NULL);
		if (BVar4 != 0) {
			pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"SlugTime",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == NULL) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"SlugTime",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar15 = std::atof(pcVar6);
			level->SlugTime = (float)fVar15;
			if ((float)fVar15 == 0.0) {
				level->SlugTime = 60.0;
			}
			level->SlugTime = level->SlugTime * 25.0;
			pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"InitialSlugTime",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == NULL) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"InitialSlugTime",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar15 = std::atof(pcVar6);
			if ((float10)0.0 == fVar15) {
				fVar15 = (float10)60.0;
			}
			globs::legoGlobs.InitialSlugTime = (float)(fVar15 * (float10)25.0);
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"RockFallStyle",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	effect::Effect_GetRockFallStyle(pcVar6,&local_164);
	effect::Effect_SetRockFallStyle(local_164);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"noFallins",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	globs::legoGlobs.IsFallinsEnabled = ZEXT14(BVar8 != BOOL3_TRUE);
	front::Panel_Crystals_LoadRewardQuota(root,globs::legoGlobs.gameName,levelName);
	game::Object_GetObjectByName
						(nameEmergeCreature,(ObjectType *)&nameEmergeCreature,&level->EmergeCreature,NULL);
	pfVar17 = &globs::legoGlobs.FogColourRGB.blue;
	pfVar13 = &globs::legoGlobs.FogColourRGB.green;
	pCVar16 = &globs::legoGlobs.FogColourRGB;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FogColourRGB",0);
	BVar4 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar6,&pCVar16->red,pfVar13,pfVar17);
	if (BVar4 == 0) {
		globs::legoGlobs.flags1 &= ~GAME1_FOGCOLOURRGB;
	}
	else {
		pfVar17 = &globs::legoGlobs.HighFogColourRGB.blue;
		pfVar13 = &globs::legoGlobs.HighFogColourRGB.green;
		pCVar16 = &globs::legoGlobs.HighFogColourRGB;
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"HighFogColourRGB",0);
		BVar4 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar6,&pCVar16->red,pfVar13,pfVar17);
		if (BVar4 == 0) {
			globs::legoGlobs.flags1 &= ~GAME1_HIGHFOGCOLOURRGB;
		}
		else {
			globs::legoGlobs.flags1 |= GAME1_HIGHFOGCOLOURRGB;
			globs::legoGlobs.float_364 = 1.0;
			pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FogRate",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == NULL) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FogRate",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar15 = std::atof(pcVar6);
			if ((float10)0.0 == fVar15) {
				globs::legoGlobs.FogRate = 1500.0;
			}
			else {
				globs::legoGlobs.FogRate = (float)fVar15 * 25.0;
			}
		}
		res::Container_SetFogColour
							(globs::legoGlobs.FogColourRGB.red,globs::legoGlobs.FogColourRGB.green,
							 globs::legoGlobs.FogColourRGB.blue);
		res::Container_SetFogMode(D3DRMFOGMETHOD_TABLE);
		res::Container_SetFogParams
							(0.0,(globs::legoGlobs.level)->BlockSize * globs::legoGlobs.FPClipBlocks,0.0032);
		globs::legoGlobs.flags1 |= GAME1_FOGCOLOURRGB;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"nextlevel",0);
	pcVar6 = cfg::CFG_CopyString(root,pcVar6);
	level->NextLevel = pcVar6;
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"FullName",0);
	nameEmergeCreature = cfg::CFG_CopyString(root,pcVar6);
	level->FullName = nameEmergeCreature;
	if (nameEmergeCreature == NULL) {
		level->FullName = NULL;
	}
	else {
		iVar5 = -1;
		uVar7 = 0;
		pcVar6 = nameEmergeCreature;
		do {
			if (iVar5 == 0) break;
			iVar5 += -1;
			cVar2 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar2 != '\0');
		if (iVar5 != -2) {
			do {
				cVar2 = nameEmergeCreature[uVar7];
				if (cVar2 == '_') {
					cVar2 = ' ';
				}
				nameEmergeCreature[uVar7] = cVar2;
				nameEmergeCreature = level->FullName;
				uVar14 = 0xffffffff;
				uVar7 += 1;
				pcVar6 = nameEmergeCreature;
				do {
					if (uVar14 == 0) break;
					uVar14 -= 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar6 + 1;
				} while (cVar2 != '\0');
			} while (uVar7 < ~uVar14 - 1);
		}
	}
	game::Objective_Level_LoadObjectiveInfo
						(root,globs::legoGlobs.gameName,levelName,level,globs::mainGlobs.appWidth,
						 globs::mainGlobs.appHeight);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeTriggerTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeTriggerTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	local_1bc = (float)fVar15;
	if ((float10)0.0 == fVar15) {
		local_1bc = 10.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeErodeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeErodeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	local_1b8 = (float)fVar15;
	if ((float10)0.0 == fVar15) {
		local_1b8 = 5.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeLockTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"ErodeLockTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	local_1c0 = (float)fVar15;
	if ((float10)0.0 == fVar15) {
		local_1c0 = 60.0;
	}
	game::Erode_Initialise(local_1bc,local_1b8,local_1c0);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NumberOfLandSlidesTillCaveIn",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NumberOfLandSlidesTillCaveIn",0)
		;
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	iVar5 = std::atoi(pcVar6);
	if (iVar5 == 0) {
		iVar5 = 3;
	}
	game::Fallin_Initialise(iVar5);
	pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"DisableStartTeleport",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->levelName = levelName;
	level->IsStartTeleportEnabled = (uint)(BVar8 != BOOL3_TRUE);
	level->float_204 = (float)&DAT_42c80000;
	level->oxygenLevel = (float)&DAT_42c80000;
	level->numCrystals = 0;
	level->numOre = 0;
	level->field_90 = 0;
	level->field_a4 = 0;
	level->field_94 = 0;
	level->field_a8 = 0;
	level->status = LEVELSTATUS_NONE;
	globs::legoGlobs.placeDestSmallTeleporter = NULL;
	globs::legoGlobs.placeDestBigTeleporter = NULL;
	nerps::NERPsFile_LoadScriptFile(filenameNERP);
	nerps::NERPsFile_LoadMessageFile(filenameNERPMessage);
	BVar4 = game::PTL_Initialise(filenamePTL,globs::legoGlobs.gameName);
	if (BVar4 != 0) {
		local_1bc = 0.0;
		local_1c0._0_1_ = '\0';
		local_1b8 = 0.0;
		local_19c = NULL;
		local_1b0 = OBJECT_NONE;
		if ((local_1a0 != NULL) && (iVar5 = util::Util_Tokenise(local_1a0,&local_160,":"), iVar5 == 2))
		{
			std::atoi(local_15c);
		}
		if ((local_1a8 != NULL) && (iVar5 = util::Util_Tokenise(local_1a8,&local_160,":"), iVar5 == 2))
		{
			local_1b0 = std::atoi(local_15c);
		}
		if ((local_194 != NULL) && (iVar5 = util::Util_Tokenise(local_194,&local_160,":"), iVar5 == 2))
		{
			local_19c = (char *)std::atoi(local_15c);
		}
		if ((local_198 != NULL) && (iVar5 = util::Util_Tokenise(local_198,&local_160,":"), iVar5 == 2))
		{
			local_1b8 = (float)std::atoi(local_15c);
		}
		if ((local_1ac != NULL) && (iVar5 = util::Util_Tokenise(local_1ac,&local_160,":"), iVar5 == 2))
		{
			iVar5 = std::atoi(local_15c);
			local_1c0._0_1_ = (char)iVar5;
		}
		if ((local_1a4 != NULL) && (iVar5 = util::Util_Tokenise(local_1a4,&local_160,":"), iVar5 == 2))
		{
			local_1bc = (float)std::atoi(local_15c);
		}
		if ((local_190 != NULL) && (iVar5 = util::Util_Tokenise(local_190,&local_160,":"), iVar5 == 2))
		{
			std::atoi(local_15c);
		}
		pcVar6 = local_184;
		if ((local_184 != NULL) && (iVar5 = util::Util_Tokenise(local_184,&local_160,":"), iVar5 == 2))
		{
			local_1bc = (float)std::atoi(local_15c);
		}
		BVar4 = Lego_LoadMapSet(level,local_1a0,local_1a8,local_1b0,local_194,(int)local_19c,local_198,
														local_1b8,local_1ac,local_1c0._0_1_,local_18c,local_1a4,(int)local_1bc,
														local_178,pcVar6,local_188,local_190);
		if (BVar4 != 0) {
			std::free(local_1a0);
			std::free(local_1a8);
			std::free(local_194);
			std::free(local_198);
			std::free(local_1ac);
			std::free(local_18c);
			std::free(pcVar6);
			std::free(local_188);
			std::free(local_190);
			if (local_1a4 != NULL) {
				std::free(local_1a4);
			}
			game::ElectricFence_ResetAll(level);
			game::SpiderWeb_ResetAll(level);
			game::Objective_SetCompleteStatus(LEVELSTATUS_NONE);
			game::Objective_Update(globs::legoGlobs.textWnd_80,globs::legoGlobs.level,1.0,1.0);
			BVar4 = game::Game_LoadOLObjectList(level,(char *)filenameObjectList.x);
			if (BVar4 != 0) {
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"InitialCrystals",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				if (pcVar6 == NULL) {
					pcVar6 = ____EMPTYSTR__;
				}
				else {
					pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"InitialCrystals",0);
					pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				}
				searchAddCryOre.crystalCount = std::atoi(pcVar6);
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"InitialOre",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				if (pcVar6 == NULL) {
					pcVar6 = ____EMPTYSTR__;
				}
				else {
					pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"InitialOre",0);
					pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				}
				searchAddCryOre.oreCount = std::atoi(pcVar6);
				game::Search_LiveObjects_SkipIgnoreMes(game::LiveObject_Callback_AddCryOre,&searchAddCryOre)
				;
				front::Loader_display_loading_bar(NULL);
				filenameObjectList.x = 350.0;
				filenameObjectList.y = 70.0;
				Lego_PlayMovie_old(filenameIntroAVI,&filenameObjectList);
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"NoGather",0);
				BVar8 = cfg::CFG_ReadBool(root,pcVar6);
				ai::AITask_Game_SetNoGather((uint)(BVar8 == BOOL3_TRUE));
				front::Info_SetFlag4(TRUE);
				if ((level->StartFP == 0) || (globs::liveGlobs.minifigureObj_9cb8 == NULL)) {
					Lego_SetViewMode(VIEW_TOPDOWN,NULL,0);
				}
				else {
					Lego_SetViewMode(VIEW_FIRSTPERSON,globs::liveGlobs.minifigureObj_9cb8,1);
					game::Message_AddMessageAction(MESSAGE_SELECT,globs::liveGlobs.minifigureObj_9cb8,0,NULL);
					front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_FIRSTPERSON,NULL);
				}
				nerps::NERPs_InitBlockPointersTable(level);
				pcVar6 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,levelName,"Precreate",0);
				BVar8 = cfg::CFG_ReadBool(root,pcVar6);
				if (BVar8 == BOOL3_TRUE) {
					ppLVar11 = local_12c;
					iVar5 = 10;
					do {
						pLVar10 = game::LiveObject_Create
																((int **)globs::legoGlobs.MiniFigureData_TABLE,OBJECT_MINIFIGURE,0);
						*ppLVar11 = pLVar10;
						ppLVar11 = ppLVar11 + 1;
						iVar5 += -1;
					} while (iVar5 != 0);
					ppLVar11 = local_12c;
					iVar5 = 10;
					do {
						game::LiveObject_Remove(*ppLVar11);
						ppLVar11 = ppLVar11 + 1;
						iVar5 += -1;
					} while (iVar5 != 0);
				}
				return TRUE;
			}
		}
	}
	std::free(level);
LAB_0042b198:
	std::free(local_1a0);
	std::free(local_1a8);
	std::free(local_194);
	std::free(local_198);
	std::free(local_1ac);
	std::free(local_18c);
	std::free(local_184);
	front::Loader_display_loading_bar(NULL);
	globs::legoGlobs.level = NULL;
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_AddCryOre(LiveObject *liveObj,SearchAddCryOre_c *search)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		Level_AddCrystals__unusedLiveObject(liveObj,search->crystalCount);
		Level_AddOre__unusedLiveObject(liveObj,search->oreCount);
	}
	return 0;
}



BOOL __cdecl lego::game::WorldMesh_LoadPromeshGrid(LevelData *level,char *meshBaseName)
{
	ProMeshData **ppPVar1;
	ProMeshData *pPVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	int local_20c;
	char meshName_a [256];
	char meshName_b [256];
	uint width;
	uint height;
	
	height = (level->surfTextSize).height;
	width = (level->surfTextSize).width;
	ppPVar1 = (ProMeshData **)std::malloc(height * width * 4);
	level->promeshGrid = ppPVar1;
	if (ppPVar1 == NULL) {
		return 0;
	}
	if ((globs::mainGlobs.flags & CMD_REDUCEPROMESHES) == CMD_NONE) {
		uVar5 = 0;
		if (height != 0) {
			local_20c = 0;
			do {
				uVar4 = 0;
				iVar3 = local_20c;
				if (width != 0) {
					do {
						std::sprintf(meshName_a,"%s%0.1x%0.1xa",meshBaseName,uVar4,uVar5);
						std::sprintf(meshName_b,"%s%0.1x%0.1xb",meshBaseName,uVar4,uVar5);
						pPVar2 = res::DynamicPM_LoadPromesh_AB
															 (globs::legoGlobs.contRoot,meshName_a,meshName_b,level->BlockSize,
																level->surfTextGrid);
						uVar4 += 1;
						*(ProMeshData **)((int)level->promeshGrid + iVar3) = pPVar2;
						iVar3 = iVar3 + 4;
					} while (uVar4 < width);
				}
				uVar5 += 1;
				local_20c += width * 4;
			} while (uVar5 < height);
			return TRUE;
		}
	}
	else {
		for (uVar5 = height * width & 0x3fffffff; uVar5 != 0; uVar5 -= 1) {
			*ppPVar1 = NULL;
			ppPVar1 = ppPVar1 + 1;
		}
		for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
			*(undefined *)ppPVar1 = 0;
			ppPVar1 = (ProMeshData **)((int)ppPVar1 + 1);
		}
	}
	return TRUE;
}



void __cdecl lego::game::Level_Free_ProMeshGrid(LevelData *level)
{
	LevelData *pLVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	LevelData *level_00;
	int width;
	
	level_00 = level;
	pLVar1 = (LevelData *)(level->surfTextSize).height;
	width = (level->surfTextSize).width;
	if (pLVar1 != NULL) {
		iVar3 = 0;
		iVar2 = width;
		level = pLVar1;
		iVar4 = iVar3;
		do {
			for (; iVar2 != 0; iVar2 = iVar2 + -1) {
				res::DynamicPM_Free(*(ProMeshData **)((int)level_00->promeshGrid + iVar3));
				iVar3 += 4;
			}
			iVar3 = iVar4 + width * 4;
			level = (LevelData *)((int)&level[-1].IsStartTeleportEnabled + 3);
			iVar2 = width;
			iVar4 = iVar3;
		} while (level != NULL);
	}
	std::free(level_00->promeshGrid);
	level_00->promeshGrid = NULL;
	return;
}



RadarMap * __cdecl lego::lrr::Lego_GetRadarMap(void)
{
	return (globs::legoGlobs.level)->radarMap;
}



BOOL __cdecl
lego::lrr::Lego_LoadMapSet
					(LevelData *level,char *surfaceMap,char *predugMap,int predugParam,char *terrainMap,
					int terrainParam,char *blockPointersMap,int blockPointersParam,char *cryOreMap,
					char cryOreParam,char *erodeMap,char *pathMap,int pathParam,char *textureSet,
					char *emergeMap,char *aiMap,char *fallinMap)
{
	short sVar1;
	SurfaceMap *surfMap;
	RadarMap *pRVar2;
	BOOL BVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	
	surfMap = game::Map3D_LoadSurfaceMap
											(globs::legoGlobs.contRoot,surfaceMap,level->BlockSize,level->RoughLevel);
	level->surfaceMap = surfMap;
	if (surfMap != NULL) {
		pRVar2 = game::RadarMap_Create
											 (surfMap,&globs::legoGlobs.radarScreenRect,globs::legoGlobs.tvTiltOrZoom_334)
		;
		level->radarMap = pRVar2;
		game::Map3D_SetPerspectiveCorrectionAll(level->surfaceMap,TRUE);
						// It seems this entire chain of calls is redundant, as they all cause the exact same
						// effect.
		game::Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		game::Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		game::Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		game::Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		game::Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		game::Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		surfMap = level->surfaceMap;
		(level->dimensions).width = (surfMap->dimensions).width;
		(level->dimensions).height = (surfMap->dimensions).height;
		game::ElectricFence_ResetAll(level);
		game::SpiderWeb_ResetAll(level);
		if (level->UseRoof != BOOL3_FALSE) {
			game::Roof_Initialise
								(globs::legoGlobs.contRoot,(level->dimensions).width,(level->dimensions).height);
						// Roof is only visible in FirstPerson view, make sure we start with it hidden
			game::Roof_Hide(TRUE);
		}
		surfMap = (SurfaceMap *)Lego_LoadTextureSet(level,textureSet);
		if (surfMap != NULL) {
			surfMap = (SurfaceMap *)
								std::malloc((level->dimensions).height * (level->dimensions).width * 0x48);
			level->blocks = (LevelBlock *)surfMap;
			if (surfMap != NULL) {
				uVar6 = 0;
				for (uVar4 = (uint)((level->dimensions).height * (level->dimensions).width * 0x48) >> 2;
						uVar4 != 0; uVar4 -= 1) {
					(surfMap->smallDimensions).width = 0;
					surfMap = (SurfaceMap *)&(surfMap->smallDimensions).height;
				}
				for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
					*(undefined *)&(surfMap->smallDimensions).width = 0;
					surfMap = (SurfaceMap *)((int)&(surfMap->smallDimensions).width + 1);
				}
				if ((level->dimensions).height != 0) {
					do {
						uVar4 = (level->dimensions).width;
						uVar7 = 0;
						if (uVar4 != 0) {
							do {
								level->blocks[uVar6 * uVar4 + uVar7].predug = PREDUG_WALL;
								level->blocks[uVar6 * (level->dimensions).width + uVar7].texture = TEXTURE_GROUND;
								level->blocks[uVar6 * (level->dimensions).width + uVar7].terrain = TERRAIN_TUNNEL;
								level->blocks[uVar6 * (level->dimensions).width + uVar7].flags1 = BLOCK1_NONE;
								level->blocks[uVar6 * (level->dimensions).width + uVar7].field_3 = 0;
								level->blocks[uVar6 * (level->dimensions).width + uVar7].struct1c_18 = NULL;
								level->blocks[uVar6 * (level->dimensions).width + uVar7].float_14 = 0.0;
								sVar1 = math::Maths_Rand();
								iVar5 = uVar6 * (level->dimensions).width + uVar7;
								uVar7 += 1;
								level->blocks[iVar5].randomness = sVar1;
								uVar4 = (level->dimensions).width;
							} while (uVar7 < uVar4);
						}
						uVar6 += 1;
					} while (uVar6 < (uint)(level->dimensions).height);
				}
				surfMap = (SurfaceMap *)Lego_LoadPreDugMap(level,predugMap,predugParam);
				if (surfMap != NULL) {
					surfMap = (SurfaceMap *)Lego_LoadTerrainMap(level,terrainMap,terrainParam);
					if (surfMap != NULL) {
						Lego_LoadCryOreMap(level,cryOreMap,cryOreParam);
						Lego_LoadErodeMap(level,erodeMap);
						Lego_LoadPathMap(level,pathMap,pathParam);
						Lego_LoadEmergeMap(level,emergeMap);
						Lego_LoadAIMap(level,aiMap);
						Lego_LoadFallinMap(level,fallinMap);
						BVar3 = game::lego::lrr::Lego_LoadBlockPointersMap
															(level,blockPointersMap,blockPointersParam);
						if (BVar3 != 0) {
							level->hasBlockPointers = 1;
						}
						uVar4 = 0;
						if ((level->dimensions).height != 0) {
							do {
								uVar6 = 0;
								if ((level->dimensions).width != 0) {
									do {
										game::Level_BlockUpdateSurface(level,uVar6,uVar4,1);
										uVar6 += 1;
									} while (uVar6 < (uint)(level->dimensions).width);
								}
								uVar4 += 1;
							} while (uVar4 < (uint)(level->dimensions).height);
						}
						game::Map3D_UpdateAll_BlockTexturesAndVertices(level->surfaceMap);
						game::Water_Initialise(globs::legoGlobs.contRoot,level);
						surfMap = (SurfaceMap *)TRUE;
					}
				}
			}
		}
	}
	return (BOOL)surfMap;
}



void __cdecl lego::game::SurfaceMap_InitTextureCoords(SurfaceMap *surfMap)
{
	SurfaceTexture SVar1;
	uint uVar2;
	uint uVar3;
	SurfaceTexture local_68 [8];
	SurfaceTexture local_60 [8];
	SurfaceTexture local_58 [8];
	SurfaceTexture local_50 [8];
	SurfaceTexture local_48 [8];
	SurfaceTexture local_40 [8];
	SurfaceTexture local_38 [8];
	SurfaceTexture local_30 [16];
	SurfaceTexture local_20 [32];
	
	local_38[0] = TEXTURE_TUNNEL;
	local_38[1] = TEXTURE_TUNNEL;
	local_38[2] = TEXTURE_TUNNEL;
	local_38[3] = TEXTURE_TUNNEL;
	local_38[4] = TEXTURE_TUNNEL;
	local_38[5] = TEXTURE_TUNNEL;
	local_30[4] = TEXTURE_WALL_F_SOIL;
	local_30[5] = TEXTURE_WALL_F_ORESEAM;
	local_30[6] = TEXTURE_WALL_F_CRYSTALSEAM;
	local_30[7] = TEXTURE_WALL_F_RECHARGESEAM;
	local_30[12] = TEXTURE_WALL_F_SOIL;
	local_30[13] = TEXTURE_WALL_F_ORESEAM;
	local_30[14] = TEXTURE_WALL_F_CRYSTALSEAM;
	local_30[15] = TEXTURE_WALL_F_RECHARGESEAM;
	local_20[0] = TEXTURE_GROUND;
	local_20[1] = TEXTURE_GROUND;
	local_20[2] = TEXTURE_GROUND;
	local_20[3] = TEXTURE_GROUND;
	local_20[4] = TEXTURE_LAVA;
	local_20[5] = TEXTURE_LAVA_NOTHOT;
	local_20[6] = TEXTURE_WATER;
	local_20[7] = TEXTURE_GROUND;
	local_20[8] = TEXTURE_FOUNDATION;
	local_20[9] = TEXTURE_FOUNDATION_POWERED;
	local_20[10] = TEXTURE_RUBBLE_FULL;
	local_20[11] = TEXTURE_RUBBLE_HIGH;
	local_20[12] = TEXTURE_RUBBLE_MEDIUM;
	local_20[13] = TEXTURE_RUBBLE_LOW;
	local_20[14] = TEXTURE_ERODE_LOW;
	local_20[15] = TEXTURE_ERODE_MEDIUM;
	local_20[16] = TEXTURE_ERODE_HIGH;
	local_20[17] = TEXTURE_ERODE_FULL;
	local_20[18] = TEXTURE_07;
	local_20[19] = TEXTURE_PATH_BUILD;
	local_20[20] = TEXTURE_PATH_4;
	local_20[21] = TEXTURE_PATH_2;
	local_20[22] = TEXTURE_PATH_C;
	local_20[23] = TEXTURE_PATH_3;
	local_20[24] = TEXTURE_PATH_1;
	local_20[25] = TEXTURE_PATH_4_POWERED;
	local_20[26] = TEXTURE_PATH_2_POWERED;
	local_20[27] = TEXTURE_PATH_C_POWERED;
	local_20[28] = TEXTURE_PATH_3_POWERED;
	local_20[29] = TEXTURE_PATH_1_POWERED;
	local_20[30] = TEXTURE_SLUGHOLE;
	local_30[0] = TEXTURE_WALL_F_IMMOVABLE;
	local_30[1] = TEXTURE_WALL_F_HARD;
	local_30[2] = TEXTURE_WALL_F_MEDIUM;
	local_30[3] = TEXTURE_WALL_F_LOOSE;
	local_30[8] = TEXTURE_WALL_F_IMMOVABLE;
	local_30[9] = TEXTURE_WALL_F_HARD;
	local_30[10] = TEXTURE_WALL_F_MEDIUM;
	local_30[11] = TEXTURE_WALL_F_LOOSE;
	local_68[0] = TEXTURE_WALL_R_IMMOVABLE;
	local_68[1] = TEXTURE_WALL_R_HARD;
	local_68[2] = TEXTURE_WALL_R_MEDIUM;
	local_68[3] = TEXTURE_WALL_R_LOOSE;
	local_68[4] = TEXTURE_WALL_R_SOIL;
	local_60[0] = TEXTURE_WALL_C_IMMOVABLE;
	local_60[1] = TEXTURE_WALL_C_HARD;
	local_60[2] = TEXTURE_WALL_C_MEDIUM;
	local_60[3] = TEXTURE_WALL_C_LOOSE;
	local_60[4] = TEXTURE_WALL_C_SOIL;
	local_58[0] = TEXTURE_WALL_C_IMMOVABLE;
	local_58[1] = TEXTURE_WALL_C_HARD;
	local_58[2] = TEXTURE_WALL_C_MEDIUM;
	local_58[3] = TEXTURE_WALL_C_LOOSE;
	local_58[4] = TEXTURE_WALL_C_SOIL;
	local_50[4] = TEXTURE_WALL_O_SOIL;
	local_48[4] = TEXTURE_WALL_O_SOIL;
	local_50[0] = TEXTURE_WALL_O_IMMOVABLE;
	local_50[1] = TEXTURE_WALL_O_HARD;
	local_50[2] = TEXTURE_WALL_O_MEDIUM;
	local_50[3] = TEXTURE_WALL_O_LOOSE;
	local_48[0] = TEXTURE_WALL_O_IMMOVABLE;
	local_48[1] = TEXTURE_WALL_O_HARD;
	local_48[2] = TEXTURE_WALL_O_MEDIUM;
	local_48[3] = TEXTURE_WALL_O_LOOSE;
	local_40[0] = TEXTURE_WALL_GAP;
	local_40[1] = TEXTURE_WALL_GAP;
	local_40[2] = TEXTURE_WALL_GAP;
	local_40[3] = TEXTURE_WALL_GAP;
	local_40[4] = TEXTURE_WALL_GAP;
	uVar2 = 0;
	do {
		SVar1 = local_20[uVar2];
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_30[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 0x10);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_68[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_60[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_58[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_50[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_48[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_40[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar2 += 1;
	} while (uVar2 < 0x1f);
	uVar2 = 0;
	do {
		SVar1 = local_38[uVar2];
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_30[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 0x10);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_68[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_60[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_58[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_50[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_48[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_40[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar2 += 1;
	} while (uVar2 < 6);
	return;
}



BOOL __cdecl lego::lrr::Lego_LoadTextureSet(LevelData *level,char *keyTexturePath)
{
	SurfaceMap *surfMap;
	CFGProperty *prop;
	char *pcVar1;
	int iVar2;
	int iVar3;
	char *pcVar4;
	SurfaceTextureGrid *field2c;
	BOOL BVar5;
	BOOL result;
	
	prop = globs::legoGlobs.config;
	result = 0;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"surftextwidth",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"surftextwidth",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	}
	iVar2 = std::atoi(pcVar1);
	if (iVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"surftextheight",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			pcVar1 = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"surftextheight",0);
			pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		}
		iVar3 = std::atoi(pcVar1);
		if (iVar3 != 0) {
			surfMap = level->surfaceMap;
			(level->surfTextSize).width = iVar2;
			(level->surfTextSize).height = iVar3;
			game::SurfaceMap_InitTextureCoords(surfMap);
			game::Map3D_UpdateAll_BlockTexturesAndVertices(level->surfaceMap);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"meshbasename",0);
			pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
			if (pcVar1 != NULL) {
				pcVar4 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"texturebasename",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 != NULL) {
					field2c = res::DynamicPM_LoadTextureBaseName
															(pcVar4,(level->surfTextSize).width,(level->surfTextSize).height);
					level->surfTextGrid = field2c;
					if (field2c != NULL) {
						game::Map3D_SetField_2c(level->surfaceMap,field2c);
						BVar5 = game::WorldMesh_LoadPromeshGrid(level,pcVar1);
						if (BVar5 != 0) {
							pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,keyTexturePath,"rooftexture",0);
							pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
							if (pcVar1 != NULL) {
								BVar5 = game::Roof_SetTexture(pcVar1);
								if (BVar5 != 0) {
									result = TRUE;
								}
							}
						}
					}
				}
			}
		}
	}
	return result;
}



BOOL __cdecl lego::lrr::Lego_LoadPreDugMap(LevelData *level,char *filename,int modifier)
{
	int *piVar1;
	LevelBlockFlags1 *pLVar2;
	int iVar3;
	uint uVar4;
	char *pcVar5;
	int *piVar6;
	uint uVar7;
	int iVar8;
	uint by;
	int iVar9;
	char *bx;
	uint local_58;
	uint local_54;
	Point2I local_50;
	int local_48 [5];
	undefined4 local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if ((filename != NULL) &&
		 (uVar4 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar4 != 0xffffffff)) {
		local_54 = uVar4;
		game::MapShared_GetDimensions(uVar4,(uint *)&filename,&local_58);
		if ((filename == (char *)(level->dimensions).width) && (local_58 == (level->dimensions).height))
		{
			by = 1;
			pcVar5 = filename;
			uVar7 = local_58;
			if (local_58 != 1 && local_58 != 2) {
				do {
					bx = (char *)0x1;
					if (pcVar5 != (char *)0x1 && pcVar5 != (char *)0x2) {
						do {
							uVar4 = game::MapShared_GetBlock(local_54,(int)bx,by);
							iVar9 = uVar4 - modifier;
							if ((iVar9 == 1) || (iVar9 == 3)) {
								game::Level_DestroyWall(level,(uint)bx,by,1);
								local_48[0] = -1;
								local_48[1] = 0xffffffff;
								local_48[3] = 0xffffffff;
								local_34 = 0xffffffff;
								local_18 = 0xffffffff;
								local_10 = 0xffffffff;
								local_8 = 0;
								local_48[2] = 0;
								local_48[4] = 1;
								local_30 = 1;
								local_2c = 0;
								local_28 = 1;
								local_24 = 1;
								local_20 = 0;
								local_1c = 1;
								local_14 = 1;
								local_c = 0;
								local_4 = 0;
								piVar6 = local_48;
								iVar8 = 9;
								do {
									piVar1 = piVar6 + 1;
									iVar3 = *piVar6;
									piVar6 = piVar6 + 2;
									pLVar2 = &level->blocks
														[(int)(bx + iVar3 + (*piVar1 + by) * (level->dimensions).width)].flags1;
									iVar8 += -1;
									*pLVar2 = *pLVar2 | BLOCK1_EXPOSED;
								} while (iVar8 != 0);
							}
							else {
								if ((iVar9 == 2) || (iVar9 == 4)) {
									level->blocks[(int)(bx + by * (level->dimensions).width)].flags1 =
											 level->blocks[(int)(bx + by * (level->dimensions).width)].flags1 |
											 BLOCK1_HIDDEN;
								}
							}
							if (iVar9 == 3) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 =
										 level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 |
										 BLOCK2_SLUGHOLE_EXPOSED;
								local_50.x = (int)bx;
								local_50.y = by;
								game::Level_RegisterSlimySlugHole(&local_50);
							}
							if (iVar9 == 4) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 =
										 level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 |
										 BLOCK2_SLUGHOLE_HIDDEN;
							}
							bx = bx + 1;
							pcVar5 = filename;
							uVar7 = local_58;
						} while (bx < filename + -1);
					}
					by += 1;
					uVar4 = local_54;
				} while (by < uVar7 - 1);
			}
			lego::file::Mem_FreeHandle(uVar4);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar4);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadErodeMap(LevelData *level,char *filename)
{
	bool bVar1;
	short sVar2;
	uint uVar3;
	char *pcVar4;
	uint uVar5;
	char *bx;
	uint by;
	uint local_10;
	uint local_c;
	Point2I blockPos;
	
	if ((filename != NULL) &&
		 (uVar3 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar3 != 0xffffffff)) {
		local_c = uVar3;
		game::MapShared_GetDimensions(uVar3,(uint *)&filename,&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			by = 0;
			pcVar4 = filename;
			uVar5 = local_10;
			if (local_10 != 0) {
				do {
					bx = NULL;
					if (pcVar4 != NULL) {
						do {
							blockPos.x = (int)bx;
							blockPos.y = by;
							uVar3 = game::MapShared_GetBlock(local_c,(int)bx,by);
							bVar1 = false;
							if ((uVar3 == 0) || ((uVar3 & 1) != 0)) {
								uVar3 += 1;
							}
							else {
								bVar1 = true;
							}
							level->blocks[(int)(bx + by * (level->dimensions).width)].erodeSpeed =
									 (ErodeType)(uVar3 >> 1);
							if (bVar1) {
								sVar2 = math::Maths_Rand();
								uVar3 = (int)sVar2 >> 0x1f;
								game::Erode_AddActiveBlock
													(&blockPos,(((int)sVar2 ^ uVar3) - uVar3 & 3 ^ uVar3) - uVar3);
							}
							bx = bx + 1;
							pcVar4 = filename;
							uVar5 = local_10;
						} while (bx < filename);
					}
					by += 1;
					uVar3 = local_c;
				} while (by < uVar5);
			}
			lego::file::Mem_FreeHandle(uVar3);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar3);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadAIMap(LevelData *level,char *filename)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *bx;
	uint by;
	uint local_4;
	
	if ((filename != NULL) &&
		 (sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL), sharedIndex != 0xffffffff)) {
		game::MapShared_GetDimensions(sharedIndex,(uint *)&filename,&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = game::MapShared_GetBlock(sharedIndex,(int)bx,by);
							pcVar2 = bx + by * (level->dimensions).width;
							bx = bx + 1;
							level->blocks[(int)pcVar2].aiNode = (byte)uVar1;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadEmergeMap(LevelData *level,char *filename)
{
	LevelBlockFlags2 *pLVar1;
	uint uVar2;
	uint uVar3;
	void *pvVar4;
	int iVar5;
	char *pcVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	uint local_c;
	char *local_8;
	uint local_4;
	
	if (filename != NULL) {
		uVar2 = lego::file::File_LoadBinaryHandle(filename,NULL);
		local_4 = uVar2;
		if (((uVar2 != 0xffffffff) &&
				(game::MapShared_GetDimensions(uVar2,&local_c,(uint *)&local_8),
				local_c == (level->dimensions).width)) && (local_8 == (char *)(level->dimensions).height)) {
			filename = NULL;
			uVar3 = local_c;
			pcVar6 = local_8;
			if (local_8 != NULL) {
				do {
					uVar2 = 0;
					if (uVar3 != 0) {
						do {
							uVar3 = game::MapShared_GetBlock(local_4,uVar2,(int)filename);
							if (uVar3 != 0) {
								uVar7 = (uVar3 - 1) % 6;
								uVar8 = (uVar3 - 1) / 6;
								uVar3 = uVar8 + 1;
								if (level->count_c < uVar3) {
									if (level->ptrtable_8 == NULL) {
										pvVar4 = std::malloc(uVar3 * 0x4c);
									}
									else {
										pvVar4 = std::realloc(level->ptrtable_8,uVar3 * 0x4c);
									}
									level->ptrtable_8 = pvVar4;
									puVar9 = (undefined4 *)((int)level->ptrtable_8 + level->count_c * 0x4c);
									for (uVar3 = ((uVar8 - level->count_c) + 1) * 0x13 & 0x3fffffff; uVar3 != 0;
											uVar3 -= 1) {
										*puVar9 = 0;
										puVar9 = puVar9 + 1;
									}
									for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
										*(undefined *)puVar9 = 0;
										puVar9 = (undefined4 *)((int)puVar9 + 1);
									}
									level->count_c = uVar8 + 1;
								}
								if (uVar7 == 0) {
									iVar5 = (int)filename * (level->dimensions).width + uVar2;
									level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 | BLOCK2_EMERGE_TRIGGER;
									*(uint *)(uVar8 * 0x4c + 4 + (int)level->ptrtable_8) = uVar2;
									*(char **)(uVar8 * 0x4c + 8 + (int)level->ptrtable_8) = filename;
								}
								else {
									pLVar1 = &level->blocks[(int)filename * (level->dimensions).width + uVar2].flags2;
									*pLVar1 = *pLVar1 | BLOCK2_EMERGE_POINT;
									iVar5 = uVar8 * 0x4c;
									*(uint *)(iVar5 + uVar7 * 0xc + 4 + (int)level->ptrtable_8) = uVar2;
									*(char **)(uVar7 * 0xc + iVar5 + 8 + (int)level->ptrtable_8) = filename;
									*(undefined4 *)(iVar5 + (uVar7 + 1) * 0xc + (int)level->ptrtable_8) = 1;
								}
							}
							uVar2 += 1;
							uVar3 = local_c;
							pcVar6 = local_8;
						} while (uVar2 < local_c);
					}
					filename = filename + 1;
					uVar2 = local_4;
				} while (filename < pcVar6);
			}
			lego::file::Mem_FreeHandle(uVar2);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar2);
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_UnkEmerge_FUN_0042c260
					(LevelData *level,Point2I *in_position,undefined4 *out_unkPosition)
{
	int iVar1;
	LiveObject *pLVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	uint local_4;
	
	iVar4 = 0;
	local_4 = 0;
	if (level->count_c == 0) {
		return 0;
	}
	do {
		iVar1 = (int)level->ptrtable_8 + iVar4;
		if (((in_position->x == *(int *)(iVar1 + 4)) && (in_position->y == *(int *)(iVar1 + 8))) &&
			 ((ushort)((ushort)(*(float *)(iVar1 + 0xc) < 0.0) << 8 |
								(ushort)(*(float *)(iVar1 + 0xc) == 0.0) << 0xe) != 0)) {
			iVar1 = 0;
			uVar5 = 0;
			do {
				if (*(int *)(iVar4 + uVar5 + 0x18 + (int)level->ptrtable_8) != 0) {
					iVar3 = iVar4 + uVar5 + (int)level->ptrtable_8;
					pLVar2 = Game_TryGeneratedRockMonsterLiveObject
														 ((int **)(globs::legoGlobs.RockMonsterData_TABLE +
																			level->EmergeCreature),OBJECT_ROCKMONSTER,
															level->EmergeCreature,*(uint *)(iVar3 + 0x10),*(uint *)(iVar3 + 0x14))
					;
					if (pLVar2 != NULL) {
						iVar4 = local_4 * 0x4c;
						*(float *)(iVar4 + 0xc + (int)level->ptrtable_8) = level->EmergeTimeOut;
						if (out_unkPosition != NULL) {
							*out_unkPosition =
									 *(undefined4 *)(iVar1 * 0xc + iVar4 + 0x10 + (int)level->ptrtable_8);
							out_unkPosition[1] =
									 *(undefined4 *)(iVar1 * 0xc + iVar4 + 0x14 + (int)level->ptrtable_8);
						}
						return 1;
					}
				}
				uVar5 += 0xc;
				iVar1 += 1;
			} while (uVar5 < 0x3c);
		}
		local_4 += 1;
		iVar4 += 0x4c;
	} while (local_4 < level->count_c);
	return 0;
}



void __cdecl lego::game::Level_FUN_0042c370(LevelData *level,float elapsedAbs)
{
	float *pfVar1;
	float fVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 0;
	if (level->count_c != 0) {
		iVar3 = 0;
		do {
			fVar2 = *(float *)((int)level->ptrtable_8 + iVar3 + 0xc);
			pfVar1 = (float *)((int)level->ptrtable_8 + iVar3 + 0xc);
			if ((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) == 0) {
				*pfVar1 = *pfVar1 - elapsedAbs;
			}
			uVar4 += 1;
			iVar3 += 0x4c;
		} while (uVar4 < level->count_c);
	}
	return;
}



BOOL __cdecl lego::lrr::Lego_LoadTerrainMap(LevelData *level,char *filename,int modifier)
{
	TerrainType TVar1;
	uint sharedIndex;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	uint by;
	char *bx;
	uint local_c;
	Point2I local_8;
	
	sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL);
	if (sharedIndex != 0xffffffff) {
		game::MapShared_GetDimensions(sharedIndex,(uint *)&filename,&local_c);
		if ((filename == (char *)(level->dimensions).width) && (local_c == (level->dimensions).height))
		{
			by = 0;
			pcVar4 = filename;
			uVar2 = local_c;
			if (local_c != 0) {
				do {
					bx = NULL;
					if (pcVar4 != NULL) {
						do {
							uVar2 = game::MapShared_GetBlock(sharedIndex,(int)bx,by);
							iVar3 = uVar2 - modifier;
						// Soil SurfaceType was removed, change to Dirt
							if (iVar3 == 5) {
								iVar3 = 4;
							}
							level->blocks[(int)(bx + by * (level->dimensions).width)].terrain = (TerrainType)iVar3
							;
							TVar1 = level->blocks[(int)(bx + by * (level->dimensions).width)].terrain;
							if (TVar1 == TERRAIN_LAVA) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].field_7 = 4;
							}
							else {
								if (TVar1 == TERRAIN_RECHARGESEAM) {
									local_8.x = (int)bx;
									local_8.y = by;
									game::Level_RegisterRechargeSeam(&local_8);
									res::Level_LevelStruct1C_Create_Res_Unk_RechargeSparkle(level,&local_8,1);
								}
							}
							bx = bx + 1;
							pcVar4 = filename;
							uVar2 = local_c;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar2);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl
lego::lrr::Lego_GetBlockCryOre
					(Point2I *position,int *out_crystal,int *out_ore,int *out_crystalAlt,int *out_oreAlt)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	int CRYORE_COUNTS [5];
	
	uVar3 = (uint)(globs::legoGlobs.level)->blocks
								[position->y * ((globs::legoGlobs.level)->dimensions).width + position->x].cryOre;
	CRYORE_COUNTS[0] = 1;
	uVar2 = uVar3 - 1;
	*out_oreAlt = 0;
	*out_crystalAlt = 0;
	*out_ore = 0;
	CRYORE_COUNTS[1] = 3;
	CRYORE_COUNTS[2] = 5;
	CRYORE_COUNTS[3] = 10;
	CRYORE_COUNTS[4] = 0x19;
	*out_crystal = 0;
	if (uVar3 != 0) {
		iVar1 = *(int *)((int)CRYORE_COUNTS + (uVar2 & 0xfffffffc));
		switch(uVar2 & 3) {
		case 0:
			*out_crystal = iVar1;
			return 1;
		case 1:
			*out_crystalAlt = iVar1;
			return 1;
		case 2:
			*out_ore = iVar1;
			return 1;
		case 3:
			*out_oreAlt = iVar1;
		}
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadCryOreMap(LevelData *level,char *filename,char modifier)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *bx;
	uint by;
	uint local_4;
	
	sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL);
	if (sharedIndex != 0xffffffff) {
		game::MapShared_GetDimensions(sharedIndex,(uint *)&filename,&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = game::MapShared_GetBlock(sharedIndex,(int)bx,by);
							pcVar2 = bx + by * (level->dimensions).width;
							bx = bx + 1;
							level->blocks[(int)pcVar2].cryOre = (char)uVar1 - modifier;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadPathMap(LevelData *level,char *filename,int modifier)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags1 LVar2;
	uint uVar3;
	BOOL BVar4;
	char *pcVar5;
	uint uVar6;
	uint by;
	int iVar7;
	char *bx;
	uint local_10;
	uint local_c;
	Point2I local_8;
	
	if ((filename != NULL) &&
		 (uVar3 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar3 != 0xffffffff)) {
		local_c = uVar3;
		game::MapShared_GetDimensions(uVar3,(uint *)&filename,&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			by = 0;
			pcVar5 = filename;
			uVar6 = local_10;
			if (local_10 != 0) {
				do {
					bx = NULL;
					if (pcVar5 != NULL) {
						do {
							local_8.x = (int)bx;
							local_8.y = by;
							uVar3 = game::MapShared_GetBlock(local_c,(int)bx,by);
							pLVar1 = &level->blocks[(int)(bx + by * (level->dimensions).width)].flags1;
							LVar2 = *pLVar1;
							if ((LVar2 & BLOCK1_GROUND) != BLOCK1_NONE) {
								if (uVar3 - modifier == 2) {
									*pLVar1 = LVar2 | BLOCK1_PATH;
								}
								else {
									if ((((uVar3 - modifier == 1) &&
											 (((globs::legoGlobs.level)->blocks
												 [(int)(local_8.x + ((globs::legoGlobs.level)->dimensions).width * local_8.y
															 )].flags1 & BLOCK1_BUILDINGSOLID) == BLOCK1_NONE)) &&
											((*(byte *)&(globs::legoGlobs.level)->blocks
																	[(int)(local_8.x +
																				((globs::legoGlobs.level)->dimensions).width * local_8.y)].
																	flags2 & 4) == 0)) &&
										 ((((globs::legoGlobs.level)->blocks
												[(int)(local_8.x + ((globs::legoGlobs.level)->dimensions).width * local_8.y)
												].flags1 & BLOCK1_BUILDINGPATH) == BLOCK1_NONE &&
											(BVar4 = game::Construction_BlockCheck_FUN_00408fd0(&local_8), BVar4 == 0))))
									{
										(globs::legoGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::legoGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::legoGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::legoGlobs.level)->dimensions).width * local_8.y)].
													 flags1 & ~BLOCK1_CLEARED_UNK;
										(globs::legoGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::legoGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::legoGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::legoGlobs.level)->dimensions).width * local_8.y)].
													 flags1 & ~BLOCK1_PATH;
										(globs::legoGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::legoGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::legoGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::legoGlobs.level)->dimensions).width * local_8.y)].
													 flags1 & ~BLOCK1_UNK_40000000;
										game::LiveManager_InitFlagsToggle_AndClearNumDrained();
										ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(&local_8);
										util::logf_removed((char *)&local_8);
										iVar7 = 4;
										do {
											ai::AITask_DoClear_AtPosition(&local_8,MESSAGE_CLEARINITIAL_COMPLETE);
											iVar7 += -1;
										} while (iVar7 != 0);
										(globs::legoGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::legoGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::legoGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::legoGlobs.level)->dimensions).width * local_8.y)].
													 flags1 | BLOCK1_RUBBLE_FULL;
									}
								}
							}
							bx = bx + 1;
							pcVar5 = filename;
							uVar6 = local_10;
						} while (bx < filename);
					}
					by += 1;
					uVar3 = local_c;
				} while (by < uVar6);
			}
			lego::file::Mem_FreeHandle(uVar3);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar3);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadFallinMap(LevelData *level,char *filename)
{
	uint uVar1;
	char *pcVar2;
	uint uVar3;
	uint by;
	char *bx;
	uint local_10;
	uint sharedIndex;
	uint local_8;
	undefined4 uStack4;
	
	globs::legoGlobs.hasFallins = 0;
	if ((filename != NULL) &&
		 (uVar1 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar1 != 0xffffffff)) {
		sharedIndex = uVar1;
		game::MapShared_GetDimensions(uVar1,(uint *)&filename,&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar3 = local_10;
			if (local_10 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = game::MapShared_GetBlock(sharedIndex,(int)bx,by);
							level->blocks[(int)(bx + by * (level->dimensions).width)].fallinIntensity = 0;
							if (uVar1 != 0) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].fallinIntensity = uVar1;
						// * 25 (0x19)
								local_8 = (uint)(int)level->blocks[(int)(bx + by * (level->dimensions).width)].
																		 randomness % (uVar1 * globs::legoGlobs.FallinMultiplier * 0x19)
								;
								uStack4 = 0;
								level->blocks[(int)(bx + by * (level->dimensions).width)].fallinTimer =
										 (float)(ulonglong)local_8;
								level->blocks[(int)(bx + by * (level->dimensions).width)].fallinUpper = 0;
								if (4 < uVar1) {
									level->blocks[(int)(bx + by * (level->dimensions).width)].fallinIntensity =
											 uVar1 - 4;
									level->blocks[(int)(bx + by * (level->dimensions).width)].fallinUpper = TRUE;
								}
							}
							bx = bx + 1;
							pcVar2 = filename;
							uVar3 = local_10;
						} while (bx < filename);
					}
					by += 1;
					uVar1 = sharedIndex;
				} while (by < uVar3);
			}
			globs::legoGlobs.hasFallins = TRUE;
			lego::file::Mem_FreeHandle(uVar1);
			return TRUE;
		}
		lego::file::Mem_FreeHandle(uVar1);
	}
	return 0;
}



void __cdecl lego::game::Game_UpdateFallins(float elapsedGame)
{
	uint uVar1;
	uint uVar2;
	LevelData *level;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	Point2I position;
	LevelBlock *block;
	
	level = lrr::Lego_GetLevel();
	if ((((globs::legoGlobs.hasFallins != 0) && (uVar1 = (level->dimensions).width, uVar1 != 0)) &&
			(uVar2 = (level->dimensions).height, uVar2 != 0)) && (uVar5 = 0, uVar2 != 0)) {
		do {
			uVar6 = 0;
			if (uVar1 != 0) {
				do {
					block = level->blocks + uVar5 * (level->dimensions).width + uVar6;
					if (block->fallinIntensity != 0) {
						block->fallinTimer = elapsedGame + block->fallinTimer;
						iVar3 = uVar5 * (level->dimensions).width + uVar6;
						block = level->blocks + iVar3;
						if ((float)(ulonglong)
											 (level->blocks[iVar3].fallinIntensity * globs::legoGlobs.FallinMultiplier *
											 0x19) < block->fallinTimer) {
							block->fallinTimer = 0.0;
							position.x = uVar6;
							position.y = uVar5;
							BVar4 = Fallin_Block_FUN_0040f0c0
																(&position,
																 level->blocks[uVar5 * (level->dimensions).width + uVar6].
																 fallinUpper);
							if (BVar4 != 0) {
								front::Info_Send(INFO_LANDSLIDE,NULL,NULL,&position);
							}
						}
					}
					uVar6 += 1;
				} while (uVar6 < uVar1);
			}
			uVar5 += 1;
		} while (uVar5 < uVar2);
	}
	return;
}



BOOL __cdecl
lego::game::lego::lrr::Lego_LoadBlockPointersMap(LevelData *level,char *filename,int modifier)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *bx;
	uint by;
	uint local_4;
	
	if ((filename != NULL) &&
		 (sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL), sharedIndex != 0xffffffff)) {
		MapShared_GetDimensions(sharedIndex,(uint *)&filename,&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)bx,by);
							pcVar2 = bx + by * (level->dimensions).width;
							bx = bx + 1;
							level->blocks[(int)pcVar2].blockpointer = (char)uVar1 - (char)modifier;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



UpgradeData * __cdecl lego::game::Game_GetUpgradeData(char *upgradeName)
{
	int iVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::legoGlobs.UpgradeTypes_COUNT == 0) {
		return NULL;
	}
	do {
		iVar1 = std::_stricmp(upgradeName,globs::legoGlobs.UpgradeTypes_TABLE[uVar2]);
		if (iVar1 == 0) {
			return globs::legoGlobs.UpgradeData_TABLE + uVar2;
		}
		uVar2 += 1;
	} while (uVar2 < globs::legoGlobs.UpgradeTypes_COUNT);
	return NULL;
}



BOOL __cdecl lego::lrr::Lego_LoadVehicleTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::legoGlobs.VehicleTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"VehicleTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::legoGlobs.VehicleTypes_COUNT += 1;
	}
	if ((globs::legoGlobs.VehicleTypes_COUNT != 0) &&
		 (globs::legoGlobs.VehicleData_TABLE =
					 (VehicleData *)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 0x1ec),
		 globs::legoGlobs.VehicleData_TABLE != NULL)) {
		globs::legoGlobs.VehicleTypes_TABLE =
				 (char **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
		if (globs::legoGlobs.VehicleTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"VehicleTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Vehicle_LoadActivityFile
																((VehicleData *)
																 ((int)(globs::legoGlobs.VehicleData_TABLE)->WheelMeshes +
																 iVar7 + -0x10),local_4,globs::legoGlobs.contRoot,pCVar3->value,
																 globs::legoGlobs.gameName), BVar4 != 0))) {
				res::Vehicle_HideAll
									((VehicleData *)
									 ((int)(globs::legoGlobs.VehicleData_TABLE)->WheelMeshes + iVar7 + -0x10),TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x1ec;
				globs::legoGlobs.VehicleTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::legoGlobs.VehicleTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::legoGlobs.VehicleTypes_TABLE);
		}
		std::free(globs::legoGlobs.VehicleData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadMiniFigureTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::legoGlobs.MiniFigureTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiniFigureTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::legoGlobs.MiniFigureTypes_COUNT += 1;
	}
	if ((globs::legoGlobs.MiniFigureTypes_COUNT != 0) &&
		 (globs::legoGlobs.MiniFigureData_TABLE =
					 (CreatureData *)std::malloc(globs::legoGlobs.MiniFigureTypes_COUNT * 0x74),
		 globs::legoGlobs.MiniFigureData_TABLE != NULL)) {
		globs::legoGlobs.MiniFigureTypes_TABLE =
				 (char **)std::malloc(globs::legoGlobs.MiniFigureTypes_COUNT * 4);
		if (globs::legoGlobs.MiniFigureTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"MiniFigureTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Creature_LoadActivityFile
																((CreatureData *)
																 ((int)(globs::legoGlobs.MiniFigureData_TABLE)->cameraFramesTable_54
																 + iVar7 + -0x54),local_4,globs::legoGlobs.contRoot,pCVar3->value,
																 globs::legoGlobs.gameName), BVar4 != 0))) {
				res::Object_HideAll((BasicObjectData *)
														((int)(globs::legoGlobs.MiniFigureData_TABLE)->cameraFramesTable_54 +
														iVar7 + -0x54),TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x74;
				globs::legoGlobs.MiniFigureTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::legoGlobs.MiniFigureTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::legoGlobs.MiniFigureTypes_TABLE);
		}
		std::free(globs::legoGlobs.MiniFigureData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadRockMonsterTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::legoGlobs.RockMonsterTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"RockMonsterTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::legoGlobs.RockMonsterTypes_COUNT += 1;
	}
	if ((globs::legoGlobs.RockMonsterTypes_COUNT != 0) &&
		 (globs::legoGlobs.RockMonsterData_TABLE =
					 (CreatureData *)std::malloc(globs::legoGlobs.RockMonsterTypes_COUNT * 0x74),
		 globs::legoGlobs.RockMonsterData_TABLE != NULL)) {
		globs::legoGlobs.RockMonsterTypes_TABLE =
				 (char **)std::malloc(globs::legoGlobs.RockMonsterTypes_COUNT * 4);
		if (globs::legoGlobs.RockMonsterTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"RockMonsterTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Creature_LoadActivityFile
																((CreatureData *)
																 ((int)(globs::legoGlobs.RockMonsterData_TABLE)->
																			 cameraFramesTable_54 + iVar7 + -0x54),local_4,
																 globs::legoGlobs.contRoot,pCVar3->value,globs::legoGlobs.gameName),
						 BVar4 != 0))) {
				res::Object_HideAll((BasicObjectData *)
														((int)(globs::legoGlobs.RockMonsterData_TABLE)->cameraFramesTable_54 +
														iVar7 + -0x54),TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x74;
				globs::legoGlobs.RockMonsterTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::legoGlobs.RockMonsterTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::legoGlobs.RockMonsterTypes_TABLE);
		}
		std::free(globs::legoGlobs.RockMonsterData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadBuildingTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::legoGlobs.BuildingTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"BuildingTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::legoGlobs.BuildingTypes_COUNT += 1;
	}
	if ((globs::legoGlobs.BuildingTypes_COUNT != 0) &&
		 (globs::legoGlobs.BuildingData_TABLE =
					 (BuildingData *)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 0x14c),
		 globs::legoGlobs.BuildingData_TABLE != NULL)) {
		globs::legoGlobs.BuildingTypes_TABLE =
				 (char **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
		if (globs::legoGlobs.BuildingTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"BuildingTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Building_LoadActivityFile
																((BuildingData *)
																 ((int)(globs::legoGlobs.BuildingData_TABLE)->carryFramesTable_28 +
																 iVar7 + -0x28),local_4,globs::legoGlobs.contRoot,pCVar3->value,
																 globs::legoGlobs.gameName), BVar4 != 0))) {
				res::Building_HideAll
									((BuildingData *)
									 ((int)(globs::legoGlobs.BuildingData_TABLE)->carryFramesTable_28 + iVar7 + -0x28)
									 ,TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x14c;
				globs::legoGlobs.BuildingTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::legoGlobs.BuildingTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::legoGlobs.BuildingTypes_TABLE);
		}
		std::free(globs::legoGlobs.BuildingData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadUpgradeTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	int local_4;
	
	iVar6 = 0;
	globs::legoGlobs.UpgradeTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"UpgradeTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::legoGlobs.UpgradeTypes_COUNT += 1;
	}
	if ((globs::legoGlobs.UpgradeTypes_COUNT != 0) &&
		 (globs::legoGlobs.UpgradeData_TABLE =
					 (UpgradeData *)std::malloc(globs::legoGlobs.UpgradeTypes_COUNT << 4),
		 globs::legoGlobs.UpgradeData_TABLE != NULL)) {
		globs::legoGlobs.UpgradeTypes_TABLE =
				 (char **)std::malloc(globs::legoGlobs.UpgradeTypes_COUNT * 4);
		if (globs::legoGlobs.UpgradeTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"UpgradeTypes",0);
			for (pCVar3 = cfg::CFG_GetChildren(globs::legoGlobs.config,pcVar2); pCVar3 != NULL;
					pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
				res::Upgrade_LoadActivityFile
									((UpgradeData *)((int)&(globs::legoGlobs.UpgradeData_TABLE)->objectIndex + iVar6),
									 local_4,globs::legoGlobs.contRoot,pCVar3->value);
				res::Object_HideAll((BasicObjectData *)
														((int)&(globs::legoGlobs.UpgradeData_TABLE)->objectIndex + iVar6),TRUE);
				uVar4 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar4 == 0) break;
					uVar4 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar4);
				iVar6 += 0x10;
				globs::legoGlobs.UpgradeTypes_TABLE[local_4] = pcVar2;
				uVar4 = 0xffffffff;
				puVar7 = (undefined4 *)pCVar3->key;
				do {
					if (uVar4 == 0) break;
					uVar4 -= 1;
					cVar1 = *(char *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)pCVar3->key;
				puVar8 = (undefined4 *)globs::legoGlobs.UpgradeTypes_TABLE[local_4];
				for (uVar5 = ~uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar8 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar8 = puVar8 + 1;
				}
				local_4 += 1;
				for (uVar4 = ~uVar4 & 3; uVar4 != 0; uVar4 -= 1) {
					*(undefined *)puVar8 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				}
			}
			if (true) {
				return TRUE;
			}
			std::free(globs::legoGlobs.UpgradeTypes_TABLE);
		}
		std::free(globs::legoGlobs.UpgradeData_TABLE);
	}
	return 0;
}



void __cdecl lego::lrr::Lego_LoadObjectNames(CFGProperty *root)
{
	char *pcVar1;
	uint uVar2;
	uint uVar3;
	
	globs::legoGlobs.ObjectNames_VehicleTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames",
																 globs::legoGlobs.VehicleTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectNames_VehicleTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.VehicleTypes_COUNT);
	}
	globs::legoGlobs.ObjectNames_MiniFigureTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.MiniFigureTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames",
																 globs::legoGlobs.MiniFigureTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectNames_MiniFigureTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.MiniFigureTypes_COUNT);
	}
	globs::legoGlobs.ObjectNames_RockMonsterTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.RockMonsterTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames",
																 globs::legoGlobs.RockMonsterTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectNames_RockMonsterTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.RockMonsterTypes_COUNT);
	}
	globs::legoGlobs.ObjectNames_BuildingTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames",
																 globs::legoGlobs.BuildingTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectNames_BuildingTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.BuildingTypes_COUNT);
	}
	globs::legoGlobs.ObjectNames_UpgradeTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.UpgradeTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.UpgradeTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames",
																 globs::legoGlobs.UpgradeTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pcVar1 = util::Util_RemoveUnderscores(pcVar1);
				globs::legoGlobs.ObjectNames_UpgradeTypes_TABLE[uVar2] = pcVar1;
			}
			uVar3 = uVar2 + 1;
			globs::legoGlobs.ObjectNames_UpgradeTypes_TABLE[uVar2] = NULL;
			uVar2 = uVar3;
		} while (uVar3 < globs::legoGlobs.UpgradeTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_PowerCrystal = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_Ore = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_ProcessedOre = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_Dynamite = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_Barrier = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_ElectricFence = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_SpiderWeb = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_OohScary = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectNames","Path",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectNames_Path = util::Util_RemoveUnderscores(pcVar1);
	}
	return;
}



void __cdecl lego::lrr::Lego_LoadObjectTheNames(CFGProperty *root)
{
	char *pcVar1;
	uint uVar2;
	uint uVar3;
	
	globs::legoGlobs.ObjectTheNames_VehicleTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.VehicleTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames",
																 globs::legoGlobs.VehicleTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectTheNames_VehicleTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.VehicleTypes_COUNT);
	}
	globs::legoGlobs.ObjectTheNames_MiniFigureTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.MiniFigureTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames",
																 globs::legoGlobs.MiniFigureTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectTheNames_MiniFigureTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.MiniFigureTypes_COUNT);
	}
	globs::legoGlobs.ObjectTheNames_RockMonsterTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.RockMonsterTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames",
																 globs::legoGlobs.RockMonsterTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectTheNames_RockMonsterTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.RockMonsterTypes_COUNT);
	}
	globs::legoGlobs.ObjectTheNames_BuildingTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.BuildingTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames",
																 globs::legoGlobs.BuildingTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::legoGlobs.ObjectTheNames_BuildingTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::legoGlobs.BuildingTypes_COUNT);
	}
	globs::legoGlobs.ObjectTheNames_UpgradeTypes_TABLE =
			 (char **)std::malloc(globs::legoGlobs.UpgradeTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::legoGlobs.UpgradeTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames",
																 globs::legoGlobs.UpgradeTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pcVar1 = util::Util_RemoveUnderscores(pcVar1);
				globs::legoGlobs.ObjectTheNames_UpgradeTypes_TABLE[uVar2] = pcVar1;
			}
			uVar3 = uVar2 + 1;
			globs::legoGlobs.ObjectTheNames_UpgradeTypes_TABLE[uVar2] = NULL;
			uVar2 = uVar3;
		} while (uVar3 < globs::legoGlobs.UpgradeTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_PowerCrystal = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_Ore = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_ProcessedOre = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_Dynamite = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_Barrier = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_ElectricFence = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_SpiderWeb = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_OohScary = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ObjectTheNames","Path",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.ObjectTheNames_Path = util::Util_RemoveUnderscores(pcVar1);
	}
	return;
}



void __cdecl lego::lrr::Lego_GotoInfo(LiveObject *liveObj,Point2I *blockPos,BOOL gotoBool)
{
	Point2F *pPVar1;
	int iVar2;
	uint scrollBlockX;
	uint scrollBlockY;
	uint bx;
	uint by;
	Point2F *pPVar3;
	Point2I blockPos2;
	LevelData *level;
	SurfaceMap *surfMap;
	
	level = globs::legoGlobs.level;
	globs::legoGlobs.gotoBool_98 = gotoBool;
	if (liveObj == NULL) {
		if (gotoBool == 0) {
			surfMap = (globs::legoGlobs.level)->surfaceMap;
			pPVar1 = globs::legoGlobs.gotoPositions_88;
			pPVar3 = globs::legoGlobs.gotoPositions_88;
			by = blockPos->y;
			bx = blockPos->x;
		}
		else {
			pPVar1 = globs::legoGlobs.gotoPositions_88 + 1;
			pPVar3 = globs::legoGlobs.gotoPositions_88 + 1;
			by = blockPos->y;
			bx = blockPos->x;
			surfMap = (globs::legoGlobs.level)->surfaceMap;
		}
		game::Map3D_BlockToWorldPos(surfMap,bx,by,&pPVar3->x,&pPVar1->y);
		blockPos2.x = blockPos->x;
		blockPos2.y = blockPos->y;
	}
	else {
		if (gotoBool == 0) {
			pPVar1 = globs::legoGlobs.gotoPositions_88;
			pPVar3 = globs::legoGlobs.gotoPositions_88;
		}
		else {
			pPVar1 = globs::legoGlobs.gotoPositions_88 + 1;
			pPVar3 = globs::legoGlobs.gotoPositions_88 + 1;
		}
		game::LiveObject_GetPosition(liveObj,&pPVar3->x,&pPVar1->y);
		game::LiveObject_GetBlockPos(liveObj,&blockPos2.x,&blockPos2.y);
	}
	scrollBlockY = blockPos2.y;
	scrollBlockX = blockPos2.x;
	iVar2 = lego::view::Camera_GetMouseScrollIndent();
	if (blockPos2.x < iVar2) {
		scrollBlockX = lego::view::Camera_GetMouseScrollIndent();
	}
	iVar2 = lego::view::Camera_GetMouseScrollIndent();
	if ((level->surfaceMap->smallDimensions).width - iVar2 <= blockPos2.x) {
		iVar2 = lego::view::Camera_GetMouseScrollIndent();
		scrollBlockX = ((level->surfaceMap->smallDimensions).width - iVar2) - 1;
	}
	iVar2 = lego::view::Camera_GetMouseScrollIndent();
	if (blockPos2.y < iVar2) {
		scrollBlockY = lego::view::Camera_GetMouseScrollIndent();
	}
	iVar2 = lego::view::Camera_GetMouseScrollIndent();
	if ((level->surfaceMap->smallDimensions).height - iVar2 <= blockPos2.y) {
		iVar2 = lego::view::Camera_GetMouseScrollIndent();
		scrollBlockY = ((level->surfaceMap->smallDimensions).height - iVar2) - 1;
	}
	if ((blockPos2.x != scrollBlockX) || (blockPos2.y != scrollBlockY)) {
		if (gotoBool == 0) {
			pPVar1 = globs::legoGlobs.gotoPositions_88;
			pPVar3 = globs::legoGlobs.gotoPositions_88;
			surfMap = (globs::legoGlobs.level)->surfaceMap;
		}
		else {
			pPVar1 = globs::legoGlobs.gotoPositions_88 + 1;
			pPVar3 = globs::legoGlobs.gotoPositions_88 + 1;
			surfMap = (globs::legoGlobs.level)->surfaceMap;
		}
		game::Map3D_BlockToWorldPos(surfMap,scrollBlockX,scrollBlockY,&pPVar3->x,&pPVar1->y);
	}
	globs::legoGlobs.flags1 = globs::legoGlobs.flags1 | GAME1_UNK_200000;
	return;
}



void __cdecl lego::game::Game_RemoveRecordObject(LiveObject *liveObj)
{
	LiveObject **ppLVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::legoGlobs.recordObjsCount != 0) {
		ppLVar1 = globs::legoGlobs.recordObjs;
		do {
			if (liveObj == *ppLVar1) {
				*ppLVar1 = NULL;
			}
			uVar2 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globs::legoGlobs.recordObjsCount);
	}
	return;
}



BOOL __cdecl lego::game::Game_GetRecordObject(uint recordObjPtr,LiveObject **out_liveObj)
{
	LiveObject *liveObj;
	
	if ((recordObjPtr < globs::legoGlobs.recordObjsCount) &&
		 (liveObj = globs::legoGlobs.recordObjs[recordObjPtr], *out_liveObj = liveObj, liveObj != NULL))
	{
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::Game_LoadOLObjectList(LevelData *level,char *filename)
{
	LiveObject *liveObj;
	float heading;
	CFGProperty *prop;
	char *pcVar1;
	CFGProperty *prop_00;
	CFGProperty *pCVar2;
	uint by;
	BOOL BVar3;
	LevelBlockFlags1 LVar4;
	Point2I *shapePoints;
	ObjectStatsFlags3 OVar5;
	ObjectStatsFlags1 OVar6;
	int iVar7;
	char **ppcVar8;
	LiveObject *pLVar9;
	Direction rotation;
	uint uVar10;
	LiveObject **ppLVar11;
	bool bVar12;
	float10 fVar13;
	float10 fVar14;
	float10 fVar15;
	float10 fVar16;
	ulonglong uVar17;
	ulonglong uVar18;
	longlong lVar19;
	float trackTilt;
	float trackRotationSpeed;
	TrainedFlags trainFlags;
	uint local_9c8;
	ObjectType objType;
	Point2F worldPos;
	float objYpos;
	float objHeading;
	uint local_9b0;
	float objXpos;
	int objIndex;
	float objHealth;
	LiveObject **local_9a0;
	char *objDrivenByName;
	int local_998;
	CFGProperty *local_994;
	Container *objSrcData;
	char *objTypeName;
	uint shapeCount;
	Point2I shapeTranslation;
	char *objDrivingName;
	Point2F hiddenWorldPos;
	LiveObject *local_960 [200];
	char *local_640 [200];
	char *apcStack800 [200];
	
	bVar12 = false;
	local_998 = 1;
	local_9c8 = 0;
	prop = cfg::CFG_Open(filename);
	local_994 = prop;
	if (prop != NULL) {
		ppLVar11 = globs::legoGlobs.recordObjs;
		for (iVar7 = 10; iVar7 != 0; iVar7 += -1) {
			*ppLVar11 = NULL;
			ppLVar11 = ppLVar11 + 1;
		}
		globs::legoGlobs.recordObjsCount = 0;
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,0);
		prop_00 = cfg::CFG_GetChildren(prop,pcVar1);
		if (prop_00 != NULL) {
			local_9a0 = local_960;
			do {
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"type",0);
				objTypeName = cfg::CFG_CopyString(prop,pcVar1);
				if (objTypeName == NULL) break;
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"xpos",0);
				pCVar2 = cfg::CFG_GetProperty(prop,pcVar1);
				if (pCVar2 == NULL) break;
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"ypos",0);
				pCVar2 = cfg::CFG_GetProperty(prop,pcVar1);
				if (pCVar2 == NULL) break;
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"heading",0);
				pCVar2 = cfg::CFG_GetProperty(prop,pcVar1);
				if (pCVar2 == NULL) break;
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"xpos",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == NULL) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"xpos",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar13 = std::atof(pcVar1);
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"ypos",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == NULL) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"ypos",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar14 = std::atof(pcVar1);
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"heading",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == NULL) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"heading",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar15 = std::atof(pcVar1);
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"health",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == NULL) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"health",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar16 = std::atof(pcVar1);
				objHealth = (float)fVar16;
				if ((float10)0.0 == fVar16) {
					objHealth = (float)&DAT_42c80000;
				}
				pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,prop_00->key,"driving",0);
				pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
				apcStack800[local_9c8] = pcVar1;
				objDrivenByName = util::_strdup(prop_00->key);
				local_640[local_9c8] = objDrivenByName;
				uVar17 = __ftol((float10)((float)fVar13 - 1.0));
				uVar10 = (uint)uVar17;
				uVar18 = __ftol((float10)((float)fVar14 - 1.0));
				by = (uint)uVar18;
				Map3D_BlockToWorldPos(level->surfaceMap,uVar10,by,&worldPos.x,&worldPos.y);
				worldPos.x = worldPos.x +
										 (((float)fVar13 - 1.0) - ((float)(uVar17 & 0xffffffff) - -0.5)) *
										 level->BlockSize;
				worldPos.y = worldPos.y -
										 (((float)fVar14 - 1.0) - ((float)(uVar18 & 0xffffffff) - -0.5)) *
										 level->BlockSize;
				heading = (float)fVar15 * 0.005555556 * 3.141593;
				BVar3 = Object_GetObjectByName(objTypeName,&objType,&objIndex,&objSrcData);
				if (BVar3 == 0) break;
				pLVar9 = NULL;
				if (objType == OBJECT_TVCAMERA) {
					lego::view::Camera_SetTopdownPosition(globs::legoGlobs.cameraMain,worldPos.x,worldPos.y);
					lego::view::Camera_SetYaw(globs::legoGlobs.cameraMain,heading);
					lego::view::Camera_SetTilt(globs::legoGlobs.cameraMain,0.8);
					globs::legoGlobs.tvFaceDirection_338.x = worldPos.x;
					globs::legoGlobs.tvFaceDirection_338.y = worldPos.y;
					globs::legoGlobs.tvTiltOrZoom_334 = 15.0;
				}
				else {
					iVar7 = ((globs::legoGlobs.level)->dimensions).width;
					if ((uVar10 < iVar7 - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
						LVar4 = (globs::legoGlobs.level)->blocks[by * iVar7 + uVar10].flags1 & BLOCK1_GROUND;
					}
					else {
						LVar4 = BLOCK1_NONE;
					}
					if (LVar4 == BLOCK1_NONE) {
						hiddenWorldPos.x = worldPos.x;
						hiddenWorldPos.y = worldPos.y;
						HiddenObject_Add(objSrcData,objType,objIndex,&hiddenWorldPos,heading,objHealth,
														 objDrivenByName,pcVar1);
					}
					else {
						if (objType == OBJECT_BUILDING) {
							shapeTranslation.x = uVar10;
							shapeTranslation.y = by;
							objDrivenByName =
									 (char *)res::Building_GetShapePoints
																		 (globs::legoGlobs.BuildingData_TABLE + objIndex,&shapeCount);
							lVar19 = __ftol((float10)heading * (float10)0.1591549 * (float10)8.0);
							rotation = ((uint)lVar19 & 1) + (uint)lVar19 >> 1;
							shapePoints = res::SelectPlace_TransformShapePoints
																			(&shapeTranslation,(Point2I *)objDrivenByName,shapeCount,
																			 rotation);
							pLVar9 = Construction_AddShape_FUN_004099c0
																 (objIndex,&shapeTranslation,rotation,shapePoints,shapeCount,
																	level->IsStartTeleportEnabled);
							if (pLVar9 != NULL) {
								LiveObject_FUN_00438720(pLVar9);
							}
						}
						else {
							pLVar9 = LiveObject_Create((int **)objSrcData,objType,objIndex);
						}
					}
				}
				*local_9a0 = pLVar9;
				if (pLVar9 != NULL) {
					if (local_998 != 0) {
						trackRotationSpeed = 0.01;
						trackTilt = 0.7;
						fVar13 = stats::StatsObject_GetTrackDist(pLVar9);
						lego::view::Camera_TrackObject
											(globs::legoGlobs.cameraRadar,pLVar9,2.0,(float)fVar13,trackTilt,
											 trackRotationSpeed);
					}
					local_998 = 0;
					if (objType != OBJECT_BUILDING) {
						LiveObject_SetPositionAndHeading(pLVar9,worldPos.x,worldPos.y,heading,TRUE);
					}
					if ((((objType == OBJECT_POWERCRYSTAL) || (objType == OBJECT_ORE)) ||
							(objType == OBJECT_DYNAMITE)) || (objType == OBJECT_BARRIER)) {
						ai::AITask_DoCollect(pLVar9,0.0);
					}
					if ((globs::liveGlobs.minifigureObj_9cb8 == NULL) &&
						 (pLVar9->objType == OBJECT_MINIFIGURE)) {
						globs::liveGlobs.minifigureObj_9cb8 = pLVar9;
					}
					if (globs::legoGlobs.recordObjsCount < 10) {
						globs::legoGlobs.recordObjs[globs::legoGlobs.recordObjsCount] = pLVar9;
						globs::legoGlobs.recordObjsCount += 1;
					}
					pLVar9->flags4 = pLVar9->flags4 | LIVEOBJ4_UNK_200;
					pLVar9->health = objHealth;
					front::HelpWindow_RecallDependencies(pLVar9->objType,pLVar9->objIndex,0,TRUE);
					if ((globs::legoGlobs.flags2 & GAME2_RECALLOLOBJECTS) != GAME2_NONE) {
						ObjectRecall_RecallMiniFigure(pLVar9);
					}
					LiveObject_RegisterVehicle__callsForWater(pLVar9);
					if (objType == OBJECT_SPIDERWEB) {
						pLVar9->flags3 = pLVar9->flags3 | LIVEOBJ3_UNK_10000;
						res::Container_SetActivity(pLVar9->other,"FlapInWind");
						res::Container_SetAnimationTime(pLVar9->other,0.0);
						SpiderWeb_Add(uVar10,by,pLVar9);
					}
					else {
						if (objType == OBJECT_ELECTRICFENCE) {
							ElectricFence_AssignBlockObject(pLVar9);
						}
					}
				}
				std::free(objTypeName);
				local_9c8 += 1;
				local_9a0 = local_9a0 + 1;
				prop_00 = cfg::CFG_NextFlat(prop_00);
				prop = local_994;
			} while (prop_00 != NULL);
			bVar12 = prop_00 == NULL;
		}
		cfg::CFG_Close(prop);
	}
	if (!bVar12) {
		return 0;
	}
	local_9b0 = 0;
	if (local_9c8 != 0) {
		do {
			pLVar9 = local_960[local_9b0];
			if ((pLVar9 != NULL) && (pcVar1 = apcStack800[local_9b0], pcVar1 != NULL)) {
				uVar10 = 0;
				ppcVar8 = local_640;
				do {
					iVar7 = std::_stricmp(pcVar1,*ppcVar8);
					if (iVar7 == 0) {
						liveObj = local_960[uVar10];
						if (liveObj != NULL) {
							pLVar9->object_2fc = liveObj;
							pLVar9->flags2 = pLVar9->flags2 | LIVEOBJ2_UNK_4;
							OVar5 = stats::StatsObject_GetStatsFlags3(liveObj);
							if ((OVar5 & STATS3_NEEDSPILOT) == STATS3_NONE) {
								OVar6 = stats::StatsObject_GetStatsFlags1(liveObj);
								if ((OVar6 & STATS1_CROSSWATER) == STATS1_NONE) {
									trainFlags = TRAINED_DRIVER;
								}
								else {
									OVar6 = stats::StatsObject_GetStatsFlags1(liveObj);
									if ((OVar6 & STATS1_CROSSLAND) == STATS1_NONE) {
										trainFlags = TRAINED_SAILOR;
									}
									else {
										trainFlags = TRAINED_PILOT;
									}
								}
							}
							else {
								trainFlags = TRAINED_PILOT;
							}
							LiveObject_TrainMiniFigure_instantunk(pLVar9,trainFlags);
							LiveObject_ClearFlags4_40_AndSameForObject2FC(pLVar9,liveObj);
						}
						break;
					}
					uVar10 += 1;
					ppcVar8 = ppcVar8 + 1;
				} while (uVar10 < local_9c8);
			}
			local_9b0 += 1;
		} while (local_9b0 < local_9c8);
	}
	uVar10 = 0;
	if (local_9c8 != 0) {
		do {
			if (local_640[uVar10] != NULL) {
				std::free(local_640[uVar10]);
			}
			if (apcStack800[uVar10] != NULL) {
				std::free(apcStack800[uVar10]);
			}
			uVar10 += 1;
		} while (uVar10 < local_9c8);
	}
	return 1;
}



BOOL __cdecl
lego::game::Object_GetObjectByName
					(char *objName,ObjectType *out_objType,int *out_objIndex,Container **opt_resData)
{
	int iVar1;
	uint index;
	
	index = 0;
	*out_objIndex = 0;
	if (globs::legoGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			iVar1 = std::_stricmp(globs::legoGlobs.RockMonsterTypes_TABLE[index],objName);
			if (iVar1 == 0) {
				*out_objType = OBJECT_ROCKMONSTER;
				*out_objIndex = index;
				if (opt_resData == NULL) {
					return 1;
				}
				*opt_resData = (Container *)(globs::legoGlobs.RockMonsterData_TABLE + index);
				return 1;
			}
			index += 1;
		} while (index < globs::legoGlobs.RockMonsterTypes_COUNT);
	}
	iVar1 = std::_stricmp("tvcamera",objName);
	if (iVar1 == 0) {
		*out_objType = OBJECT_TVCAMERA;
		if (opt_resData != NULL) {
			*opt_resData = NULL;
			return 1;
		}
	}
	else {
		iVar1 = std::_stricmp("PowerCrystal",objName);
		if (iVar1 == 0) {
			*out_objType = OBJECT_POWERCRYSTAL;
			if (opt_resData != NULL) {
				*opt_resData = globs::legoGlobs.contCrystal;
				return 1;
			}
		}
		else {
			iVar1 = std::_stricmp("Ore",objName);
			if (iVar1 == 0) {
				*out_objType = OBJECT_ORE;
				*out_objIndex = 0;
				if (opt_resData != NULL) {
					*opt_resData = globs::legoGlobs.contOresTable[0];
					return 1;
				}
			}
			else {
				iVar1 = std::_stricmp("ProcessedOre",objName);
				if (iVar1 == 0) {
					*out_objType = OBJECT_ORE;
					*out_objIndex = 1;
					if (opt_resData != NULL) {
						*opt_resData = globs::legoGlobs.contOresTable[1];
						return 1;
					}
				}
				else {
					iVar1 = std::_stricmp("Boulder",objName);
					if (iVar1 == 0) {
						*out_objType = OBJECT_BOULDER;
						if (opt_resData != NULL) {
							*opt_resData = globs::legoGlobs.contBoulder;
							return 1;
						}
					}
					else {
						iVar1 = std::_stricmp("Pusher",objName);
						if (iVar1 == 0) {
							*out_objType = OBJECT_PUSHER;
							if (opt_resData != NULL) {
								*opt_resData = globs::legoGlobs.contPusher;
								return 1;
							}
						}
						else {
							iVar1 = std::_stricmp("LaserShot",objName);
							if (iVar1 == 0) {
								*out_objType = OBJECT_LASERSHOT;
								if (opt_resData != NULL) {
									*opt_resData = globs::legoGlobs.contLaserShot;
									return 1;
								}
							}
							else {
								iVar1 = std::_stricmp("Freezer",objName);
								if (iVar1 == 0) {
									*out_objType = OBJECT_FREEZER;
									if (opt_resData != NULL) {
										*opt_resData = globs::legoGlobs.contFreezer;
										return 1;
									}
								}
								else {
									iVar1 = std::_stricmp("Dynamite",objName);
									if (iVar1 == 0) {
										*out_objType = OBJECT_DYNAMITE;
										if (opt_resData != NULL) {
											*opt_resData = globs::legoGlobs.contDynamite;
											return 1;
										}
									}
									else {
										iVar1 = std::_stricmp("ElectricFence",objName);
										if (iVar1 == 0) {
											*out_objType = OBJECT_ELECTRICFENCE;
											if (opt_resData != NULL) {
												*opt_resData = globs::legoGlobs.contElectricFence;
												return 1;
											}
										}
										else {
											iVar1 = std::_stricmp("SpiderWeb",objName);
											if (iVar1 == 0) {
												*out_objType = OBJECT_SPIDERWEB;
												if (opt_resData != NULL) {
													*opt_resData = globs::legoGlobs.contSpiderWeb;
													return 1;
												}
											}
											else {
												iVar1 = std::_stricmp("Barrier",objName);
												if (iVar1 == 0) {
													*out_objType = OBJECT_BARRIER;
													if (opt_resData != NULL) {
														*opt_resData = globs::legoGlobs.contBarrier;
														return 1;
													}
												}
												else {
													iVar1 = std::_stricmp("OohScary",objName);
													if (iVar1 == 0) {
														*out_objType = OBJECT_OOHSCARY;
														if (opt_resData != NULL) {
															*opt_resData = globs::legoGlobs.contOohScary;
															return 1;
														}
													}
													else {
														iVar1 = std::_stricmp("Path",objName);
														if (iVar1 == 0) {
															*out_objType = OBJECT_PATH;
															if (opt_resData != NULL) {
																*opt_resData = NULL;
																return 1;
															}
														}
														else {
															index = 0;
															if (globs::legoGlobs.VehicleTypes_COUNT != 0) {
																do {
																	iVar1 = std::_stricmp(globs::legoGlobs.VehicleTypes_TABLE[index],
																												objName);
																	if (iVar1 == 0) {
																		*out_objType = OBJECT_VEHICLE;
																		*out_objIndex = index;
																		if (opt_resData == NULL) {
																			return 1;
																		}
																		*opt_resData = (Container *)
																									 (globs::legoGlobs.VehicleData_TABLE + index);
																		return 1;
																	}
																	index += 1;
																} while (index < globs::legoGlobs.VehicleTypes_COUNT);
															}
															index = 0;
															if (globs::legoGlobs.MiniFigureTypes_COUNT != 0) {
																do {
																	iVar1 = std::_stricmp(globs::legoGlobs.MiniFigureTypes_TABLE
																												[index],objName);
																	if (iVar1 == 0) {
																		*out_objType = OBJECT_MINIFIGURE;
																		*out_objIndex = index;
																		if (opt_resData == NULL) {
																			return 1;
																		}
																		*opt_resData = (Container *)
																									 (globs::legoGlobs.MiniFigureData_TABLE + index);
																		return 1;
																	}
																	index += 1;
																} while (index < globs::legoGlobs.MiniFigureTypes_COUNT);
															}
															index = 0;
															if (globs::legoGlobs.BuildingTypes_COUNT == 0) {
																return 0;
															}
															while (iVar1 = std::_stricmp(globs::legoGlobs.BuildingTypes_TABLE
																													 [index],objName), iVar1 != 0) {
																index += 1;
																if (globs::legoGlobs.BuildingTypes_COUNT <= index) {
																	return 0;
																}
															}
															*out_objType = OBJECT_BUILDING;
															*out_objIndex = index;
															if (opt_resData != NULL) {
																*opt_resData = (Container *)
																							 (globs::legoGlobs.BuildingData_TABLE + index);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl
lego::game::Object_GetTypeResource(ObjectType objType,int objIndex,Container **out_resData)
{
	if (objType == OBJECT_TVCAMERA) {
		*out_resData = NULL;
		return 1;
	}
	if (objType == OBJECT_POWERCRYSTAL) {
		*out_resData = globs::legoGlobs.contCrystal;
		return 1;
	}
	if (objType == OBJECT_ORE) {
		*out_resData = globs::legoGlobs.contOresTable[objIndex];
		return 1;
	}
	if (objType == OBJECT_DYNAMITE) {
		*out_resData = globs::legoGlobs.contDynamite;
		return 1;
	}
	if (objType == OBJECT_BARRIER) {
		*out_resData = globs::legoGlobs.contBarrier;
		return 1;
	}
	if (objType == OBJECT_ELECTRICFENCE) {
		*out_resData = globs::legoGlobs.contElectricFence;
		return 1;
	}
	if (objType == OBJECT_SPIDERWEB) {
		*out_resData = globs::legoGlobs.contSpiderWeb;
		return 1;
	}
	if (objType == OBJECT_OOHSCARY) {
		*out_resData = globs::legoGlobs.contOohScary;
		return 1;
	}
	if (objType == OBJECT_PATH) {
		*out_resData = NULL;
		return 1;
	}
	if (objType == OBJECT_BOULDER) {
		*out_resData = globs::legoGlobs.contBoulder;
		return 1;
	}
	if (objType == OBJECT_VEHICLE) {
		*out_resData = (Container *)(globs::legoGlobs.VehicleData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_MINIFIGURE) {
		*out_resData = (Container *)(globs::legoGlobs.MiniFigureData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_ROCKMONSTER) {
		*out_resData = (Container *)(globs::legoGlobs.RockMonsterData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_BUILDING) {
		*out_resData = (Container *)(globs::legoGlobs.BuildingData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_PUSHER) {
		*out_resData = globs::legoGlobs.contPusher;
		return 1;
	}
	if (objType == OBJECT_LASERSHOT) {
		*out_resData = globs::legoGlobs.contLaserShot;
		return 1;
	}
	if (objType == OBJECT_FREEZER) {
		*out_resData = globs::legoGlobs.contFreezer;
		return 1;
	}
	return 0;
}



int __cdecl lego::game::Object_GetTypeCount(ObjectType objType)
{
	uint uVar1;
	
	uVar1 = objType + OBJECT_TVCAMERA;
	switch(objType) {
	case OBJECT_VEHICLE:
		return globs::legoGlobs.VehicleTypes_COUNT;
	case OBJECT_MINIFIGURE:
		return globs::legoGlobs.MiniFigureTypes_COUNT;
	case OBJECT_ROCKMONSTER:
		return globs::legoGlobs.RockMonsterTypes_COUNT;
	case OBJECT_BUILDING:
		return globs::legoGlobs.BuildingTypes_COUNT;
	case OBJECT_BOULDER:
	case OBJECT_POWERCRYSTAL:
	case OBJECT_DYNAMITE:
	case OBJECT_BARRIER:
	case OBJECT_ELECTRICFENCE:
	case OBJECT_SPIDERWEB:
	case OBJECT_OOHSCARY:
	case OBJECT_ELECTRICFENCESTUD:
	case OBJECT_PATH:
	case OBJECT_PUSHER:
	case OBJECT_FREEZER:
	case OBJECT_ICECUBE:
	case OBJECT_LASERSHOT:
		uVar1 = 1;
		break;
	case OBJECT_ORE:
		return 2;
	case OBJECT_UPGRADEPART:
		return globs::legoGlobs.UpgradeTypes_COUNT;
	}
	return uVar1;
}



// This is an old method for playing movies.
// It supports playing a movie that isn't just in the center of the screen
//  (which can be seen by setting certain Level CFG AVI properties).
// All movie playback seen in LegoRR is done by Front_PlayMovie (which supports
//  skipping, and scales to screen, but not playing at a specified position).

void __cdecl lego::lrr::Lego_PlayMovie_old(char *fName,Point2F *opt_point)
{
	Point2F *pPVar1;
	Movie_t *mov;
	int iVar2;
	BOOL doFillSurface;
	RECT *lpRect;
	longlong lVar3;
	RECT rect;
	
	if (fName == NULL) {
		return;
	}
	mov = video::Movie_Load(fName);
	pPVar1 = opt_point;
	if (mov == NULL) {
		return;
	}
	if (opt_point == NULL) {
		doFillSurface = TRUE;
		if (true) goto LAB_0042ef98;
	}
	else {
		video::Movie_GetSize(mov,(uint *)&fName,(uint *)&opt_point);
		lVar3 = __ftol((float10)pPVar1->x);
		rect.left = (LONG)lVar3;
		lVar3 = __ftol((float10)pPVar1->y);
		rect.top = (LONG)lVar3;
		lVar3 = __ftol((float10)ZEXT48(fName) + (float10)pPVar1->x);
		rect.right = (LONG)lVar3;
		lVar3 = __ftol((float10)ZEXT48(opt_point) + (float10)pPVar1->y);
		rect.bottom = (LONG)lVar3;
		doFillSurface = 0;
	}
	ddraw::DirectDraw_ReturnFrontBuffer();
LAB_0042ef98:
	lpRect = (RECT *)(~-(uint)(doFillSurface != 0) & (uint)&rect);
	iVar2 = video::Movie_Update(mov,1.0,lpRect);
	while (iVar2 != 0) {
		main::Main_LoopUpdate(doFillSurface);
		iVar2 = video::Movie_Update(mov,1.0,lpRect);
	}
	video::Movie_Free(mov);
	return;
}



// Returns string containing name of nextLevel.

char * __cdecl lego::game::Level_Free(void)
{
	char *nextLevel;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	nextLevel = NULL;
	if (globs::legoGlobs.level != NULL) {
		std::free((globs::legoGlobs.level)->ptrtable_8);
		if (globs::legoGlobs.EndGameAVI1 != NULL) {
			std::free(globs::legoGlobs.EndGameAVI1);
		}
		if (globs::legoGlobs.EndGameAVI2 != NULL) {
			std::free(globs::legoGlobs.EndGameAVI2);
		}
		std::free(level->FullName);
		globs::legoGlobs.flags1 &= ~(GAME1_UNK_200000|GAME1_UNK_8000000);
		globs::liveGlobs.flags &= 0xffffffbf;
		globs::legoGlobs.flags2 &= ~(GAME2_UNK_2|GAME2_NOMULTISELECT);
		globs::legoGlobs.gotoBool_98 = 0;
		globs::legoGlobs.objTeleportQueue_COUNT = 0;
		globs::liveGlobs.minifigureObj_9cb8 = NULL;
		globs::liveGlobs.count_c434 = 0;
		globs::liveGlobs.countBuildingsOnly_c438 = 0;
		lrr::LegoGame_SetCallToArmsOn(0);
		globs::legoGlobs.flags1 &= ~GAME1_LASERTRACKER;
		globs::legoGlobs.flags2 &= ~(GAME2_ATTACKDEFER|GAME2_UNK_40|GAME2_UNK_80|GAME2_MENU_HASNEXT);
		globs::legoGlobs.pointsCount2_dcc[0] = 0;
		globs::legoGlobs.pointsCount2_dcc[1] = 0;
		lego::view::Camera_Shake(globs::legoGlobs.cameraMain,0.0,0.0);
		lego::view::Camera_SetDist(globs::legoGlobs.cameraMain,200.0);
		effect::Smoke_RemoveAll();
		lrr::LegoGame_ClearSomeFlags3_FUN_00435950();
		nextLevel = level->NextLevel;
		front::Text_Clear();
		front::HelpWindow_ClearFlag1();
		Dependencies_Reset_ClearAllLevelFlags_10c();
		nerps::NERPs_BlockPointers_FUN_00456f20();
		ai::AITask_Reset_Or_ClearFlag2(0);
		LiveManager_FUN_00437560();
		Construction_RemoveAll();
		effect::Effect_StopAll();
		ai::AITask_Reset_Or_ClearFlag2(TRUE);
		front::Info_SetFlag4(0);
		Roof_Shutdown();
		lego::view::Camera_TrackObject(globs::legoGlobs.cameraRadar,NULL,0.0,0.0,0.0,0.0);
		lego::view::Camera_SetFPObject(globs::legoGlobs.cameraFP,NULL,0);
		Message_CleanupSelectedUnitsCount();
		nerps::NERPsFile_Free();
		RadarMap_Free_UnwindMultiUse(level->radarMap);
		Map3D_Free(level->surfaceMap);
		Level_Free_ProMeshGrid(level);
		res::DynamicPM_Free_SurfaceTextureGrid(level->surfTextGrid);
		Level_FreeAll_LevelStruct1Cs_FUN_00431460(level);
		effect::Effect_RemoveAll_BoulderExplode();
		std::free(level->blocks);
		std::free(level);
		front::Info_ClearAllMessages();
		front::Interface_LevelFree_FUN_0041a850();
		Game_SetGameSpeed(1.0);
		front::Panel_ResetAll();
		front::Advisor_Cleanup();
		snd::Sound3D_StopAllSounds();
		effect::DamageFont_Cleanup();
	}
	globs::legoGlobs.level = NULL;
	return nextLevel;
}



void __cdecl
lego::game::Level_Block_SetFlags1_200_AndUpdateSurface_LevelStruct428
					(LevelData *level,uint bx,uint by,BOOL setFlag200)
{
	LevelBlockFlags1 *pFlags1;
	int width;
	
	width = (level->dimensions).width;
	if (setFlag200 != 0) {
		pFlags1 = &level->blocks[width * by + bx].flags1;
		*pFlags1 = *pFlags1 | BLOCK1_UNK_200;
		Level_BlockUpdateSurface(level,bx,by,0);
		return;
	}
	pFlags1 = &level->blocks[width * by + bx].flags1;
	*pFlags1 = *pFlags1 & ~BLOCK1_UNK_200;
	Level_BlockUpdateSurface(level,bx,by,0);
	return;
}



uint __cdecl FUN_0042f280(int param_1,int param_2,undefined *param_3,int param_4)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	undefined3 uVar3;
	uint uVar5;
	int iVar6;
	int *piVar7;
	int iVar8;
	uint local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	undefined3 uVar4;
	
	local_20[2] = 1;
	local_c = 1;
	local_20[1] = 0xffffffff;
	local_20[3] = 0;
	local_20[4] = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	local_24 = 0;
	uVar5 = 0;
	piVar7 = local_20 + 1;
	do {
		iVar6 = piVar7[-1] + param_1;
		iVar8 = param_2 + *piVar7;
		if ((((iVar6 < 0) || (iVar8 < 0)) ||
				(iVar1 = ((lego::globs::legoGlobs.level)->dimensions).width, iVar1 <= iVar6)) ||
			 (((lego::globs::legoGlobs.level)->dimensions).height <= iVar8)) {
			LVar2 = BLOCK1_NONE;
		}
		else {
			LVar2 = (lego::globs::legoGlobs.level)->blocks[iVar8 * iVar1 + iVar6].flags1 & BLOCK1_PATH;
		}
		if ((LVar2 != BLOCK1_NONE) ||
			 (((lego::globs::legoGlobs.level)->blocks
				 [((lego::globs::legoGlobs.level)->dimensions).width * iVar8 + iVar6].flags1 &
				BLOCK1_BUILDINGSOLID) != BLOCK1_NONE)) {
			local_24 |= 1 << ((byte)uVar5 & 0x1f);
		}
		uVar5 += 1;
		piVar7 = piVar7 + 2;
	} while (uVar5 < 4);
	uVar3 = (undefined3)(local_24 >> 8);
	uVar4 = (undefined3)((uint)param_3 >> 8);
	if (param_4 == 0) {
		switch(local_24) {
		case 0:
			*param_3 = 0;
			return CONCAT31(uVar3,0x65);
		case 1:
			*param_3 = 2;
			return CONCAT31(uVar4,0x65);
		case 2:
			*param_3 = 3;
			return CONCAT31(uVar3,0x65);
		case 3:
			*param_3 = 3;
			return CONCAT31(uVar3,99);
		case 4:
			*param_3 = 0;
			return CONCAT31(uVar3,0x65);
		case 5:
			*param_3 = 0;
			return CONCAT31(uVar3,0x62);
		case 6:
			*param_3 = 0;
			return CONCAT31(uVar3,99);
		case 7:
			*param_3 = 0;
			return CONCAT31(uVar3,100);
		case 8:
			*param_3 = 1;
			return CONCAT31(uVar4,0x65);
		case 9:
			*param_3 = 2;
			return CONCAT31(uVar4,99);
		case 10:
			*param_3 = 1;
			return CONCAT31(uVar4,0x62);
		case 0xb:
			*param_3 = 3;
			return CONCAT31(uVar3,100);
		case 0xc:
			*param_3 = 1;
			return CONCAT31(uVar3,99);
		case 0xd:
			*param_3 = 2;
			return CONCAT31(uVar3,100);
		case 0xe:
			*param_3 = 1;
			return CONCAT31(uVar4,100);
		case 0xf:
			*param_3 = 0;
			return CONCAT31(uVar3,0x60);
		}
	}
	else {
		switch(local_24) {
		case 0:
			*param_3 = 0;
			return CONCAT31(uVar4,0x75);
		case 1:
			*param_3 = 2;
			return CONCAT31(uVar3,0x75);
		case 2:
			*param_3 = 3;
			return CONCAT31(uVar4,0x75);
		case 3:
			*param_3 = 3;
			return CONCAT31(uVar4,0x73);
		case 4:
			*param_3 = 0;
			return CONCAT31(uVar3,0x75);
		case 5:
			*param_3 = 0;
			return CONCAT31(uVar3,0x72);
		case 6:
			*param_3 = 0;
			return CONCAT31(uVar4,0x73);
		case 7:
			*param_3 = 0;
			return CONCAT31(uVar3,0x74);
		case 8:
			*param_3 = 1;
			return CONCAT31(uVar3,0x75);
		case 9:
			*param_3 = 2;
			return CONCAT31(uVar3,0x73);
		case 10:
			*param_3 = 1;
			return CONCAT31(uVar3,0x72);
		case 0xb:
			*param_3 = 3;
			return CONCAT31(uVar3,0x74);
		case 0xc:
			*param_3 = 1;
			return CONCAT31(uVar3,0x73);
		case 0xd:
			*param_3 = 2;
			return CONCAT31(uVar4,0x74);
		case 0xe:
			*param_3 = 1;
			return CONCAT31(uVar3,0x74);
		case 0xf:
			*param_3 = 0;
			return CONCAT31(uVar4,0x71);
		}
	}
	return local_24 & 0xffffff00 | (uint)param_3 & 0xff;
}



// WARNING: Switch with 1 destination removed at 0x0042fd79 : 5 cases all go to same destination
// WARNING: Switch with 1 destination removed at 0x0042fdd8 : 5 cases all go to same destination

void __cdecl lego::game::Level_BlockUpdateSurface(LevelData *level,int bx,int by,BOOL reserved)
{
	LevelBlock *pLVar1;
	SurfaceMap *surfMap;
	int iVar2;
	LevelBlockFlags1 LVar3;
	LevelBlockFlags2 LVar4;
	LevelBlockFlags1 LVar5;
	BOOL BVar6;
	SurfaceMapStruct_2a8 *pSVar7;
	FeatureFlags FVar8;
	Point2I *pDir;
	uint *puVar9;
	uint uVar10;
	float local_60;
	int local_5c;
	float local_58;
	float local_54;
	Point2I *local_50;
	SurfaceMap *local_4c;
	Vector3F local_48;
	int local_3c;
	Point2I local_38;
	Point2I DIRECTIONS [4];
	LevelBlock *block;
	
	iVar2 = (level->dimensions).width;
	if (iVar2 - 1U <= (uint)bx) {
		return;
	}
	if ((level->dimensions).height - 1U <= (uint)by) {
		return;
	}
	local_4c = level->surfaceMap;
	iVar2 = by * iVar2 + bx;
	local_5c = 0;
	DIRECTIONS[0].x = 0;
	LVar3 = level->blocks[iVar2].flags1 & BLOCK1_PATH;
	DIRECTIONS[0].y = 0;
	block = level->blocks + iVar2;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = 0;
	DIRECTIONS[3].y = 1;
	local_3c = 1;
	if ((LVar3 == BLOCK1_NONE) || ((block->flags2 & BLOCK2_UNK_400) != BLOCK2_NONE)) {
		if ((LVar3 == BLOCK1_NONE) && ((block->flags2 & BLOCK2_UNK_400) != BLOCK2_NONE)) {
			LiveObject_IncLevelPathsBuilt(0);
			LVar4 = block->flags2 & ~BLOCK2_UNK_400;
			goto LAB_0042f6d5;
		}
	}
	else {
		LiveObject_IncLevelPathsBuilt(1);
		LVar4 = block->flags2 | BLOCK2_UNK_400;
LAB_0042f6d5:
		block->flags2 = LVar4;
	}
	iVar2 = (level->dimensions).width;
	pLVar1 = level->blocks;
	local_50 = &local_38;
	uVar10 = 0;
						// Get surrounding blocks for orientation?
	pDir = DIRECTIONS;
	do {
		if (pLVar1[(pDir->y + by) * iVar2 + bx + pDir->x].predug == PREDUG_EXPOSED) {
			local_48.x = (float)((uint)local_48.x & 0xffffff00 | uVar10 & 0xff);
			local_5c += 1;
		}
		else {
			*(char *)&local_50->x = (char)uVar10;
			local_50 = (Point2I *)((int)&local_50->x + 1);
		}
		uVar10 += 1;
		pDir = pDir + 1;
	} while (uVar10 < 4);
	LVar3 = block->flags1;
	LVar5 = LVar3 & ~(BLOCK1_GROUND|BLOCK1_WALL_UNK|BLOCK1_CORNEROBTUSE|BLOCK1_CORNERINNER|
									 BLOCK1_UNK_2000);
	block->flags1 = LVar5;
	if (local_5c == 4) {
		local_38.x = bx;
		local_38.y = by;
		block->flags1 =
				 LVar3 & ~(BLOCK1_GROUND|BLOCK1_WALL_UNK|BLOCK1_REINFORCED|BLOCK1_CORNEROBTUSE|
									 BLOCK1_CORNERINNER|BLOCK1_UNK_2000) | (BLOCK1_SURVEYED|BLOCK1_GROUND);
		block->field_3 = 0;
		if ((LVar3 & BLOCK1_GROUND) == BLOCK1_NONE) {
			local_48.x = (float)bx;
			local_48.y = (float)by;
			ai::AITask_Block_FUN_00402a10(&local_38,0);
			Level_Block_LevelStruct1C_DoActivityDestroy(level,(Point2I *)&local_48,TRUE);
			if ((globs::legoGlobs.flags1 & GAME1_ALWAYSROCKFALL) != GAME1_NONE) {
				Message_AddMessageAction
									(MESSAGE_DIG_COMPLETE,0,
									 (uint)(globs::legoGlobs.level)->blocks
												 [((globs::legoGlobs.level)->dimensions).width * by + bx].field_3,
									 (Point2I *)&local_48);
			}
		}
		if ((block->flags1 & BLOCK1_UNK_400000) == BLOCK1_NONE) {
			if ((((((globs::legoGlobs.level)->blocks
							[((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x].flags1 &
						 BLOCK1_BUILDINGSOLID) == BLOCK1_NONE) &&
					 ((*(byte *)&(globs::legoGlobs.level)->blocks
											 [((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x].
											 flags2 & 4) == 0)) &&
					((*(byte *)((int)&(globs::legoGlobs.level)->blocks
														[((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x]
														.flags1 + 1) & 0x80) == 0)) &&
				 (BVar6 = Construction_BlockCheck_FUN_00408fd0(&local_38), BVar6 == 0)) {
				iVar2 = ((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::legoGlobs.level)->blocks[iVar2].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_CLEARED_UNK;
				iVar2 = ((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::legoGlobs.level)->blocks[iVar2].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_PATH;
				iVar2 = ((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::legoGlobs.level)->blocks[iVar2].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
				LiveManager_InitFlagsToggle_AndClearNumDrained();
				ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(&local_38);
				util::logf_removed((char *)&local_38);
				iVar2 = 4;
				do {
					ai::AITask_DoClear_AtPosition(&local_38,MESSAGE_CLEAR_COMPLETE);
					iVar2 += -1;
				} while (iVar2 != 0);
				iVar2 = ((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::legoGlobs.level)->blocks[iVar2].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar2].flags1 | BLOCK1_RUBBLE_FULL;
			}
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * local_38.y + local_38.x;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 | BLOCK1_UNK_400000;
			front::Interface_BackToMain_IfSelectedWall_IsBlockPos(&local_38);
		}
		BVar6 = ElectricFence_Block_FUN_0040e110(level,bx,by);
		ElectricFence_Block_ElecFenceStud_FUN_0040e280(level,bx,by,(uint)(BVar6 != 0));
		if ((block->terrain == TERRAIN_LAVA) ||
			 (LVar3 = block->flags1, (LVar3 & BLOCK1_UNK_80000000) != BLOCK1_NONE)) {
			Erode_Block_FUN_0040ed80(&local_38,TRUE);
			if ((block->flags1 & BLOCK1_UNK_200) == BLOCK1_NONE) {
				if (block->field_7 == 4) {
					block->texture = TEXTURE_LAVA;
					Map3D_Block_TextCoords_FUN_00450c20(level->surfaceMap,bx,by,TRUE);
					if ((block->flags1 & BLOCK1_UNK_4000) == BLOCK1_NONE) {
						if ((int)block->randomness % 3 == 0) {
							local_48.x = 0.1;
							local_48.y = 0.1;
							local_48.z = -1.0;
							pSVar7 = effect::Smoke_CreateSmokeArea
																 (0,bx,by,&local_48,0.6,0.4,0.0,1.0,0.3,0,(int)block->randomness,
																	0x26);
							block->smokeptr_1c = pSVar7;
							block->flags1 = block->flags1 | BLOCK1_UNK_4000;
						}
					}
					else {
						effect::Smoke_Hide(block->smokeptr_1c,FALSE);
					}
				}
				else {
					Map3D_Block_TextCoords_FUN_00450c20(level->surfaceMap,bx,by,FALSE);
					switch(block->field_7) {
					case 0:
						block->texture = TEXTURE_ERODE_LOW;
						break;
					case 1:
						block->texture = TEXTURE_ERODE_MEDIUM;
						break;
					case 2:
						block->texture = TEXTURE_ERODE_HIGH;
						break;
					case 3:
						block->texture = TEXTURE_ERODE_FULL;
					}
				}
			}
			else {
				Map3D_Block_TextCoords_FUN_00450c20(level->surfaceMap,bx,by,FALSE);
				block->texture = TEXTURE_LAVA_NOTHOT;
				if ((block->flags1 & BLOCK1_UNK_4000) != BLOCK1_NONE) {
					effect::Smoke_Hide(block->smokeptr_1c,TRUE);
				}
			}
		}
		else {
			if (block->terrain == TERRAIN_LAKE) {
				block->texture = TEXTURE_WATER;
				Map3D_Block_TextCoords_FUN_00450c20(level->surfaceMap,bx,by,TRUE);
			}
			else {
				if ((LVar3 & BLOCK1_FOUNDATION) == BLOCK1_NONE) {
					if ((LVar3 & BLOCK1_PATH) == BLOCK1_NONE) {
						if ((*(byte *)&block->flags2 & BLOCK2_SLUGHOLE_EXPOSED) == 0) {
							if ((LVar3 & BLOCK1_CLEARED_UNK) == BLOCK1_NONE) {
								switch(LVar3 & BLOCK1_RUBBLE_FULL) {
								case BLOCK1_NONE:
									block->texture = TEXTURE_RUBBLE_LOW;
									break;
								case BLOCK1_RUBBLE_LOW:
									block->texture = TEXTURE_RUBBLE_MEDIUM;
									break;
								case BLOCK1_RUBBLE_MEDIUM:
									block->texture = TEXTURE_RUBBLE_HIGH;
									break;
								case BLOCK1_RUBBLE_FULL:
									block->texture = TEXTURE_RUBBLE_FULL;
								}
							}
							else {
								if ((LVar3 & BLOCK1_UNK_40000000) == BLOCK1_NONE) {
									block->texture = TEXTURE_GROUND;
								}
								else {
									block->texture = TEXTURE_PATH_BUILD;
								}
							}
						}
						else {
							block->texture = TEXTURE_SLUGHOLE;
						}
					}
					else {
						uVar10 = FUN_0042f280(bx,by,&block->field_3,block->flags2 & BLOCK2_POWERED);
						block->texture = (SurfaceTexture)uVar10;
					}
				}
				else {
					if ((block->flags2 & BLOCK2_POWERED) == BLOCK2_NONE) {
						block->texture = TEXTURE_FOUNDATION;
					}
					else {
						block->texture = TEXTURE_FOUNDATION_POWERED;
					}
				}
			}
		}
		goto switchD_0042fb8d_caseD_4;
	}
	if (local_5c != 2) {
		if ((local_5c != 1) && (local_5c != 3)) {
			if (((LVar3 & BLOCK1_SURVEYED) == BLOCK1_NONE) || (block->terrain - 1 < 5)) {
				block->texture = TEXTURE_TUNNEL;
			}
			block->field_3 = 0;
			goto switchD_0042fb8d_caseD_4;
		}
		block->flags1 =
				 LVar3 & ~(BLOCK1_GROUND|BLOCK1_WALL_UNK|BLOCK1_REINFORCED|BLOCK1_CORNEROBTUSE|
									 BLOCK1_CORNERINNER|BLOCK1_UNK_2000) | (BLOCK1_SURVEYED|BLOCK1_WALL_UNK);
		if (local_5c == 1) {
			if (true) {
				if (true) {
					switch(block->terrain) {
					case TERRAIN_IMMOVABLE:
					case TERRAIN_WATER_unused:
						goto switchD_0042fe25_caseD_1;
					case TERRAIN_HARD:
						goto switchD_0042fe25_caseD_2;
					case TERRAIN_MEDIUM:
						goto switchD_0042fe25_caseD_3;
					case TERRAIN_LOOSE:
						goto switchD_0042fe25_caseD_4;
					case TERRAIN_SOIL:
						goto switchD_0042fe25_caseD_5;
					}
				}
			}
			else {
				if (true) {
					switch(block->terrain) {
					case TERRAIN_IMMOVABLE:
					case TERRAIN_WATER_unused:
switchD_0042fe25_caseD_1:
						block->texture = TEXTURE_WALL_C_IMMOVABLE;
						break;
					case TERRAIN_HARD:
switchD_0042fe25_caseD_2:
						block->texture = TEXTURE_WALL_C_HARD;
						break;
					case TERRAIN_MEDIUM:
switchD_0042fe25_caseD_3:
						block->texture = TEXTURE_WALL_C_MEDIUM;
						break;
					case TERRAIN_LOOSE:
switchD_0042fe25_caseD_4:
						block->texture = TEXTURE_WALL_C_LOOSE;
						break;
					case TERRAIN_SOIL:
switchD_0042fe25_caseD_5:
						block->texture = TEXTURE_WALL_C_SOIL;
					}
				}
			}
			block->flags1 =
					 LVar3 & ~(BLOCK1_GROUND|BLOCK1_WALL_UNK|BLOCK1_REINFORCED|BLOCK1_CORNEROBTUSE|
										 BLOCK1_CORNERINNER|BLOCK1_UNK_2000) |
					 (BLOCK1_SURVEYED|BLOCK1_WALL_UNK|BLOCK1_CORNEROBTUSE);
			local_38.y = by;
			block->field_3 = SUB41(local_48.x,0) + 2U & 3;
			local_38.x = bx;
			Level_Block_LevelStruct1C_DoActivityDestroy(level,&local_38,TRUE);
		}
		else {
			if (local_5c == 3) {
				if (true) {
					if (true) {
						switch(block->terrain) {
						case TERRAIN_IMMOVABLE:
						case TERRAIN_WATER_unused:
							goto switchD_0042febf_caseD_1;
						case TERRAIN_HARD:
							goto switchD_0042febf_caseD_2;
						case TERRAIN_MEDIUM:
							goto switchD_0042febf_caseD_3;
						case TERRAIN_LOOSE:
							goto switchD_0042febf_caseD_4;
						case TERRAIN_SOIL:
							goto switchD_0042febf_caseD_5;
						}
					}
				}
				else {
						// Duplicate code. Unreachable, but contains effects of above switch
					if (true) {
						switch(block->terrain) {
						case TERRAIN_IMMOVABLE:
						case TERRAIN_WATER_unused:
switchD_0042febf_caseD_1:
							block->texture = TEXTURE_WALL_O_IMMOVABLE;
							break;
						case TERRAIN_HARD:
switchD_0042febf_caseD_2:
							block->texture = TEXTURE_WALL_O_HARD;
							break;
						case TERRAIN_MEDIUM:
switchD_0042febf_caseD_3:
							block->texture = TEXTURE_WALL_O_MEDIUM;
							break;
						case TERRAIN_LOOSE:
switchD_0042febf_caseD_4:
							block->texture = TEXTURE_WALL_O_LOOSE;
							break;
						case TERRAIN_SOIL:
switchD_0042febf_caseD_5:
							block->texture = TEXTURE_WALL_O_SOIL;
						}
					}
				}
				local_48.x = (float)bx;
				local_48.y = (float)by;
				Level_Block_LevelStruct1C_DoActivityDestroy(level,(Point2I *)&local_48,TRUE);
				ai::AITask_Block_FUN_00402a60((Point2I *)&local_48);
				block->field_3 = (byte)local_38.x;
				block->flags1 = block->flags1 | BLOCK1_CORNERINNER;
			}
		}
		surfMap = local_4c;
		Map3D_BlockVertexToWorldPos(local_4c,bx,by,&local_60,&local_60,&local_58);
		Map3D_BlockVertexToWorldPos(surfMap,bx + 1U,by + 1U,&local_60,&local_60,&local_54);
		local_48.x = local_58 - local_54;
		Map3D_BlockVertexToWorldPos(surfMap,bx + 1U,by,&local_60,&local_60,&local_58);
		Map3D_BlockVertexToWorldPos(surfMap,bx,by + 1U,&local_60,&local_60,&local_54);
		Map3D_Block_ShiftVertices_AndInitPlaneNormals
							(surfMap,bx,by,
							 (uint)((ushort)((ushort)(ABS(local_48.x) < ABS(local_58 - local_54)) << 8 |
															(ushort)(ABS(local_48.x) == ABS(local_58 - local_54)) << 0xe) == 0));
		local_38.x = bx;
		local_38.y = by;
		Level_Block_LevelStruct1C_DoActivityDestroy(level,&local_38,TRUE);
		goto switchD_0042fb8d_caseD_4;
	}
	DIRECTIONS[0].y = 1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[3].x = 0;
	DIRECTIONS[2].y = 3;
	DIRECTIONS[3].y = 3;
	uVar10 = 0;
	DIRECTIONS[1].y = 2;
	DIRECTIONS[2].x = 2;
	block->flags1 = LVar5 | (BLOCK1_SURVEYED|BLOCK1_WALL_UNK);
	puVar9 = (uint *)&DIRECTIONS[0].y;
	do {
		if ((puVar9[-1] == (local_38.x & 0xffU)) && (*puVar9 == ((uint)local_38.x >> 8 & 0xff))) {
			bx._0_1_ = (byte)uVar10;
			goto LAB_0042fc43;
		}
		uVar10 += 1;
		puVar9 = puVar9 + 2;
	} while (uVar10 < 6);
LAB_0042fc43:
	if (3 < (byte)bx) {
		if (block->terrain - 1 < 5) {
			block->texture = TEXTURE_WALL_GAP;
		}
		block->flags1 =
				 LVar3 & ~(BLOCK1_RUBBLE_FULL|BLOCK1_SURVEYED|BLOCK1_GROUND|BLOCK1_WALL_UNK|
									 BLOCK1_REINFORCED|BLOCK1_CORNEROBTUSE|BLOCK1_CORNERINNER|BLOCK1_UNK_100|
									 BLOCK1_UNK_200|BLOCK1_BUILDINGSOLID|BLOCK1_UNK_800|BLOCK1_UNK_1000|
									 BLOCK1_UNK_2000|BLOCK1_UNK_4000|BLOCK1_BUILDINGPATH) |
				 (uint)CONCAT11((char)(LVar5 >> 8),(char)(LVar5 | (BLOCK1_SURVEYED|BLOCK1_WALL_UNK))) |
				 BLOCK1_UNK_2000;
		block->field_3 = (byte)bx - 4;
		Map3D_Block_ShiftVertices_AndInitPlaneNormals(local_4c,bx,by,(byte)((byte)bx - 4) & 1);
		goto switchD_0042fb8d_caseD_4;
	}
	if ((LVar3 & BLOCK1_REINFORCED) == BLOCK1_NONE) {
		if ((int)block->randomness % 10 == 0) {
			if (true) {
				switch(block->terrain) {
				case TERRAIN_IMMOVABLE:
				case TERRAIN_WATER_unused:
					goto switchD_0042fce8_caseD_1;
				case TERRAIN_HARD:
					goto switchD_0042fce8_caseD_2;
				case TERRAIN_MEDIUM:
					goto switchD_0042fce8_caseD_3;
				case TERRAIN_LOOSE:
					goto switchD_0042fce8_caseD_4;
				case TERRAIN_SOIL:
					goto switchD_0042fce8_caseD_5;
				case TERRAIN_ORESEAM:
					goto switchD_0042fce8_caseD_8;
				case TERRAIN_CRYSTALSEAM:
					goto switchD_0042fce8_caseD_a;
				case TERRAIN_RECHARGESEAM:
					goto switchD_0042fce8_caseD_b;
				}
			}
		}
		else {
			if (true) {
				switch(block->terrain) {
				case TERRAIN_IMMOVABLE:
				case TERRAIN_WATER_unused:
switchD_0042fce8_caseD_1:
					block->texture = TEXTURE_WALL_F_IMMOVABLE;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_HARD:
switchD_0042fce8_caseD_2:
					block->texture = TEXTURE_WALL_F_HARD;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_MEDIUM:
switchD_0042fce8_caseD_3:
					block->texture = TEXTURE_WALL_F_MEDIUM;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_LOOSE:
switchD_0042fce8_caseD_4:
					block->texture = TEXTURE_WALL_F_LOOSE;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_SOIL:
switchD_0042fce8_caseD_5:
					block->texture = TEXTURE_WALL_F_SOIL;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_ORESEAM:
switchD_0042fce8_caseD_8:
					block->texture = TEXTURE_WALL_F_ORESEAM;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_CRYSTALSEAM:
switchD_0042fce8_caseD_a:
					block->texture = TEXTURE_WALL_F_CRYSTALSEAM;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_RECHARGESEAM:
switchD_0042fce8_caseD_b:
					block->texture = TEXTURE_WALL_F_RECHARGESEAM;
				}
			}
		}
	}
	else {
		if (true) {
			switch(block->terrain) {
			case TERRAIN_IMMOVABLE:
			case TERRAIN_WATER_unused:
				block->texture = TEXTURE_WALL_R_IMMOVABLE;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_HARD:
				block->texture = TEXTURE_WALL_R_HARD;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_MEDIUM:
				block->texture = TEXTURE_WALL_R_MEDIUM;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_LOOSE:
				block->texture = TEXTURE_WALL_R_LOOSE;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_SOIL:
				block->texture = TEXTURE_WALL_R_SOIL;
				block->field_3 = (byte)bx;
				break;
			default:
				goto switchD_0042fce8_caseD_6;
			}
			goto switchD_0042fb8d_caseD_4;
		}
	}
switchD_0042fce8_caseD_6:
	block->field_3 = (byte)bx;
switchD_0042fb8d_caseD_4:
	LVar3 = block->flags1;
	if ((((LVar3 & BLOCK1_SURVEYED) != BLOCK1_NONE) && ((LVar3 & BLOCK1_UNK_800000) != BLOCK1_NONE))
		 && ((block->terrain == TERRAIN_IMMOVABLE ||
				 ((block->terrain == TERRAIN_WATER_unused || ((LVar3 & BLOCK1_GROUND) != BLOCK1_NONE)))))) {
		block->flags1 = LVar3 & ~BLOCK1_UNK_800000;
		Map3D_Block_ClearHighlight(level->surfaceMap,bx,by);
	}
	FVar8 = main::Main_GetCLFlags();
	iVar2 = local_3c;
	if ((FVar8 & FEATURE_BLOCKFADEIN) == FEATURE_NONE) {
		iVar2 = 0;
	}
	if (iVar2 == 0) {
		Map3D_UpdateBlockVisual(level->surfaceMap,bx,by,block->texture,block->field_3);
	}
	else {
		Map3D_FadeInBlock(level->surfaceMap,bx,by,block->texture,block->field_3);
	}
	if (level->UseRoof != BOOL3_FALSE) {
		Level_Block_LowerRoofVertices(level,bx,by);
	}
	return;
}



void __cdecl lego::game::Level_Block_Proc_FUN_004301e0(Point2I *blockPos)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	pLVar1 = &(globs::legoGlobs.level)->blocks
						[((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1;
	*pLVar1 = *pLVar1 & ~BLOCK1_PATH;
	iVar2 = ((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x;
	(globs::legoGlobs.level)->blocks[iVar2].flags1 =
			 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(blockPos);
	util::logf_removed((char *)blockPos);
	return;
}



void __cdecl lego::ai::AITask_DoClearTypeAction(Point2I *position,MessageType completeAction)
{
	BOOL BVar1;
	int iVar2;
	
	if (((((globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * position->y + position->x].flags1 &
				BLOCK1_BUILDINGSOLID) == BLOCK1_NONE) &&
			((*(byte *)&(globs::legoGlobs.level)->blocks
									[((globs::legoGlobs.level)->dimensions).width * position->y + position->x].flags2
			 & 4) == 0)) &&
		 (((globs::legoGlobs.level)->blocks
			 [((globs::legoGlobs.level)->dimensions).width * position->y + position->x].flags1 &
			BLOCK1_BUILDINGPATH) == BLOCK1_NONE)) {
		BVar1 = game::Construction_BlockCheck_FUN_00408fd0(position);
		if (BVar1 == 0) {
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * position->y + position->x;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_CLEARED_UNK;
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * position->y + position->x;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_PATH;
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * position->y + position->x;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
			game::LiveManager_InitFlagsToggle_AndClearNumDrained();
			AITask_DoCallbacks_IfAttackPath_FUN_00402970(position);
			util::logf_removed((char *)position);
			iVar2 = 4;
			do {
				AITask_DoClear_AtPosition(position,completeAction);
				iVar2 += -1;
			} while (iVar2 != 0);
			iVar2 = ((globs::legoGlobs.level)->dimensions).width * position->y + position->x;
			(globs::legoGlobs.level)->blocks[iVar2].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar2].flags1 | BLOCK1_RUBBLE_FULL;
		}
	}
	return;
}



void __cdecl
lego::debug::Level_Debug_WKey_NeedsBlockFlags1_8_FUN_004303a0
					(LevelData *level,BOOL unused,uint bx,uint by)
{
	WaterEntry *water;
	int idx;
	int width;
	
	if ((bx != 0) && (by != 0)) {
		width = (level->dimensions).width;
						// BLOCK1_UNK_8
						//  setting equate causes Ghidra to hang :(
		if ((bx < width - 2U) &&
			 ((by < (level->dimensions).height - 2U &&
				((*(byte *)&level->blocks[by * width + bx].flags1 & 8) != 0)))) {
			water = game::Water_Block_SubDestroyWall_AndDebug_WKey(bx,by,NULL);
			if (water != NULL) {
				idx = by * (level->dimensions).width + bx;
				level->blocks[idx].flags1 = level->blocks[idx].flags1 & ~BLOCK1_GROUND;
				idx = by * (level->dimensions).width + bx;
				level->blocks[idx].flags1 = level->blocks[idx].flags1 | BLOCK1_WALL_UNK;
				game::Level_BlockUpdateSurface(level,bx,by,0);
				game::Water_Block_Debug_WKey(bx,by);
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_DestroyWall(LevelData *level,uint bx,uint by,BOOL isHiddenCavern)
{
	int *piVar1;
	LevelBlock *pLVar2;
	short *psVar3;
	SurfaceMap *surfMap;
	int *piVar4;
	Point2I *pPVar5;
	TutorialFlags tutorialFlags;
	BOOL BVar6;
	uint uVar7;
	int iVar8;
	int iVar9;
	uint uVar10;
	InfoType infoType;
	Point2I local_50;
	Point2I local_48;
	Point2I ANGLES [8];
	uint bx_00;
	LevelBlockFlags1 flags1;
	LevelBlockFlags2 flags2;
	LevelBlockFlags1 *pFlags1;
	LevelBlockFlags2 *pFlags2;
	PredugType predug;
	TerrainType terrain;
	
	bx_00 = bx;
	surfMap = level->surfaceMap;
	ANGLES[0].x = 0;
	ANGLES[0].y = 0;
	ANGLES[1].x = 1;
	ANGLES[1].y = 0;
	ANGLES[2].x = 1;
	ANGLES[2].y = 1;
	ANGLES[3].x = 0;
	ANGLES[3].y = 1;
	if ((((bx == 0) || (by == 0)) || (iVar9 = (level->dimensions).width, iVar9 - 2U <= bx)) ||
		 (((level->dimensions).height - 2U <= by ||
			(pLVar2 = level->blocks + by * iVar9 + bx, (*(byte *)&pLVar2->flags1 & 8) != 0)))) {
		return 0;
	}
	if ((pLVar2->terrain == TERRAIN_ORESEAM) || (pLVar2->terrain == TERRAIN_CRYSTALSEAM)) {
		local_48.x = bx;
		local_48.y = by;
		pLVar2->float_14 = 0.0;
		pPVar5 = ANGLES;
		bx = 4;
		do {
			uVar7 = pPVar5->y + by;
			iVar9 = pPVar5->x;
			iVar8 = uVar7 * (level->dimensions).width + bx_00 + iVar9;
			if (level->blocks[iVar8].predug == PREDUG_WALL) {
				local_50.x = bx_00;
				local_50.y = by;
				level->blocks[iVar8].predug = PREDUG_EXPOSED|PREDUG_HIDDEN_SLUGHOLE;
				terrain = level->blocks[by * (level->dimensions).width + bx_00].terrain;
				if ((terrain == TERRAIN_ORESEAM) || (terrain == TERRAIN_CRYSTALSEAM)) {
					front::Info_Send(INFO_GENERICSEAMFOUND,NULL,NULL,&local_50);
				}
				terrain = level->blocks[by * (level->dimensions).width + bx_00].terrain;
				if (terrain == TERRAIN_ORESEAM) {
					infoType = INFO_ORESEAMFOUND;
				}
				else {
					if (terrain != TERRAIN_CRYSTALSEAM) goto LAB_00430c0d;
					infoType = INFO_CRYSTALSEAMFOUND;
				}
				front::Info_Send(infoType,NULL,NULL,&local_50);
			}
LAB_00430c0d:
			predug = level->blocks[uVar7 * (level->dimensions).width + bx_00 + iVar9].predug;
			if (predug != PREDUG_EXPOSED) {
				level->blocks[uVar7 * (level->dimensions).width + bx_00 + iVar9].predug =
						 predug + ~PREDUG_WALL;
				Map3D_Unk_ChangeWallDepth(surfMap,iVar9 + bx_00,uVar7,level->DigDepth * 0.25);
			}
			pPVar5 = pPVar5 + 1;
			bx -= 1;
		} while (bx != 0);
		Level_Block_FUN_00430d20(&local_48);
		psVar3 = &level->blocks[by * (level->dimensions).width + bx_00].short_22;
		*psVar3 = *psVar3 + 1;
		iVar9 = 4;
		if (level->blocks[by * (level->dimensions).width + bx_00].short_22 != 4) {
			Level_Block_LowerRoofVertices(globs::legoGlobs.level,bx_00,by);
			Construction_FlattenGround(&local_48);
			return 0;
		}
		level->blocks[by * (level->dimensions).width + bx_00].terrain = TERRAIN_SOIL;
		pPVar5 = ANGLES;
		do {
			piVar1 = &pPVar5->y;
			piVar4 = &pPVar5->x;
			pPVar5 = pPVar5 + 1;
			iVar9 += -1;
			level->blocks[(*piVar1 + by) * (level->dimensions).width + bx_00 + *piVar4].predug =
					 PREDUG_EXPOSED;
		} while (iVar9 != 0);
		Level_DestroyWall(level,bx_00,by,isHiddenCavern);
	}
	else {
		if (pLVar2->predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,bx,by,level->DigDepth);
			level->blocks[by * (level->dimensions).width + bx].predug = PREDUG_EXPOSED;
		}
		if (level->blocks[by * (level->dimensions).width + 1 + bx].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,bx + 1,by,level->DigDepth);
			level->blocks[by * (level->dimensions).width + 1 + bx].predug = PREDUG_EXPOSED;
		}
		uVar7 = by + 1;
		if (level->blocks[uVar7 * (level->dimensions).width + 1 + bx].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,bx + 1,uVar7,level->DigDepth);
			level->blocks[uVar7 * (level->dimensions).width + 1 + bx].predug = PREDUG_EXPOSED;
		}
		if (level->blocks[uVar7 * (level->dimensions).width + bx].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,bx,uVar7,level->DigDepth);
			level->blocks[uVar7 * (level->dimensions).width + bx].predug = PREDUG_EXPOSED;
		}
		ANGLES[0].x = -1;
		ANGLES[0].y = -1;
		ANGLES[1].y = -1;
		ANGLES[2].y = -1;
		ANGLES[3].x = -1;
		ANGLES[5].x = -1;
		pPVar5 = ANGLES;
		ANGLES[1].x = 0;
		ANGLES[2].x = 1;
		ANGLES[3].y = 0;
		ANGLES[4].x = 1;
		ANGLES[4].y = 0;
		ANGLES[5].y = 1;
		ANGLES[6].x = 0;
		ANGLES[6].y = 1;
		ANGLES[7].x = 1;
		ANGLES[7].y = 1;
		bx = 8;
		do {
			iVar9 = pPVar5->x;
			iVar8 = pPVar5->y + by;
			pFlags1 = &level->blocks[iVar8 * (level->dimensions).width + bx_00 + iVar9].flags1;
			flags1 = *pFlags1;
			if ((flags1 & BLOCK1_GROUND) == BLOCK1_NONE) {
				*pFlags1 = flags1 | BLOCK1_WALL_UNK;
				iVar9 = iVar8 * (level->dimensions).width + bx_00 + iVar9;
				level->blocks[iVar9].flags1 = level->blocks[iVar9].flags1 & ~BLOCK1_DESTROYEDCONNECTION_UNK;
			}
			pPVar5 = pPVar5 + 1;
			bx -= 1;
		} while (bx != 0);
		local_48.x = bx_00;
		local_48.y = by;
		pFlags1 = &level->blocks[by * (level->dimensions).width + bx_00].flags1;
		*pFlags1 = *pFlags1 | BLOCK1_GROUND;
		Level_Block_LevelStruct1C_DoActivityDestroy(level,&local_48,TRUE);
		iVar9 = by * (level->dimensions).width + bx_00;
		level->blocks[iVar9].flags1 = level->blocks[iVar9].flags1 & ~BLOCK1_REINFORCED;
		iVar9 = by * (level->dimensions).width + bx_00;
		level->blocks[iVar9].flags1 = level->blocks[iVar9].flags1 | BLOCK1_UNK_400000;
		flags1 = level->blocks[by * (level->dimensions).width + bx_00].flags1;
		if ((((flags1 & BLOCK1_EXPOSED) == BLOCK1_NONE) || ((flags1 & BLOCK1_HIDDEN) != BLOCK1_NONE)) &&
			 ((flags1 & BLOCK1_UNK_800000) != BLOCK1_NONE)) {
			reward::Rewards_WallDestroyed();
		}
		if (isHiddenCavern == 0) {
			uVar7 = by - 1;
			local_48.x = bx_00;
			local_48.y = by;
			if (uVar7 <= by + 1) {
				do {
					uVar10 = bx_00 - 1;
					if (uVar10 <= bx_00 + 1) {
						do {
						// if ((block->flags1 & BLOCK1_HIDDEN) != BLOCK1_NONE)
							if ((*(byte *)((int)&level->blocks[uVar7 * (level->dimensions).width + uVar10].flags1
														+ 2) & 2) != 0) {
								Level_UncoverHiddenCavern(uVar10,uVar7);
								tutorialFlags = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
								if (tutorialFlags == TUTORIAL_NONE) {
									front::Info_Send(INFO_CAVERNLOCATED,NULL,NULL,&local_48);
									front::Text_DisplayMessage(TEXT_CAVERNDISCOVERED,TRUE,FALSE);
									reward::Rewards_CavernDiscovered();
								}
							}
							uVar10 += 1;
						} while (uVar10 <= bx_00 + 1);
					}
					uVar7 += 1;
				} while (uVar7 <= by + 1);
			}
			iVar9 = ((globs::legoGlobs.level)->dimensions).width * by + bx_00;
			(globs::legoGlobs.level)->blocks[iVar9].flags1 =
					 (globs::legoGlobs.level)->blocks[iVar9].flags1 | BLOCK1_UNK_800;
			Message_AddMessageAction
								(MESSAGE_DIG_COMPLETE,0,
								 (uint)(globs::legoGlobs.level)->blocks
											 [((globs::legoGlobs.level)->dimensions).width * by + bx_00].field_3,&local_48
								);
			Water_Block_DestroyWallComplete(level,bx_00,by);
			local_50.x = bx_00;
			local_50.y = by;
			if (((((globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * by + bx_00].flags1 &
						BLOCK1_BUILDINGSOLID) == BLOCK1_NONE) &&
					((*(byte *)&(globs::legoGlobs.level)->blocks
											[((globs::legoGlobs.level)->dimensions).width * by + bx_00].flags2 & 4) == 0))
				 && ((((globs::legoGlobs.level)->blocks
							 [((globs::legoGlobs.level)->dimensions).width * by + bx_00].flags1 &
							BLOCK1_BUILDINGPATH) == BLOCK1_NONE &&
						 (BVar6 = Construction_BlockCheck_FUN_00408fd0(&local_50), BVar6 == 0)))) {
				iVar9 = ((globs::legoGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::legoGlobs.level)->blocks[iVar9].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar9].flags1 & ~BLOCK1_CLEARED_UNK;
				iVar9 = ((globs::legoGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::legoGlobs.level)->blocks[iVar9].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar9].flags1 & ~BLOCK1_PATH;
				iVar9 = ((globs::legoGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::legoGlobs.level)->blocks[iVar9].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar9].flags1 & ~BLOCK1_UNK_40000000;
				LiveManager_InitFlagsToggle_AndClearNumDrained();
				ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(&local_50);
				util::logf_removed((char *)&local_50);
				iVar9 = 4;
				do {
					ai::AITask_DoClear_AtPosition(&local_50,MESSAGE_CLEAR_COMPLETE);
					iVar9 += -1;
				} while (iVar9 != 0);
				iVar9 = ((globs::legoGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::legoGlobs.level)->blocks[iVar9].flags1 =
						 (globs::legoGlobs.level)->blocks[iVar9].flags1 | BLOCK1_RUBBLE_FULL;
			}
			front::Interface_BackToMain_IfSelectedWall_IsBlockPos(&local_50);
		}
		else {
			pFlags1 = &level->blocks[by * (level->dimensions).width + bx_00].flags1;
			*pFlags1 = *pFlags1 | BLOCK1_CLEARED_UNK;
		}
		local_48.x = bx_00;
		local_48.y = by;
		ai::AITask_Block_FUN_00402a10(&local_48,0);
		uVar7 = by - 1;
		if (uVar7 < by + 2) {
			do {
				uVar10 = bx_00 - 1;
				if (uVar10 < bx_00 + 2) {
					do {
						Level_BlockUpdateSurface(level,uVar10,uVar7,isHiddenCavern);
						uVar10 += 1;
					} while (uVar10 < bx_00 + 2);
				}
				uVar7 += 1;
			} while (uVar7 < by + 2);
		}
		iVar9 = by * (level->dimensions).width + bx_00;
		level->blocks[iVar9].flags1 = level->blocks[iVar9].flags1 & ~BLOCK1_UNK_800000;
		uVar7 = by - 1;
		if (uVar7 <= by + 2) {
			do {
				uVar10 = bx_00 - 1;
				if (uVar10 <= bx_00 + 2) {
					do {
						Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,uVar10,uVar7);
						uVar10 += 1;
					} while (uVar10 <= bx_00 + 2);
				}
				uVar7 += 1;
			} while (uVar7 <= by + 2);
		}
		if ((isHiddenCavern == 0) && ((globs::legoGlobs.flags2 & GAME2_GENERATESPIDERS) != GAME2_NONE))
		{
			uVar7 = SEXT24(level->blocks[by * (level->dimensions).width + bx_00].randomness);
			uVar10 = (int)uVar7 >> 0x1f;
						// if (positive modulus (block->randomness % 4) == 0)
			if (((uVar7 ^ uVar10) - uVar10 & 3 ^ uVar10) == uVar10) {
				Level_GenerateSmallSpiders(bx_00,by,(int)uVar7 % 0x549);
			}
		}
		local_50.x = bx_00;
		local_50.y = by;
		HiddenObject_ExposeBlock(&local_50);
		pFlags2 = &level->blocks[by * (level->dimensions).width + bx_00].flags2;
		flags2 = *pFlags2;
		if ((flags2 & BLOCK2_SLUGHOLE_HIDDEN) != BLOCK2_NONE) {
			*pFlags2 = flags2 & ~BLOCK2_SLUGHOLE_HIDDEN;
			iVar9 = by * (level->dimensions).width + bx_00;
			level->blocks[iVar9].flags2 = level->blocks[iVar9].flags2 | BLOCK2_SLUGHOLE_EXPOSED;
			Level_RegisterSlimySlugHole(&local_50);
			Level_BlockUpdateSurface(level,bx_00,by,0);
		}
		if (isHiddenCavern == 0) {
			front::Info_Send(INFO_WALLDUG,NULL,NULL,&local_50);
			return TRUE;
		}
	}
	return TRUE;
}



void __cdecl lego::game::Level_Block_FUN_00430d20(Point2I *blockPos)
{
	int idx;
	Point2I *pDir;
	uint i;
	Point2I local_28;
	Point2I DIRECTIONS [4];
	TerrainType terrain;
	int x;
	int y;
	
	i = 0;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = 1;
	y = blockPos->y;
	x = blockPos->x;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	pDir = DIRECTIONS;
	do {
		idx = (pDir->y + y) * ((globs::legoGlobs.level)->dimensions).width + x + pDir->x;
		if ((((*(byte *)&(globs::legoGlobs.level)->blocks[idx].flags1 & 8) != 0) &&
				(terrain = (globs::legoGlobs.level)->blocks[idx].terrain, terrain != TERRAIN_LAKE)) &&
			 (terrain != TERRAIN_LAVA)) break;
		i += 1;
		pDir = pDir + 1;
	} while (i < 4);
	if (i != 4) {
		local_28.y = DIRECTIONS[i].y + y;
		local_28.x = DIRECTIONS[i].x + x;
		terrain = (globs::legoGlobs.level)->blocks[y * ((globs::legoGlobs.level)->dimensions).width + x]
							.terrain;
		if (terrain == TERRAIN_ORESEAM) {
			Level_GenerateOre(&local_28,0,NULL,TRUE);
			return;
		}
		if (terrain == TERRAIN_CRYSTALSEAM) {
			Level_GenerateCrystal(&local_28,0,NULL,TRUE);
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_DestroyWallConnection(LevelData *level,uint bx,uint by)
{
	int *piVar1;
	LevelBlockFlags1 *pLVar2;
	int iVar3;
	uint uVar4;
	Point2I *pDir;
	int *piVar5;
	uint i;
	int iVar6;
	uint uVar7;
	Point2I local_28;
	Point2I DIRECTIONS [4];
	LevelBlock **pBlocks;
	Size2I *pDimensions;
	
	uVar4 = bx;
	local_28.x = (int)level->surfaceMap;
	DIRECTIONS[0].x = -1;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[1].x = 0;
	DIRECTIONS[1].y = -1;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = 0;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[3].y = 0;
	if ((((bx != 0) && (by != 0)) && (iVar6 = (level->dimensions).width, bx < iVar6 - 2U)) &&
		 (by < (level->dimensions).height - 2U)) {
		if (level->blocks[by * iVar6 + bx].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth((SurfaceMap *)local_28.x,bx,by,level->DigDepth);
			iVar6 = 4;
			level->blocks[by * (level->dimensions).width + bx].predug = PREDUG_EXPOSED;
			piVar5 = &DIRECTIONS[0].y;
			do {
				piVar1 = piVar5 + -1;
				iVar3 = *piVar5;
				piVar5 = piVar5 + 2;
				pLVar2 = &level->blocks[(by + iVar3) * (level->dimensions).width + *piVar1 + bx].flags1;
				iVar6 += -1;
				*pLVar2 = *pLVar2 | BLOCK1_DESTROYEDCONNECTION_UNK;
			} while (iVar6 != 0);
			for (i = by - 1; i <= by; i += 1) {
				for (uVar7 = bx - 1; uVar7 <= bx; uVar7 += 1) {
					Level_BlockUpdateSurface(level,uVar7,i,0);
				}
			}
			i = by - 1;
			if (i <= by + 1) {
				do {
					uVar7 = bx - 1;
					if (uVar7 <= bx + 1) {
						do {
							Map3D_SetFlags2_AndStruct28_SetFlag19_4((SurfaceMap *)local_28.x,uVar7,i);
							uVar7 += 1;
						} while (uVar7 <= bx + 1);
					}
					i += 1;
				} while (i <= by + 1);
			}
			pDimensions = &level->dimensions;
			pBlocks = &level->blocks;
			i = 0;
			DIRECTIONS[1].x = 1;
			DIRECTIONS[2].y = 1;
			local_28.x = bx;
			local_28.y = by;
			level = NULL;
			DIRECTIONS[0].x = 0;
			DIRECTIONS[0].y = -1;
			DIRECTIONS[1].y = 0;
			DIRECTIONS[2].x = 0;
			DIRECTIONS[3].x = -1;
			DIRECTIONS[3].y = 0;
			pDir = DIRECTIONS;
			do {
				if ((*pBlocks)[(pDir->y + by) * pDimensions->width + uVar4 + pDir->x].predug ==
						PREDUG_EXPOSED) {
					level = (LevelData *)((int)&level->levelName + 1);
					bx = i;
				}
				i += 1;
				pDir = pDir + 1;
			} while (i < 4);
			if (level == (LevelData *)0x1) {
				Message_AddMessageAction(MESSAGE_DIG_COMPLETE,0,bx - 2 & 3 | 0x10000,&local_28);
			}
			ai::AITask_Block_FUN_00402a10(&local_28,1);
		}
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Level_Block_RemoveReinforcement(Point2I *blockPos)
{
	LevelData *level;
	int iVar1;
	
	level = globs::legoGlobs.level;
	Level_Block_LevelStruct1C_DoActivityDestroy(globs::legoGlobs.level,blockPos,FALSE);
	iVar1 = (level->dimensions).width * blockPos->y + blockPos->x;
	level->blocks[iVar1].flags1 = level->blocks[iVar1].flags1 & ~BLOCK1_REINFORCED;
	Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
	return;
}



void __cdecl lego::game::Level_Block_Reinforce(int bx,int by)
{
	LevelData *level;
	Point2I blockPos;
	LevelBlockFlags1 flags1;
	LevelBlockFlags1 *pFlags1;
	
	level = globs::legoGlobs.level;
	pFlags1 = &(globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * by + bx].flags1;
	flags1 = *pFlags1;
	if (((flags1 & BLOCK1_WALL_UNK) != BLOCK1_NONE) &&
		 ((flags1 & (BLOCK1_REINFORCED|BLOCK1_CORNEROBTUSE|BLOCK1_CORNERINNER)) == BLOCK1_NONE)) {
		*pFlags1 = flags1 | BLOCK1_REINFORCED;
		Level_BlockUpdateSurface(level,bx,by,0);
		blockPos.x = bx;
		blockPos.y = by;
		res::Level_LevelStruct1C_Create_Res_Unk_RechargeSparkle(level,&blockPos,0);
		ai::AITask_Block_FUN_00402a60(&blockPos);
		front::Info_Send(INFO_WALLREINFORCED,NULL,NULL,&blockPos);
	}
	return;
}



void __cdecl
lego::res::Level_LevelStruct1C_Create_Res_Unk_RechargeSparkle
					(LevelData *level,Point2I *blockPos,BOOL bool18)
{
	int iVar1;
	LevelStruct_1c *pLVar2;
	Container *pCVar3;
	uint uVar4;
	LevelStruct_1c *pLVar5;
	float10 fVar6;
	float local_3c;
	float local_38;
	float local_34;
	float local_30 [4];
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pCVar3 = globs::legoGlobs.contRechargeSparkle;
	iVar1 = blockPos->y * (level->dimensions).width + blockPos->x;
	local_30[0] = 0.0;
	local_30[1] = 1.0;
	local_30[2] = 0.0;
	uVar4 = (uint)level->blocks[iVar1].field_3;
	local_30[3] = 1.0;
	local_20 = 0;
	local_1c = 0;
	local_18 = 0;
	local_14 = 0xbf800000;
	local_10 = 0;
	local_c = 0xbf800000;
	local_8 = 0;
	local_4 = 0;
	if (bool18 != 0) {
		pLVar2 = level->blocks[iVar1].struct1c_18;
		if (pLVar2 == NULL) {
			pLVar2 = (LevelStruct_1c *)std::malloc(0x1c);
			pLVar5 = pLVar2;
			for (iVar1 = 7; iVar1 != 0; iVar1 += -1) {
				pLVar5->resData = NULL;
				pLVar5 = (LevelStruct_1c *)&pLVar5->blockPos;
			}
			pLVar2->bool_18 = bool18;
			pCVar3 = Container_Clone(pCVar3);
			pLVar2->resData = pCVar3;
			if (pLVar2->bool_18 == 0) {
				Container_SetActivity(pCVar3,"Activity_Build");
			}
			Container_SetAnimationTime(pLVar2->resData,0.0);
			(pLVar2->blockPos).x = blockPos->x;
						// (pLVar2->blockPos).y = blockPos->y;  WTF Ghidra
			*(int *)&pLVar2->blockPos = blockPos->y;
			pLVar2->next = NULL;
			pLVar5 = level->terrain1c_88;
			pLVar2->previous = pLVar5;
			if (pLVar5 != NULL) {
				pLVar5->next = pLVar2;
			}
			level->terrain1c_88 = pLVar2;
			level->blocks[blockPos->y * (level->dimensions).width + blockPos->x].struct1c_18 = pLVar2;
		}
		game::Map3D_BlockToWorldPos(level->surfaceMap,blockPos->x,blockPos->y,&local_3c,&local_38);
		fVar6 = game::Map3D_GetWorldZ(level->surfaceMap,local_3c,local_38);
		local_34 = (float)fVar6;
		Container_SetPosition(pLVar2->resData,NULL,local_3c,local_38,local_34);
		Container_SetOrientation
							(pLVar2->resData,NULL,local_30[uVar4 * 3],local_30[uVar4 * 3 + 1],
							 local_30[uVar4 * 3 + 2],0.0,0.0,-1.0);
	}
	return;
}



void __cdecl lego::game::Level_LevelStruct1C_FUN_004312e0(LevelData *level,float elapsedGame)
{
	byte bVar1;
	LevelStruct_1c *pLVar2;
	LevelStruct_1c *pLVar3;
	float10 fVar4;
	
	pLVar2 = level->terrain1c_88;
	while (pLVar3 = pLVar2, pLVar3 != NULL) {
		pLVar2 = pLVar3->previous;
		fVar4 = res::Container_MoveAnimation(pLVar3->resData,elapsedGame);
		if (pLVar3->bool_18 == 0) {
			bVar1 = *(byte *)&pLVar3->flags;
			if (((bVar1 & 1) == 0) && ((float)fVar4 != 0.0)) {
				*(byte *)&pLVar3->flags = bVar1 | 1;
				res::Container_SetActivity(pLVar3->resData,"Activity_Stand");
			}
			else {
				if ((bVar1 & 2) == 0) {
					if (((bVar1 & 4) != 0) && ((float)fVar4 != 0.0)) {
						*(byte *)&pLVar3->flags = bVar1 | 2;
					}
				}
				else {
					Level_Remove_LevelStruct1C_AndFree(pLVar3);
				}
			}
		}
	}
	return;
}



void __cdecl
lego::game::Level_Block_LevelStruct1C_DoActivityDestroy
					(LevelData *level,Point2I *blockPos,BOOL requireNotBool18)
{
	LevelStruct_1c *pLVar1;
	
	pLVar1 = level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].struct1c_18;
	if (pLVar1 != NULL) {
		if ((requireNotBool18 == 0) && (pLVar1->bool_18 == 0)) {
			res::Container_SetActivity(pLVar1->resData,"Activity_Destroy");
			res::Container_SetAnimationTime(pLVar1->resData,0.0);
			*(byte *)&pLVar1->flags = *(byte *)&pLVar1->flags | 4;
			return;
		}
		*(byte *)&pLVar1->flags = *(byte *)&pLVar1->flags | 2;
	}
	return;
}



void __cdecl lego::game::Level_Remove_LevelStruct1C_AndFree(LevelStruct_1c *param_1)
{
	LevelData *level;
	
	level = globs::legoGlobs.level;
	res::Container_Remove(param_1->resData);
	level->blocks[(param_1->blockPos).y * (level->dimensions).width + (param_1->blockPos).x].
	struct1c_18 = NULL;
	if (param_1->next == NULL) {
		level->terrain1c_88 = param_1->previous;
	}
	else {
		param_1->next->previous = param_1->previous;
	}
	if (param_1->previous != NULL) {
		param_1->previous->next = param_1->next;
	}
	std::free(param_1);
	return;
}



void __cdecl lego::game::Level_FreeAll_LevelStruct1Cs_FUN_00431460(LevelData *level)
{
	LevelStruct_1c *pLVar1;
	LevelStruct_1c *pLVar2;
	
	pLVar2 = level->terrain1c_88;
	while (pLVar2 != NULL) {
		pLVar1 = pLVar2->previous;
		Level_Remove_LevelStruct1C_AndFree(pLVar2);
		pLVar2 = pLVar1;
	}
	return;
}



LevelData * __cdecl lego::lrr::Lego_GetLevel(void)
{
	return globs::legoGlobs.level;
}



SurfaceMap * __cdecl lego::lrr::Lego_GetMap(void)
{
	LevelData *pLVar1;
	
	pLVar1 = Lego_GetLevel();
	return pLVar1->surfaceMap;
}



void __cdecl lego::game::Level_UncoverHiddenCavern(uint bx,uint by)
{
	uint uVar1;
	float fVar2;
	float fVar3;
	LevelData *level;
	float *pfVar4;
	int iVar5;
	uint uVar6;
	uint by_00;
	uint uVar7;
	int iVar8;
	float *pfVar9;
	longlong lVar10;
	uint local_2c;
	int local_10 [2];
	float *local_8 [2];
	uint bx_00;
	
	level = globs::legoGlobs.level;
	iVar8 = ((globs::legoGlobs.level)->dimensions).height +
					((globs::legoGlobs.level)->dimensions).width;
	local_10[0] = 0;
	local_10[1] = 0;
	uVar7 = 0;
	pfVar4 = (float *)std::malloc(iVar8 * 0x20);
	local_8[0] = pfVar4;
	if (pfVar4 != NULL) {
		local_8[1] = pfVar4 + iVar8 * 4;
		*pfVar4 = (float)(ulonglong)bx;
		bx = (uint)local_10;
		local_10[0] = 1;
		iVar8 = 0;
		pfVar4[1] = (float)(ulonglong)by;
		do {
			local_2c = 0;
			if (*(int *)bx != 0) {
				pfVar9 = *(float **)((int)local_8 + iVar8);
				do {
					fVar2 = pfVar9[1];
					fVar3 = *pfVar9;
					lVar10 = __ftol((float10)fVar2);
					by_00 = (int)lVar10 - 1;
					iVar8 = (int)lVar10 + 1;
					if ((int)by_00 <= iVar8) {
						lVar10 = __ftol((float10)fVar3);
						uVar1 = (int)lVar10 - 1;
						bx_00 = uVar1;
						do {
							for (; (int)bx_00 <= (int)lVar10 + 1; bx_00 = bx_00 + 1) {
								if ((level->blocks[by_00 * (level->dimensions).width + bx_00].flags1 & BLOCK1_HIDDEN
										) != BLOCK1_NONE) {
									Level_DestroyWall(level,bx_00,by_00,TRUE);
									iVar5 = by_00 * (level->dimensions).width + bx_00;
									level->blocks[iVar5].flags1 = level->blocks[iVar5].flags1 & ~BLOCK1_HIDDEN;
									if ((fVar3 != (float)bx_00) || ((float)by_00 != fVar2)) {
										uVar6 = (uint)(uVar7 == 0);
										iVar5 = local_10[uVar6];
										pfVar4 = local_8[uVar6];
										pfVar4[iVar5 * 2] = (float)bx_00;
										local_10[uVar6] = iVar5 + 1;
										pfVar4[iVar5 * 2 + 1] = (float)by_00;
									}
								}
							}
							by_00 += 1;
							bx_00 = uVar1;
						} while ((int)by_00 <= iVar8);
					}
					local_2c += 1;
					pfVar9 = pfVar9 + 2;
					pfVar4 = local_8[0];
				} while (local_2c < *(uint *)bx);
			}
			uVar7 = (uint)(uVar7 == 0);
			*(undefined4 *)bx = 0;
			iVar8 = uVar7 * 4;
			bx = (uint)(local_10 + uVar7);
		} while (local_10[uVar7] != 0);
		std::free(pfVar4);
	}
	return;
}



void __cdecl lego::game::Game_PTL_RockFall(uint bx,uint by,int param_3,BOOL param_4)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlock *pLVar2;
	int iVar3;
	BOOL BVar4;
	float *pfVar5;
	bool bVar6;
	float10 fVar7;
	float10 extraout_ST0;
	longlong lVar8;
	longlong lVar9;
	float dirX;
	float fVar10;
	float local_40;
	undefined4 uStack60;
	uint local_38;
	float local_34;
	undefined4 uStack48;
	Vector3F local_2c;
	float local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uStack60 = 0;
	fVar7 = (float10)(ulonglong)by;
	uStack48 = 0;
	local_38 = 0;
	local_34 = (float)(ulonglong)bx;
	pLVar2 = (globs::legoGlobs.level)->blocks;
	iVar3 = ((globs::legoGlobs.level)->dimensions).width;
	local_20[0] = 1.0;
	local_20[1] = 0.0;
	local_20[2] = 0.0;
	local_20[3] = 1.0;
	local_20[4] = -1.0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0xbf800000;
	pfVar5 = local_20;
						// local_40 = 4;
	local_40 = 5.605194e-45;
	do {
		*pfVar5 = local_34 + *pfVar5;
		fVar10 = pfVar5[1];
		pfVar5[1] = (float)(fVar7 + (float10)fVar10);
		lVar8 = __ftol(fVar7 + (float10)fVar10);
		lVar9 = __ftol((float10)*pfVar5);
		if ((*(byte *)&pLVar2[iVar3 * (int)lVar8 + (int)lVar9].flags1 & 8) != 0) {
			local_38 += 1;
		}
		pfVar5 = pfVar5 + 2;
		local_40 = (float)((int)local_40 + -1);
		fVar7 = extraout_ST0;
	} while (local_40 != 0.0);
	if ((float)param_4 == 0.0) {
		Map3D_BlockToWorldPos((globs::legoGlobs.level)->surfaceMap,bx,by,&local_40,(float *)&param_4);
	}
	else {
		Map3D_BlockVertexToWorldPos
							((globs::legoGlobs.level)->surfaceMap,bx,by,&local_40,(float *)&param_4,&local_34);
	}
	local_2c.y = (float)param_4;
	local_2c.x = local_40;
	fVar7 = Map3D_GetWorldZ((globs::legoGlobs.level)->surfaceMap,local_40,(float)param_4);
	local_2c.z = (float)fVar7;
	res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_ROCKBREAK,0,0,&local_2c);
	bVar6 = 1 < local_38;
	local_20[0] = 0.0;
	local_20[1] = 1.0;
	local_20[2] = 1.0;
	local_20[3] = 0.0;
	local_20[4] = 0.0;
	local_c = 0xbf800000;
	local_8 = 0xbf800000;
	local_4 = 0;
	fVar10 = local_20[param_3 * 2 + 1];
	dirX = local_20[param_3 * 2];
	fVar7 = Map3D_GetWorldZ((globs::legoGlobs.level)->surfaceMap,local_40,(float)param_4);
	BVar4 = effect::Effect_Spawn_RockFall((uint)bVar6,bx,by,local_40,param_4,(float)fVar7,dirX,fVar10)
	;
	if (BVar4 != 0) {
		pLVar1 = &(globs::legoGlobs.level)->blocks
							[((globs::legoGlobs.level)->dimensions).width * by + bx].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_800;
	}
	return;
}



SurfaceType __cdecl lego::lrr::Lego_GetBlockTerrain(int bx,int by)
{
	return (uint)(globs::legoGlobs.level)->blocks
							 [((globs::legoGlobs.level)->dimensions).width * by + bx].terrain;
}



uint __cdecl lego::game::MapShared_GetBlock(uint memHandle,int bx,int by)
{
	MapFileInfo *mapFile;
	uint local_4;
	uint sharedIndex_00;
	
	sharedIndex_00 = memHandle;
	mapFile = (MapFileInfo *)lego::file::Mem_AddressHandle(memHandle);
	MapShared_GetDimensions(sharedIndex_00,&memHandle,&local_4);
	return (uint)mapFile->blocks[memHandle * by + bx];
}



BOOL __cdecl
lego::game::Level_FindSelectedUnit_BlockCheck_FUN_00431960(uint bx,uint by,BOOL param_3)
{
	LiveObject **pLiveObj;
	BOOL BVar1;
	uint local_8;
	uint numSelected;
	
	pLiveObj = Message_GetSelectedUnits2(&numSelected);
	if ((pLiveObj != NULL) && (local_8 = 0, numSelected != 0)) {
		do {
			BVar1 = LiveObject_BlockCheck_FUN_004326a0(*pLiveObj,bx,by,param_3,TRUE);
			if (BVar1 != 0) {
				return TRUE;
			}
			local_8 += 1;
			pLiveObj = pLiveObj + 1;
		} while (local_8 < numSelected);
		return 0;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_FindSelectedLiveObject_BlockReinforce_FUN_004319e0(uint bx,uint by)
{
	LiveObject **ppLVar1;
	BOOL BVar2;
	uint uVar3;
	uint local_4;
	
	ppLVar1 = Message_GetSelectedUnits2(&local_4);
	if ((ppLVar1 != NULL) && (uVar3 = 0, local_4 != 0)) {
		do {
			BVar2 = LiveObject_CanReinforceBlock(*ppLVar1,bx,by);
			if (BVar2 != 0) {
				return TRUE;
			}
			uVar3 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar3 < local_4);
		return 0;
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_BlockCheck_SelectPlace_FUN_00431a50(int bx,int by,BOOL param_3,BOOL param_4)
{
	int idx;
	BOOL BVar1;
	Point2I *pDir;
	uint i;
	Point2I blockPos;
	Point2I DIRECTIONS [4];
	LevelBlock *block;
	LevelBlockFlags1 flags1;
	
	blockPos.y = by;
	idx = ((globs::legoGlobs.level)->dimensions).width * by + bx;
	blockPos.x = bx;
	block = (globs::legoGlobs.level)->blocks + idx;
	if ((*(byte *)&(globs::legoGlobs.level)->blocks[idx].flags2 & BLOCK2_SLUGHOLE_EXPOSED) == 0) {
		BVar1 = Construction_BlockCheck_FUN_00408fd0(&blockPos);
		if ((BVar1 == 0) && (flags1 = block->flags1, (flags1 & BLOCK1_PATH) == BLOCK1_NONE)) {
			i = 0;
			if (((param_3 == 0) || ((param_4 == 0 || (block->terrain == TERRAIN_LAKE)))) &&
				 (((param_3 == 0 || ((flags1 & BLOCK1_BUILDINGPATH) == BLOCK1_NONE)) &&
					((((param_4 != 0 || (block->terrain != TERRAIN_LAKE)) && (block->terrain != TERRAIN_LAVA))
					 && ((((flags1 & BLOCK1_GROUND) != BLOCK1_NONE &&
								((flags1 & BLOCK1_CLEARED_UNK) != BLOCK1_NONE)) &&
							 ((flags1 & (BLOCK1_BUILDINGSOLID|BLOCK1_BUILDINGPATH|BLOCK1_FOUNDATION)) ==
								BLOCK1_NONE)))))))) {
				BVar1 = ElectricFence_Block_IsFence(bx,by);
				if (BVar1 == 0) {
					DIRECTIONS[0].y = -1;
					DIRECTIONS[3].x = -1;
					DIRECTIONS[0].x = 0;
					DIRECTIONS[1].x = 1;
					DIRECTIONS[1].y = 0;
					DIRECTIONS[2].x = 0;
					DIRECTIONS[2].y = 1;
					DIRECTIONS[3].y = 0;
					pDir = DIRECTIONS;
					while ((globs::legoGlobs.level)->blocks
								 [(pDir->y + by) * ((globs::legoGlobs.level)->dimensions).width + bx + pDir->x].
								 terrain != TERRAIN_RECHARGESEAM) {
						i += 1;
						pDir = pDir + 1;
						if (3 < i) {
							return TRUE;
						}
					}
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00431ba0
					(LiveObject *liveObj,Point2I *param_2,Point2I *out_point,BOOL param_4)
{
	LevelBlockFlags1 LVar1;
	bool bVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	int bx1;
	LevelData *pLVar6;
	uint uVar7;
	uint local_24;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 0xffffffff;
	local_8 = 0xffffffff;
						// static variable used only in this function
	globs::gamectrlGlobs.direction_178 += DIRECTION_RIGHT;
	local_20[0] = 0;
	local_20[2] = 1;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 1;
	local_4 = 0;
	local_24 = 0;
	pLVar6 = globs::legoGlobs.level;
	do {
		uVar7 = globs::gamectrlGlobs.direction_178 + local_24 & 3;
		if (param_4 == 0) {
LAB_00431c58:
			iVar4 = local_20[uVar7 * 2 + 1] + param_2->y;
			bx1 = local_20[uVar7 * 2] + param_2->x;
			iVar4 = LiveObject_Routing_GetCrossTerrainType(liveObj,bx1,iVar4,bx1,iVar4,0);
			pLVar6 = globs::legoGlobs.level;
			if (iVar4 != 0) {
				iVar4 = local_20[uVar7 * 2 + 1];
				out_point->x = local_20[uVar7 * 2] + param_2->x;
				out_point->y = iVar4 + param_2->y;
				return TRUE;
			}
		}
		else {
			uVar5 = local_20[uVar7 * 2] + param_2->x;
			iVar4 = (pLVar6->dimensions).width;
			uVar3 = local_20[uVar7 * 2 + 1] + param_2->y;
			if ((((uVar5 < iVar4 - 1U) && (uVar3 < (pLVar6->dimensions).height - 1U)) &&
					(LVar1 = pLVar6->blocks[uVar3 * iVar4 + uVar5].flags1,
					(LVar1 & BLOCK1_WALL_UNK) != BLOCK1_NONE)) && ((LVar1 & BLOCK1_GROUND) == BLOCK1_NONE)) {
				bVar2 = true;
			}
			else {
				bVar2 = false;
			}
			if (!bVar2) goto LAB_00431c58;
		}
		local_24 += 1;
		if (3 < local_24) {
			return 0;
		}
	} while( true );
}



int __cdecl
lego::game::LiveObject_Routing_GetCrossTerrainType
					(LiveObject *in_liveObj,int bx1,int by1,int bx2,int by2,BOOL param_6)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	int iVar3;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar4;
	int *pDirY;
	ObjectStatsFlags3 OVar5;
	ObjectStatsFlags2 OVar6;
	BOOL BVar7;
	int iVar8;
	BOOL checkWater;
	LevelBlockFlags1 LVar9;
	BOOL checkLava;
	BOOL checkLand;
	BOOL checkEnterToolStore;
	BOOL checkSingleWidthDig;
	Point2I blockPos;
	Point2I DIRECTIONS [4];
	LevelBlock *block1_b;
	LevelBlock *blocksGrid;
	int by1_00;
	LevelData *level;
	
	by1_00 = by1;
	liveObj = in_liveObj;
	level = globs::legoGlobs.level;
	iVar1 = ((globs::legoGlobs.level)->dimensions).width;
	blocksGrid = (globs::legoGlobs.level)->blocks;
	checkWater = 0;
	checkLand = TRUE;
	checkLava = 0;
	checkEnterToolStore = 0;
	block1_b = blocksGrid + by1 * iVar1 + bx1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	by1 = 1;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[3].y = 0;
	if (((in_liveObj != NULL) &&
			(OVar4 = stats::StatsObject_GetStatsFlags1(in_liveObj),
			(OVar4 & STATS1_CANBEDRIVEN) != STATS1_NONE)) && (in_liveObj->drivenObject == NULL)) {
		return 0;
	}
	in_liveObj = NULL;
	pDirY = &DIRECTIONS[0].y;
	do {
		if ((pDirY[-1] + bx2 == bx1) && (by2 + *pDirY == by1_00)) break;
		pDirY = pDirY + 2;
		in_liveObj = (LiveObject *)((int)&in_liveObj->objType + 1);
	} while (in_liveObj < (LiveObject *)&DAT_00000004);
	if (liveObj == NULL) {
		checkSingleWidthDig = 0;
	}
	else {
		if (liveObj->objType == OBJECT_ELECTRICFENCE) {
			return 0;
		}
		OVar5 = stats::StatsObject_GetStatsFlags3(liveObj);
		checkEnterToolStore = OVar5 & STATS3_ENTERTOOLSTORE;
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		checkSingleWidthDig = OVar4 & STATS1_SINGLEWIDTHDIG;
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		checkWater = OVar4 & STATS1_CROSSWATER;
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		checkLand = OVar4 & STATS1_CROSSLAND;
		OVar6 = stats::StatsObject_GetStatsFlags2(liveObj);
		checkLava = OVar6 & STATS2_CROSSLAVA;
		if (((param_6 == 0) &&
				(BVar7 = LiveObject_GetBlockPos(liveObj,&blockPos.x,&blockPos.y), BVar7 != 0)) &&
			 ((bx1 == blockPos.x && (by1_00 == blockPos.y)))) {
			return 1;
		}
	}
	if (block1_b->terrain == TERRAIN_LAKE) {
		if (checkWater == STATS1_NONE) {
			return 0;
		}
		if (true) goto LAB_00431ea3;
	}
	if (checkLand == 0) {
		return 0;
	}
LAB_00431ea3:
	if (((block1_b->terrain == TERRAIN_LAVA) && (checkLava == STATS2_NONE)) &&
		 ((block1_b->flags1 & BLOCK1_UNK_200) == BLOCK1_NONE)) {
		return 0;
	}
	LVar2 = block1_b->flags1;
	if ((LVar2 & BLOCK1_BUILDINGSOLID) != BLOCK1_NONE) {
		return 0;
	}
	if ((param_6 != 0) && ((LVar2 & BLOCK1_CORNEROBTUSE) != BLOCK1_NONE)) {
		return 0;
	}
	if ((checkEnterToolStore == 0) && ((*(byte *)&block1_b->flags2 & 4) != 0)) {
		return 0;
	}
	if (checkSingleWidthDig == 0) {
		if ((LVar2 & BLOCK1_GROUND) == BLOCK1_NONE) {
			return 0;
		}
	}
	else {
		if ((LVar2 & BLOCK1_WALL_UNK) != BLOCK1_NONE) {
			by1 = 3;
		}
		if (block1_b->predug == PREDUG_WALL) {
			return 0;
		}
		iVar3 = (level->dimensions).width;
		block1_b = level->blocks;
		iVar8 = by1_00 * iVar3 + bx1;
		LVar9 = block1_b[iVar8].flags1 & BLOCK1_WALL_UNK;
		if (LVar9 != BLOCK1_NONE) {
			if ((block1_b + iVar8)[-1].terrain == TERRAIN_LAVA) {
				return 0;
			}
			if (block1_b[(by1_00 + -1) * iVar3 + bx1].terrain == TERRAIN_LAVA) {
				return 0;
			}
		}
		if (LVar9 != BLOCK1_NONE) {
			if ((block1_b + iVar8)[-1].terrain == TERRAIN_WATER_unused) {
				return 0;
			}
			if (block1_b[(by1_00 + -1) * iVar3 + bx1].terrain == TERRAIN_WATER_unused) {
				return 0;
			}
		}
		if (in_liveObj == NULL) {
			if ((LVar2 & BLOCK1_UNK_2000) != BLOCK1_NONE) {
				by1 = 2;
			}
			if ((blocksGrid[by2 * iVar1 + bx2].flags1 & BLOCK1_UNK_2000) != BLOCK1_NONE) {
				by1 = 2;
			}
		}
	}
	if ((bx2 != bx1) && (by2 != by1_00)) {
		iVar1 = (level->dimensions).width;
		if (((*(byte *)&level->blocks[by2 * iVar1 + bx1].flags1 & 8) != 0) &&
			 ((*(byte *)&level->blocks[by1_00 * iVar1 + bx2].flags1 & 8) != 0)) {
			return 2;
		}
	}
	return by1;
}



void __cdecl lego::game::Level_Block_SetPowered_AddToTable(Point2I *blockPos)
{
	LevelData *level;
	LevelBlockFlags2 *flags2;
	
	level = globs::legoGlobs.level;
	flags2 = &(globs::legoGlobs.level)->blocks
						[((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2;
	*flags2 = *flags2 | BLOCK2_POWERED;
	globs::legoGlobs.points2x100_78c[globs::legoGlobs.pointsCount2_dcc[0]].x = blockPos->x;
	globs::legoGlobs.points2x100_78c[globs::legoGlobs.pointsCount2_dcc[0]].y = blockPos->y;
	globs::legoGlobs.pointsCount2_dcc[0] += 1;
	Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
	return;
}



BOOL __cdecl lego::game::Level_Block_IsPowered(Point2I *blockPos)
{
	return (globs::legoGlobs.level)->blocks
				 [blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].flags2 &
				 BLOCK2_POWERED;
}



void __cdecl lego::game::Game_UpdateLevelBlocks_PointsAAC(void)
{
	int by;
	int bx;
	LevelData *level;
	uint uVar1;
	Point2I (*paPVar2) [100];
	
	level = globs::legoGlobs.level;
	uVar1 = 0;
	if (globs::legoGlobs.pointsCount2_dcc[1] != 0) {
		paPVar2 = globs::legoGlobs.points2x100_78c[1];
		do {
			by = (*paPVar2)[0].y;
			bx = (*paPVar2)[0].x;
			if ((*(byte *)((int)&level->blocks[(level->dimensions).width * by + bx].flags2 + 1) & 1) == 0)
			{
				Level_BlockUpdateSurface(level,bx,by,0);
			}
			uVar1 += 1;
			paPVar2 = (Point2I (*) [100])(*paPVar2 + 1);
		} while (uVar1 < globs::legoGlobs.pointsCount2_dcc[1]);
	}
	globs::legoGlobs.pointsCount2_dcc[1] = 0;
	return;
}



void __cdecl lego::game::Game_LevelClearBlockFlag2_100_Points28C(void)
{
	LevelBlockFlags2 *pLVar1;
	Point2I *pPVar2;
	Point2I *pPVar3;
	Point2I (*paPVar4) [100];
	uint uVar5;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	uVar5 = 0;
	globs::legoGlobs.pointsCount2_dcc[1] = globs::legoGlobs.pointsCount2_dcc[0];
	if (globs::legoGlobs.pointsCount2_dcc[0] != 0) {
		paPVar4 = globs::legoGlobs.points2x100_78c;
		do {
			paPVar4[1][0].x = (*paPVar4)[0].x;
			paPVar4[1][0].y = (*paPVar4)[0].y;
			pPVar2 = *paPVar4;
			pPVar3 = *paPVar4;
			paPVar4 = (Point2I (*) [100])(*paPVar4 + 1);
			pLVar1 = &level->blocks[pPVar2->y * (level->dimensions).width + pPVar3->x].flags2;
			uVar5 += 1;
			*pLVar1 = *pLVar1 & ~BLOCK2_POWERED;
			globs::legoGlobs.pointsCount2_dcc[1] = globs::legoGlobs.pointsCount2_dcc[0];
		} while (uVar5 < globs::legoGlobs.pointsCount2_dcc[0]);
	}
	globs::legoGlobs.pointsCount2_dcc[0] = 0;
	return;
}



void __cdecl lego::game::Level_Block_AddPowerPathDrainTemp_ToTable_Unk(Point2I *blockPos)
{
	LevelBlockFlags2 *pLVar1;
	
	pLVar1 = &(globs::legoGlobs.level)->blocks
						[((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2;
	*pLVar1 = *pLVar1 | BLOCK2_UNK_2;
	globs::legoGlobs.blockPts_468[globs::legoGlobs.blockPtsCount_788].x = blockPos->x;
	globs::legoGlobs.blockPts_468[globs::legoGlobs.blockPtsCount_788].y = blockPos->y;
	globs::legoGlobs.blockPtsCount_788 = globs::legoGlobs.blockPtsCount_788 + 1;
	return;
}



BOOL __cdecl lego::game::Level_Block_IsPowerPathDrainTemp_Unk(Point2I *blockPos)
{
	return (globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2 &
				 BLOCK2_UNK_2;
}



void __cdecl lego::game::Game_UnkProcessBlockPtsTable_UnsetsFlag2_2(void)
{
	int *piVar1;
	int *piVar2;
	Point2I *pBlockPos;
	uint i;
	LevelData *level;
	LevelBlockFlags2 *pFlags2;
	
	level = globs::legoGlobs.level;
	i = 0;
	if (globs::legoGlobs.blockPtsCount_788 != 0) {
		pBlockPos = globs::legoGlobs.blockPts_468;
		do {
			piVar1 = &pBlockPos->y;
			piVar2 = &pBlockPos->x;
			pBlockPos = pBlockPos + 1;
			pFlags2 = &level->blocks[*piVar1 * (level->dimensions).width + *piVar2].flags2;
			i += 1;
			*pFlags2 = *pFlags2 & ~BLOCK2_UNK_2;
		} while (i < globs::legoGlobs.blockPtsCount_788);
	}
	globs::legoGlobs.blockPtsCount_788 = 0;
	return;
}



void __cdecl
lego::game::Level_Block_UnsetFlags1_108400PwrPath_AndUnsetFlags2_4_UpdateSurface(Point2I *blockPos)
{
	LevelData *level;
	LevelBlockFlags2 *pFlags2;
	LevelBlockFlags1 *pFlags1;
	
	level = globs::legoGlobs.level;
	pFlags1 = &(globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1;
	*pFlags1 = *pFlags1 & ~(BLOCK1_BUILDINGSOLID|BLOCK1_BUILDINGPATH|BLOCK1_FOUNDATION|BLOCK1_PATH);
	pFlags2 = &level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].flags2;
	*pFlags2 = *pFlags2 & ~BLOCK2_TOOLSTORE_UNK;
	Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
	return;
}



void __cdecl lego::game::Level_Block_UnsetGeneratePower(Point2I *blockPos)
{
	LevelBlockFlags2 *pFlags2;
	
	pFlags2 = &(globs::legoGlobs.level)->blocks
						 [blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].flags2;
	*pFlags2 = *pFlags2 & ~BLOCK2_GENERATEPOWER;
	return;
}



void __cdecl lego::game::Level_Block_SetToolStoreBuilding(Point2I *blockPos)
{
	LevelData *level;
	LevelBlockFlags1 *pFlags1;
	LevelBlockFlags2 *pFlags2;
	
	level = globs::legoGlobs.level;
	pFlags1 = &(globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1;
	*pFlags1 = *pFlags1 | (BLOCK1_BUILDINGPATH|BLOCK1_FOUNDATION);
	pFlags2 = &level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].flags2;
	*pFlags2 = *pFlags2 | BLOCK2_TOOLSTORE_UNK;
	Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
	return;
}



void __cdecl lego::game::Level_Block_SetSolidBuilding(int bx,int by)
{
	LevelData *level;
	LevelBlockFlags1 *pFlags1;
	
	level = globs::legoGlobs.level;
	pFlags1 = &(globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * by + bx].flags1;
	*pFlags1 = *pFlags1 | (BLOCK1_BUILDINGSOLID|BLOCK1_FOUNDATION);
	Level_BlockUpdateSurface(level,bx,by,0);
	return;
}



void __cdecl lego::game::Level_Block_SetPathBuilding(int bx,int by)
{
	LevelData *level;
	LevelBlockFlags1 *pFlags1;
	
	level = globs::legoGlobs.level;
	pFlags1 = &(globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * by + bx].flags1;
	*pFlags1 = *pFlags1 | (BLOCK1_BUILDINGPATH|BLOCK1_FOUNDATION|BLOCK1_PATH);
	Level_BlockUpdateSurface(level,bx,by,0);
	return;
}



void __cdecl lego::game::Level_Block_SetFenceRequest(int bx,int by,BOOL state)
{
	int idx;
	int width;
	LevelBlockFlags2 *pFlags2;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if (state != 0) {
		pFlags2 = &(globs::legoGlobs.level)->blocks[width * by + bx].flags2;
		*pFlags2 = *pFlags2 | BLOCK2_FENCEREQUEST;
		return;
	}
	idx = width * by + bx;
	(globs::legoGlobs.level)->blocks[idx].flags2 =
			 (globs::legoGlobs.level)->blocks[idx].flags2 & ~BLOCK2_FENCEREQUEST;
	return;
}



BOOL __cdecl lego::game::Level_Block_IsFenceRequest(int bx,int by)
{
	return (globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * by + bx].
				 flags2 & BLOCK2_FENCEREQUEST;
}



// Some originally optional functionality, always returns TRUE.

BOOL __cdecl lego::game::Level_IsBuildPathBoolUnk_true(Point2I *blockPos)
{
	return TRUE;
}



void __cdecl lego::game::Level_Block_SetLayedPath(Point2I *blockPos,BOOL state)
{
	LevelData *level;
	LevelBlockFlags1 *pFlags1;
	LevelBlockFlags1 flags1;
	int width;
	
	level = globs::legoGlobs.level;
	width = ((globs::legoGlobs.level)->dimensions).width;
	if (state == 0) {
		pFlags1 = &(globs::legoGlobs.level)->blocks[width * blockPos->y + blockPos->x].flags1;
		flags1 = *pFlags1 & ~BLOCK1_UNK_40000000;
	}
	else {
		pFlags1 = &(globs::legoGlobs.level)->blocks[width * blockPos->y + blockPos->x].flags1;
		flags1 = *pFlags1 | BLOCK1_UNK_40000000;
	}
	*pFlags1 = flags1;
	Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
	return;
}



void __cdecl lego::game::Level_Block_SetGeneratePower(Point2I *blockPos)
{
	LevelBlockFlags2 *pFlags2;
	
	pFlags2 = &(globs::legoGlobs.level)->blocks
						 [blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].flags2;
	*pFlags2 = *pFlags2 | BLOCK2_GENERATEPOWER;
	return;
}



// Also updates path connections... I think.

BOOL __cdecl lego::game::Level_Block_SetPath(Point2I *blockPos)
{
	LevelData *level;
	int idx;
	int dir;
	Point2I *pDir;
	Point2I DIRECTIONS_I5 [5];
	LevelBlock *block;
	LevelBlockFlags1 flags1;
	
	level = globs::legoGlobs.level;
	idx = ((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x;
	block = (globs::legoGlobs.level)->blocks + idx;
	flags1 = (globs::legoGlobs.level)->blocks[idx].flags1;
	if (((flags1 & BLOCK1_CLEARED_UNK) != BLOCK1_NONE) && (block->terrain != TERRAIN_LAVA)) {
		DIRECTIONS_I5[0].x = 0;
		DIRECTIONS_I5[0].y = 0;
		DIRECTIONS_I5[1].x = 0;
		DIRECTIONS_I5[1].y = -1;
		DIRECTIONS_I5[2].x = 1;
		DIRECTIONS_I5[2].y = 0;
		DIRECTIONS_I5[3].x = 0;
		DIRECTIONS_I5[3].y = 1;
		DIRECTIONS_I5[4].x = -1;
		DIRECTIONS_I5[4].y = 0;
		if ((flags1 & BLOCK1_UNK_80000000) == BLOCK1_NONE) {
			block->flags1 = flags1 | BLOCK1_PATH;
		}
		else {
			Erode_Block_FUN_0040ed80(blockPos,0);
			level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].field_7 = 0;
		}
		idx = (level->dimensions).width * blockPos->y + blockPos->x;
		pDir = DIRECTIONS_I5;
		dir = 5;
		level->blocks[idx].flags1 = level->blocks[idx].flags1 & ~BLOCK1_UNK_40000000;
		do {
			Level_BlockUpdateSurface(level,blockPos->x + pDir->x,pDir->y + blockPos->y,0);
			pDir = pDir + 1;
			dir += -1;
		} while (dir != 0);
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Level_Block_SetFlags1_80000(Point2I *blockPos,BOOL condition)
{
	int idx;
	int width;
	LevelBlockFlags1 *pFlags1;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if (condition != 0) {
		pFlags1 = &(globs::legoGlobs.level)->blocks[width * blockPos->y + blockPos->x].flags1;
		*pFlags1 = *pFlags1 | BLOCK1_UNK_80000;
		return;
	}
	idx = width * blockPos->y + blockPos->x;
	(globs::legoGlobs.level)->blocks[idx].flags1 =
			 (globs::legoGlobs.level)->blocks[idx].flags1 & ~BLOCK1_UNK_80000;
	return;
}



BOOL __cdecl
lego::game::LiveObject_BlockCheck_FUN_004326a0
					(LiveObject *liveObj,uint bx,uint by,BOOL param_4,BOOL param_5)
{
	ObjectStatsFlags1 sflags1;
	uint i;
	float10 fVar1;
	Point2I DIRECTIONS_1 [4];
	Point2I DIRECTIONS_2 [4];
	LevelBlock *block;
	LevelData *level;
	Point2I *pDir;
	TerrainType terrain;
	int width;
	
	level = globs::legoGlobs.level;
	block = (globs::legoGlobs.level)->blocks + by * ((globs::legoGlobs.level)->dimensions).width + bx;
	sflags1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((sflags1 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) {
		if ((param_4 != 0) &&
			 (sflags1 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (sflags1 & STATS1_SINGLEWIDTHDIG) == STATS1_NONE)) {
			return 0;
		}
		if (((((param_5 == 0) || ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) &&
				 ((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_2) != 0)) &&
				((fVar1 = stats::StatsObject_GetDrillTimeType(liveObj,(uint)block->terrain),
				 fVar1 != (float10)0.0 && (width = (level->dimensions).width, bx < width - 2U)))) &&
			 (by < (level->dimensions).height - 2U)) {
			i = 0;
			if (param_4 == 0) {
				if ((((block->flags1 & BLOCK1_WALL_UNK) != BLOCK1_NONE) &&
						((block->flags1 & BLOCK1_CORNEROBTUSE) == BLOCK1_NONE)) &&
					 ((terrain = block->terrain, terrain != TERRAIN_IMMOVABLE &&
						((terrain != TERRAIN_WATER_unused && (terrain != TERRAIN_RECHARGESEAM)))))) {
					return TRUE;
				}
			}
			else {
				if (block->predug == PREDUG_WALL) {
					DIRECTIONS_1[1].x = 1;
					DIRECTIONS_1[2].y = 1;
					DIRECTIONS_2[0].x = -1;
					DIRECTIONS_2[0].y = -1;
					DIRECTIONS_2[1].x = 0;
					DIRECTIONS_2[1].y = -1;
					DIRECTIONS_2[2].x = 0;
					DIRECTIONS_2[2].y = 0;
					DIRECTIONS_2[3].x = -1;
					DIRECTIONS_2[3].y = 0;
					DIRECTIONS_1[0].x = 0;
					DIRECTIONS_1[0].y = -1;
					DIRECTIONS_1[1].y = 0;
					DIRECTIONS_1[2].x = 0;
					DIRECTIONS_1[3].x = -1;
					DIRECTIONS_1[3].y = 0;
					pDir = DIRECTIONS_1;
					do {
						if (level->blocks[(pDir->y + by) * width + bx + pDir->x].predug != PREDUG_WALL) break;
						i += 1;
						pDir = pDir + 1;
					} while (i < 4);
					if (i < 4) {
						i = 0;
						pDir = DIRECTIONS_2;
						do {
							terrain = level->blocks[(pDir->y + by) * width + bx + pDir->x].terrain;
							if ((terrain != TERRAIN_IMMOVABLE) && (terrain != TERRAIN_WATER_unused)) break;
							i += 1;
							pDir = pDir + 1;
						} while (i < 4);
						if (i < 4) {
							return TRUE;
						}
					}
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CanDynamiteBlockPos(LiveObject *liveObj,uint bx,uint by)
{
	int idx;
	LevelBlockFlags1 flags1;
	int width;
	TerrainType terrain;
	
	if (((((liveObj->flags3 & LIVEOBJ3_UNK_8000) != LIVEOBJ3_NONE) && (bx != 0)) && (by != 0)) &&
		 ((width = ((globs::legoGlobs.level)->dimensions).width, bx < width - 2U &&
			(by < ((globs::legoGlobs.level)->dimensions).height - 2U)))) {
		idx = by * width + bx;
		flags1 = (globs::legoGlobs.level)->blocks[idx].flags1;
		if (((((flags1 & BLOCK1_WALL_UNK) != BLOCK1_NONE) &&
				 (((flags1 & BLOCK1_CORNEROBTUSE) == BLOCK1_NONE &&
					(terrain = (globs::legoGlobs.level)->blocks[idx].terrain, terrain != TERRAIN_IMMOVABLE))))
				&& (terrain != TERRAIN_RECHARGESEAM)) && (terrain != TERRAIN_WATER_unused)) {
			return TRUE;
		}
	}
	return 0;
}



// "Nearly" identical to Level_Block_IsGround...
//  only used for BirdScarer placement...

BOOL __cdecl lego::game::Level_Block_IsGround_alt(LiveObject *liveObj,uint bx,uint by)
{
	BOOL BVar1;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	BVar1 = Map3D_IsInsideDimensions((globs::legoGlobs.level)->surfaceMap,bx,by);
						// GHIDRA WARNING: DO NOT TRY TO EQUATE THIS FLAG 0x8!!
						//   It causes Ghidra to fail decompilation... -_-
	if ((BVar1 != 0) &&
		 ((*(byte *)&level->blocks[(level->dimensions).width * by + bx].flags1 & 8) != 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CanReinforceBlock(LiveObject *liveObj,uint bx,uint by)
{
	int width;
	LevelBlockFlags1 flags1;
	TerrainType terrain;
	
	if (((((liveObj == NULL) || ((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_4) != 0)) && (bx != 0)) &&
			((by != 0 && (width = ((globs::legoGlobs.level)->dimensions).width, bx < width - 2U)))) &&
		 (by < ((globs::legoGlobs.level)->dimensions).height - 2U)) {
		flags1 = (globs::legoGlobs.level)->blocks[by * width + bx].flags1;
		if ((((flags1 & BLOCK1_WALL_UNK) != BLOCK1_NONE) &&
				((flags1 & BLOCK1_REINFORCED) == BLOCK1_NONE)) &&
			 ((terrain = (globs::legoGlobs.level)->blocks[by * width + bx].terrain,
				terrain != TERRAIN_RECHARGESEAM &&
				((terrain != TERRAIN_ORESEAM && (terrain != TERRAIN_CRYSTALSEAM)))))) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Level_Block_IsSolidBuilding(uint bx,uint by,BOOL allowToolStore)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if (allowToolStore == 0) {
		return (globs::legoGlobs.level)->blocks[width * by + bx].flags1 & BLOCK1_BUILDINGSOLID;
	}
	if ((((globs::legoGlobs.level)->blocks[width * by + bx].flags1 & BLOCK1_BUILDINGSOLID) ==
			 BLOCK1_NONE) &&
		 ((*(byte *)&(globs::legoGlobs.level)->blocks[width * by + bx].flags2 & BLOCK2_TOOLSTORE_UNK) ==
			0)) {
						// return FALSE;
		return BLOCK1_NONE;
	}
						// return TRUE;
	return BLOCK1_RUBBLE_LOW;
}



BOOL __cdecl lego::game::Level_Block_IsFlags1_800(uint bx,uint by)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		return (globs::legoGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_UNK_800;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_Block_IsGround(uint bx,uint by)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		return (globs::legoGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_GROUND;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_Block_IsSeamWall(uint bx,uint by)
{
	TerrainType terrain;
	
	terrain = (globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * by + bx]
						.terrain;
	if (((terrain != TERRAIN_ORESEAM) && (terrain != TERRAIN_CRYSTALSEAM)) &&
		 (terrain != TERRAIN_RECHARGESEAM)) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::game::Level_Block_IsWall(uint bx,uint by)
{
	int width;
	LevelBlockFlags1 flags1;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) &&
			(flags1 = (globs::legoGlobs.level)->blocks[by * width + bx].flags1,
			(flags1 & BLOCK1_WALL_UNK) != BLOCK1_NONE)) && ((flags1 & BLOCK1_GROUND) == BLOCK1_NONE)) {
		return TRUE;
	}
	return 0;
}



// This flag is not fully understood, but is related to an unimplemented feature
//  involving !SingleWidthDig, where a walls connections are destroyed, rather
//  than the entire block.

BOOL __cdecl lego::game::Level_Block_IsDestroyedConnection(uint bx,uint by)
{
	return (globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * by + bx].
				 flags1 & BLOCK1_DESTROYEDCONNECTION_UNK;
}



uint __cdecl lego::game::Level_Block_GetRubbleLayers(Point2I *blockPos)
{
	LevelBlockFlags1 flags1;
	
	flags1 = (globs::legoGlobs.level)->blocks
					 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1;
	if ((flags1 & BLOCK1_CLEARED_UNK) != BLOCK1_NONE) {
		return 0;
	}
	return (flags1 & BLOCK1_RUBBLE_FULL) + BLOCK1_RUBBLE_LOW;
}



BOOL __cdecl lego::game::Level_Block_ClearRubbleLayer(Point2I *blockPos)
{
	LevelData *level;
	int idx;
	LevelBlockFlags1 rubble;
	BOOL result;
	float10 fVar1;
	Vector3F worldPos;
	Vector3F vecRandom;
	LevelBlockFlags1 flags1;
	LevelBlock *pBlock;
	
	level = globs::legoGlobs.level;
	result = TRUE;
	idx = ((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x;
	pBlock = (globs::legoGlobs.level)->blocks + idx;
	flags1 = (globs::legoGlobs.level)->blocks[idx].flags1;
						// BLOCK1_RUBBLE_FULL is also a mask for rubble level
	rubble = flags1 & BLOCK1_RUBBLE_FULL;
	if ((flags1 & BLOCK1_CLEARED_UNK) == BLOCK1_NONE) {
		if (rubble != BLOCK1_NONE) {
						// Positive modulus ((rubble - 1) % 4)
			pBlock->flags1 = (rubble + ~BLOCK1_NONE ^ flags1) & BLOCK1_RUBBLE_FULL ^ flags1;
		}
		else {
			pBlock->flags1 = flags1 | BLOCK1_CLEARED_UNK;
			front::Info_RemoveAllAtBlockPos(blockPos);
			front::Interface_IfSelectedRubble_IsBlockPos(blockPos);
			ai::AITask_DoCallbacks_Block_FUN_00402a90(blockPos,FALSE);
			Map3D_BlockToWorldPos(level->surfaceMap,blockPos->x,blockPos->y,&worldPos.x,&worldPos.y);
			fVar1 = Map3D_GetWorldZ(level->surfaceMap,worldPos.x,worldPos.y);
			worldPos.z = (float)fVar1;
			math::Maths_Vector3DRandom(&vecRandom);
			vecRandom.z = 0.0;
			effect::Effect_Spawn_Particle(MISCOBJECT_PATHDUST,&worldPos,&vecRandom);
		}
		result = ZEXT14(rubble == BLOCK1_NONE);
		Level_BlockUpdateSurface(level,blockPos->x,blockPos->y,0);
	}
	return result;
}



BOOL __cdecl lego::game::Level_Block_IsReinforced(uint bx,uint by)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		return (globs::legoGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_REINFORCED;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_Block_IsBusy(Point2I *blockPos)
{
	return (globs::legoGlobs.level)->blocks
				 [blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].flags1 &
				 BLOCK1_BUSY;
}



void __cdecl lego::game::Level_Block_SetBusy(Point2I *blockPos,BOOL state)
{
	int idx;
	int width;
	LevelBlockFlags1 *pFlags1;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if (state != 0) {
		pFlags1 = &(globs::legoGlobs.level)->blocks[width * blockPos->y + blockPos->x].flags1;
		*pFlags1 = *pFlags1 | BLOCK1_BUSY;
		return;
	}
	idx = width * blockPos->y + blockPos->x;
	(globs::legoGlobs.level)->blocks[idx].flags1 =
			 (globs::legoGlobs.level)->blocks[idx].flags1 & ~BLOCK1_BUSY;
	return;
}



BOOL __cdecl lego::game::Level_Block_IsCorner(uint bx,uint by)
{
						// (BLOCK1_CORNEROBTUSE|BLOCK1_CORNERINNER)  (0x40|0x80)
	if ((*(byte *)&(globs::legoGlobs.level)->blocks
								 [((globs::legoGlobs.level)->dimensions).width * by + bx].flags1 & 0xc0) == 0) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::game::Level_Block_IsExposed(Point2I *blockPos)
{
	return (globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1 &
				 BLOCK1_EXPOSED;
}



BOOL __cdecl lego::game::Level_Block_IsImmovable(Point2I *blockPos)
{
	return (uint)((globs::legoGlobs.level)->blocks
								[((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].terrain
							 == TERRAIN_IMMOVABLE);
}



BOOL __cdecl lego::game::Level_Block_IsLava(Point2I *blockPos)
{
	return (uint)((globs::legoGlobs.level)->blocks
								[blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].terrain
							 == TERRAIN_LAVA);
}



BOOL __cdecl lego::game::Level_Block_IsNotWallOrGround(uint bx,uint by)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		return (uint)(((globs::legoGlobs.level)->blocks[by * width + bx].flags1 &
									(BLOCK1_GROUND|BLOCK1_WALL_UNK)) == BLOCK1_NONE);
	}
	return TRUE;
}



BOOL __cdecl lego::game::Level_Block_IsSurveyed(uint bx,uint by)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		return (globs::legoGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_SURVEYED;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_Block_IsFlags1_2000(uint bx,uint by)
{
	return (globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * by + bx].
				 flags1 & BLOCK1_UNK_2000;
}



BOOL __cdecl lego::game::Level_Block_IsCornerInner(uint bx,uint by)
{
	return (globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * by + bx].
				 flags1 & BLOCK1_CORNERINNER;
}



BOOL __cdecl lego::game::Level_Block_IsPathBuilding(Point2I *blockPos)
{
	return (globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1 &
				 BLOCK1_BUILDINGPATH;
}



BOOL __cdecl lego::game::Level_Block_IsGeneratePower(Point2I *blockPos)
{
	return (globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2 &
				 BLOCK2_GENERATEPOWER;
}



BOOL __cdecl lego::game::Level_Block_IsPath(Point2I *blockPos)
{
	int width;
	int x;
	int y;
	
	x = blockPos->x;
	if ((((-1 < x) && (y = blockPos->y, -1 < y)) &&
			(width = ((globs::legoGlobs.level)->dimensions).width, x < width)) &&
		 (y < ((globs::legoGlobs.level)->dimensions).height)) {
		return (globs::legoGlobs.level)->blocks[width * y + x].flags1 & BLOCK1_PATH;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_Block_IsAnyFlags1_80000_Foundation(Point2I *blockPos)
{
	if (((globs::legoGlobs.level)->blocks
			 [blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].flags1 &
			(BLOCK1_UNK_80000|BLOCK1_FOUNDATION)) == BLOCK1_NONE) {
		return 0;
	}
	return TRUE;
}



void __cdecl lego::game::Level_Block_SetFlags1_10000000(Point2I *blockPos,BOOL state)
{
	int idx;
	LevelBlockFlags1 *pFlags1;
	
	if (state != 0) {
		pFlags1 = &(globs::legoGlobs.level)->blocks
							 [blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x].flags1;
		*pFlags1 = *pFlags1 | BLOCK1_UNK_10000000;
		return;
	}
	idx = blockPos->y * ((globs::legoGlobs.level)->dimensions).width + blockPos->x;
	(globs::legoGlobs.level)->blocks[idx].flags1 =
			 (globs::legoGlobs.level)->blocks[idx].flags1 & ~BLOCK1_UNK_10000000;
	return;
}



BOOL __cdecl
lego::game::LiveObject_GetRockFallInDamage_Unk
					(LiveObject *liveObj,int bx,int by,float elapsed,float *optout_value)
{
	ObjectType OVar1;
	ObjectStatsFlags1 OVar2;
	ObjectStatsFlags2 OVar3;
	uint weaponType;
	float10 fVar4;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	OVar1 = liveObj->objType;
	if ((((((OVar1 != OBJECT_POWERCRYSTAL) && (OVar1 != OBJECT_ORE)) && (OVar1 != OBJECT_BOULDER)) &&
			 ((OVar1 != OBJECT_DYNAMITE && (OVar1 != OBJECT_ELECTRICFENCE)))) &&
			(((OVar1 != OBJECT_OOHSCARY && ((OVar1 != OBJECT_ELECTRICFENCESTUD && (OVar1 != OBJECT_PATH)))
				) && (OVar1 != OBJECT_PUSHER)))) &&
		 (((OVar1 != OBJECT_FREEZER && (OVar1 != OBJECT_ICECUBE)) && (OVar1 != OBJECT_LASERSHOT)))) {
		if ((liveObj->drivenObject != NULL) &&
			 (OVar2 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE)) {
			return 0;
		}
		if (((level->blocks[by * (level->dimensions).width + bx].terrain == TERRAIN_LAVA) &&
				((level->blocks[by * (level->dimensions).width + bx].flags1 & BLOCK1_UNK_200) == BLOCK1_NONE
				)) && (OVar3 = stats::StatsObject_GetStatsFlags2(liveObj),
							(OVar3 & STATS2_CROSSLAVA) == STATS2_NONE)) {
			if (optout_value == NULL) {
				return 1;
			}
			*optout_value = elapsed;
			return TRUE;
		}
		if ((level->blocks[by * (level->dimensions).width + bx].flags1 & BLOCK1_UNK_1000) != BLOCK1_NONE
			 ) {
			if (optout_value != NULL) {
				weaponType = tools::Weapon_GetWeaponTypeByName("RockFallIn");
				fVar4 = tools::Weapon_GetDamageForLiveObject(weaponType,liveObj);
				*optout_value = (float)(fVar4 * (float10)elapsed);
			}
			return TRUE;
		}
	}
	return 0;
}



uint __cdecl lego::game::Level_Block_GetField3__routingRelated(uint bx,uint by)
{
	return (uint)(globs::legoGlobs.level)->blocks
							 [((globs::legoGlobs.level)->dimensions).width * by + bx].field_3;
}



void __cdecl lego::game::Level_Block_SetSurveyed(uint bx,uint by)
{
	int iVar1;
	
	iVar1 = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < iVar1 - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		iVar1 = by * iVar1 + bx;
		(globs::legoGlobs.level)->blocks[iVar1].flags1 =
				 (globs::legoGlobs.level)->blocks[iVar1].flags1 | BLOCK1_SURVEYED;
	}
	return;
}



BOOL __cdecl lego::game::Level_Block_GetSurfaceType(uint bx,uint by,SurfaceType *out_surfaceType)
{
	int width;
	
	width = ((globs::legoGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::legoGlobs.level)->dimensions).height - 1U)) {
		*out_surfaceType = (uint)(globs::legoGlobs.level)->blocks[by * width + bx].terrain;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Level_Block_LowerRoofVertices(LevelData *level,uint bx,uint by)
{
	float fVar1;
	int idx;
	Vector3F vertPoses [4];
	int width;
	LevelBlockFlags1 block;
	LevelBlock *blocksGrid;
	
	if ((bx < (level->dimensions).width - 1U) && (by < (level->dimensions).height - 1U)) {
		Map3D_GetBlockVertexPositions2(level->surfaceMap,bx,by,vertPoses);
		width = (level->dimensions).width;
		blocksGrid = level->blocks;
		idx = by * width + bx;
		block = blocksGrid[idx].flags1;
		if ((block & BLOCK1_GROUND) == BLOCK1_NONE) {
			if ((block & BLOCK1_WALL_UNK) == BLOCK1_NONE) {
				return;
			}
			if (blocksGrid[idx].predug == PREDUG_EXPOSED) {
				vertPoses[0].z = vertPoses[0].z - (level->DigDepth + level->RoofHeight);
			}
			if (blocksGrid[idx + 1].predug == PREDUG_EXPOSED) {
				vertPoses[1].z = vertPoses[1].z - (level->DigDepth + level->RoofHeight);
			}
			idx = (by + 1) * width + bx;
			if (blocksGrid[idx + 1].predug == PREDUG_EXPOSED) {
				vertPoses[2].z = vertPoses[2].z - (level->DigDepth + level->RoofHeight);
			}
			if (blocksGrid[idx].predug == PREDUG_EXPOSED) {
				vertPoses[3].z = vertPoses[3].z - (level->DigDepth + level->RoofHeight);
			}
		}
		else {
			fVar1 = level->DigDepth + level->RoofHeight;
			vertPoses[0].z = vertPoses[0].z - fVar1;
			vertPoses[1].z = vertPoses[1].z - fVar1;
			vertPoses[2].z = vertPoses[2].z - fVar1;
			vertPoses[3].z = vertPoses[3].z - fVar1;
		}
		Roof_LowerBlockRoofVertices(bx,by,vertPoses,vertPoses + 1,vertPoses + 2,vertPoses + 3);
	}
	return;
}



void __cdecl lego::game::MapShared_GetDimensions(uint sharedIndex,uint *out_width,uint *out_height)
{
	MapFileInfo *mapFile;
	
	mapFile = (MapFileInfo *)lego::file::Mem_AddressHandle(sharedIndex);
	*out_width = (mapFile->dimensions).width;
	*out_height = (mapFile->dimensions).height;
	return;
}



BOOL __cdecl lego::lrr::Lego_LoadGraphicsSettings(void)
{
	char *pcVar1;
	int cmp;
	BoolTri dither;
	BoolTri filter;
	BoolTri blend;
	BoolTri sort;
	BoolTri mipmap;
	BoolTri linearmipmap;
	GraphicsQuality renderQuality;
	float10 fVar2;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","fpclipblocks",0);
	pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","fpclipblocks",0);
		pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globs::legoGlobs.FPClipBlocks = (float)fVar2;
	if ((float10)0.0 != fVar2) {
		pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","quality",0);
		pcVar1 = cfg::CFG_ReadString(globs::legoGlobs.config,pcVar1);
		if (pcVar1 != NULL) {
			cmp = std::_stricmp("gouraud",pcVar1);
			if (cmp == 0) {
				renderQuality = QUALITY_GOURAUD;
			}
			else {
				cmp = std::_stricmp("flat",pcVar1);
				if (cmp == 0) {
					renderQuality = QUALITY_FLAT;
				}
				else {
					cmp = std::_stricmp("wireframe",pcVar1);
					if (cmp != 0) {
						return 0;
					}
					renderQuality = QUALITY_WIREFRAME;
				}
			}
			globs::legoGlobs.Quality = renderQuality;
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","dither",0);
			dither = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","filter",0);
			filter = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","blend",0);
			blend = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","sort",0);
			sort = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","mipmap",0);
			mipmap = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","linearmipmap",0);
			linearmipmap = cfg::CFG_ReadBool(globs::legoGlobs.config,pcVar1);
			main::Main_Setup3D(renderQuality,(uint)(dither == BOOL3_TRUE),(uint)(filter == BOOL3_TRUE),
												 (uint)(mipmap == BOOL3_TRUE),(uint)(linearmipmap == BOOL3_TRUE),
												 (uint)(blend == BOOL3_TRUE),(uint)(sort == BOOL3_TRUE));
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::lrr::Lego_LoadLighting(void)
{
	char *pcVar1;
	BOOL BVar2;
	Container *opt_parent;
	float *pfVar3;
	float *pfVar4;
	float *pfVar5;
	float b;
	float g;
	float r;
	
	pfVar4 = &b;
	pfVar5 = &g;
	pfVar3 = &r;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","topspotrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globs::legoGlobs.contTopSpotlight =
			 res::Container_MakeLight((globs::legoGlobs.cameraMain)->cont3,D3DRMLIGHT_SPOT,r,g,b);
	if (globs::legoGlobs.contTopSpotlight == NULL) {
		return 0;
	}
	res::Container_Light_SetSpotPenumbra(globs::legoGlobs.contTopSpotlight,0.85);
	res::Container_Light_SetSpotUmbra(globs::legoGlobs.contTopSpotlight,0.4);
	res::Container_SetPosition
						(globs::legoGlobs.contTopSpotlight,(globs::legoGlobs.cameraMain)->cont3,200.0,140.0,
						 -130.0);
	res::Container_SetOrientation
						(globs::legoGlobs.contTopSpotlight,(globs::legoGlobs.cameraMain)->cont3,-1.0,-0.8,0.75,
						 0.0,1.0,0.0);
	pfVar4 = &b;
	pfVar5 = &g;
	pfVar3 = &r;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","trackspotrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globs::legoGlobs.contTrackSpotlight =
			 res::Container_MakeLight((globs::legoGlobs.cameraRadar)->cont2,D3DRMLIGHT_SPOT,r,g,b);
	if (globs::legoGlobs.contTrackSpotlight == NULL) {
		return 0;
	}
	res::Container_SetPosition(globs::legoGlobs.contTrackSpotlight,NULL,0.0,0.0,-150.0);
	res::Container_SetOrientation(globs::legoGlobs.contTrackSpotlight,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
	pfVar4 = &b;
	pfVar5 = &g;
	pfVar3 = &r;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","ambientrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globs::legoGlobs.contAmbientLight =
			 res::Container_MakeLight(globs::legoGlobs.contRoot,D3DRMLIGHT_AMBIENT,r,g,b);
	pfVar5 = &b;
	if (globs::legoGlobs.contAmbientLight == NULL) {
		return 0;
	}
	pfVar3 = &g;
	pfVar4 = &r;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","fplightrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar1,pfVar4,pfVar3,pfVar5);
	if (BVar2 == 0) {
		return 0;
	}
	globs::legoGlobs.contFPLight =
			 res::Container_MakeLight((globs::legoGlobs.cameraFP)->contCam,D3DRMLIGHT_POINT,r,g,b);
	pfVar5 = &b;
	if (globs::legoGlobs.contFPLight == NULL) {
		return 0;
	}
	pfVar3 = &g;
	pfVar4 = &r;
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","fprotlightrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::legoGlobs.config,pcVar1,pfVar4,pfVar3,pfVar5);
	if (BVar2 == 0) {
		globs::legoGlobs.contFPRotLight = NULL;
	}
	else {
		globs::legoGlobs.contFPRotLight =
				 res::Container_MakeLight((globs::legoGlobs.cameraFP)->contCam,D3DRMLIGHT_DIRECTIONAL,r,g,b)
		;
	}
	globs::legoGlobs.contFPRotLightDefault =
			 res::Container_MakeLight
								 ((globs::legoGlobs.cameraFP)->contCam,D3DRMLIGHT_DIRECTIONAL,1.0,0.0,0.0);
	if (globs::legoGlobs.contFPRotLightDefault == NULL) {
		return 0;
	}
	opt_parent = res::GetRoot();
	globs::legoGlobs.contRootLight = res::Container_Create(opt_parent);
	globs::legoGlobs.contRootSpotlight =
			 res::Container_MakeLight(globs::legoGlobs.contRootLight,D3DRMLIGHT_SPOT,1.0,1.0,1.0);
	if (globs::legoGlobs.contRootSpotlight == NULL) {
		return 0;
	}
	light::LightEffects_Initialise
						(globs::legoGlobs.contRootSpotlight,globs::legoGlobs.contRootLight,0.8,0.8,0.8);
	res::Container_SetOrientation(globs::legoGlobs.contRootSpotlight,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
	res::Container_Light_SetSpotPenumbra(globs::legoGlobs.contRootSpotlight,0.85);
	res::Container_Light_SetSpotUmbra(globs::legoGlobs.contRootSpotlight,0.0);
	res::Container_Hide(globs::legoGlobs.contFPLight,TRUE);
	if (globs::legoGlobs.contFPRotLight != NULL) {
		res::Container_Hide(globs::legoGlobs.contFPRotLight,TRUE);
	}
	res::Container_Hide(globs::legoGlobs.contTopSpotlight,TRUE);
	res::Container_Hide(globs::legoGlobs.contTrackSpotlight,TRUE);
	res::Container_Hide(globs::legoGlobs.contAmbientLight,TRUE);
	res::Container_Hide(globs::legoGlobs.contRootSpotlight,TRUE);
	res::Container_Hide(globs::legoGlobs.contFPRotLightDefault,TRUE);
	res::Container_Light_SetSpotRange(globs::legoGlobs.contTopSpotlight,2000.0);
	res::Container_Light_SetSpotRange(globs::legoGlobs.contTrackSpotlight,2000.0);
	res::Container_Light_SetSpotRange(globs::legoGlobs.contRootSpotlight,2000.0);
	return TRUE;
}



BOOL __cdecl lego::game::Lego_WorldToBlockPos_NoZ(float in_x,float in_y,int *out_bx,int *out_by)
{
	BOOL BVar1;
	
	BVar1 = Map3D_WorldToBlockPos_NoZ((globs::legoGlobs.level)->surfaceMap,in_x,in_y,out_bx,out_by);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00433b40(LiveObject *liveObj,float param_2,BOOL param_3)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	float fVar3;
	bool bVar4;
	short rng;
	ObjectStatsFlags1 OVar5;
	BOOL BVar6;
	uint uVar7;
	uint uVar8;
	Point2I *pPVar9;
	uint uVar10;
	ulonglong uVar11;
	float local_2c;
	int local_28;
	int local_24;
	Point2I DIRECTIONS [4];
	
	uVar10 = 0;
	DIRECTIONS[0].x = -1;
	DIRECTIONS[0].y = 0;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = -1;
	DIRECTIONS[3].x = 0;
	DIRECTIONS[3].y = 1;
	OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((((OVar5 & STATS1_RANDOMENTERWALL) != STATS1_NONE) && ((*(byte *)&liveObj->flags1 & 1) == 0))
			&& (BVar6 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj), BVar6 == 0)) &&
		 (param_2 != 0.0)) {
		local_2c = param_2;
		if ((ushort)((ushort)(param_2 < 300.0) << 8 | (ushort)(param_2 == 300.0) << 0xe) == 0) {
			local_2c = 300.0;
		}
		rng = math::Maths_Rand();
		uVar11 = __ftol((float10)300.0 / (float10)local_2c);
		if ((int)((ulonglong)(uint)(int)rng % (uVar11 & 0xffffffff)) == 0) {
			LiveObject_GetBlockPos(liveObj,&local_24,&local_28);
			pPVar9 = DIRECTIONS;
			iVar1 = ((globs::legoGlobs.level)->dimensions).width;
			do {
				uVar7 = pPVar9->y + local_28;
				uVar8 = local_24 + pPVar9->x;
				if (((uVar8 < iVar1 - 1U) && (uVar7 < ((globs::legoGlobs.level)->dimensions).height - 1U))
					 && ((LVar2 = (globs::legoGlobs.level)->blocks[uVar7 * iVar1 + uVar8].flags1,
							 (LVar2 & BLOCK1_WALL_UNK) != BLOCK1_NONE && ((LVar2 & BLOCK1_GROUND) == BLOCK1_NONE))
							)) {
					bVar4 = true;
				}
				else {
					bVar4 = false;
				}
				if (bVar4) {
					liveObj->health = -1.0;
					LiveObject_TryDepart_FUN_004499c0(liveObj);
					return TRUE;
				}
				uVar10 += 1;
				pPVar9 = pPVar9 + 1;
			} while (uVar10 < 4);
		}
	}
	if (((param_3 != 0) ||
			(OVar5 = stats::StatsObject_GetStatsFlags1(liveObj),
			(OVar5 & STATS1_RANDOMMOVE) != STATS1_NONE)) &&
		 (((*(byte *)&liveObj->flags1 & 1) == 0 &&
			((BVar6 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj), BVar6 == 0 &&
			 (fVar3 = liveObj->stats->RandomMoveTime, param_2 != 0.0)))))) {
		local_2c = param_2;
		if ((ushort)((ushort)(param_2 < fVar3) << 8 | (ushort)(param_2 == fVar3) << 0xe) == 0) {
			local_2c = fVar3;
		}
		if (param_3 == 0) {
			rng = math::Maths_Rand();
			uVar11 = __ftol((float10)fVar3 / (float10)local_2c);
			if ((int)((ulonglong)(uint)(int)rng % (uVar11 & 0xffffffff)) != 0) {
				return 0;
			}
		}
		LiveObject_FUN_00444520(liveObj);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_Block_IsMeshHidden(uint bx,uint by)
{
	SurfaceMap *surfMap;
	BOOL BVar1;
	
	if (((globs::legoGlobs.level)->blocks[((globs::legoGlobs.level)->dimensions).width * by + bx].
			 flags1 & BLOCK1_UNK_100) == BLOCK1_NONE) {
		surfMap = lrr::Lego_GetMap();
		BVar1 = Map3D_IsBlockMeshHidden(surfMap,bx,by);
		if (BVar1 != 0) {
			return TRUE;
		}
	}
	return 0;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl
lego::unk::Lego_FPHighPolyBlocks_FUN_00433db0
					(Container *contCamera,Viewport *view,float fpClipBlocksMult,float highPolyBlocksMult)
{
	LevelBlockFlags1 *pLVar1;
	bool bVar2;
	LevelData *level;
	float fVar3;
	BOOL BVar4;
	uint uVar5;
	uint *puVar6;
	float *pfVar7;
	SurfaceMap *surfMap;
	uint uVar8;
	int iVar9;
	float10 fVar10;
	longlong lVar11;
	float fStack7376;
	uint uStack7372;
	SurfaceMap *pSStack7368;
	uint uStack7364;
	float fStack7360;
	float fStack7356;
	float fStack7352;
	undefined4 uStack7348;
	float fStack7344;
	int iStack7340;
	float fStack7336;
	float fStack7332;
	float fStack7328;
	float fStack7324;
	float fStack7320;
	float fStack7316;
	float fStack7312;
	float fStack7308;
	int iStack7304;
	Vector3F VStack7300;
	int iStack7288;
	uint uStack7284;
	undefined4 uStack7280;
	float fStack7276;
	undefined4 uStack7272;
	Point2F PStack7268;
	Vector3F VStack7260;
	Vector3F aVStack7248 [4];
	uint auStack7200 [600];
	float local_12c0 [1199];
	undefined4 uStack4;
	
	level = globs::legoGlobs.level;
	uStack4 = 0x433dba;
	surfMap = (globs::legoGlobs.level)->surfaceMap;
	fStack7332 = 0.0;
	pSStack7368 = surfMap;
	fVar10 = game::Map3D_GetBlockSize(surfMap);
	fStack7356 = (float)fVar10;
	lVar11 = __ftol((float10)fpClipBlocksMult / (float10)fStack7356);
	iVar9 = (int)lVar11;
	iStack7340 = 0;
	res::Container_GetPosition(contCamera,NULL,&VStack7300);
	game::Map3D_WorldToBlockPos_NoZ(surfMap,VStack7300.x,VStack7300.y,&iStack7304,&iStack7288);
	res::Container_GetOrientation(contCamera,NULL,&VStack7260,NULL);
	fVar10 = lego::view::Viewport_GetField(globs::legoGlobs.viewMain);
	fVar10 = (float10)fcos(fVar10 * (float10)1.4);
	fStack7344 = (float)fVar10;
	lego::view::Viewport_GetSize(globs::legoGlobs.viewMain,(uint *)&fStack7376,&uStack7372);
	PStack7268.x = (float)(ulonglong)(uint)fStack7376;
	uStack7348 = 0;
	PStack7268.y = (float)(ulonglong)uStack7372;
	fStack7352 = (float)(iStack7304 - iVar9);
	uVar5 = iStack7288 - iVar9;
	fStack7360 = (float)(iStack7304 + iVar9);
	uStack7364 = iVar9 + iStack7288;
	if ((int)fStack7352 < 0) {
		fStack7352 = 0.0;
	}
	if ((int)uVar5 < 0) {
		uVar5 = 0;
	}
	if ((int)fStack7360 < 0) {
		fStack7360 = 0.0;
	}
	if ((int)uStack7364 < 0) {
		uStack7364 = 0;
	}
	iVar9 = (level->dimensions).width;
	if (iVar9 <= (int)fStack7360) {
		fStack7360 = (float)(iVar9 + -1);
	}
	iVar9 = (level->dimensions).height;
	if (iVar9 <= (int)uStack7364) {
		uStack7364 = iVar9 - 1;
	}
	fVar3 = fStack7352;
	uVar8 = uStack7364;
	uStack7372 = uVar5;
	if (uVar5 < uStack7364) {
		do {
			fStack7376 = fVar3;
			fVar3 = fStack7376;
			if ((uint)fStack7376 < (uint)fStack7360) {
				puVar6 = auStack7200 + iStack7340 * 2 + 1;
				pfVar7 = local_12c0 + (int)fStack7332 * 4 + 1;
				uStack7372 = uVar5;
				do {
					surfMap = pSStack7368;
					if ((*(byte *)&level->blocks[uVar5 * (level->dimensions).width + (int)fStack7376].flags1 &
							0x18) != 0) {
						game::Map3D_BlockToWorldPos(pSStack7368,(uint)fStack7376,uVar5,&fStack7316,&fStack7312);
						fVar10 = game::Map3D_GetWorldZ(surfMap,fStack7316,fStack7312);
						fStack7308 = (float)fVar10;
						fStack7328 = (float)((float10)fStack7316 - (float10)VStack7300.x);
						fStack7324 = (float)((float10)fStack7312 - (float10)VStack7300.y);
						fStack7320 = (float)(fVar10 - (float10)VStack7300.z);
						fVar10 = SQRT((fVar10 - (float10)VStack7300.z) * (float10)fStack7320 +
													((float10)fStack7312 - (float10)VStack7300.y) * (float10)fStack7324 +
													((float10)fStack7316 - (float10)VStack7300.x) * (float10)fStack7328);
						fStack7336 = (float)fVar10;
						uVar5 = uStack7372;
						if (fVar10 < (float10)fpClipBlocksMult) {
							fVar3 = 1.0 / fStack7336;
							fVar3 = fVar3 * fStack7320 * VStack7260.z +
											fVar3 * fStack7324 * VStack7260.y + fVar3 * fStack7328 * VStack7260.x;
							bVar2 = fStack7336 < (fVar3 - -2.0) * fStack7356;
							if (bVar2) {
								fVar3 = fStack7344 - -1.0;
							}
							if ((ushort)((ushort)(fVar3 < fStack7344) << 8 | (ushort)(fVar3 == fStack7344) << 0xe)
									== 0) {
								game::Map3D_GetBlockVertexPositions2
													(pSStack7368,(uint)fStack7376,uStack7372,aVStack7248);
								fStack7276 = fStack7376;
								uStack7272 = 0;
								uStack7284 = uStack7372;
								uStack7280 = 0;
								pfVar7[-1] = (float)(ulonglong)(uint)fStack7376;
								*pfVar7 = (float)(ulonglong)uStack7372;
								pfVar7[1] = fStack7336;
								fVar10 = res::DynamicPM_FUN_0040b3a0((int)aVStack7248,view,&PStack7268,(uint)bVar2);
								pfVar7[2] = (float)fVar10;
								uVar5 = uStack7372;
								if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 |
														(ushort)(fVar10 == (float10)0.0) << 0xe) == 0) {
									fStack7332 = (float)((int)fStack7332 + 1);
									pfVar7 = pfVar7 + 4;
								}
								else {
									puVar6[-1] = (uint)fStack7376;
									iStack7340 += 1;
									*puVar6 = uStack7372;
									puVar6 = puVar6 + 2;
								}
							}
						}
					}
					fStack7376 = (float)((int)fStack7376 + 1);
					fVar3 = fStack7352;
					surfMap = pSStack7368;
					uVar8 = uStack7364;
				} while ((uint)fStack7376 < (uint)fStack7360);
			}
			uVar5 += 1;
			uStack7372 = uVar5;
		} while (uVar5 < uVar8);
	}
	fVar3 = fStack7332;
	std::qsort(local_12c0,(uint)fStack7332,0x10,Lego_QsortCompareUnk_FUN_00434380);
	pSStack7368 = NULL;
	if (fVar3 != 0.0) {
		pfVar7 = local_12c0 + 2;
		fStack7356 = fVar3;
		do {
			lVar11 = __ftol((float10)pfVar7[-2]);
			fVar3 = (float)lVar11;
			fStack7376 = fVar3;
			lVar11 = __ftol((float10)pfVar7[-1]);
			uStack7372 = (uint)lVar11;
			if (((uint)highPolyBlocksMult <= pSStack7368) || (fpClipBlocksMult * 0.6666667 <= *pfVar7)) {
				pLVar1 = &level->blocks[uStack7372 * (level->dimensions).width + (int)fVar3].flags1;
				*pLVar1 = *pLVar1 & ~BLOCK1_UNK_100;
				game::Map3D_AddBlockCoord(surfMap,(int)fStack7376,uStack7372);
				game::Roof_AddVisibleBlock((uint)fStack7376,uStack7372);
				if ((level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1 &
						BLOCK1_UNK_4000) != BLOCK1_NONE) {
					effect::Smoke_Hide(level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376]
														 .smokeptr_1c,FALSE);
				}
			}
			else {
				fStack7344 = 1.0 - *pfVar7 / (fpClipBlocksMult * 0.6666667);
				fStack7352 = fStack7344 * 0.7 - -0.3;
				if ((((byte)globs::legoGlobs.flags1 & GAME1_WALLPROMESHES) == 0) ||
					 (BVar4 = game::Level_Block_ProMesh_FUN_004343b0
															(level,(uint)fVar3,uStack7372,fStack7344,(uint)fStack7352),
					 fVar3 = fStack7376, BVar4 == 0)) {
					game::Map3D_AddBlockCoord(surfMap,(int)fVar3,uStack7372);
					game::Roof_AddVisibleBlock((uint)fStack7376,uStack7372);
					if ((level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1 &
							BLOCK1_UNK_4000) != BLOCK1_NONE) {
						effect::Smoke_Hide(level->blocks
															 [uStack7372 * (level->dimensions).width + (int)fStack7376].
															 smokeptr_1c,FALSE);
					}
					iVar9 = uStack7372 * (level->dimensions).width + (int)fStack7376;
					level->blocks[iVar9].flags1 = level->blocks[iVar9].flags1 & ~BLOCK1_UNK_100;
				}
				else {
					pLVar1 = &level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1;
					*pLVar1 = *pLVar1 | BLOCK1_UNK_100;
					game::Roof_AddVisibleBlock((uint)fStack7376,uStack7372);
					pSStack7368 = (SurfaceMap *)((int)pSStack7368 + 1);
				}
			}
			pfVar7 = pfVar7 + 4;
			fStack7356 = (float)((int)fStack7356 + -1);
		} while (fStack7356 != 0.0);
	}
	if (iStack7340 != 0) {
		puVar6 = auStack7200;
		iVar9 = iStack7340;
		do {
			game::Roof_AddVisibleBlock(*puVar6,puVar6[1]);
			puVar6 = puVar6 + 2;
			iVar9 += -1;
		} while (iVar9 != 0);
	}
	return;
}



int __cdecl lego::unk::Lego_QsortCompareUnk_FUN_00434380(int param_1,int param_2)
{
	if (*(float *)(param_1 + 0xc) < *(float *)(param_2 + 0xc)) {
		return 1;
	}
	if ((ushort)((ushort)(*(float *)(param_1 + 0xc) < *(float *)(param_2 + 0xc)) << 8 |
							(ushort)(*(float *)(param_1 + 0xc) == *(float *)(param_2 + 0xc)) << 0xe) == 0) {
		return -1;
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_Block_ProMesh_FUN_004343b0
					(LevelData *level,uint bx,uint by,undefined4 param_4,uint param_5)
{
	ProMeshData *promesh;
	int idx;
	Vector3F vertPoses [4];
	SurfaceTexture texture;
	
	if (((*(byte *)&level->blocks[by * (level->dimensions).width + bx].flags1 & 0x18) != 0) &&
		 (texture = level->blocks[by * (level->dimensions).width + bx].texture,
		 promesh = level->promeshGrid
							 [(level->surfTextSize).width * (texture & 0xf) + (uint)(texture >> 4)],
		 promesh != NULL)) {
		Map3D_GetBlockVertexPositions2(level->surfaceMap,bx,by,vertPoses);
		idx = by * (level->dimensions).width + bx;
		res::DynamicPM_FUN_0040b7b0
							(promesh,vertPoses,level->blocks[idx].texture,level->blocks[idx].field_3,param_4,
							 param_5);
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Level_RemoveAll_ProMeshes(void)
{
	uint i;
	LevelData *level;
	
	level = globs::legoGlobs.level;
	i = 0;
	if (((globs::legoGlobs.level)->surfTextSize).height *
			((globs::legoGlobs.level)->surfTextSize).width != 0) {
		do {
			if (level->promeshGrid[i] != NULL) {
				res::DynamicPM_Remove_FUN_0040b740(level->promeshGrid[i]);
			}
			i += 1;
		} while (i < (uint)((level->surfTextSize).height * (level->surfTextSize).width));
	}
	return;
}



BOOL __cdecl lego::game::Level_Block_GetUnkField14Test(uint bx,uint by,float param_3,float param_4)
{
	int idx;
	float float14;
	LevelData *level;
	
	level = globs::legoGlobs.level;
						// Divide-by-zero guard
	if ((param_3 != 0.0) &&
		 (idx = by * ((globs::legoGlobs.level)->dimensions).width + bx,
		 (globs::legoGlobs.level)->blocks[idx].float_14 =
					param_4 / param_3 + (globs::legoGlobs.level)->blocks[idx].float_14,
		 float14 = level->blocks[by * (level->dimensions).width + bx].float_14,
		 (ushort)((ushort)(float14 < 1.0) << 8 | (ushort)(float14 == 1.0) << 0xe) == 0)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::lrr::Lego_LoadPanels(CFGProperty *root,uint screenWidth,uint screenHeight)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int yIn;
	int xIn;
	int yOut;
	int xOut;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	PanelType panelType;
	char *stringParts [10];
	char buff [256];
	
	std::sprintf(buff,"Panels%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,buff,0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		BVar3 = front::Panel_GetPanelType(prop->key,&panelType);
		if (BVar3 != 0) {
			uVar4 = 0xffffffff;
			pcVar2 = prop->value;
			do {
				pcVar7 = pcVar2;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pcVar7 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar7;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar6 = (undefined4 *)(pcVar7 + -uVar4);
			puVar8 = (undefined4 *)buff;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
				*puVar8 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar8 = puVar8 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar8 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			util::Util_Tokenise(buff,stringParts,",");
			front::Panel_LoadImage(stringParts[0],panelType,4);
			yIn = std::atoi(stringParts[4]);
			xIn = std::atoi(stringParts[3]);
			yOut = std::atoi(stringParts[2]);
			xOut = std::atoi(stringParts[1]);
			front::Panel_SetArea(panelType,xOut,yOut,xIn,yIn);
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl lego::lrr::Lego_LoadPanelButtons(CFGProperty *root,uint screenWidth,uint screenHeight)
{
	char *pcVar1;
	CFGProperty *prop;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	char **ppcVar5;
	uint uVar6;
	uint *puVar7;
	char **ppcVar8;
	CFGProperty *pCStack11756;
	int iStack11752;
	int iStack11748;
	PanelButtonType PStack11744;
	ToolTipType TStack11740;
	uint auStack11736 [12];
	char *pcStack11688;
	char *apcStack11684 [4];
	char *pcStack11668;
	char *pcStack11664;
	char *pcStack11660;
	char *pcStack11656;
	char acStack11648 [128];
	ToolTipType aTStack11520 [288];
	PanelButtonType aPStack10368 [288];
	char *apcStack9216 [288];
	undefined auStack8064 [1152];
	undefined auStack6912 [1152];
	char *apcStack5760 [288];
	float afStack4608 [1151];
	undefined4 uStack4;
	
	uStack4 = 0x43464a;
	puVar7 = auStack11736;
	auStack11736[0] = 0;
	for (iVar4 = 0xb; puVar7 = puVar7 + 1, iVar4 != 0; iVar4 += -1) {
		*puVar7 = 0;
	}
	iStack11748 = 0;
	std::sprintf(acStack11648,"Buttons%ix%i",screenWidth,screenHeight);
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,acStack11648,0);
	prop = cfg::CFG_GetChildren(root,pcVar1);
	if (prop != NULL) {
		ppcVar5 = apcStack5760;
		do {
			BVar2 = front::Panel_GetPanelType(prop->key,(PanelType *)&pCStack11756);
			if (BVar2 != 0) {
				pcVar1 = util::_strdup(prop->value);
				*ppcVar5 = pcVar1;
				util::Util_Tokenise(pcVar1,&pcStack11688,",");
				BVar2 = front::Panel_GetButtonType((PanelType)pCStack11756,pcStack11688,&PStack11744);
				if (BVar2 != 0) {
					uVar6 = 0;
					ppcVar8 = apcStack11684;
					aPStack10368[auStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18] = PStack11744;
					do {
						iVar3 = std::_stricmp("NULL",*ppcVar8);
						iVar4 = auStack11736[(int)pCStack11756] + ((int)&pCStack11756->fileData + uVar6) * 0x18;
						if (iVar3 == 0) {
							apcStack9216[iVar4] = NULL;
						}
						else {
							apcStack9216[iVar4] = *ppcVar8;
						}
						uVar6 += 0xc;
						ppcVar8 = ppcVar8 + 1;
					} while (uVar6 < 0x24);
					iStack11752 = std::atoi(apcStack11684[3]);
					afStack4608[(auStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11668);
					afStack4608[(auStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 1] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11664);
					afStack4608[(auStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 2] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11660);
					afStack4608[(auStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 3] =
							 (float)iStack11752;
					BVar2 = front::ToolTip_GetType(pcStack11656,&TStack11740);
					uVar6 = auStack11736[(int)pCStack11756];
					iVar4 = uVar6 + (int)pCStack11756 * 0x18;
					if (BVar2 == 0) {
						aTStack11520[iVar4] = TOOLTIP_NULL;
					}
					else {
						aTStack11520[iVar4] = TStack11740;
					}
					auStack11736[(int)pCStack11756] = uVar6 + 1;
					iStack11748 += 1;
					ppcVar5 = ppcVar5 + 1;
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != NULL);
		do {
			pCStack11756 = prop;
			front::Panel_CreateButtons
								((PanelType)prop,auStack11736[(int)prop],(int)(aPStack10368 + (int)prop * 0x18),
								 (int)(afStack4608 + (int)prop * 0x60),(int *)(apcStack9216 + (int)prop * 0x18),
								 (int)(auStack8064 + (int)prop * 0x60),(int)(auStack6912 + (int)prop * 0x60),
								 (int)(aTStack11520 + (int)prop * 0x18));
			prop = (CFGProperty *)((int)&pCStack11756->fileData + 1);
		} while (prop < (CFGProperty *)&DAT_0000000c);
		if (iStack11748 != 0) {
			ppcVar5 = apcStack5760;
			iVar4 = iStack11748;
			pCStack11756 = prop;
			do {
				std::free(*ppcVar5);
				ppcVar5 = ppcVar5 + 1;
				iVar4 += -1;
			} while (iVar4 != 0);
		}
	}
	return;
}



void __cdecl lego::lrr::Lego_LoadTutorialIcon(CFGProperty *root)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","TutorialIcon",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::legoGlobs.TutorialIcon = lego::image::Image_LoadBMPScaled(pcVar1,0,0);
		if (globs::legoGlobs.TutorialIcon != NULL) {
			lego::image::Image_SetPenZeroTrans(globs::legoGlobs.TutorialIcon);
		}
	}
	return;
}



void __cdecl lego::lrr::Lego_LoadSamples(CFGProperty *root,BOOL noReduceSamples)
{
	char *pcVar1;
	CFGProperty *prop;
	BOOL BVar2;
	SFXType sfxType;
	bool reduced;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Samples",0);
	prop = cfg::CFG_GetChildren(root,pcVar1);
	if (prop != NULL) {
		snd::SFX_SetSamplePopulateMode(TRUE);
		do {
			pcVar1 = prop->key;
			reduced = false;
			if ((*pcVar1 == '!') && (pcVar1 = pcVar1 + 1, noReduceSamples == 0)) {
				reduced = true;
			}
			if (!reduced) {
						// Audio_SetSamplePopulateMode(TRUE); was called, meaning this function will register
						// new SFX if they don't already exist
				BVar2 = snd::SFX_GetType(pcVar1,&sfxType);
				if (BVar2 != 0) {
					snd::SFX_Sample_LoadProperty(prop->value,sfxType);
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != NULL);
		snd::SFX_SetSamplePopulateMode(0);
	}
	return;
}



void __cdecl lego::lrr::Lego_LoadTextMessages(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	TextType local_22c;
	char *stringParts [10];
	char buffer [512];
	
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"TextMessages",0);
	for (pCVar3 = cfg::CFG_GetChildren(root,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		BVar4 = front::Text_GetTextType(pCVar3->key,&local_22c);
		if (BVar4 != 0) {
			front::Text_SetMessage(local_22c,pCVar3->value);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"TextMessagesWithImages",0);
	pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (pCVar3 == NULL) {
			return;
		}
		BVar4 = front::Text_GetTextType(pCVar3->key,&local_22c);
		if (BVar4 != 0) {
			uVar5 = 0xffffffff;
			pcVar2 = pCVar3->value;
			do {
				pcVar8 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar8 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar8;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar8 + -uVar5);
			puVar9 = (undefined4 *)buffer;
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			util::Util_Tokenise(buffer,stringParts,":");
			front::Text_SetMessageWithImage(local_22c,stringParts[0],stringParts[1],stringParts[2]);
		}
		pCVar3 = cfg::CFG_NextFlat(pCVar3);
	} while( true );
}



void __cdecl lego::lrr::Lego_LoadInfoMessages(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	InfoType infoType;
	SFXType sfxType;
	char *stringParts [10];
	char buffer [1024];
	
	pcVar2 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"InfoMessages",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		BVar3 = front::Info_GetInfoType(prop->key,&infoType);
		if (BVar3 != 0) {
			uVar5 = 0xffffffff;
			pcVar2 = prop->value;
			do {
				pcVar8 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar8 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar8;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar8 + -uVar5);
			puVar9 = (undefined4 *)buffer;
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			uVar5 = util::Util_Tokenise(buffer,stringParts,":");
			front::Info_SetTypeText(infoType,stringParts[0]);
			front::Info_SetTypeImageFile(infoType,stringParts[1]);
			BVar3 = snd::SFX_GetType(stringParts[2],&sfxType);
			if (BVar3 != 0) {
				front::Info_SetTypeSFX(infoType,sfxType);
			}
			if (uVar5 < 4) {
				front::Info_SetTypeChangeGameSpeed(infoType,1);
				BVar3 = 0;
			}
			else {
				iVar4 = std::_stricmp(stringParts[3],"SLOW");
				front::Info_SetTypeChangeGameSpeed(infoType,(uint)(iVar4 == 0));
				iVar4 = std::_stricmp(stringParts[3],"ALWAYSPLAYSFX");
				if (iVar4 == 0) {
					BVar3 = 1;
				}
				else {
					if ((uVar5 < 5) || (iVar4 = std::_stricmp(stringParts[4],"ALWAYSPLAYSFX"), iVar4 != 0)) {
						BVar3 = 0;
					}
					else {
						BVar3 = 1;
					}
				}
			}
			front::Info_SetTypeFlag_20000(infoType,BVar3);
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::lrr::Lego_LoadToolTips(CFGProperty *root)
{
	char *pcVar1;
	CFGProperty *pCVar2;
	BOOL BVar3;
	ToolTipType toolTipType;
	SFXType sfxType;
	
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTips",0);
	for (pCVar2 = cfg::CFG_GetChildren(root,pcVar1); pCVar2 != NULL;
			pCVar2 = cfg::CFG_NextFlat(pCVar2)) {
		BVar3 = front::ToolTip_GetType(pCVar2->key,&toolTipType);
		if (BVar3 != 0) {
			front::ToolTip_SetText(toolTipType,pCVar2->value);
		}
	}
	pcVar1 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipsSFXs",0);
	for (pCVar2 = cfg::CFG_GetChildren(root,pcVar1); pCVar2 != NULL;
			pCVar2 = cfg::CFG_NextFlat(pCVar2)) {
		BVar3 = front::ToolTip_GetType(pCVar2->key,&toolTipType);
		if ((BVar3 != 0) && (BVar3 = snd::SFX_GetType(pCVar2->value,&sfxType), BVar3 != 0)) {
			front::ToolTip_SetSFX(toolTipType,sfxType);
		}
	}
	return;
}



BOOL __cdecl lego::game::Game_TryTeleportObject(ObjectType objType,int objIndex)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	Vector3F local_c;
	
	globs::legoGlobs.flags3 &= ~GAME3_PLACEBUILDING;
	front::HelpWindow_IfFlag4_AndParam_Clear1_Set2_Else_Clear3(TRUE);
	if ((objType == OBJECT_BUILDING) || (objType == OBJECT_ELECTRICFENCE)) {
		globs::legoGlobs.flags3 |= GAME3_PLACEBUILDING;
		globs::legoGlobs.placeObjType = objType;
		globs::legoGlobs.placeObjIndex = objIndex;
		res::Container_GetOrientation((globs::legoGlobs.cameraMain)->contCam,NULL,&local_c,NULL);
		if (ABS(local_c.x) <= ABS(local_c.y)) {
			if ((ushort)((ushort)(local_c.y < 0.0) << 8 | (ushort)(local_c.y == 0.0) << 0xe) == 0) {
				globs::legoGlobs.placeObjDirection = DIRECTION_DOWN;
				return TRUE;
			}
			globs::legoGlobs.placeObjDirection = DIRECTION_UP;
			return TRUE;
		}
		if ((ushort)((ushort)(local_c.x < 0.0) << 8 | (ushort)(local_c.x == 0.0) << 0xe) == 0) {
			globs::legoGlobs.placeObjDirection = DIRECTION_LEFT;
			return TRUE;
		}
		globs::legoGlobs.placeObjDirection = DIRECTION_RIGHT;
		return TRUE;
	}
	OVar1 = stats::Stats_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USESMALLTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globs::legoGlobs.placeDestSmallTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = stats::Stats_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USEBIGTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globs::legoGlobs.placeDestBigTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = stats::Stats_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USEWATERTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globs::legoGlobs.placeDestWaterTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = stats::Stats_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USELEGOMANTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(NULL,objType,objIndex);
		return BVar2;
	}
	return 0;
}



void __cdecl
lego::game::Level_Block_UpdateSurveyRadius_FUN_00434f40(Point2I *blockPos,int surveyRadius)
{
	uint bx;
	LevelData *pLVar1;
	uint by;
	int iVar2;
	int iVar3;
	int iVar4;
	
	pLVar1 = globs::legoGlobs.level;
	iVar2 = -surveyRadius;
	iVar4 = iVar2;
	if (-surveyRadius == surveyRadius || SBORROW4(iVar2,surveyRadius) != surveyRadius * -2 < 0) {
		do {
			for (iVar3 = iVar2; iVar3 <= surveyRadius; iVar3 += 1) {
				if ((((iVar3 * iVar3 + iVar4 * iVar4 <= surveyRadius * surveyRadius) &&
						 (bx = iVar3 + blockPos->x, -1 < (int)bx)) && ((int)bx < (pLVar1->dimensions).width)) &&
					 ((by = blockPos->y + iVar4, -1 < (int)by && ((int)by < (pLVar1->dimensions).height)))) {
					Level_Block_SetSurveyed(bx,by);
				}
			}
			iVar4 += 1;
		} while (iVar4 <= surveyRadius);
	}
	return;
}



void __cdecl lego::lrr::Lego_LoadSurfaceTypeDescriptions_sound(CFGProperty *root,char *rootPath)
{
	char cVar1;
	char *pcVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	SFXType *pSVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	SFXType sfxType;
	undefined4 *local_42c;
	char *local_428;
	char *local_424;
	char buff [1024];
	
	pSVar6 = globs::legoGlobs.SurfaceTypeDescriptions_sound_TABLE;
	do {
		pcVar2 = cfg::CFG_JoinPath(rootPath,"SurfaceTypeDescriptions",pSVar6[-0x24],0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
		if (pcVar2 != NULL) {
			uVar4 = 0xffffffff;
			local_42c = (undefined4 *)buff;
			pcVar8 = pcVar2;
			do {
				pcVar9 = pcVar8;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pcVar9 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar9;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)(pcVar9 + -uVar4);
			puVar10 = local_42c;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
			util::Util_Tokenise(pcVar2,&local_428,",");
			pcVar2 = util::Util_RemoveUnderscores(local_428);
			pSVar6[-0x12] = (SFXType)pcVar2;
			BVar3 = snd::SFX_GetType(local_424,&sfxType);
			*pSVar6 = -(uint)(BVar3 != 0) & sfxType;
		}
		pSVar6 = pSVar6 + 1;
		if ((SFXType *)((int)globs::legoGlobs.SurfaceTypeDescriptions_sound_TABLE + 0x47) < pSVar6) {
			return;
		}
	} while( true );
}



char * __cdecl lego::game::Game_GetSurfaceTypeDescription(SurfaceType surfaceType)
{
	char *pcVar1;
	
	pcVar1 = globs::legoGlobs.SurfaceTypeDescriptions_name_TABLE[surfaceType];
	if (pcVar1 == NULL) {
		pcVar1 = "Need config for surface type.";
	}
	return pcVar1;
}



SFXType __cdecl lego::game::Game_GetSurfaceTypeSFX(SurfaceType surfaceType)
{
	return globs::legoGlobs.SurfaceTypeDescriptions_sound_TABLE[surfaceType];
}



void __cdecl lego::game::Level_SetPointer_FromSurfaceType(SurfaceType surfaceType)
{
	if (surfaceType == SURFACE_IMMOVABLE) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_IMMOVABLE);
		return;
	}
	if (surfaceType == SURFACE_HARD) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_HARD);
		return;
	}
	if (surfaceType == SURFACE_MEDIUM) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_MEDIUM);
		return;
	}
	if (surfaceType == SURFACE_LOOSE) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_LOOSE);
		return;
	}
	if (surfaceType == SURFACE_SOIL) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_SOIL);
		return;
	}
	if (surfaceType == SURFACE_ORESEAM) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_ORESEAM);
		return;
	}
	if (surfaceType == SURFACE_CRYSTALSEAM) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_CRYSTALSEAM);
		return;
	}
	if (surfaceType == SURFACE_RECHARGESEAM) {
		front::Pointer_SetCurrent_IfTimerFinished(POINTER_SURFACETYPE_RECHARGESEAM);
	}
	return;
}



void __cdecl lego::game::Level_GenerateFallin_InRadius(Point2I *blockPos,int radius,BOOL param_3)
{
	short rng1;
	short rng2;
	uint uVar1;
	BOOL BVar2;
	int iVar3;
	BOOL *pBVar4;
	uint i;
	Point2I blockOffPos;
	BOOL fallins [100];
	uint diameter;
	
						// Fallins can be performed in a maximum of 10x10 diameter(?)
	pBVar4 = fallins;
	for (iVar3 = 100; iVar3 != 0; iVar3 += -1) {
		*pBVar4 = 0;
		pBVar4 = pBVar4 + 1;
	}
	diameter = radius * 2;
	i = 0;
	while( true ) {
		if (param_3 == 0) {
			uVar1 = diameter * diameter >> 2;
		}
		else {
			uVar1 = diameter * diameter;
		}
		if (uVar1 <= i) break;
		rng1 = math::Maths_Rand();
		rng2 = math::Maths_Rand();
		blockOffPos.x = ((uint)(int)rng1 % diameter + blockPos->x) - radius;
		blockOffPos.y = (blockPos->y + (uint)(int)rng2 % diameter) - radius;
		iVar3 = (uint)(int)rng2 % diameter + ((uint)(int)rng1 % diameter) * 10;
		if (fallins[iVar3] == 0) {
			BVar2 = Fallin_Block_FUN_0040f0c0(&blockOffPos,TRUE);
			if ((BVar2 != 0) && (param_3 != 0)) {
				return;
			}
			fallins[iVar3] = TRUE;
		}
		i += 1;
	}
	return;
}



void __cdecl
lego::game::Level_UpdateTutorialBlockFlashing
					(LevelData *level,Viewport *viewMain,float elapsedGame,float elapsedAbs)
{
	LevelBlock *pLVar1;
	TutorialFlags TVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	WallHighlightType WVar5;
	uint by;
	uint bx;
	float10 fVar6;
	float10 fVar7;
	Point2F local_14;
	Vector3F local_c;
	
	fVar6 = (float10)fsin((float10)globs::gamectrlGlobs.timerTutorialBlockFlash);
	globs::gamectrlGlobs.timerTutorialBlockFlash =
			 globs::gamectrlGlobs.timerTutorialBlockFlash - elapsedAbs * 25.0 * -0.01333333;
	TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar2 != TUTORIAL_NONE) {
		by = 0;
		pSVar3 = level->surfaceMap;
		if ((pSVar3->smallDimensions).height != 0) {
			do {
				bx = 0;
				if ((pSVar3->smallDimensions).width != 0) {
					do {
						BVar4 = Level_Block_IsMeshHidden(bx,by);
						if (BVar4 == 0) {
							pLVar1 = level->blocks + by * (level->dimensions).width + bx;
							if (pLVar1->blockpointer == 0) {
								if (pLVar1->field_44 == 1) {
									pLVar1->field_44 = 0;
									TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
									if ((((TVar2 & TUTORIAL_UNK_2) == TUTORIAL_NONE) &&
											(level->blocks[by * (level->dimensions).width + bx].clickCount != 0)) &&
										 (InterfaceMenuType_004deccc == INTERFACE_MENU_MAIN)) {
										Map3D_Block_SetHighlightType
															((globs::legoGlobs.level)->surfaceMap,bx,by,WALLHIGHLIGHT_SELECTED);
									}
									else {
										pSVar3 = (globs::legoGlobs.level)->surfaceMap;
LAB_0043544b:
										Map3D_Block_ClearHighlight(pSVar3,bx,by);
									}
								}
								else {
									if ((pLVar1->field_44 == 0) &&
										 (WVar5 = Map3D_Block_GetHighlightType
																				((globs::legoGlobs.level)->surfaceMap,bx,by),
										 WVar5 == WALLHIGHLIGHT_TUTORIAL)) {
										pSVar3 = (globs::legoGlobs.level)->surfaceMap;
										goto LAB_0043544b;
									}
								}
							}
							else {
								Map3D_BlockToWorldPos(level->surfaceMap,bx,by,&local_c.x,&local_c.y);
								fVar7 = Map3D_GetWorldZ(level->surfaceMap,local_c.x,local_c.y);
								local_c.z = (float)fVar7;
								lego::view::Viewport_WorldToScreen(viewMain,&local_14,&local_c);
								local_14.x = local_14.x - (float)((int)(globs::legoGlobs.TutorialIcon)->width / 2);
								local_14.y = local_14.y -
														 ((float)fVar6 * 20.0 +
														 (float)((globs::legoGlobs.TutorialIcon)->height << 1));
								lego::image::Image_DisplayScaled(globs::legoGlobs.TutorialIcon,NULL,&local_14,NULL);
								if (BOOL_004ded1c == 0) {
									Map3D_Block_ClearHighlight((globs::legoGlobs.level)->surfaceMap,bx,by);
									level->blocks[by * (level->dimensions).width + bx].field_44 = 1;
								}
								else {
									Map3D_Block_SetHighlightType
														((globs::legoGlobs.level)->surfaceMap,bx,by,WALLHIGHLIGHT_TUTORIAL);
									level->blocks[by * (level->dimensions).width + bx].field_44 = 1;
								}
							}
						}
						bx += 1;
					} while (bx < (uint)(level->surfaceMap->smallDimensions).width);
				}
				pSVar3 = level->surfaceMap;
				by += 1;
			} while (by < (uint)(pSVar3->smallDimensions).height);
		}
	}
	return;
}



BOOL __cdecl lego::front::Front_LeftButtonInputUnk_FUN_00435480(void)
{
	if ((globs::INPUT.mslb == 0) && (globs::gamectrlGlobs.mslb_Last_1 != 0)) {
		globs::gamectrlGlobs.mslb_Last_1 = globs::INPUT.mslb;
		return TRUE;
	}
	globs::gamectrlGlobs.mslb_Last_1 = globs::INPUT.mslb;
	return 0;
}



BOOL __cdecl lego::front::Front_DrawDialogContrastOverlay(void)
{
	Point2F point;
	
	point.x = 0.0;
	point.y = 0.0;
	if (globs::legoGlobs.DialogContrastOverlay == NULL) {
		return 0;
	}
	lego::image::Image_DisplayScaled(globs::legoGlobs.DialogContrastOverlay,NULL,&point,NULL);
	return TRUE;
}



int __cdecl
lego::front::SaveMenu_ConfirmMessage_FUN_004354f0
					(char *titleText,char *message,char *okText,char *cancelText)
{
	float fVar1;
	float fVar2;
	uint uVar3;
	uint uVar4;
	BOOL BVar5;
	int iVar6;
	Point2F local_18;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	iVar6 = -1;
	if (((globs::legoGlobs.DialogImage != NULL) && (globs::legoGlobs.DialogTextWndTitle != NULL)) &&
		 (globs::legoGlobs.DialogTextWndMessage != NULL)) {
		Front_DrawDialogContrastOverlay();
		local_18.x = (float)((int)globs::mainGlobs.appWidth / 2) -
								 (float)((globs::legoGlobs.DialogImage)->width >> 1);
		local_18.y = (float)((int)globs::mainGlobs.appHeight / 2) -
								 (float)((globs::legoGlobs.DialogImage)->height >> 1);
		lego::image::Image_DisplayScaled(globs::legoGlobs.DialogImage,NULL,&local_18,NULL);
		TextWindow_Clear(globs::legoGlobs.DialogTextWndTitle);
		TextWindow_Clear(globs::legoGlobs.DialogTextWndMessage);
		TextWindow_Clear(globs::legoGlobs.DialogTextWndOK);
		TextWindow_Clear(globs::legoGlobs.DialogTextWndCancel);
		if (okText != NULL) {
			local_c = 0.0;
			local_8 = 0;
			local_4 = 0.0;
			uVar3 = lego::image::Font_GetStringWidth(globs::legoGlobs.bmpMbriefFONT,okText);
			uVar4 = lego::image::Font_GetHeight(globs::legoGlobs.bmpMbriefFONT);
			fVar1 = (((globs::legoGlobs.DialogTextWndOK)->windowSize).x -
							((globs::legoGlobs.DialogTextWndOK)->windowSize).width * -0.5) - (float)(uVar3 >> 1);
			local_c = ((globs::legoGlobs.DialogTextWndOK)->windowSize).y;
			local_4 = (float)(ulonglong)uVar4;
			fVar2 = (float)globs::INPUT.msx;
			if ((((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) ||
					(fVar1 + (float)(ulonglong)uVar3 <= fVar2)) ||
				 ((fVar1 = (float)globs::INPUT.msy,
					(ushort)((ushort)(fVar1 < local_c) << 8 | (ushort)(fVar1 == local_c) << 0xe) != 0 ||
					(local_c + local_4 <= fVar1)))) {
				(globs::legoGlobs.DialogTextWndOK)->font = globs::legoGlobs.bmpMbriefFONT;
				TextWindow_PrintF(globs::legoGlobs.DialogTextWndOK,okText);
			}
			else {
				(globs::legoGlobs.DialogTextWndOK)->font = globs::legoGlobs.bmpMbriefFONT2;
				TextWindow_PrintF(globs::legoGlobs.DialogTextWndOK,okText);
				BVar5 = Front_LeftButtonInputUnk_FUN_00435480();
				if (BVar5 != 0) {
					iVar6 = 1;
				}
			}
		}
		if (cancelText != NULL) {
			local_c = 0.0;
			local_8 = 0;
			local_4 = 0.0;
			uVar3 = lego::image::Font_GetStringWidth(globs::legoGlobs.bmpMbriefFONT,cancelText);
			uVar4 = lego::image::Font_GetHeight(globs::legoGlobs.bmpMbriefFONT);
			fVar1 = (((globs::legoGlobs.DialogTextWndCancel)->windowSize).x -
							((globs::legoGlobs.DialogTextWndCancel)->windowSize).width * -0.5) -
							(float)(uVar3 >> 1);
			local_c = ((globs::legoGlobs.DialogTextWndCancel)->windowSize).y;
			local_4 = (float)(ulonglong)uVar4;
			fVar2 = (float)globs::INPUT.msx;
			if ((((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) ||
					(fVar1 + (float)(ulonglong)uVar3 <= fVar2)) ||
				 ((fVar1 = (float)globs::INPUT.msy,
					(ushort)((ushort)(fVar1 < local_c) << 8 | (ushort)(fVar1 == local_c) << 0xe) != 0 ||
					(local_c + local_4 <= fVar1)))) {
				(globs::legoGlobs.DialogTextWndCancel)->font = globs::legoGlobs.bmpMbriefFONT;
				TextWindow_PrintF(globs::legoGlobs.DialogTextWndCancel,cancelText);
			}
			else {
				(globs::legoGlobs.DialogTextWndCancel)->font = globs::legoGlobs.bmpMbriefFONT2;
				TextWindow_PrintF(globs::legoGlobs.DialogTextWndCancel,cancelText);
				BVar5 = Front_LeftButtonInputUnk_FUN_00435480();
				if (BVar5 != 0) {
					iVar6 = 0;
				}
			}
		}
		TextWindow_PrintF(globs::legoGlobs.DialogTextWndTitle,titleText);
		TextWindow_PrintF(globs::legoGlobs.DialogTextWndMessage,message);
		TextWindow_Update(globs::legoGlobs.DialogTextWndTitle,0,1.0,NULL);
		TextWindow_Update(globs::legoGlobs.DialogTextWndMessage,0,1.0,NULL);
		TextWindow_Update(globs::legoGlobs.DialogTextWndOK,0,1.0,NULL);
		TextWindow_Update(globs::legoGlobs.DialogTextWndCancel,0,1.0,NULL);
		return iVar6;
	}
	return -1;
}



// This is a messy function that handles a ton of front end behavior on level end.
// Including: show rewards, level cleanup, RUN MAIN MENU LEVEL SELECT IU LOOP!!!!

BOOL __cdecl lego::lrr::Lego_EndLevel(void)
{
	BOOL BVar1;
	BOOL BVar2;
	BOOL BVar3;
	char *nextLevelName;
	int iVar4;
	
	Lego_GetLevel();
	BVar1 = front::Front_IsMenuLabelUnkValue1_NotM1();
	BVar2 = front::Front_GetUnkTutoOrMissions();
	snd::Sound3D_StopAllSounds();
	BVar3 = front::Front_IsFrontEndEnabled();
	if (BVar3 != 0) {
		reward::Reward_CreateLevel();
		reward::Reward_Prepare();
		reward::Reward_Show();
		reward::Reward_FreeLevel();
	}
	Lego_SetViewMode(VIEW_TOPDOWN,NULL,0);
	front::TextWindow_Clear(globs::legoGlobs.textWnd_80);
	nextLevelName = game::Level_Free();
	BVar3 = front::Front_IsFrontEndEnabled();
	if (BVar3 != 0) {
		if (BVar1 == 0) {
			if (BVar2 == 0) goto LAB_00435915;
			front::Front_RunScreenMenuType(MENU_SCREEN_TRAINING);
			iVar4 = front::Front_IsTriggerAppQuit();
			if (iVar4 != 0) {
				return 0;
			}
		}
		else {
			front::Front_RunScreenMenuType(MENU_SCREEN_MISSIONS);
			iVar4 = front::Front_IsTriggerAppQuit();
			if (iVar4 != 0) {
				return 0;
			}
		}
		nextLevelName = front::Front_GetSelectedLevel();
	}
LAB_00435915:
	front::Front_SetOptionParameters(TRUE,FALSE);
	if (nextLevelName == NULL) {
		return 0;
	}
	BVar1 = Lego_LoadLevel(nextLevelName);
	if (BVar1 == 0) {
		return 0;
	}
	std::free(nextLevelName);
	return TRUE;
}



void __cdecl lego::lrr::LegoGame_ClearSomeFlags3_FUN_00435950(void)
{
	globs::legoGlobs.flags3 &=
			 ~(GAME3_UNK_1|GAME3_UNK_2|GAME3_UNK_4|GAME3_PICKUPOBJECT|GAME3_LOADVEHICLE|GAME3_UNK_20|
				 GAME3_UNK_40|GAME3_PLACEBUILDING);
	res::SelectPlace_Hide(globs::legoGlobs.selectPlace,TRUE);
	return;
}



void __cdecl lego::lrr::LegoGame_UnkTeleporterInit_FUN_00435980(void)
{
	BOOL BVar1;
	
	if ((globs::legoGlobs.flags1 & GAME1_UNK_8000000) != GAME1_NONE) {
		BVar1 = unk::Teleporter_ServiceAll
											(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
											 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
		if (BVar1 != 0) {
			globs::legoGlobs.flags2 |= GAME2_UNK_2;
		}
	}
	return;
}



void __cdecl lego::lrr::LegoGame_SetAttackDefer(BOOL defer)
{
	if (defer != 0) {
		globs::legoGlobs.flags2 = globs::legoGlobs.flags2 | GAME2_ATTACKDEFER;
		return;
	}
	globs::legoGlobs.flags2 = globs::legoGlobs.flags2 & ~GAME2_ATTACKDEFER;
	return;
}



void __cdecl lego::lrr::LegoGame_SetCallToArmsOn(BOOL callToArms)
{
	if (callToArms != 0) {
		globs::legoGlobs.flags2 |= GAME2_CALLTOARMS;
		if ((ushort)((ushort)(globs::legoGlobs.timerGame_e3c < 0.0) << 8 |
								(ushort)(globs::legoGlobs.timerGame_e3c == 0.0) << 0xe) != 0) {
			snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_SIREN,FALSE);
			globs::legoGlobs.timerGame_e3c = 250.0;
		}
		front::Panel_Button_SetFlag_8_OrUnset_c(PANEL_TOPPANEL,PANELBUTTON_TOPPANEL_CALLTOARMS,TRUE);
		return;
	}
	globs::legoGlobs.flags2 &= ~GAME2_CALLTOARMS;
	globs::legoGlobs.timerGame_e3c = 0.0;
	front::Panel_Button_SetFlag_8_OrUnset_c(PANEL_TOPPANEL,PANELBUTTON_TOPPANEL_CALLTOARMS,FALSE);
	return;
}



Camera * __cdecl lego::view::Camera_Create(Container *contRoot,CameraType camType)
{
	Camera *cam;
	Container *cont;
	
	cam = (Camera *)std::malloc(0xbc);
	if (cam != NULL) {
		cam->camType = camType;
		cam->trackObj = NULL;
		cam->trackRadarDist = 0.0;
		cam->trackRadarFloat_8 = 0.0;
		*(undefined *)&cam->flags = CAMERA_NONE;
		cam->yaw = 0.0;
		cam->tilt = 0.0;
		cam->dist = 200.0;
		cam->trackFPCameraFrame = 0;
		(cam->moveVector).x = 0.0;
		(cam->moveVector).y = 0.0;
		(cam->moveVector).z = 0.0;
		cam->moveSpeed = 0.0;
		cam->shakeFloat_a8 = 0.0;
		cam->shakeDuration = 0.0;
		cam->shakeIntensity = 0.0;
		(cam->shakeVector).z = 0.0;
		(cam->shakeVector).y = 0.0;
		(cam->shakeVector).x = 0.0;
		cont = res::Container_Create(NULL);
		cam->contCam = cont;
		if (cam->contCam != NULL) {
			res::Container_SetPosition(cam->contCam,NULL,0.0,0.0,-cam->dist);
			res::Container_SetOrientation(cam->contCam,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
			if (camType == CAMERATYPE_FIRSTPERSON) {
				res::Container_SetParent(cam->contCam,contRoot);
				return cam;
			}
			cont = res::Container_Create(contRoot);
			cam->cont2 = cont;
			if (cam->cont2 != NULL) {
				cont = res::Container_Create(contRoot);
				cam->cont3 = cont;
				if (cam->cont3 != NULL) {
					cont = res::Container_Create(cam->cont2);
					cam->cont4 = cont;
					if (cam->cont4 != NULL) {
						if (camType == CAMERATYPE_TOPDOWN) {
							cont = res::Container_Create(cam->cont4);
							cam->contListener = cont;
							if (cam->contListener != NULL) {
								res::Container_SetPosition(cam->contListener,NULL,0.0,0.0,-80.0);
							}
						}
						res::Container_SetParent(cam->contCam,cam->cont4);
						return cam;
					}
					res::Container_Remove(cam->cont3);
				}
				res::Container_Remove(cam->cont2);
			}
			res::Container_Remove(cam->contCam);
		}
		std::free(cam);
	}
	return NULL;
}



// If true, allows orientation movement while ignoring
//  zoom, tilt, and yaw range restrictions.

void __cdecl lego::view::Camera_Debug_EnableFreeMovement(Camera *cam,BOOL on)
{
	if (on == FALSE) {
						// ~CAMERA_FREEMOVEMENT (~0x8)
		*(byte *)&cam->flags = *(byte *)&cam->flags & 0xf7;
	}
	else {
		*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_FREEMOVEMENT;
	}
	return;
}



void __cdecl lego::view::Camera_Free(Camera *cam)
{
	res::Container_Remove(cam->contCam);
	if (cam->camType != CAMERATYPE_FIRSTPERSON) {
		res::Container_Remove(cam->cont2);
		res::Container_Remove(cam->cont4);
	}
	std::free(cam);
	return;
}



void __cdecl
lego::view::Camera_SetCameraMovements
					(float cameraSpeed,float cameraDropOff,float cameraAcceleration,int mouseScrollIndent)
{
	globs::cameraGlobs.CameraSpeed = cameraSpeed;
	globs::cameraGlobs.CameraDropOff = cameraDropOff;
	globs::cameraGlobs.CameraAcceleration = cameraAcceleration;
	globs::cameraGlobs.MouseScrollIndent = mouseScrollIndent;
	return;
}



void __cdecl
lego::view::Camera_CopyPositionOrientation_IfFirstPerson(Camera *dstCamera,Camera *srcCamera)
{
	Vector3F vectorPos;
	Vector3F vectorD;
	Vector3F vectorU;
	
	if (dstCamera->camType == CAMERATYPE_FIRSTPERSON) {
		res::Container_GetPosition(srcCamera->contCam,NULL,&vectorPos);
		res::Container_GetOrientation(srcCamera->contCam,NULL,&vectorD,&vectorU);
		res::Container_SetPosition(dstCamera->contCam,NULL,vectorPos.x,vectorPos.y,vectorPos.z);
		res::Container_SetOrientation
							(dstCamera->contCam,NULL,vectorD.x,vectorD.y,vectorD.z,vectorU.x,vectorU.y,vectorU.z);
	}
	return;
}



// Set liveObj to NULL to disable.

void __cdecl
lego::view::Camera_TrackObject
					(Camera *cam,LiveObject *liveObj,float trackFloat_8,float trackDist,float trackTilt,
					float trackRotationSpeed)
{
	cam->trackObj = liveObj;
	cam->trackRadarFloat_8 = trackFloat_8;
	cam->trackRadarDist = trackDist;
	Camera_SetTilt(cam,trackTilt);
	cam->trackRadarYawSpeed = trackRotationSpeed;
	return;
}



void __cdecl lego::view::Camera_SetFPObject(Camera *cam,LiveObject *liveObj,int cameraFrame)
{
	cam->trackObj = liveObj;
	cam->trackFPCameraFrame = cameraFrame;
	return;
}



int __cdecl lego::view::Camera_GetFPCameraFrame(Camera *cam)
{
	return cam->trackFPCameraFrame;
}



void __cdecl lego::view::Camera_StopMovement(Camera *cam)
{
	cam->moveSpeed = 0.0;
	return;
}



int __cdecl lego::view::Camera_GetMouseScrollIndent(void)
{
	return globs::cameraGlobs.MouseScrollIndent;
}



void __cdecl lego::view::Camera_Shake(Camera *cam,float intensity,float duration)
{
	cam->shakeIntensity = intensity;
	cam->shakeDuration = duration;
	cam->shakeFloat_a8 = 0.0;
	return;
}



void __cdecl
lego::view::Camera_Update(Camera *cam,LevelData *level,float elapsedAbs,float elapsedGame)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	BOOL bInside;
	SurfaceMap *surfMap;
	Container *radar_objCont;
	float10 fVar10;
	float10 fVar11;
	Vector3F radar_vecCont1Pos2;
	Vector3F local_d4;
	Vector3F local_c8;
	Vector3F radar_vecCont2Pos;
	Vector3F radar_vecObjDir;
	Vector3F radar_vecCont1Pos;
	Vector3F radar_vecObjPos;
	Vector3F fp_vecObjPos;
	Vector3F fp_vecUp;
	float fp_distOrient;
	Vector3F fp_vecCont1Pos;
	Vector3F fp_vecCont1Dir;
	float fp_distPos;
	Vector3F top_vecPos;
	Vector3F top_vecDir;
	Vector3F top_vecUp;
	uint blockY;
	uint blockX;
	
	res::Container_AddTranslation
						(cam->contCam,D3DRMCOMBINE_BEFORE,-(cam->shakeVector).x,-(cam->shakeVector).y,
						 -(cam->shakeVector).z);
	fVar1 = globs::cameraGlobs.CameraDropOff;
	if (cam->camType == CAMERATYPE_TOPDOWN) {
						// Decelerate camera movement.
						// Maths_Vector3DScale(cam->vector_18, cam->vector_18, cameraGlobs.CameraDropOff);
		(cam->moveVector).x = (cam->moveVector).x * globs::cameraGlobs.CameraDropOff;
		(cam->moveVector).y = (cam->moveVector).y * fVar1;
		(cam->moveVector).z = (cam->moveVector).z * fVar1;
		res::Container_AddTranslation
							(cam->cont2,D3DRMCOMBINE_AFTER,(cam->moveVector).x,(cam->moveVector).y,
							 (cam->moveVector).z);
		res::Container_GetPosition(cam->cont2,NULL,&top_vecPos);
		res::Container_GetOrientation(cam->cont2,NULL,&top_vecDir,&top_vecUp);
		bInside = game::Map3D_WorldToBlockPos_NoZ
												(level->surfaceMap,top_vecPos.x,top_vecPos.y,(int *)&blockX,(int *)&blockY);
		if (bInside == 0) {
						// Cancel out moveVector ??
			res::Container_AddTranslation
								(cam->cont2,D3DRMCOMBINE_AFTER,-(cam->moveVector).x,-(cam->moveVector).y,
								 -(cam->moveVector).z);
		}
		else {
			if ((blockX < (uint)globs::cameraGlobs.MouseScrollIndent) ||
				 ((uint)((level->surfaceMap->smallDimensions).width - globs::cameraGlobs.MouseScrollIndent)
					<= blockX)) {
				res::Container_AddTranslation(cam->cont2,D3DRMCOMBINE_AFTER,-(cam->moveVector).x,0.0,0.0);
			}
			if ((blockY < (uint)globs::cameraGlobs.MouseScrollIndent) ||
				 ((uint)((level->surfaceMap->smallDimensions).height - globs::cameraGlobs.MouseScrollIndent)
					<= blockY)) {
				res::Container_AddTranslation(cam->cont2,D3DRMCOMBINE_AFTER,0.0,-(cam->moveVector).y,0.0);
			}
			fVar10 = game::Map3D_GetWorldZ(level->surfaceMap,top_vecPos.x,top_vecPos.y);
			res::Container_SetPosition(cam->cont3,NULL,top_vecPos.x,top_vecPos.y,(float)fVar10);
			res::Container_SetOrientation(cam->cont3,NULL,top_vecUp.x,top_vecUp.y,0.0,0.0,0.0,-1.0);
			surfMap = lrr::Lego_GetMap();
			fVar10 = game::Map3D_UnkCameraXYFunc_RetZunk(surfMap,top_vecPos.x,top_vecPos.y);
			res::Container_SetPosition(cam->contCam,cam->cont4,0.0,0.0,-(cam->dist + (float)-fVar10));
		}
		goto LAB_004368f0;
	}
	if (cam->camType != CAMERATYPE_FIRSTPERSON) {
		if (cam->camType == CAMERATYPE_RADAR) {
			if (cam->trackObj == NULL) {
				game::Game_SetFlag1_20000_unkCameraRadarHasTrackObj(TRUE);
			}
			else {
				radar_objCont = game::LiveObject_GetContainer(cam->trackObj);
				if (radar_objCont != NULL) {
					fVar2 = cam->trackRadarFloat_8 * elapsedGame;
					game::Game_SetFlag1_20000_unkCameraRadarHasTrackObj(FALSE);
					res::Container_GetPosition(cam->contCam,NULL,&radar_vecCont1Pos);
					res::Container_GetPosition(radar_objCont,NULL,&radar_vecObjPos);
					radar_vecObjPos.z = radar_vecObjPos.z - cam->trackRadarDist / 10.0;
					fVar1 = cam->dist;
					cam->dist = cam->trackRadarDist;
					res::Container_SetPosition(cam->contCam,cam->cont4,0.0,0.0,-cam->dist);
					res::Container_GetPosition(cam->cont2,NULL,&radar_vecCont2Pos);
					res::Container_SetPosition
										(cam->cont2,NULL,radar_vecObjPos.x,radar_vecObjPos.y,radar_vecObjPos.z);
					res::Container_GetPosition(cam->contCam,NULL,&radar_vecCont1Pos2);
					fVar10 = std::sqrt((double)((radar_vecCont1Pos2.z - radar_vecCont1Pos.z) *
																			(radar_vecCont1Pos2.z - radar_vecCont1Pos.z) +
																		 (radar_vecCont1Pos2.y - radar_vecCont1Pos.y) *
																		 (radar_vecCont1Pos2.y - radar_vecCont1Pos.y) +
																		 (radar_vecCont1Pos2.x - radar_vecCont1Pos.x) *
																		 (radar_vecCont1Pos2.x - radar_vecCont1Pos.x)));
					if (((ushort)((ushort)(fVar10 < (float10)fVar2) << 8 |
											 (ushort)(fVar10 == (float10)fVar2) << 0xe) == 0) && ((float)fVar10 < 120.0))
					{
						fVar3 = (float)fVar10 / fVar2;
						res::Container_GetOrientation(radar_objCont,NULL,&radar_vecObjDir,NULL);
						radar_vecObjPos.x = radar_vecObjPos.x + radar_vecObjDir.x * fVar3;
						radar_vecObjPos.y = radar_vecObjPos.y + radar_vecObjDir.y * fVar3;
						radar_vecObjPos.z = radar_vecObjPos.z + radar_vecObjDir.z * fVar3;
						fVar4 = radar_vecObjPos.x - radar_vecCont2Pos.x;
						fVar5 = radar_vecObjPos.y - radar_vecCont2Pos.y;
						fVar6 = radar_vecObjPos.z - radar_vecCont2Pos.z;
						fVar10 = std::sqrt((double)(fVar6 * fVar6 + fVar5 * fVar5 + fVar4 * fVar4));
						fVar11 = std::fabs((double)(cam->trackRadarDist - fVar1));
						fVar3 = (float)fVar11;
						fVar7 = (float)fVar10 + fVar3;
						fVar11 = std::sqrt((double)(fVar6 * fVar6 + fVar5 * fVar5 + fVar4 * fVar4));
						fVar8 = 1.0 / (float)fVar11;
						fVar9 = ((float)fVar10 / fVar7) * fVar2;
						radar_vecCont2Pos.x = radar_vecCont2Pos.x + fVar4 * fVar8 * fVar9;
						radar_vecCont2Pos.y = radar_vecCont2Pos.y + fVar5 * fVar8 * fVar9;
						radar_vecCont2Pos.z = radar_vecCont2Pos.z + fVar6 * fVar8 * fVar9;
						res::Container_SetPosition
											(cam->cont2,NULL,radar_vecCont2Pos.x,radar_vecCont2Pos.y,radar_vecCont2Pos.z);
						if ((ushort)((ushort)(fVar1 < cam->trackRadarDist) << 8 |
												(ushort)(fVar1 == cam->trackRadarDist) << 0xe) == 0) {
							cam->dist = fVar1 - (fVar3 / fVar7) * fVar2;
						}
						else {
							if (fVar1 != cam->trackRadarDist) {
								cam->dist = (fVar3 / fVar7) * fVar2 + fVar1;
							}
						}
						res::Container_SetPosition(cam->contCam,cam->cont4,0.0,0.0,-cam->dist);
					}
					Camera_AddYaw(cam,cam->trackRadarYawSpeed * elapsedAbs);
				}
			}
		}
		goto LAB_004368f0;
	}
	if ((cam->trackObj == NULL) || (elapsedAbs == 0.0)) goto LAB_004368f0;
	res::Container_GetPosition(cam->contCam,NULL,&fp_vecCont1Pos);
	res::Container_GetOrientation(cam->contCam,NULL,&fp_vecCont1Dir,&fp_vecUp);
	game::LiveObject_FP_GetPositionAndHeading
						(cam->trackObj,cam->trackFPCameraFrame,&fp_vecObjPos,&fp_vecUp);
	if ((*(byte *)&cam->flags & CAMERA_UNK_10) == 0) {
LAB_0043621d:
		fp_vecCont1Pos.x = fp_vecObjPos.x;
		fp_vecCont1Pos.y = fp_vecObjPos.y;
		fp_vecCont1Pos.z = fp_vecObjPos.z;
		fp_vecCont1Dir.x = fp_vecUp.x;
		fp_vecCont1Dir.y = fp_vecUp.y;
		fp_vecCont1Dir.z = fp_vecUp.z;
	}
	else {
		fVar10 = std::sqrt((double)((fp_vecObjPos.z - fp_vecCont1Pos.z) *
																(fp_vecObjPos.z - fp_vecCont1Pos.z) +
															 (fp_vecObjPos.y - fp_vecCont1Pos.y) *
															 (fp_vecObjPos.y - fp_vecCont1Pos.y) +
															 (fp_vecObjPos.x - fp_vecCont1Pos.x) *
															 (fp_vecObjPos.x - fp_vecCont1Pos.x)));
		fp_distPos = (float)fVar10;
		if (((ushort)((ushort)(fVar10 < (float10)100.0) << 8 | (ushort)(fVar10 == (float10)100.0) << 0xe
								 ) == 0) ||
			 (fp_distOrient =
						 fp_vecUp.x * fp_vecCont1Dir.x + fp_vecUp.y * fp_vecCont1Dir.y +
						 fp_vecUp.z * fp_vecCont1Dir.z, fp_distOrient < 0.0)) goto LAB_0043621d;
	}
	fVar1 = (1.0 / elapsedAbs) * 4.0;
	fVar10 = std::sqrt((double)(fp_vecCont1Dir.z * fp_vecCont1Dir.z +
														 fp_vecCont1Dir.y * fp_vecCont1Dir.y +
														 fp_vecCont1Dir.x * fp_vecCont1Dir.x));
	fVar2 = 1.0 / (float)fVar10;
	fp_vecCont1Dir.x = fp_vecCont1Dir.x * fVar2;
	fp_vecCont1Dir.y = fp_vecCont1Dir.y * fVar2;
	fp_vecCont1Dir.z = fp_vecCont1Dir.z * fVar2;
	fVar10 = std::sqrt((double)(fp_vecUp.z * fp_vecUp.z +
														 fp_vecUp.y * fp_vecUp.y + fp_vecUp.x * fp_vecUp.x));
	fVar2 = 1.0 / (float)fVar10;
	fp_vecCont1Dir.x = fp_vecCont1Dir.x * fVar1;
	fp_vecCont1Dir.y = fp_vecCont1Dir.y * fVar1;
	fp_vecCont1Dir.z = fp_vecCont1Dir.z * fVar1;
	fp_vecUp.x = fp_vecUp.x * fVar2 + fp_vecCont1Dir.x;
	fp_vecUp.y = fp_vecUp.y * fVar2 + fp_vecCont1Dir.y;
	fp_vecUp.z = fp_vecUp.z * fVar2 + fp_vecCont1Dir.z;
	fp_vecCont1Pos.x = fp_vecCont1Pos.x * fVar1;
	fp_vecCont1Pos.y = fp_vecCont1Pos.y * fVar1;
	fp_vecCont1Pos.z = fp_vecCont1Pos.z * fVar1;
	fVar1 = 1.0 / (fVar1 + 1.0);
	fp_vecObjPos.x = (fp_vecObjPos.x + fp_vecCont1Pos.x) * fVar1;
	fp_vecObjPos.y = (fp_vecObjPos.y + fp_vecCont1Pos.y) * fVar1;
	fp_vecObjPos.z = (fp_vecObjPos.z + fp_vecCont1Pos.z) * fVar1;
	if ((ushort)((ushort)(fp_distPos < 0.01) << 8 | (ushort)(fp_distPos == 0.01) << 0xe) == 0) {
		res::Container_SetPosition(cam->contCam,NULL,fp_vecObjPos.x,fp_vecObjPos.y,fp_vecObjPos.z);
	}
	if (fp_distOrient < 0.99999) {
		res::Container_SetOrientation(cam->contCam,NULL,fp_vecUp.x,fp_vecUp.y,fp_vecUp.z,0.0,0.0,-1.0);
	}
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_UNK_10;
LAB_004368f0:
	if (cam->shakeDuration <= cam->shakeFloat_a8) {
		(cam->shakeVector).z = 0.0;
		(cam->shakeVector).y = 0.0;
		(cam->shakeVector).x = 0.0;
	}
	else {
		fVar1 = cam->shakeDuration;
		fVar2 = cam->shakeFloat_a8;
		fVar3 = cam->shakeDuration;
		fVar4 = cam->shakeIntensity;
		fVar10 = math::Maths_RandRange(0.0,1.0);
		math::Maths_Vector3DRandom(&cam->shakeVector);
		fVar1 = ((fVar1 - fVar2) / fVar3) * fVar4 * (float)fVar10;
		(cam->shakeVector).x = (cam->shakeVector).x * fVar1;
		(cam->shakeVector).y = (cam->shakeVector).y * fVar1;
		(cam->shakeVector).z = (cam->shakeVector).z * fVar1;
		cam->shakeFloat_a8 = cam->shakeFloat_a8 + elapsedGame;
		res::Container_AddTranslation
							(cam->contCam,D3DRMCOMBINE_BEFORE,-(cam->shakeVector).x,-(cam->shakeVector).y,
							 -(cam->shakeVector).z);
	}
	return;
}



void __cdecl lego::view::Camera_SetTiltRange(Camera *cam,float minTilt,float maxTilt)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_TILTRANGE;
	(cam->tiltRange).min = minTilt;
	(cam->tiltRange).max = maxTilt;
	return;
}



void __cdecl lego::view::Camera_SetTilt(Camera *cam,float tilt)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_TILTRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_FREEMOVEMENT) != 0)) ||
		 (((cam->tiltRange).min <= tilt &&
			(fVar1 = (cam->tiltRange).max,
			(ushort)((ushort)(tilt < fVar1) << 8 | (ushort)(tilt == fVar1) << 0xe) != 0)))) {
		cam->tilt = tilt;
		res::Container_SetOrientation(cam->cont4,cam->cont2,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_AddRotation(cam->cont4,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,-tilt);
	}
	return;
}



void __cdecl lego::view::Camera_AddTilt(Camera *cam,float tiltAmount)
{
	Camera_SetTilt(cam,tiltAmount + cam->tilt);
	return;
}



void __cdecl lego::view::Camera_SetYawRange(Camera *cam,float minYaw,float maxYaw)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_YAWRANGE;
	(cam->yawRange).min = minYaw;
	(cam->yawRange).max = maxYaw;
	return;
}



void __cdecl lego::view::Camera_SetYaw(Camera *cam,float yaw)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_YAWRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_FREEMOVEMENT) != 0)) ||
		 (((cam->yawRange).min <= yaw &&
			(fVar1 = (cam->yawRange).max,
			(ushort)((ushort)(yaw < fVar1) << 8 | (ushort)(yaw == fVar1) << 0xe) != 0)))) {
		cam->yaw = yaw;
		res::Container_SetOrientation(cam->cont2,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_AddRotation(cam->cont2,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,-yaw);
	}
	return;
}



void __cdecl lego::view::Camera_AddYaw(Camera *cam,float yawAmount)
{
	Camera_SetYaw(cam,yawAmount + cam->yaw);
	return;
}



void __cdecl lego::view::Camera_SetDistRange(Camera *cam,float minDist,float maxDist)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_DISTRANGE;
	(cam->distRange).min = minDist;
	(cam->distRange).max = maxDist;
	return;
}



void __cdecl lego::view::Camera_SetDist(Camera *cam,float dist)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_DISTRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_FREEMOVEMENT) != 0)) ||
		 (((cam->distRange).min <= dist &&
			(fVar1 = (cam->distRange).max,
			(ushort)((ushort)(dist < fVar1) << 8 | (ushort)(dist == fVar1) << 0xe) != 0)))) {
		cam->dist = dist;
	}
	return;
}



void __cdecl lego::view::Camera_AddDist(Camera *cam,float distAmount)
{
	Camera_SetDist(cam,distAmount + cam->dist);
	return;
}



void __cdecl lego::view::Camera_AddTranslation2D(Camera *cam,float translateX,float translateY)
{
	res::Container_AddTranslation(cam->cont2,D3DRMCOMBINE_BEFORE,translateX,translateY,0.0);
	return;
}



void __cdecl lego::view::Camera_GetTopdownPosition(Camera *cam,Vector3F *out_position)
{
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_GetPosition(cam->cont2,NULL,out_position);
	}
	return;
}



void __cdecl lego::view::Camera_SetTopdownPosition(Camera *cam,float x,float y)
{
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_SetPosition(cam->cont2,NULL,x,y,0.0);
	}
	return;
}



// Same as Camera_GetTopdownPosition, but the returned Z value is the Map3D surface Z.

BOOL __cdecl
lego::view::Camera_GetTopdownWorldPos(Camera *cam,SurfaceMap *surfMap,Vector3F *out_worldPos)
{
	float10 z;
	
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_GetPosition(cam->cont2,NULL,out_worldPos);
		z = game::Map3D_GetWorldZ(surfMap,out_worldPos->x,out_worldPos->y);
		out_worldPos->z = (float)z;
	}
	return TRUE;
}



float10 __cdecl lego::view::Camera_GetYaw(Camera *cam)
{
	return (float10)cam->yaw;
}



void __cdecl lego::view::Camera_Move(Camera *cam,Vector3F *ref_dir,float elapsedAbs)
{
	float10 dir_dist;
	float dir_norm;
	float moveDist;
	
						// Maths_Vector3DNormalize(ref_dir);
	dir_dist = std::sqrt((double)(ref_dir->z * ref_dir->z +
															 ref_dir->y * ref_dir->y + ref_dir->x * ref_dir->x));
	dir_norm = 1.0 / (float)dir_dist;
	ref_dir->x = ref_dir->x * dir_norm;
	ref_dir->y = ref_dir->y * dir_norm;
	ref_dir->z = ref_dir->z * dir_norm;
						// Add (acceleration*timeDelta) to current speed.
						//  (note that moveSpeed itself does not contain time info,
						//   which is the best way to handle it)
	cam->moveSpeed = elapsedAbs * globs::cameraGlobs.CameraAcceleration + cam->moveSpeed;
						// cap acceleration at max (CameraSpeed)
						// 
						// if (cam->movingSpeed > cameraGlobs.CameraSpeed)
						//   cam->movingSpeed = cameraGlobs.CameraSpeed;
	if ((ushort)((ushort)(cam->moveSpeed < globs::cameraGlobs.CameraSpeed) << 8 |
							(ushort)(cam->moveSpeed == globs::cameraGlobs.CameraSpeed) << 0xe) == 0) {
		cam->moveSpeed = globs::cameraGlobs.CameraSpeed;
	}
	moveDist = cam->moveSpeed * elapsedAbs;
						// Set length of direction vector to moveDist
						// Maths_Vector3DScale(ref_dir, ref_dir, moveDist);
	ref_dir->x = ref_dir->x * moveDist;
	ref_dir->y = ref_dir->y * moveDist;
	ref_dir->z = ref_dir->z * moveDist;
						// Add directional movement to cam->vector_18
						// Maths_Vector3DAdd(cam->vector_18, cam->vector_18, ref_dir);
	(cam->moveVector).x = (cam->moveVector).x + ref_dir->x;
	(cam->moveVector).y = (cam->moveVector).y + ref_dir->y;
	(cam->moveVector).z = (cam->moveVector).z + ref_dir->z;
	return;
}



void __cdecl lego::game::LiveManager_Initialise(void)
{
	int iVar1;
	LiveObject_Globs *pLVar2;
	
	pLVar2 = &globs::liveGlobs;
	for (iVar1 = 0x318f; iVar1 != 0; iVar1 += -1) {
		pLVar2->listSet[0] = NULL;
		pLVar2 = (LiveObject_Globs *)(pLVar2->listSet + 1);
	}
	globs::liveGlobs.Activities_TABLE[0] = "Activity_Stand";
	globs::liveGlobs.Activities_TABLE[1] = "Activity_Route";
	globs::liveGlobs.Activities_TABLE[2] = "Activity_RouteRubble";
	globs::liveGlobs.Activities_TABLE[3] = "Activity_RunPanic";
	globs::liveGlobs.Activities_TABLE[4] = "Activity_Drill";
	globs::liveGlobs.Activities_TABLE[5] = "Activity_Teleport";
	globs::liveGlobs.Activities_TABLE[6] = "Activity_Walk";
	globs::liveGlobs.Activities_TABLE[7] = "Activity_Reinforce";
	globs::liveGlobs.Activities_TABLE[8] = "Activity_Reverse";
	globs::liveGlobs.Activities_TABLE[9] = "Activity_TurnLeft";
	globs::liveGlobs.Activities_TABLE[10] = "Activity_TurnRight";
	globs::liveGlobs.Activities_TABLE[11] = "Activity_CantDo";
	globs::liveGlobs.Activities_TABLE[12] = "Activity_Emerge";
	globs::liveGlobs.Activities_TABLE[13] = "Activity_Enter";
	globs::liveGlobs.Activities_TABLE[14] = "Activity_EnterRein";
	globs::liveGlobs.Activities_TABLE[15] = "Activity_Collect";
	globs::liveGlobs.Activities_TABLE[16] = "Activity_Gather";
	globs::liveGlobs.Activities_TABLE[17] = "Activity_Carry";
	globs::liveGlobs.Activities_TABLE[18] = "Activity_CarryRubble";
	globs::liveGlobs.Activities_TABLE[19] = "Activity_Throw";
	globs::liveGlobs.Activities_TABLE[20] = "Activity_CarryTurnLeft";
	globs::liveGlobs.Activities_TABLE[21] = "Activity_CarryTurnRight";
	globs::liveGlobs.Activities_TABLE[22] = "Activity_CarryStand";
	globs::liveGlobs.Activities_TABLE[23] = "Activity_HitLeft";
	globs::liveGlobs.Activities_TABLE[24] = "Activity_HitRight";
	globs::liveGlobs.Activities_TABLE[25] = "Activity_HitFront";
	globs::liveGlobs.Activities_TABLE[26] = "Activity_HitBack";
	globs::liveGlobs.Activities_TABLE[27] = "Activity_HitHard";
	globs::liveGlobs.Activities_TABLE[28] = "Activity_Dynamite";
	globs::liveGlobs.Activities_TABLE[29] = "Activity_Deposit";
	globs::liveGlobs.Activities_TABLE[30] = "Activity_Clear";
	globs::liveGlobs.Activities_TABLE[31] = "Activity_Place";
	globs::liveGlobs.Activities_TABLE[32] = "Activity_Repair";
	globs::liveGlobs.Activities_TABLE[33] = "Activity_Slip";
	globs::liveGlobs.Activities_TABLE[34] = "Activity_Rest";
	globs::liveGlobs.Activities_TABLE[35] = "Activity_Eat";
	globs::liveGlobs.Activities_TABLE[36] = "Activity_Stamp";
	globs::liveGlobs.Activities_TABLE[37] = "Activity_ThrowMan";
	globs::liveGlobs.Activities_TABLE[38] = "Activity_ThrownByRockMonster";
	globs::liveGlobs.Activities_TABLE[39] = "Activity_GetUp";
	globs::liveGlobs.Activities_TABLE[40] = "Activity_BuildPath";
	globs::liveGlobs.Activities_TABLE[41] = "Activity_Upgrade";
	globs::liveGlobs.Activities_TABLE[42] = "Activity_Explode";
	globs::liveGlobs.Activities_TABLE[43] = "Activity_Unpowered";
	globs::liveGlobs.Activities_TABLE[44] = "Activity_FireLaser";
	globs::liveGlobs.Activities_TABLE[45] = "Activity_Freezed";
	globs::liveGlobs.Activities_TABLE[46] = "Activity_FreezeStart";
	globs::liveGlobs.Activities_TABLE[47] = "Activity_FreezeMelt";
	globs::liveGlobs.Activities_TABLE[48] = "Activity_Recharge";
	globs::liveGlobs.Activities_TABLE[49] = "Activity_WakeUp";
	globs::liveGlobs.Activities_TABLE[50] = "Activity_Train";
	globs::liveGlobs.Activities_TABLE[51] = "Activity_FloatOn";
	globs::liveGlobs.Activities_TABLE[52] = "Activity_FloatOff";
	globs::liveGlobs.Activities_TABLE[53] = "Activity_Opening";
	globs::liveGlobs.Activities_TABLE[54] = "Activity_Closing";
	globs::liveGlobs.Activities_TABLE[55] = "Activity_Open";
	globs::liveGlobs.Activities_TABLE[56] = "Activity_Waiting1";
	globs::liveGlobs.Activities_TABLE[57] = "Activity_Waiting2";
	globs::liveGlobs.Activities_TABLE[58] = "Activity_Waiting3";
	globs::liveGlobs.Activities_TABLE[59] = "Activity_Waiting4";
	globs::liveGlobs.Activities_TABLE[60] = "Activity_Waiting5";
	globs::liveGlobs.Activities_TABLE[61] = "Activity_Waiting6";
	globs::liveGlobs.Activities_TABLE[62] = "Activity_Waiting7";
	globs::liveGlobs.Activities_TABLE[63] = "Activity_Waiting8";
	globs::liveGlobs.Activities_TABLE[64] = "Activity_Waiting9";
	globs::liveGlobs.Activities_TABLE[65] = "Activity_Waiting10";
	globs::liveGlobs.Activities_TABLE[66] = "Activity_Waiting11";
	globs::liveGlobs.Activities_TABLE[67] = "Activity_Waiting12";
	globs::liveGlobs.Activities_TABLE[68] = "Activity_Waiting13";
	globs::liveGlobs.Activities_TABLE[69] = "Activity_Waiting14";
	globs::liveGlobs.Activities_TABLE[70] = "Activity_Waiting15";
	globs::liveGlobs.Activities_TABLE[71] = "Activity_Waiting16";
	globs::liveGlobs.Activities_TABLE[72] = "Activity_Waiting17";
	globs::liveGlobs.Activities_TABLE[73] = "Activity_Waiting18";
	globs::liveGlobs.Activities_TABLE[74] = "Activity_Waiting19";
	globs::liveGlobs.Activities_TABLE[75] = "Activity_Waiting20";
	globs::liveGlobs.Activities_TABLE[76] = "Activity_Waiting21";
	globs::liveGlobs.Activities_TABLE[77] = "Activity_Crumble";
	globs::liveGlobs.Activities_TABLE[78] = "Activity_TeleportIn";
	globs::liveGlobs.AbilityTypes_TABLE[0] = "LegoObject_AbilityType_Pilot";
	globs::liveGlobs.AbilityTypes_TABLE[1] = "LegoObject_AbilityType_Sailor";
	globs::liveGlobs.AbilityTypes_TABLE[2] = "LegoObject_AbilityType_Driver";
	globs::liveGlobs.AbilityTypes_TABLE[3] = "LegoObject_AbilityType_Dynamite";
	globs::liveGlobs.AbilityTypes_TABLE[4] = "LegoObject_AbilityType_Repair";
	globs::liveGlobs.AbilityTypes_TABLE[5] = "LegoObject_AbilityType_Scanner";
	pLVar2 = &globs::liveGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		pLVar2->listSet[0] = NULL;
		pLVar2 = (LiveObject_Globs *)(pLVar2->listSet + 1);
	}
	globs::liveGlobs.freeList = NULL;
	globs::liveGlobs.listCount = 0;
	globs::liveGlobs.flags = LIVEMANAGER_ISUSED;
	globs::liveGlobs.ToolNullIndexes_TABLE[0] = 0;
	globs::liveGlobs.ToolNullIndexes_TABLE[1] = 0;
	globs::liveGlobs.ToolNullIndexes_TABLE[2] = 1;
	globs::liveGlobs.ToolNullIndexes_TABLE[3] = 1;
	globs::liveGlobs.ToolNullIndexes_TABLE[4] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[5] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[6] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[7] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[8] = 3;
	globs::liveGlobs.ToolNullIndexes_TABLE[9] = 2;
	globs::liveGlobs.ToolNullIndexes_TABLE[10] = 4;
	globs::legoGlobs.ToolTypes_TABLE[0] = "LegoObject_ToolType_Drill";
	globs::legoGlobs.ToolTypes_TABLE[1] = "LegoObject_ToolType_Spade";
	globs::legoGlobs.ToolTypes_TABLE[2] = "LegoObject_ToolType_Hammer";
	globs::legoGlobs.ToolTypes_TABLE[3] = "LegoObject_ToolType_Spanner";
	globs::legoGlobs.ToolTypes_TABLE[4] = "LegoObject_ToolType_Laser";
	globs::legoGlobs.ToolTypes_TABLE[5] = "LegoObject_ToolType_PusherGun";
	globs::legoGlobs.ToolTypes_TABLE[6] = "LegoObject_ToolType_BirdScarer";
	globs::legoGlobs.ToolTypes_TABLE[7] = "LegoObject_ToolType_FreezerGun";
	return;
}



void __cdecl lego::game::LiveManager_Shutdown(void)
{
	LiveObject_Globs *pLVar1;
	
	LiveManager_Cleanup_FUN_0043b5e0();
	pLVar1 = &globs::liveGlobs;
	do {
		if (pLVar1->listSet[0] != NULL) {
			std::free(pLVar1->listSet[0]);
		}
		pLVar1 = (LiveObject_Globs *)(pLVar1->listSet + 1);
	} while (pLVar1 < (LiveObject_Globs *)&globs::liveGlobs.freeList);
	globs::liveGlobs.freeList = NULL;
	globs::liveGlobs.flags = LIVEMANAGER_NONE;
	if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
		std::free(globs::liveGlobs.UnkSurfaceGrid_1_TABLE);
	}
	globs::liveGlobs.flags = globs::liveGlobs.flags & ~LIVEMANAGER_ISUSED;
	return;
}



void __cdecl lego::save::Save_CopyStruct18(SaveStruct_18 *out_saveStruct18)
{
	int iVar1;
	SaveStruct_18 *pSVar2;
	
	pSVar2 = &globs::liveGlobs.savestruct18_c01c;
	for (iVar1 = 6; iVar1 != 0; iVar1 += -1) {
		*(undefined4 *)out_saveStruct18 = *(undefined4 *)pSVar2;
		pSVar2 = (SaveStruct_18 *)&pSVar2->field_0x4;
		out_saveStruct18 = (SaveStruct_18 *)&out_saveStruct18->field_0x4;
	}
	return;
}



// NULL will simply memzero the entire structure at the address

void __cdecl lego::save::Save_OverwriteStruct18(SaveStruct_18 *saveStruct18)
{
	int iVar1;
	SaveStruct_18 *pSVar2;
	
	iVar1 = 6;
	if (saveStruct18 != NULL) {
		pSVar2 = &globs::liveGlobs.savestruct18_c01c;
		for (; iVar1 != 0; iVar1 += -1) {
			*(undefined4 *)pSVar2 = *(undefined4 *)saveStruct18;
			saveStruct18 = (SaveStruct_18 *)&saveStruct18->field_0x4;
			pSVar2 = (SaveStruct_18 *)&pSVar2->field_0x4;
		}
		return;
	}
	pSVar2 = &globs::liveGlobs.savestruct18_c01c;
	for (; iVar1 != 0; iVar1 += -1) {
		*(undefined4 *)pSVar2 = 0;
		pSVar2 = (SaveStruct_18 *)&pSVar2->field_0x4;
	}
	return;
}



int __cdecl lego::game::LiveManager_FUN_004373c0(ObjectType objType,BOOL param_2)
{
	ObjectStatsFlags1 OVar1;
	uint uVar2;
	int iVar3;
	uint objIndex;
	uint objLevel;
	
	iVar3 = 0;
	objIndex = 0;
	do {
		objLevel = 0;
		do {
			if (param_2 == 0) {
LAB_004373e4:
				uVar2 = LiveObject_GetLevelObjectsBuilt(objType,objIndex,objLevel,TRUE);
				iVar3 += uVar2;
			}
			else {
				OVar1 = stats::Stats_GetStatsFlags1(objType,objIndex);
				if ((OVar1 & STATS1_STOREOBJECTS) == STATS1_NONE) goto LAB_004373e4;
			}
			objLevel += 1;
		} while (objLevel < 0x10);
		objIndex += 1;
		if (0xe < objIndex) {
			return iVar3;
		}
	} while( true );
}



void __cdecl lego::game::LiveManager_LoadToolTipIcons(CFGProperty *root)
{
	char *keyPath;
	CFGProperty *prop;
	int iVar1;
	Image *pIVar2;
	int iVar3;
	char **ppcVar4;
	Image **ppIVar5;
	
	keyPath = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"ToolTipIcons",0);
	prop = cfg::CFG_GetChildren(root,keyPath);
	do {
		if (prop == NULL) {
			if (globs::liveGlobs.ToolTipIcon_Ore != NULL) {
				lego::image::Image_SetupTrans(globs::liveGlobs.ToolTipIcon_Ore,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			return;
		}
		iVar3 = 0;
		ppcVar4 = globs::legoGlobs.ToolTypes_TABLE;
		do {
			if ((*ppcVar4 != NULL) && (iVar1 = std::_stricmp(prop->key,*ppcVar4), iVar1 == 0)) {
				pIVar2 = lego::image::Image_LoadBMPScaled(prop->value,0,0);
				globs::liveGlobs.ToolTipIcons_Tools_TABLE[iVar3] = pIVar2;
				break;
			}
			ppcVar4 = ppcVar4 + 1;
			iVar3 += 1;
		} while (ppcVar4 < globs::legoGlobs.ToolNames_TABLE);
		if (iVar3 == 0xb) {
			iVar3 = 0;
			ppIVar5 = (Image **)globs::liveGlobs.AbilityTypes_TABLE;
			do {
				if ((*ppIVar5 != NULL) && (iVar1 = std::_stricmp(prop->key,(char *)*ppIVar5), iVar1 == 0)) {
					pIVar2 = lego::image::Image_LoadBMPScaled(prop->value,0,0);
					globs::liveGlobs.ToolTipIcons_Abilities[iVar3] = pIVar2;
					break;
				}
				ppIVar5 = ppIVar5 + 1;
				iVar3 += 1;
			} while (ppIVar5 < globs::liveGlobs.ToolTipIcons_Abilities);
		}
		if (iVar3 == 6) {
			iVar3 = std::_stricmp(prop->key,"Blank");
			if (iVar3 == 0) {
				globs::liveGlobs.ToolTipIcon_Blank = lego::image::Image_LoadBMPScaled(prop->value,0,0);
			}
			else {
				iVar3 = std::_stricmp(prop->key,"Ore");
				if (iVar3 == 0) {
					globs::liveGlobs.ToolTipIcon_Ore = lego::image::Image_LoadBMPScaled(prop->value,0,0);
				}
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::game::LiveManager_FUN_00437560(void)
{
	int iVar1;
	Point2I *pPVar2;
	LiveObject **ppLVar3;
	
	LiveManager_Cleanup_FUN_0043b5e0();
	LiveManager_FUN_00437700();
	HiddenObject_RemoveAll();
	pPVar2 = globs::liveGlobs.SlugHoles_TABLE;
	for (iVar1 = 0x28; iVar1 != 0; iVar1 += -1) {
		pPVar2->x = 0;
		pPVar2 = (Point2I *)&pPVar2->y;
	}
	pPVar2 = globs::liveGlobs.RechargeSeams_TABLE;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 += -1) {
		pPVar2->x = 0;
		pPVar2 = (Point2I *)&pPVar2->y;
	}
	globs::liveGlobs.SlugHoles_COUNT = 0;
	globs::liveGlobs.RechargeSeams_COUNT = 0;
	globs::liveGlobs.float_c018 = 0.0;
	ppLVar3 = globs::liveGlobs.liveObjArray100_c43c;
	for (iVar1 = 100; iVar1 != 0; iVar1 += -1) {
		*ppLVar3 = NULL;
		ppLVar3 = ppLVar3 + 1;
	}
	globs::liveGlobs.uintCount_c5cc = 0;
	LiveManage_SetNumBuildingsTeleported(0);
	return;
}



void __cdecl
lego::game::LiveObject_Weapon_FUN_004375c0(LiveObject *in_liveObj,int weaponType,float param_3)
{
	LiveObject *pLVar1;
	float10 fVar2;
	Point2I local_8;
	
	if (weaponType == -1) {
		fVar2 = (float10)param_3;
	}
	else {
		fVar2 = tools::Weapon_GetDischargeRate(weaponType);
		fVar2 = fVar2 * (float10)param_3;
	}
	globs::liveGlobs.float_c018 = (float)(fVar2 + (float10)globs::liveGlobs.float_c018);
	LiveObject_GetBlockPos(in_liveObj,&local_8.x,&local_8.y);
	while (((1.0 <= globs::liveGlobs.float_c018 &&
					(pLVar1 = FUN_00438d20(&local_8,OBJECT_POWERCRYSTAL,0,0), pLVar1 != NULL)) &&
				 (pLVar1 = LiveObject_FUN_0043a910(pLVar1,OBJECT_POWERCRYSTAL,0,0), pLVar1 != NULL))) {
		pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_POWEROFF;
		LiveObject_SetCrystalPoweredColor(pLVar1,0);
		globs::liveGlobs.float_c018 = globs::liveGlobs.float_c018 - 1.0;
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00437690(LiveObject *liveObj,BOOL condition)
{
	BOOL BVar1;
	
	if ((condition == 0) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE)) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_2000 | LIVEOBJ4_UNK_4000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_CLOSING,0);
		BVar1 = LiveObject_Container_ActivityUpdate_Check(liveObj);
		return BVar1;
	}
	if ((condition != 0) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) == LIVEOBJ4_NONE)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_1000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_OPENING,0);
	}
	BVar1 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	return BVar1;
}



void __cdecl lego::game::LiveManager_FUN_00437700(void)
{
	int iVar1;
	uint (*paauVar2) [15] [16];
	
	paauVar2 = globs::liveGlobs.ObjectLevels_Previous_TABLE;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 += -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	paauVar2 = globs::liveGlobs.ObjectLevels_Current_TABLE;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 += -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	return;
}



uint __cdecl
lego::game::LiveObject_GetLevelObjectsBuilt
					(ObjectType objType,int objIndex,int objLevel,BOOL currentLevel)
{
	uint levelsCount;
	
	levelsCount = globs::liveGlobs.ObjectLevels_Current_TABLE[objType][objIndex][objLevel];
	if (currentLevel != 0) {
		levelsCount -= globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][objLevel];
	}
	return levelsCount;
}



uint __cdecl
lego::game::LiveObject_GetPreviousLevelObjectsBuilt(ObjectType objType,int objIndex,int objLevel)
{
	return globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][objLevel];
}



void __cdecl lego::game::LiveObject_IncLevelPathsBuilt(BOOL incCurrent)
{
	if (incCurrent != 0) {
		globs::liveGlobs.ObjectLevels_Current_TABLE[15][0][0] += 1;
		return;
	}
	globs::liveGlobs.ObjectLevels_Previous_TABLE[15][0][0] += 1;
	return;
}



void __cdecl lego::game::LiveObject_FUN_004377b0(LiveObject *liveObj)
{
	if (liveObj->objType != OBJECT_BOULDER) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_UnkDoRouting_IfObject2FC,liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_UnkDoRouting_IfObject2FC(LiveObject *liveObj1,LiveObject *liveObj2)
{
	if (liveObj1->object_2fc == liveObj2) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj1,FALSE);
		liveObj1->object_2fc = NULL;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Remove(LiveObject *liveObj)
{
	LiveFlags4 *pLVar1;
	LiveObject *pLVar2;
	ObjectType OVar3;
	ObjectStatsFlags1 OVar4;
	VehicleData *buffer;
	
	globs::liveGlobs.ObjectLevels_Previous_TABLE[liveObj->objType][liveObj->objIndex]
	[liveObj->objLevel] =
			 globs::liveGlobs.ObjectLevels_Previous_TABLE[liveObj->objType][liveObj->objIndex]
			 [liveObj->objLevel] + 1;
	if ((liveObj->flags4 & LIVEOBJ4_UNK_100000) != LIVEOBJ4_NONE) {
		snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_350);
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_80000) != LIVEOBJ4_NONE) {
		snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_354);
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_SetField_3c4,liveObj);
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		ai::AITask_LiveObject_DoCallbacks_FUN_004029d0(liveObj);
	}
	if (liveObj->resData_2e4 != NULL) {
		res::Container_Remove(liveObj->resData_2e4);
	}
	if (liveObj->carryingThisObject != NULL) {
		LiveObject_DropCarriedObject_FUN_0043a130(liveObj->carryingThisObject,0);
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		if (liveObj->object_2fc != NULL) {
			pLVar1 = &liveObj->object_2fc->flags4;
			*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_40;
		}
	}
	LiveObject_WaterVehicle_Unregister(liveObj);
	if ((*(byte *)&liveObj->flags4 & 1) != 0) {
		globs::legoGlobs.flags1 &= ~GAME1_LASERTRACKER;
	}
	if ((*(byte *)&liveObj->flags4 & 0x80) != 0) {
		pLVar2 = liveObj->object_2fc;
		if (pLVar2 != NULL) {
			pLVar2->flags4 = pLVar2->flags4 & ~LIVEOBJ4_UNK_80;
		}
		liveObj->object_2fc = NULL;
	}
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	LiveObject_DoBuildingsCallback_AttackByBoulder(liveObj);
	LiveObject_DropCarriedObject_FUN_0043a130(liveObj,0);
	ai::AITask_LiveObject_FUN_00403980(liveObj);
	LiveObject_RemoveObject3CC(liveObj);
	front::Encyclopedia_LiveObject_ClearPtr_004c8ea4_IfEqual(liveObj);
	OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
		 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_PROCESSORE) != STATS1_NONE
		 )) {
		ai::AITask_LiveObject_FUN_00403940(liveObj);
	}
	Message_LiveObject_FUN_00452770(liveObj);
	front::Info_RemoveAllForObject(liveObj);
	front::Bubble_LiveObject_FUN_004072d0(liveObj);
	LiveObject_FUN_004377b0(liveObj);
	Game_RemoveRecordObject(liveObj);
	OVar3 = liveObj->objType;
	if (OVar3 == OBJECT_VEHICLE) {
		res::Vehicle_Destroy(liveObj->vehicle);
		buffer = liveObj->vehicle;
	}
	else {
		if (OVar3 == OBJECT_MINIFIGURE) {
			res::Creature_Destroy(liveObj->miniFigure);
			buffer = (VehicleData *)liveObj->miniFigure;
		}
		else {
			if (OVar3 == OBJECT_ROCKMONSTER) {
				OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
				if ((OVar4 & STATS1_FLOCKS) != STATS1_NONE) {
					LiveObject_FlocksDestroy(liveObj);
				}
				res::Creature_Destroy(liveObj->rockMonster);
				buffer = (VehicleData *)liveObj->rockMonster;
			}
			else {
				if (OVar3 == OBJECT_BUILDING) {
					res::Building_Destroy(liveObj->building);
					buffer = (VehicleData *)liveObj->building;
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						res::Container_Remove(liveObj->other);
						goto LAB_00437a4d;
					}
					if (OVar3 != OBJECT_UPGRADEPART) goto LAB_00437a4d;
					res::Upgrade_Destroy(liveObj->upgrade);
					buffer = (VehicleData *)liveObj->upgrade;
				}
			}
		}
	}
	std::free(buffer);
LAB_00437a4d:
	liveObj->nextFree = globs::liveGlobs.freeList;
	globs::liveGlobs.freeList = liveObj;
	return 0;
}



BOOL __cdecl
lego::game::Search_LiveObjects_SkipIgnoreMes(SearchLiveObjectCallback predicateFunc,void *search)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects(predicateFunc,search,TRUE);
	return BVar1;
}



BOOL __cdecl
lego::game::Search_LiveObjects(SearchLiveObjectCallback callback,void *search,BOOL skipIgnoreMeObjs)
{
	LiveObject *liveObj;
	BOOL BVar1;
	int iVar2;
	LiveObject_Globs *pLVar3;
	uint uVar4;
	uint uVar5;
	uint tblIndex;
	
	tblIndex = 0;
	if (globs::liveGlobs.listCount == 0) {
		return 0;
	}
	pLVar3 = &globs::liveGlobs;
	do {
		if (pLVar3->listSet[0] != NULL) {
			uVar5 = 0;
			uVar4 = 1 << ((byte)tblIndex & 0x1f);
			if (uVar4 != 0) {
				iVar2 = 0;
				do {
					liveObj = (LiveObject *)((int)pLVar3->listSet[0]->routing_points_4 + iVar2 + -0x34);
					if ((((liveObj != NULL) && (liveObj->nextFree == liveObj)) &&
							((skipIgnoreMeObjs == 0 ||
							 ((liveObj->flags3 & LIVEOBJ3_IGNOREME_UNK) == LIVEOBJ3_NONE)))) &&
						 (BVar1 = (*callback)(liveObj,search), BVar1 != 0)) {
						return TRUE;
					}
					uVar5 += 1;
					iVar2 += 0x40c;
				} while (uVar5 < uVar4);
			}
		}
		tblIndex += 1;
		pLVar3 = (LiveObject_Globs *)(pLVar3->listSet + 1);
		if (globs::liveGlobs.listCount <= tblIndex) {
			return 0;
		}
	} while( true );
}



// Pass NULL or empty string to remove custom name

void __cdecl lego::game::LiveObject_SetCustomName(LiveObject *liveObj,char *customName)
{
	char *pcVar1;
	
	if ((customName != NULL) && (*customName != '\0')) {
						// There is no regard for memory bounds here,
						// allocates 11 bytes, assigns bytes[11]...
						// why......
		if (liveObj->customName == NULL) {
			pcVar1 = (char *)std::malloc(0xb);
			liveObj->customName = pcVar1;
		}
		std::strncpy(liveObj->customName,customName,0xb);
		liveObj->customName[0xb] = '\0';
		return;
	}
	if (liveObj->customName != NULL) {
		std::free(liveObj->customName);
	}
	liveObj->customName = NULL;
	return;
}



void __cdecl lego::game::HiddenObject_RemoveAll(void)
{
	int iVar1;
	char **ppcVar2;
	uint uVar3;
	HiddenObject *pHVar4;
	
	uVar3 = 0;
	if (globs::liveGlobs.hiddenObjectCount != 0) {
		ppcVar2 = &globs::liveGlobs.hiddenObjects[0].thisOLName;
		do {
			if (ppcVar2[1] != NULL) {
				std::free(ppcVar2[1]);
			}
			if (*ppcVar2 != NULL) {
				std::free(*ppcVar2);
			}
			uVar3 += 1;
			ppcVar2 = ppcVar2 + 0xb;
		} while (uVar3 < globs::liveGlobs.hiddenObjectCount);
	}
	globs::liveGlobs.hiddenObjectCount = 0;
	pHVar4 = globs::liveGlobs.hiddenObjects;
	for (iVar1 = 200; iVar1 != 0; iVar1 += -1) {
		(pHVar4->blockPos).x = 0;
		pHVar4 = (HiddenObject *)&(pHVar4->blockPos).y;
	}
	nerps::NERPsRuntime_ClearHiddenObjectsFound();
	return;
}



void __cdecl lego::game::HiddenObject_ExposeBlock(Point2I *blockPos)
{
	ObjectType OVar1;
	char *pcVar2;
	char *pcVar3;
	LiveObject *liveObj;
	Point2I *pPVar4;
	LiveObject *pLVar5;
	ObjectStatsFlags3 OVar6;
	ObjectStatsFlags1 OVar7;
	int iVar8;
	HiddenObject *translation;
	HiddenObject *pHVar9;
	uint i;
	Direction rotation;
	int *piVar10;
	uint uVar11;
	longlong lVar12;
	TrainedFlags trainFlags;
	char **local_96c;
	uint local_968;
	uint local_964;
	LiveObject *apLStack2400 [200];
	char *local_640 [200];
	char *apcStack800 [200];
	
	uVar11 = 0;
	i = 0;
	local_968 = 0;
	if (globs::liveGlobs.hiddenObjectCount != 0) {
		local_96c = local_640;
		translation = globs::liveGlobs.hiddenObjects;
		do {
						// GHIDRA FAIL: this is comparing hiddenstruct->blockPos.x and blockPos.y
						//  (whatever this *(int *)&hiddenstruct->blockPos nonsense is, is LIES.
			pHVar9 = translation;
			if (((translation->blockPos).x == blockPos->x) &&
				 (*(int *)&translation->blockPos == blockPos->y)) {
				if (translation->objType == OBJECT_BUILDING) {
					pPVar4 = res::Building_GetShapePoints
														 (globs::legoGlobs.BuildingData_TABLE + translation->objIndex,&local_964
														 );
					lVar12 = __ftol((float10)translation->heading * (float10)0.1591549 * (float10)8.0);
					rotation = ((uint)lVar12 & 1) + (uint)lVar12 >> 1;
					pPVar4 = res::SelectPlace_TransformShapePoints
														 (&translation->blockPos,pPVar4,local_964,rotation);
					pLVar5 = Construction_AddShape_FUN_004099c0
														 (translation->objIndex,&translation->blockPos,rotation,pPVar4,local_964
															,0);
					uVar11 = local_968;
				}
				else {
					pLVar5 = LiveObject_Create((int **)translation->objSrcData,translation->objType,
																		 translation->objIndex);
				}
				if (pLVar5 != NULL) {
					if (translation->objType != OBJECT_BUILDING) {
						LiveObject_SetPositionAndHeading
											(pLVar5,(translation->worldPos).x,(translation->worldPos).y,
											 translation->heading,1);
					}
					OVar1 = translation->objType;
					if ((((OVar1 == OBJECT_POWERCRYSTAL) || (OVar1 == OBJECT_ORE)) ||
							(OVar1 == OBJECT_DYNAMITE)) || (OVar1 == OBJECT_BARRIER)) {
						ai::AITask_DoCollect(pLVar5,0.0);
					}
					pLVar5->health = translation->health;
					if (pLVar5->objType == OBJECT_MINIFIGURE) {
						nerps::NERPsRuntime_IncHiddenObjectsFound(OBJECT_MINIFIGURE);
						front::Info_Send(INFO_FOUNDMINIFIGURE,NULL,pLVar5,NULL);
					}
					pLVar5->flags4 = pLVar5->flags4 | LIVEOBJ4_UNK_200;
					LiveObject_FUN_00438720(pLVar5);
					if (pLVar5->objType == OBJECT_ELECTRICFENCE) {
						ElectricFence_AssignBlockObject(pLVar5);
					}
					pcVar2 = translation->thisOLName;
					pcVar3 = translation->drivingOLName;
					apLStack2400[uVar11] = pLVar5;
					apcStack800[uVar11] = pcVar2;
					*local_96c = pcVar3;
					local_968 = uVar11 + 1;
					local_96c = local_96c + 1;
					translation->thisOLName = NULL;
				}
				i -= 1;
				pHVar9 = translation + -1;
				piVar10 = (int *)((int)globs::liveGlobs.RechargeSeams_TABLE +
												 globs::liveGlobs.hiddenObjectCount * 0x2c + 0x2c);
				globs::liveGlobs.hiddenObjectCount = globs::liveGlobs.hiddenObjectCount - 1;
				for (iVar8 = 0xb; uVar11 = local_968, iVar8 != 0; iVar8 += -1) {
					(translation->blockPos).x = *piVar10;
					piVar10 = piVar10 + 1;
					translation = (HiddenObject *)&translation->blockPos;
				}
			}
			i += 1;
			translation = pHVar9 + 1;
		} while (i < globs::liveGlobs.hiddenObjectCount);
	}
	local_96c = NULL;
	if (uVar11 != 0) {
		do {
			pcVar2 = local_640[(int)local_96c];
			if (pcVar2 != NULL) {
				i = 0;
				do {
					if ((local_96c != (char **)i) &&
						 (iVar8 = std::_stricmp(apcStack800[i],pcVar2), iVar8 == 0)) {
						pLVar5 = apLStack2400[(int)local_96c];
						liveObj = apLStack2400[i];
						pLVar5->object_2fc = liveObj;
						pLVar5->flags2 = pLVar5->flags2 | LIVEOBJ2_UNK_4;
						OVar6 = stats::StatsObject_GetStatsFlags3(liveObj);
						if ((OVar6 & STATS3_NEEDSPILOT) == STATS3_NONE) {
							OVar7 = stats::StatsObject_GetStatsFlags1(liveObj);
							if ((OVar7 & STATS1_CROSSWATER) == STATS1_NONE) {
								trainFlags = TRAINED_DRIVER;
							}
							else {
								OVar7 = stats::StatsObject_GetStatsFlags1(liveObj);
								if ((OVar7 & STATS1_CROSSLAND) == STATS1_NONE) {
									trainFlags = TRAINED_SAILOR;
								}
								else {
									trainFlags = TRAINED_PILOT;
								}
							}
						}
						else {
							trainFlags = TRAINED_PILOT;
						}
						LiveObject_TrainMiniFigure_instantunk(pLVar5,trainFlags);
						LiveObject_ClearFlags4_40_AndSameForObject2FC(pLVar5,liveObj);
						uVar11 = local_968;
					}
					i += 1;
				} while (i < uVar11);
			}
			local_96c = (char **)((int)local_96c + 1);
		} while (local_96c < uVar11);
	}
	i = 0;
	if (uVar11 != 0) {
		do {
			if (local_640[i] != NULL) {
				std::free(local_640[i]);
			}
			if (apcStack800[i] != NULL) {
				std::free(apcStack800[i]);
			}
			i += 1;
		} while (i < uVar11);
	}
	return;
}



void __cdecl
lego::game::HiddenObject_Add
					(void *objSrcData,ObjectType objType,int objIndex,Point2F *worldPos,float heading,
					float health,char *thisOLName,char *drivingOLName)
{
	char *str;
	SurfaceMap *surfMap;
	HiddenObject *out_bx;
	int *out_by;
	HiddenObject *hidden;
	uint index;
	float xPos;
	float yPos;
	
	index = globs::liveGlobs.hiddenObjectCount;
	out_bx = globs::liveGlobs.hiddenObjects + globs::liveGlobs.hiddenObjectCount;
	hidden = globs::liveGlobs.hiddenObjects + globs::liveGlobs.hiddenObjectCount;
	globs::liveGlobs.hiddenObjectCount = globs::liveGlobs.hiddenObjectCount + 1;
	(hidden->worldPos).x = worldPos->x;
	yPos = worldPos->y;
	globs::liveGlobs.hiddenObjects[index].objSrcData = objSrcData;
	globs::liveGlobs.hiddenObjects[index].worldPos.y = yPos;
	globs::liveGlobs.hiddenObjects[index].health = health;
	globs::liveGlobs.hiddenObjects[index].heading = heading;
	globs::liveGlobs.hiddenObjects[index].objType = objType;
	globs::liveGlobs.hiddenObjects[index].objIndex = objIndex;
	if (thisOLName != NULL) {
		str = util::_strdup(thisOLName);
		globs::liveGlobs.hiddenObjects[index].thisOLName = str;
	}
	if (drivingOLName != NULL) {
		str = util::_strdup(drivingOLName);
		globs::liveGlobs.hiddenObjects[index].drivingOLName = str;
	}
	yPos = worldPos->y;
	xPos = worldPos->x;
	out_by = &globs::liveGlobs.hiddenObjects[index].blockPos.y;
	surfMap = lrr::Lego_GetMap();
	Map3D_WorldToBlockPos_NoZ(surfMap,xPos,yPos,(int *)out_bx,out_by);
	return;
}



BOOL __cdecl lego::game::LiveObject_CanShootObject(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	float10 fVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_CANBESHOTAT) != STATS2_NONE) {
		fVar2 = stats::StatsObject_GetPainThreshold(liveObj);
		if (fVar2 < (float10)liveObj->health) {
			return 1;
		}
	}
	return 0;
}



LiveObject * __cdecl lego::game::LiveObject_Create(int **srcData,ObjectType objType,int objIndex)
{
	ObjectType OVar1;
	LiveObject *liveObj;
	BOOL BVar2;
	VehicleData *out_vehicle;
	uint uVar3;
	ObjectStatsFlags1 OVar4;
	CreatureData *pCVar5;
	BuildingData *out_building;
	UpgradeData *out_upgrade;
	Container *cont;
	LiveFlags3 LVar6;
	BOOL BVar7;
	ObjectStatsFlags2 OVar8;
	
	liveObj = LiveObject_Create_internal();
	if (liveObj == NULL) {
		return NULL;
	}
	liveObj->objType = objType;
	liveObj->objIndex = objIndex;
	liveObj->flags3 = LIVEOBJ3_NONE;
	liveObj->health = (float)&DAT_42c80000;
	liveObj->energy = (float)&DAT_42c80000;
	res::Container_EnableSoundTriggers(0);
	BVar2 = snd::SFX_IsSoundOn();
	snd::SFX_SetSoundStates_IsOn_StopAll(0,0);
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		out_vehicle = (VehicleData *)std::malloc(0x1ec);
		liveObj->vehicle = out_vehicle;
		res::Vehicle_Duplicate((VehicleData *)srcData,out_vehicle);
		res::Vehicle_SetOwnerObject(liveObj->vehicle,liveObj);
		uVar3 = res::Vehicle_GetCarryNullFrames(liveObj->vehicle);
		liveObj->field_328 = uVar3;
		res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,0);
		liveObj->flags5 = LIVEOBJ5_ABILITY_SCANNER;
		liveObj->flags3 =
				 liveObj->flags3 |
				 (LIVEOBJ3_UNK_10|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_1000|LIVEOBJ3_UNK_40000|
				 LIVEOBJ3_UNK_400000);
		stats::StatsObject_SetObjectLevel(liveObj,0);
		if (srcData[0x2d] != NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_2;
		}
		if (srcData[0x37] != NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_20;
			OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
			if ((OVar4 & STATS1_CROSSLAND) != STATS1_NONE) {
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_40;
			}
		}
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		pCVar5 = (CreatureData *)std::malloc(0x74);
		liveObj->miniFigure = pCVar5;
		res::Creature_Duplicate((CreatureData *)srcData,pCVar5);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->miniFigure,liveObj);
		uVar3 = nerps::funcs::NERPFunc__True(&liveObj->miniFigure->objIndex);
		LVar6 = liveObj->flags3;
		liveObj->field_328 = uVar3;
		liveObj->flags3 =
				 LVar6 | (LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_10|LIVEOBJ3_UNK_20|LIVEOBJ3_UNK_40|
									LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_40000|LIVEOBJ3_UNK_400000);
		if (srcData[0xb] != NULL) {
			liveObj->flags3 =
					 LVar6 | (LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_10|LIVEOBJ3_UNK_20|
										LIVEOBJ3_UNK_40|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_40000|
									 LIVEOBJ3_UNK_400000);
		}
		stats::StatsObject_SetObjectLevel(liveObj,0);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_8000;
		MiniFigure_EquipTool(liveObj,TOOL_DRILL);
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		pCVar5 = (CreatureData *)std::malloc(0x74);
		liveObj->rockMonster = pCVar5;
		res::Creature_Duplicate((CreatureData *)srcData,pCVar5);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->rockMonster,liveObj);
		uVar3 = nerps::funcs::NERPFunc__True(&liveObj->rockMonster->objIndex);
		LVar6 = liveObj->flags3;
		liveObj->field_328 = uVar3;
		liveObj->flags3 =
				 LVar6 | (LIVEOBJ3_UNK_200|LIVEOBJ3_UNK_40000|LIVEOBJ3_UNK_400000|LIVEOBJ3_UNK_8000000);
		if (srcData[0xb] != NULL) {
			liveObj->flags3 =
					 LVar6 | (LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_200|LIVEOBJ3_UNK_40000|LIVEOBJ3_UNK_400000|
									 LIVEOBJ3_UNK_8000000);
		}
		stats::StatsObject_SetObjectLevel(liveObj,0);
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_FLOCKS) == STATS1_NONE) {
			liveObj->flocksData_32c = NULL;
		}
		else {
			LiveObject_Flocks_Initialise(liveObj);
			OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
			if ((OVar4 & STATS1_FLOCKS_DEBUG) == STATS1_NONE) {
				LiveObject_HideAll(liveObj,TRUE);
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_CANSELECT;
			}
		}
		BVar7 = LiveObject_CanShootObject(liveObj);
		if (BVar7 != 0) {
			ai::AITask_DoAttackRockMonster_Target(liveObj);
		}
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_POWEROFF;
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_BUILDING) {
		out_building = (BuildingData *)std::malloc(0x14c);
		liveObj->building = out_building;
		res::Building_Duplicate((BuildingData *)srcData,out_building);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->building,liveObj);
		uVar3 = res::Building_GetCarryNullFrames(liveObj->building);
		liveObj->field_328 = uVar3;
		liveObj->flags3 = liveObj->flags3 | (LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_40000);
		res::Building_ChangeUpgradeParts(liveObj->building,0);
		stats::StatsObject_SetObjectLevel(liveObj,0);
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE) {
			globs::legoGlobs.placeDestSmallTeleporter = liveObj;
		}
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE) {
			globs::legoGlobs.placeDestBigTeleporter = liveObj;
		}
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE) {
			globs::legoGlobs.placeDestWaterTeleporter = liveObj;
		}
		stats::StatsObject_GetStatsFlags1(liveObj);
		OVar4 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_SNAXULIKE) != STATS1_NONE) {
			ai::AITask_DoGotoEat(liveObj);
		}
		ai::AITask_DoRepair(liveObj);
		liveObj->flags5 = LIVEOBJ5_ABILITY_SCANNER;
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		out_upgrade = (UpgradeData *)std::malloc(0x10);
		liveObj->upgrade = out_upgrade;
		res::Upgrade_Duplicate((UpgradeData *)srcData,out_upgrade);
		liveObj->stats = &globs::constant::c_ObjectStats_Upgrade;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_IGNOREME_UNK;
		goto LAB_00438452;
	}
	cont = res::Container_Clone((Container *)srcData);
	liveObj->other = cont;
	res::Container_SetUserData(cont,liveObj);
	LVar6 = liveObj->flags3;
	OVar1 = liveObj->objType;
	liveObj->flags3 = LVar6 | LIVEOBJ3_SIMPLEOBJECT;
	if (OVar1 == OBJECT_ELECTRICFENCE) {
		liveObj->flags3 = LVar6 | (LIVEOBJ3_CANSELECT|LIVEOBJ3_SIMPLEOBJECT|LIVEOBJ3_UNK_40000);
	}
	if ((OVar1 == OBJECT_ORE) || (OVar1 == OBJECT_POWERCRYSTAL)) {
		LVar6 = liveObj->flags3 | (LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_100000);
LAB_004383f9:
		liveObj->flags3 = LVar6;
	}
	else {
		if ((OVar1 == OBJECT_DYNAMITE) || (OVar1 == OBJECT_OOHSCARY)) {
			LVar6 = liveObj->flags3 | LIVEOBJ3_UNK_40000;
			goto LAB_004383f9;
		}
	}
	LiveObject_SetCrystalPoweredColor(liveObj,TRUE);
	if (true) {
		switch(liveObj->objType) {
		case OBJECT_DYNAMITE:
			liveObj->stats = &globs::constant::c_ObjectStats_Dynamite;
			break;
		case OBJECT_BARRIER:
			liveObj->stats = &globs::constant::c_ObjectStats_Barrier;
			break;
		default:
			goto switchD_0043841c_caseD_a;
		case OBJECT_SPIDERWEB:
		case OBJECT_OOHSCARY:
		case OBJECT_ELECTRICFENCESTUD:
		case OBJECT_PUSHER:
		case OBJECT_FREEZER:
		case OBJECT_ICECUBE:
		case OBJECT_LASERSHOT:
			liveObj->stats = &globs::constant::c_ObjectStats_Other;
		}
	}
	else {
switchD_0043841c_caseD_a:
		stats::StatsObject_SetObjectLevel(liveObj,0);
	}
LAB_00438452:
	liveObj->aitaskName2 = globs::liveGlobs.Activities_TABLE[0];
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[9];
	BVar7 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_8;
	}
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[16];
	BVar7 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_CANGATHER;
	}
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[2];
	BVar7 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_CANROUTERUBBLE;
	}
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[0];
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(liveObj);
	res::Container_EnableSoundTriggers(TRUE);
	if (BVar2 != 0) {
		snd::SFX_SetSoundStates_IsOn_StopAll(TRUE,FALSE);
	}
	LiveObject_UpdatePowerConsumption(liveObj);
	globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][0] =
			 globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][0] + 1;
	OVar8 = stats::StatsObject_GetStatsFlags2(liveObj);
	if ((OVar8 & STATS2_UNSELECTABLE) != STATS2_NONE) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_CANSELECT;
	}
	return liveObj;
}



LiveObject * __cdecl lego::game::LiveObject_Create_internal(void)
{
	int iVar1;
	LiveObject *pLVar2;
	LiveObject *liveObj;
	
	if (globs::liveGlobs.freeList == NULL) {
		LiveManager_AddList();
	}
	liveObj = globs::liveGlobs.freeList;
	pLVar2 = globs::liveGlobs.freeList;
	globs::liveGlobs.freeList = (globs::liveGlobs.freeList)->nextFree;
	for (iVar1 = 0x103; iVar1 != 0; iVar1 += -1) {
		pLVar2->objType = OBJECT_NONE;
		pLVar2 = (LiveObject *)&pLVar2->objIndex;
	}
	liveObj->nextFree = liveObj;
	(liveObj->point_2f4).y = -1.0;
	(liveObj->point_2f4).x = -1.0;
	return liveObj;
}



void __cdecl lego::game::LiveManager_AddList(void)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::liveGlobs.listCount & 0x1f);
	pLVar2 = (LiveObject *)std::malloc(uVar4 * 0x40c);
	globs::liveGlobs.listSet[globs::liveGlobs.listCount] = pLVar2;
	pLVar2 = globs::liveGlobs.listSet[globs::liveGlobs.listCount];
	if (pLVar2 != NULL) {
		globs::liveGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pLVar1 = pLVar2;
			do {
				pLVar1->nextFree = pLVar1 + 1;
				iVar3 += -1;
				pLVar1 = pLVar1 + 1;
			} while (iVar3 != 0);
		}
		pLVar2[uVar4 - 1].nextFree = globs::liveGlobs.freeList;
		globs::liveGlobs.freeList = pLVar2;
	}
	return;
}



int __cdecl lego::game::LiveManage_GetNumBuildingsTeleported(int *stack)
{
	return globs::liveGlobs.BuildingsTeleported;
}



void __cdecl lego::game::LiveManage_SetNumBuildingsTeleported(uint numTeleported)
{
	globs::liveGlobs.BuildingsTeleported = numTeleported;
	return;
}



void __cdecl lego::game::LiveObject_SetCrystalPoweredColor(LiveObject *liveObj,BOOL isPowered)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	float b;
	D3DRMGroupIndex groupID;
	float local_4;
	
	if (liveObj->objType == OBJECT_POWERCRYSTAL) {
		if (isPowered == 0) {
			isPowered = (BOOL)globs::legoGlobs.UnpoweredCrystalRGB.red;
			local_4 = globs::legoGlobs.UnpoweredCrystalRGB.green;
			b = globs::legoGlobs.UnpoweredCrystalRGB.blue;
		}
		else {
			isPowered = (BOOL)globs::legoGlobs.PowerCrystalRGB.red;
			local_4 = globs::legoGlobs.PowerCrystalRGB.green;
			b = globs::legoGlobs.PowerCrystalRGB.blue;
		}
		groupID = D3DRMGROUP_0;
		uVar1 = res::Container_Mesh_GetGroupCount(liveObj->other);
		if (uVar1 != 0) {
			do {
				res::Container_Mesh_SetColourAlpha(liveObj->other,groupID,(float)isPowered,local_4,b,1.0);
				res::Container_Mesh_SetEmissive(liveObj->other,groupID,(float)isPowered,local_4,b);
				groupID += 1;
				DVar2 = res::Container_Mesh_GetGroupCount(liveObj->other);
			} while (groupID < DVar2);
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00438720(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_20;
		OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_STOREOBJECTS) == STATS1_NONE) {
			OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
			if ((OVar1 & STATS1_PROCESSORE) == STATS1_NONE) {
				OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
				if ((OVar1 & STATS1_PROCESSCRYSTAL) == STATS1_NONE) {
					liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_20;
				}
				else {
					ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_POWERCRYSTAL,0,0);
				}
			}
			else {
				ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_ORE,0,0);
			}
		}
		else {
			ai::AITask_LiveObject_FUN_004038d0(liveObj);
		}
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_200000;
	}
	else {
		if (liveObj->objType == OBJECT_VEHICLE) {
			res::Vehicle_HideWheels(liveObj->vehicle,0);
		}
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		LiveObject_RemoveObject3CC(liveObj);
	}
	front::HelpWindow_RecallDependencies
						(liveObj->objType,liveObj->objIndex,0,liveObj->flags4 & LIVEOBJ4_UNK_200);
	if (liveObj->objType == OBJECT_BUILDING) {
		globs::liveGlobs.BuildingsTeleported += 1;
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		ai::AITask_DoAttackObject(liveObj);
	}
	if ((liveObj->objType == OBJECT_VEHICLE) || (liveObj->objType == OBJECT_BUILDING)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40000;
	}
	return;
}



void __cdecl lego::game::LiveObject_SetFlag3_80000000(LiveObject *liveObj,BOOL state)
{
	LiveFlags3 LVar1;
	
	if (state == 0) {
		LVar1 = liveObj->flags3 | LIVEOBJ3_POWEROFF;
	}
	else {
		LVar1 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
	}
	liveObj->flags3 = LVar1;
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	return;
}



BOOL __cdecl lego::game::LiveObject_CheckCondition_AndIsPowered(LiveObject *liveObj,BOOL state)
{
	if ((((((liveObj->flags1 &
					(LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_100000|LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) ==
					LIVEOBJ1_NONE) && ((liveObj->flags2 & LIVEOBJ2_UNK_100000) == LIVEOBJ2_NONE)) &&
			 (0.0 <= liveObj->health)) && ((liveObj->flags1 & LIVEOBJ1_UNK_20000) == LIVEOBJ1_NONE)) &&
		 ((state != 0 ||
			(((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE &&
			 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)))))) {
		return TRUE;
	}
	return 0;
}



LiveObject * __cdecl
lego::game::LiveObject_CreateInWorld
					(void *objSrcData,ObjectType objType,int objIndex,int objLevel,float xPos,float yPos,
					float heading)
{
	LiveObject *liveObj;
	
	liveObj = LiveObject_Create((int **)objSrcData,objType,objIndex);
	if (liveObj != NULL) {
		LiveObject_SetPositionAndHeading(liveObj,xPos,yPos,heading,TRUE);
		if ((liveObj->objType == OBJECT_POWERCRYSTAL) || (liveObj->objType == OBJECT_ORE)) {
			LiveObject_SetLevel_thunk(liveObj,objLevel);
		}
		return liveObj;
	}
	return NULL;
}



LiveObject * __cdecl lego::game::Game_Unk_DoSearchCallbacks_Unique(Point2I *blockPos)
{
	LiveObject *local_c;
	int local_8;
	int local_4;
	
	local_c = NULL;
	local_8 = blockPos->x;
	local_4 = blockPos->y;
	Search_LiveObjects_SkipIgnoreMes(LiveManage_FUN_00438970,&local_c);
	return local_c;
}



BOOL __cdecl lego::game::LiveManage_FUN_00438970(LiveObject *liveObj,LiveObject **param_2)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	LiveObject *local_8;
	LiveObject *local_4;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar1 & STATS2_GENERATEPOWER) != STATS2_NONE) {
			BVar2 = LiveObject_CheckCondition_AndIsPowered(liveObj,0);
			if (BVar2 != 0) {
				LiveObject_GetBlockPos(liveObj,(int *)&local_8,(int *)&local_4);
				if ((local_8 == param_2[1]) && (local_4 == param_2[2])) {
					*param_2 = liveObj;
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_AddThisDrainedCrystals(LiveObject *liveObj,int crystalCount)
{
	int count;
	
	if ((globs::legoGlobs.level)->NoDrain != 0) {
		crystalCount = 0;
	}
	count = Level_GetCrystalCount(FALSE);
	if (count < crystalCount) {
		front::Info_Send(INFO_NOPOWER,NULL,liveObj,NULL);
		return 0;
	}
	Level_AddDrainedCrystals(crystalCount);
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_GetBuildingUpgradeCost(LiveObject *liveObj,uint *out_oreCost)
{
	uint uVar1;
	
	uVar1 = stats::Stats_GetLevels(liveObj->objType,liveObj->objIndex);
	if (uVar1 <= liveObj->objLevel + 1) {
		return 0;
	}
	uVar1 = Level_GetOreCount(0);
	if (uVar1 < (uint)globs::legoGlobs.BuildingUpgradeCostOre) {
		uVar1 = Level_GetOreCount(1);
		if (uVar1 < (uint)globs::legoGlobs.BuildingUpgradeCostStuds) {
			return 0;
		}
		if (out_oreCost != NULL) {
			*out_oreCost = globs::legoGlobs.BuildingUpgradeCostStuds;
		}
	}
	else {
		if (out_oreCost != NULL) {
			*out_oreCost = 0;
			return 1;
		}
	}
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_00438ab0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	Container *cont;
	LiveObject *oreCount;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	if (in_liveObj->objType == OBJECT_BUILDING) {
		BVar1 = LiveObject_GetBuildingUpgradeCost(in_liveObj,(uint *)&in_liveObj);
		if (BVar1 != 0) {
			oreCount = in_liveObj;
			if (in_liveObj == NULL) {
				oreCount = (LiveObject *)globs::legoGlobs.BuildingUpgradeCostOre;
			}
			Level_SubtractOre((uint)(in_liveObj != NULL),(int)oreCount);
			liveObj->elapsedTime2 = 0.0;
			res::Building_ChangeUpgradeParts(liveObj->building,liveObj->objLevel + 1);
			stats::StatsObject_SetObjectLevel(liveObj,liveObj->objLevel + 1);
			out_pos = &local_c;
			opt_ref = NULL;
			cont = LiveObject_GetContainer(liveObj);
			res::Container_GetPosition(cont,opt_ref,out_pos);
			effect::Effect_Spawn_Particle(MISCOBJECT_UPGRADEEFFECT,&local_c,NULL);
			front::HelpWindow_RecallDependencies(liveObj->objType,liveObj->objIndex,liveObj->objLevel,0);
		}
	}
	return;
}



BOOL __cdecl FUN_00438b70(LiveObject *liveObj,int objLevel)
{
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	
	if ((liveObj->objType != OBJECT_VEHICLE) ||
		 (BVar1 = lego::res::Vehicle_HasUpgradeLevelMask(liveObj->vehicle,objLevel,1), BVar1 == 0)) {
		return 0;
	}
	uVar2 = lego::stats::Stats_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar3 = lego::stats::Stats_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar4 = lego::stats::Stats_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar5 = lego::game::Level_GetOreCount(0);
	if ((uVar5 < uVar4) &&
		 (uVar4 = lego::game::Level_GetOreCount(1), uVar4 < (uint)(uVar2 % 5 != 0) + uVar3 / 5)) {
		return 0;
	}
	return 1;
}



undefined4 __cdecl FUN_00438c20(LiveObject *opt_liveObj,BOOL param_2)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_18 = 0x461c4000;
	local_14 = 0x2000;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	if (param_2 != 0) {
		local_14 = 0x6000;
	}
	if (opt_liveObj != NULL) {
		lego::game::LiveObject_GetPosition(opt_liveObj,&local_20,&local_1c);
	}
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl lego::game::LiveObject_FUN_00438ca0(LiveObject *liveObj,BOOL param_2)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	uint local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_18 = 0x461c4000;
	local_14 = 0x1000;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	if (param_2 != 0) {
		local_14 |= 0x400;
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl FUN_00438d20(Point2I *blockPos,ObjectType objType,int objIndex,int objLevel)
{
	SurfaceMap *surfMap;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	ObjectType local_10;
	int local_c;
	int local_8;
	undefined4 local_4;
	
	local_c = objIndex;
	local_24 = NULL;
	local_20 = 0.0;
	local_1c = 0.0;
	local_4 = 0;
	out_y = &local_1c;
	out_x = &local_20;
	local_10 = objType;
	local_8 = objLevel;
	local_18 = 0x461c4000;
	local_14 = 1;
	by = blockPos->y;
	bx = blockPos->x;
	surfMap = lego::lrr::Lego_GetMap();
	lego::game::Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl
lego::game::LiveObject_FUN_00438da0
					(LiveObject *liveObj,Point2I *blockPos,ObjectType objType,int objLevel)
{
	SurfaceMap *surfMap;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	ObjectType local_10;
	undefined4 local_c;
	int local_8;
	undefined4 local_4;
	
	local_10 = objType;
	local_18 = 0x461c4000;
	local_24 = NULL;
	local_20 = 0.0;
	local_1c = 0.0;
	local_14 = 2;
	local_c = 0;
	local_8 = objLevel;
	local_4 = 0;
	if (liveObj == NULL) {
		out_y = &local_1c;
		out_x = &local_20;
		by = blockPos->y;
		bx = blockPos->x;
		surfMap = lrr::Lego_GetMap();
		Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
	}
	else {
		LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00438e40(LiveObject *liveObj,undefined4 param_2)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	local_14 = param_2;
	local_18 = 0x461c4000;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00438eb0(LiveObject *liveObj)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	local_18 = 0x461c4000;
	local_14 = 0x80;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00438f20(LiveObject *liveObj)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	local_18 = 0x461c4000;
	local_14 = 4;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Game_FindBigTeleporter(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 0x20;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Game_FindSmallTeleporter(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 0x10;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Game_FindWaterTeleporter(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 0x200;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Level_GetBuildingAtPosition(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 8;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00439110(LiveObject *liveObj,Point2F *param_2,TrainedFlags trainedType)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	TrainedFlags local_4;
	
	local_4 = trainedType;
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_18 = 0x461c4000;
	local_14 = 0x100;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	if (param_2 != NULL) {
		local_20 = param_2->x;
		local_1c = param_2->y;
	}
	if (liveObj != NULL) {
		lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	}
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



BOOL __cdecl lego::game::LiveObject_HasTraining(LiveObject *liveObj,TrainedFlags training)
{
	ObjectStatsFlags2 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
	if (((OVar1 & STATS2_TRAINPILOT) == STATS2_NONE) || (training != TRAINED_PILOT)) {
		OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
		if (((OVar1 & STATS2_TRAINSAILOR) == STATS2_NONE) || (training != TRAINED_SAILOR)) {
			OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
			if (((OVar1 & STATS2_TRAINDRIVER) == STATS2_NONE) || (training != TRAINED_DRIVER)) {
				OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
				if (((OVar1 & STATS2_TRAINDYNAMITE) == STATS2_NONE) || (training != TRAINED_DYNAMITE)) {
					OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
					if (((OVar1 & STATS2_TRAINREPAIR) == STATS2_NONE) || (training != TRAINED_REPAIR)) {
						OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
						if (((OVar1 & STATS2_TRAINSCANNER) == STATS2_NONE) || (training != TRAINED_SCANNER)) {
							return 0;
						}
					}
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_IsDocksBuilding_Unk(LiveObject *liveObj)
{
	BOOL BVar1;
	ObjectType local_8;
	int local_4;
	
	BVar1 = Object_GetObjectByName("Docks",&local_8,&local_4,NULL);
	if (((BVar1 != 0) && (liveObj->objType == local_8)) && (liveObj->objIndex == local_4)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CallbackSearch_FUN_00439270(LiveObject *liveObj,int **search)
{
	int *piVar1;
	bool bVar2;
	BOOL BVar3;
	ObjectStatsFlags1 OVar4;
	ObjectStatsFlags2 OVar5;
	float local_8;
	float local_4;
	
	piVar1 = search[4];
	bVar2 = false;
	BVar3 = LiveObject_CheckCondition_AndIsPowered(liveObj,(uint)piVar1 & 0x400);
	if (BVar3 == 0) {
		return 0;
	}
	if ((((uint)piVar1 & 0x4000) != 0) && ((*(byte *)&liveObj->flags4 & 0x10) != 0)) {
		return 0;
	}
	if (((uint)piVar1 & 0xfffffbff) == 0) {
		if (liveObj->objType != OBJECT_BUILDING) goto LAB_00439459;
	}
	else {
		if (((((uint)piVar1 & 1) != 0) &&
				(OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
				(OVar4 & STATS1_STOREOBJECTS) != STATS1_NONE)) &&
			 (BVar3 = LiveObject_CanSpawnCarryableObject(liveObj,(ObjectType)search[5],(int)search[6]),
			 BVar3 != 0)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x1000) != 0) &&
			 (BVar3 = LiveObject_IsDocksBuilding_Unk(liveObj), BVar3 != 0)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x2000) != 0) &&
				(OVar5 = stats::StatsObject_GetStatsFlags2(liveObj),
				(OVar5 & STATS2_SELFPOWERED) == STATS2_NONE)) &&
			 ((OVar5 = stats::StatsObject_GetStatsFlags2(liveObj),
				(OVar5 & STATS2_GENERATEPOWER) == STATS2_NONE &&
				(BVar3 = LiveObject_CheckCondition_AndIsPowered(liveObj,0), BVar3 != 0)))) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x100) != 0) &&
			 (BVar3 = LiveObject_HasTraining(liveObj,(TrainedFlags)search[8]), BVar3 != 0)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x40) != 0) &&
				(OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
				(OVar4 & STATS1_STOREOBJECTS) == STATS1_NONE)) && (liveObj->objType == OBJECT_BUILDING)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x80) != 0) &&
				(OVar5 = stats::StatsObject_GetStatsFlags2(liveObj),
				(OVar5 & STATS2_UPGRADEBUILDING) != STATS2_NONE)) && (liveObj->object_300 == NULL)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x800) != 0) &&
			 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_MANTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x10) != 0) &&
			 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x20) != 0) &&
			 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x200) != 0) &&
			 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 2) != 0) &&
			 (((OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
				 (OVar4 & STATS1_PROCESSORE) != STATS1_NONE && (search[5] == (int *)&DAT_00000007)) ||
				((OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
				 (OVar4 & STATS1_PROCESSCRYSTAL) != STATS1_NONE && (search[5] == (int *)0x6)))))) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 4) != 0) &&
			 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_SNAXULIKE) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 8) == 0) ||
			 (OVar4 = stats::StatsObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_TOOLSTORE) == STATS1_NONE)) goto LAB_00439459;
	}
	bVar2 = true;
LAB_00439459:
	if (bVar2) {
		LiveObject_GetPosition(liveObj,&local_8,&local_4);
		piVar1 = (int *)SQRT(((float)search[2] - local_4) * ((float)search[2] - local_4) +
												 ((float)search[1] - local_8) * ((float)search[1] - local_8));
		if ((float)piVar1 < (float)search[3]) {
			search[3] = piVar1;
			*search = (int *)liveObj;
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Game_CanStoredObjectTypeBeSpawned(ObjectType objType)
{
	BOOL BVar1;
	
	if (((objType != OBJECT_VEHICLE) && (objType != OBJECT_MINIFIGURE)) &&
		 (objType != OBJECT_BUILDING)) {
		BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_CanSpawnStoredObjects,&objType);
		if (BVar1 != 0) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_CanSpawnStoredObjects(LiveObject *liveObj1,LiveObject *spawnObj)
{
	ObjectStatsFlags1 OVar1;
	BOOL BVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj1);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		BVar2 = LiveObject_CanSpawnCarryableObject(liveObj1,spawnObj->objType,0);
		if (BVar2 != 0) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::Game_PTL_GenerateFromCryOre(Point2I *position)
{
	Point2I *blockPos;
	BOOL BVar1;
	Point2I *pPVar2;
	uint uVar3;
	uint local_c;
	uint local_8;
	uint local_4;
	
	blockPos = position;
	BVar1 = lrr::Lego_GetBlockCryOre
										(position,(int *)&position,(int *)&local_c,(int *)&local_8,(int *)&local_4);
	if (BVar1 != 0) {
		pPVar2 = NULL;
		if (position != NULL) {
			do {
				Level_GenerateCrystal(blockPos,0,NULL,1);
				pPVar2 = (Point2I *)((int)&pPVar2->x + 1);
			} while (pPVar2 < position);
		}
		uVar3 = 0;
		if (local_c != 0) {
			do {
				Level_GenerateCrystal(blockPos,1,NULL,1);
				uVar3 += 1;
			} while (uVar3 < local_c);
		}
		uVar3 = 0;
		if (local_8 != 0) {
			do {
				Level_GenerateOre(blockPos,0,NULL,1);
				uVar3 += 1;
			} while (uVar3 < local_8);
		}
		uVar3 = 0;
		if (local_4 != 0) {
			do {
				Level_GenerateOre(blockPos,1,NULL,1);
				uVar3 += 1;
			} while (uVar3 < local_4);
		}
	}
	return;
}



void __cdecl lego::game::Game_PTL_GenerateCrystalsAndOre(Point2I *blockPos,uint objLevel)
{
	Level_GenerateCrystal(blockPos,objLevel,NULL,TRUE);
	Level_GenerateOre(blockPos,objLevel,NULL,TRUE);
	return;
}



void __cdecl
lego::game::Level_GenerateCrystal
					(Point2I *blockPos,uint objLevel,Point2F *opt_worldPos,BOOL showInfoMessage)
{
	SurfaceMap *surfMap;
	float fVar1;
	LiveObject *argument1Obj;
	LevelData *pLVar2;
	int iVar3;
	float xPos;
	float10 fVar4;
	float10 fVar5;
	uint bx;
	uint by;
	Vector3F *out_vertPoses;
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	surfMap = lrr::Lego_GetMap();
	fVar4 = Map3D_GetBlockSize(surfMap);
	surfMap = lrr::Lego_GetMap();
	fVar5 = Map3D_GetBlockSize(surfMap);
	fVar1 = (float)((float10)(float)(fVar4 * (float10)0.5) - fVar5 * (float10)0.25);
	if (opt_worldPos == NULL) {
		by = blockPos->y;
		bx = blockPos->x;
		out_vertPoses = local_30;
		surfMap = lrr::Lego_GetMap();
		Map3D_GetBlockVertexPositions2(surfMap,bx,by,out_vertPoses);
		fVar4 = math::Maths_RandRange(local_30[0].x + fVar1,local_18 - fVar1);
		xPos = (float)fVar4;
		fVar4 = math::Maths_RandRange(local_30[0].y - fVar1,local_14 + fVar1);
		fVar1 = (float)fVar4;
	}
	else {
		xPos = opt_worldPos->x;
		fVar1 = opt_worldPos->y;
	}
	argument1Obj = LiveObject_CreateInWorld
													 (globs::legoGlobs.contCrystal,OBJECT_POWERCRYSTAL,0,objLevel,xPos,fVar1,
														0.0);
	Message_AddMessageAction(MESSAGE_GENERATECRYSTAL_COMPLETE,argument1Obj,0,NULL);
	if (showInfoMessage != 0) {
		front::Info_Send(INFO_CRYSTALFOUND,NULL,NULL,blockPos);
		front::Text_DisplayMessage(TEXT_CRYSTALFOUND,TRUE,FALSE);
		pLVar2 = lrr::Lego_GetLevel();
		iVar3 = (pLVar2->dimensions).width * blockPos->y + blockPos->x;
		pLVar2 = lrr::Lego_GetLevel();
		pLVar2->blocks[iVar3].generateCrystals = pLVar2->blocks[iVar3].generateCrystals + 1;
	}
	return;
}



void __cdecl
lego::game::Level_GenerateOre
					(Point2I *blockPos,uint objLevel,Point2F *opt_point,BOOL showInfoMessage)
{
	SurfaceMap *pSVar1;
	float fVar2;
	LiveObject *argument1Obj;
	LevelData *pLVar3;
	int iVar4;
	float xPos;
	float10 fVar5;
	float10 fVar6;
	uint bx;
	uint by;
	Vector3F *out_vertPoses;
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	pSVar1 = lrr::Lego_GetMap();
	fVar5 = Map3D_GetBlockSize(pSVar1);
	pSVar1 = lrr::Lego_GetMap();
	fVar6 = Map3D_GetBlockSize(pSVar1);
	fVar2 = (float)((float10)(float)(fVar5 * (float10)0.5) - fVar6 * (float10)0.25);
	if (opt_point == NULL) {
		by = blockPos->y;
		bx = blockPos->x;
		out_vertPoses = local_30;
		pSVar1 = lrr::Lego_GetMap();
		Map3D_GetBlockVertexPositions2(pSVar1,bx,by,out_vertPoses);
		fVar5 = math::Maths_RandRange(local_30[0].x + fVar2,local_18 - fVar2);
		xPos = (float)fVar5;
		fVar5 = math::Maths_RandRange(local_30[0].y - fVar2,local_14 + fVar2);
		fVar2 = (float)fVar5;
	}
	else {
		xPos = opt_point->x;
		fVar2 = opt_point->y;
	}
	argument1Obj = LiveObject_CreateInWorld
													 (globs::legoGlobs.contOresTable[0],OBJECT_ORE,0,objLevel,xPos,fVar2,0.0);
	Message_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,argument1Obj,0,NULL);
	front::Text_DisplayMessage(TEXT_OREFOUND,1,0);
	if (showInfoMessage != 0) {
		pLVar3 = lrr::Lego_GetLevel();
		iVar4 = (pLVar3->dimensions).width * blockPos->y + blockPos->x;
		pLVar3 = lrr::Lego_GetLevel();
		pLVar3->blocks[iVar4].generateOre = pLVar3->blocks[iVar4].generateOre + 1;
	}
	return;
}



char * __cdecl lego::game::LiveObject_GetName(LiveObject *liveObj)
{
	if (true) {
		switch(liveObj->objType) {
		case OBJECT_VEHICLE:
			return globs::legoGlobs.ObjectNames_VehicleTypes_TABLE[liveObj->vehicle->objIndex];
		case OBJECT_MINIFIGURE:
			return globs::legoGlobs.ObjectNames_MiniFigureTypes_TABLE[liveObj->miniFigure->objIndex];
		case OBJECT_ROCKMONSTER:
			return globs::legoGlobs.ObjectNames_RockMonsterTypes_TABLE[liveObj->rockMonster->objIndex];
		case OBJECT_BUILDING:
			return globs::legoGlobs.ObjectNames_BuildingTypes_TABLE[liveObj->building->objIndex];
		case OBJECT_POWERCRYSTAL:
			return globs::legoGlobs.ObjectNames_PowerCrystal;
		case OBJECT_ORE:
			return (char *)(&globs::legoGlobs.gotoPositions_88[9].x)[liveObj->objIndex];
		case OBJECT_DYNAMITE:
			return globs::legoGlobs.ObjectNames_Dynamite;
		case OBJECT_BARRIER:
			return globs::legoGlobs.ObjectNames_Barrier;
		case OBJECT_UPGRADEPART:
			return globs::legoGlobs.ObjectNames_UpgradeTypes_TABLE[liveObj->upgrade->objectIndex];
		case OBJECT_ELECTRICFENCE:
			return globs::legoGlobs.ObjectNames_ElectricFence;
		case OBJECT_SPIDERWEB:
			return globs::legoGlobs.ObjectNames_SpiderWeb;
		case OBJECT_OOHSCARY:
			return globs::legoGlobs.ObjectNames_OohScary;
		case OBJECT_PATH:
			return globs::legoGlobs.ObjectNames_Path;
		}
	}
	return NULL;
}



char * __cdecl lego::game::Object_GetTypeName(ObjectType objType,int objIndex)
{
	if (objType < OBJECT_BARRIER) {
		if (objType == OBJECT_DYNAMITE) {
			return "Dynamite";
		}
		if (true) {
			switch(objType) {
			case OBJECT_VEHICLE:
				return globs::legoGlobs.VehicleTypes_TABLE[objIndex];
			case OBJECT_MINIFIGURE:
				return globs::legoGlobs.MiniFigureTypes_TABLE[objIndex];
			case OBJECT_ROCKMONSTER:
				return globs::legoGlobs.RockMonsterTypes_TABLE[objIndex];
			case OBJECT_BUILDING:
				return globs::legoGlobs.BuildingTypes_TABLE[objIndex];
			case OBJECT_POWERCRYSTAL:
				return "PowerCrystal";
			case OBJECT_ORE:
				if (objIndex == 0) {
					return "Ore";
				}
				return "ProcessedOre";
			}
		}
	}
	else {
		if (objType < OBJECT_OOHSCARY) {
			if (objType == OBJECT_SPIDERWEB) {
				return "SpiderWeb";
			}
			if (objType == OBJECT_BARRIER) {
				return "Barrier";
			}
			if (objType == OBJECT_ELECTRICFENCE) {
				return "ElectricFence";
			}
		}
		else {
			if (objType == OBJECT_OOHSCARY) {
				return "OohScary";
			}
			if (objType == OBJECT_TVCAMERA) {
				return "tvcamera";
			}
		}
	}
	return NULL;
}



char * __cdecl lego::game::Object_GetTheName(ObjectType objType,int objIndex)
{
	if (true) {
		switch(objType) {
		case OBJECT_VEHICLE:
			return globs::legoGlobs.ObjectTheNames_VehicleTypes_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return globs::legoGlobs.ObjectTheNames_MiniFigureTypes_TABLE[objIndex];
		case OBJECT_ROCKMONSTER:
			return globs::legoGlobs.ObjectTheNames_RockMonsterTypes_TABLE[objIndex];
		case OBJECT_BUILDING:
			return globs::legoGlobs.ObjectTheNames_BuildingTypes_TABLE[objIndex];
		case OBJECT_POWERCRYSTAL:
			return globs::legoGlobs.ObjectTheNames_PowerCrystal;
		case OBJECT_ORE:
			return globs::legoGlobs.ToolTypes_TABLE[objIndex + -0x12];
		case OBJECT_DYNAMITE:
			return globs::legoGlobs.ObjectTheNames_Dynamite;
		case OBJECT_BARRIER:
			return globs::legoGlobs.ObjectTheNames_Barrier;
		case OBJECT_UPGRADEPART:
			return globs::legoGlobs.ObjectTheNames_UpgradeTypes_TABLE[objIndex];
		case OBJECT_ELECTRICFENCE:
			return globs::legoGlobs.ObjectTheNames_ElectricFence;
		case OBJECT_SPIDERWEB:
			return globs::legoGlobs.ObjectTheNames_SpiderWeb;
		case OBJECT_OOHSCARY:
			return globs::legoGlobs.ObjectTheNames_OohScary;
		case OBJECT_PATH:
			return globs::legoGlobs.ObjectTheNames_Path;
		}
	}
	return NULL;
}



char * __cdecl lego::game::Object_GetName(ObjectType objType,int objIndex)
{
	if (true) {
		switch(objType) {
		case OBJECT_VEHICLE:
			return globs::legoGlobs.ObjectNames_VehicleTypes_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return globs::legoGlobs.ObjectNames_MiniFigureTypes_TABLE[objIndex];
		case OBJECT_ROCKMONSTER:
			return globs::legoGlobs.ObjectNames_RockMonsterTypes_TABLE[objIndex];
		case OBJECT_BUILDING:
			return globs::legoGlobs.ObjectNames_BuildingTypes_TABLE[objIndex];
		case OBJECT_POWERCRYSTAL:
			return globs::legoGlobs.ObjectNames_PowerCrystal;
		case OBJECT_ORE:
			return (char *)(&globs::legoGlobs.gotoPositions_88[9].x)[objIndex];
		case OBJECT_DYNAMITE:
			return globs::legoGlobs.ObjectNames_Dynamite;
		case OBJECT_BARRIER:
			return globs::legoGlobs.ObjectNames_Barrier;
		case OBJECT_UPGRADEPART:
			return globs::legoGlobs.ObjectNames_UpgradeTypes_TABLE[objIndex];
		case OBJECT_ELECTRICFENCE:
			return globs::legoGlobs.ObjectNames_ElectricFence;
		case OBJECT_SPIDERWEB:
			return globs::legoGlobs.ObjectNames_SpiderWeb;
		case OBJECT_OOHSCARY:
			return globs::legoGlobs.ObjectNames_OohScary;
		case OBJECT_PATH:
			return globs::legoGlobs.ObjectNames_Path;
		}
	}
	return NULL;
}



void __cdecl
lego::game::LiveObject_GetTypeIndex(LiveObject *param_1,int *out_objType,int *out_objIndex)
{
	*out_objType = param_1->objType;
	*out_objIndex = param_1->objIndex;
	return;
}



void __cdecl lego::main::Main_LoadToolNames(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	char **ppcVar1;
	char ***pppcVar2;
	
	pppcVar2 = (char ***)globs::legoGlobs.ToolNames_TABLE;
	do {
		keyPath = cfg::CFG_JoinPath(keyBasePath,"ToolNames",pppcVar2[-0xb],0);
		ppcVar1 = (char **)cfg::CFG_CopyString(root,keyPath);
		*pppcVar2 = ppcVar1;
		pppcVar2 = pppcVar2 + 1;
	} while (pppcVar2 < &globs::legoGlobs.ObjectNames_VehicleTypes_TABLE);
	return;
}



void __cdecl lego::game::LiveManager_InitFlagsToggle_AndClearNumDrained(void)
{
	if ((globs::liveGlobs.flags & 0x10) != LIVEMANAGER_NONE) {
		globs::liveGlobs.flags = globs::liveGlobs.flags | 8;
		return;
	}
	globs::liveGlobs.flags |= 4;
	if (globs::legoGlobs.level != NULL) {
		(globs::legoGlobs.level)->numUnusedCrystals = 0;
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(LiveObject *liveObj)
{
	uint uVar1;
	uint uVar2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		return 0;
	}
	if (liveObj->objType == OBJECT_VEHICLE) {
		uVar2 = liveObj->field_328;
		uVar1 = stats::StatsObject_GetMaxCarry(liveObj);
		if (uVar1 <= uVar2) {
			uVar2 = stats::StatsObject_GetMaxCarry(liveObj);
		}
		if ((liveObj->numCarriedObjects < uVar2) && (liveObj->elapsedTime1 < 75.0)) {
			return 0;
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_TryCollect_FUN_00439ce0(LiveObject *liveObj1,LiveObject *targetObj)
{
	LiveObject *liveObj1_00;
	LiveObject *liveObj;
	BOOL BVar1;
	SurfaceMap *pSVar2;
	LiveObject **ppLVar3;
	LiveObject **ppLVar4;
	float *local_24;
	float *local_20;
	LiveObject *local_1c;
	LiveObject *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj1_00 = liveObj1;
	BVar1 = LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(liveObj1);
	liveObj = targetObj;
	if ((BVar1 == 0) && (BVar1 = LiveObject_FUN_00439e90(liveObj1_00,targetObj,TRUE), BVar1 != 0)) {
		LiveObject_GetPosition(liveObj,&local_10,&local_c);
		ppLVar4 = &liveObj1;
		ppLVar3 = &targetObj;
		pSVar2 = lrr::Lego_GetMap();
		Map3D_WorldToBlockPos_NoZ(pSVar2,local_10,local_c,(int *)ppLVar3,(int *)ppLVar4);
		LiveObject_GetPosition(liveObj1_00,&local_8,&local_4);
		ppLVar4 = &local_18;
		ppLVar3 = &local_1c;
		pSVar2 = lrr::Lego_GetMap();
		Map3D_WorldToBlockPos_NoZ(pSVar2,local_8,local_4,(int *)ppLVar3,(int *)ppLVar4);
		if ((local_1c == targetObj) && (local_18 == liveObj1)) {
			LiveObject_RoutingPtr_Alloc_FUN_004419c0
								(liveObj1_00,1,(float *)&targetObj,(float *)&liveObj1,&local_10);
		}
		else {
			BVar1 = LiveObject_FUN_004413b0
												(liveObj1_00,local_1c,local_18,targetObj,liveObj1,&local_24,&local_20,
												 &local_14,0,0);
			if (BVar1 == 0) {
				return 0;
			}
			LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj1_00,local_14,local_24,local_20,&local_10);
			std::free(local_24);
			std::free(local_20);
		}
		liveObj1_00->routeptr_24[liveObj1_00->routingBlocksTotal - 1].byte_11 = 3;
		liveObj1_00->object_2fc = liveObj;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00439e40(LiveObject *liveObj,LiveObject *otherObj)
{
	ObjectStatsFlags3 sflags3;
	LiveObject *foundObj;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		if (otherObj->objIndex != 0) {
			return 0;
		}
		sflags3 = stats::StatsObject_GetStatsFlags3(liveObj);
		if ((sflags3 & STATS3_ENTERTOOLSTORE) == STATS3_NONE) {
			foundObj = LiveObject_FUN_00438da0(liveObj,NULL,otherObj->objType,otherObj->objLevel);
			return (uint)(foundObj != NULL);
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00439e90(LiveObject *liveObj1,LiveObject *liveObj2,BOOL param_3)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	
	if (liveObj1->objType == OBJECT_ROCKMONSTER) {
		if ((liveObj1->flags3 & LIVEOBJ3_UNK_8000000) == LIVEOBJ3_NONE) {
			return 0;
		}
	}
	else {
		if ((*(byte *)&liveObj1->flags3 & 0x20) == 0) {
			return 0;
		}
	}
	if ((*(byte *)&liveObj1->flags1 & 1) != 0) {
		return 0;
	}
	if (param_3 != 0) {
		BVar1 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj1);
		if (BVar1 != 0) {
			return 0;
		}
	}
	OVar2 = stats::StatsObject_GetStatsFlags1(liveObj1);
	if (((OVar2 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) && (liveObj2->objType != OBJECT_POWERCRYSTAL)
		 ) {
		return 0;
	}
	OVar2 = stats::StatsObject_GetStatsFlags1(liveObj1);
	if (((OVar2 & STATS1_PROCESSORE) != STATS1_NONE) && (liveObj2->objType != OBJECT_ORE)) {
		return 0;
	}
	if ((liveObj1->numCarriedObjects != 0) &&
		 (liveObj1->carriedObjects[0]->objType != liveObj2->objType)) {
		return 0;
	}
	return TRUE;
}



void __cdecl lego::game::LiveObject_CompleteVehicleUpgrade(LiveObject *liveObj)
{
	uint uVar1;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		uVar1 = res::Vehicle_GetUpgradesCurrentLevel(liveObj->vehicle);
		uVar1 |= 1 << ((byte)liveObj->field_404 & 0x1f);
		res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,uVar1);
		stats::StatsObject_SetObjectLevel(liveObj,uVar1);
		front::Text_DisplayMessage(TEXT_UNITUPGRADED,1,0);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_SetLevel_thunk(LiveObject *liveObj,int objLevel)
{
	BOOL BVar1;
	
	BVar1 = stats::StatsObject_SetObjectLevel(liveObj,objLevel);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_IsSmallTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_SMALLTELEPORTER;
}



BOOL __cdecl lego::game::LiveObject_IsBigTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_BIGTELEPORTER;
}



BOOL __cdecl lego::game::LiveObject_IsWaterTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_WATERTELEPORTER;
}



BOOL __cdecl
lego::game::LiveObject_UnkGetTerrainCrossBlock_FUN_0043a010
					(LiveObject *liveObj,Point2I *out_blockPos)
{
	uint bx;
	BOOL BVar1;
	int iVar2;
	uint by;
	uint i;
	Point2I *pDir;
	Point2I local_28;
	Point2I DIRECTIONS [4];
	
	DIRECTIONS[0].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	LiveObject_GetBlockPos(liveObj,&local_28.x,&local_28.y);
	i = 0;
	pDir = DIRECTIONS;
	do {
		pDir->x = pDir->x + local_28.x;
		by = pDir->y + local_28.y;
		pDir->y = by;
		bx = pDir->x;
		BVar1 = Level_Block_IsGround(bx,by);
		if (BVar1 != 0) {
			iVar2 = LiveObject_Routing_GetCrossTerrainType(NULL,bx,pDir->y,bx,pDir->y,0);
			if (iVar2 != 0) {
				if (out_blockPos != NULL) {
					iVar2 = DIRECTIONS[i].y;
					out_blockPos->x = DIRECTIONS[i].x;
					out_blockPos->y = iVar2;
				}
				return TRUE;
			}
		}
		i += 1;
		pDir = pDir + 1;
	} while (i < 4);
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_UnkGetTerrainGetOutAtLandBlock_FUN_0043a0d0
					(LiveObject *liveObj,Point2I *out_blockPos)
{
	ObjectStatsFlags3 OVar1;
	BOOL BVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_GETOUTATLAND) != STATS3_NONE) {
		BVar2 = LiveObject_UnkGetTerrainCrossBlock_FUN_0043a010(liveObj,out_blockPos);
		return BVar2;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_CheckUnkGetInAtLand_FUN_0043a100(LiveObject *liveObj,Point2I *param_2)
{
	ObjectStatsFlags3 OVar1;
	BOOL BVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_GETINATLAND) != STATS3_NONE) {
		BVar2 = LiveObject_UnkGetTerrainCrossBlock_FUN_0043a010(liveObj,param_2);
		return BVar2;
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_DropCarriedObject_FUN_0043a130(LiveObject *in_liveObj,BOOL param_2)
{
	byte bVar1;
	LiveFlags1 LVar2;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	LiveObject *liveObj1;
	ObjectStatsFlags1 OVar3;
	BOOL BVar4;
	Container *cont;
	int iVar5;
	uint uVar6;
	LiveObject **ppLVar7;
	AITaskType taskType;
	Point2I local_20;
	float local_18;
	float local_14 [2];
	Vector3F local_c;
	
	liveObj1 = in_liveObj;
	LVar2 = in_liveObj->flags1;
	if (((LVar2 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 (((LVar2 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE || (param_2 != 0)))) {
		liveObj = in_liveObj->object_2fc;
		uVar6 = 0;
		in_liveObj = NULL;
		if (liveObj != NULL) {
			OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
			in_liveObj = (LiveObject *)(OVar3 & STATS1_STOREOBJECTS);
		}
		if ((in_liveObj == NULL) && (param_2 != 0)) {
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_DUMP,NULL,TRUE);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_DYNAMITE,NULL,TRUE);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_ELECFENCE,NULL,TRUE);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_BIRDSCARER,NULL,TRUE);
		}
		if (liveObj1->numCarriedObjects != 0) {
			ppLVar7 = liveObj1->carriedObjects;
			do {
				liveObj_00 = *ppLVar7;
				*ppLVar7 = NULL;
				liveObj_00->carryingThisObject = NULL;
				liveObj_00->object_300 = NULL;
				if ((in_liveObj == NULL) || (param_2 == 0)) {
					LiveObject_GetBlockPos(liveObj_00,&local_20.x,&local_20.y);
					BVar4 = Level_Block_IsGround(local_20.x,local_20.y);
					if (BVar4 == 0) {
LAB_0043a27e:
						cont = LiveObject_GetContainer(liveObj_00);
						LiveObject_GetPosition(liveObj1,&local_18,local_14);
						res::Container_GetPosition(cont,NULL,&local_c);
						res::Container_SetPosition(cont,NULL,local_18,local_14[0],local_c.z);
					}
					else {
						BVar4 = Level_Block_IsLava(&local_20);
						if (BVar4 != 0) goto LAB_0043a27e;
						BVar4 = Level_Block_IsSolidBuilding(local_20.x,local_20.y,0);
						if (BVar4 != 0) goto LAB_0043a27e;
					}
					if (param_2 == 0) {
						if ((LVar2 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE) {
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_DEPOSITE,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_DUMP,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_DYNAMITE,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_ELECFENCE,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_REQUEST,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_GATHER,NULL);
							taskType = AITASK_BIRDSCARER;
						}
						else {
							taskType = AITASK_COLLECT;
						}
						ai::AITask_LiveObject_FUN_00403b30(liveObj1,taskType,liveObj_00);
					}
					else {
						ai::AITask_LiveObject_SetAITaskUnk
											(liveObj1,AITASK_REQUEST,liveObj_00,
											 (uint)(uVar6 == liveObj1->numCarriedObjects - 1));
						if ((liveObj_00->objType != OBJECT_ORE) && (liveObj_00->objType != OBJECT_POWERCRYSTAL))
						{
							liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_PLACING;
						}
					}
					if (liveObj_00->objType == OBJECT_BOULDER) {
						LiveObject_DestroyBoulder_AndCreateExplode(liveObj_00);
					}
				}
				else {
					ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_DEPOSITE,liveObj_00,TRUE);
					LiveObject_FUN_0043ab10(liveObj,liveObj_00);
					LiveManager_InitFlagsToggle_AndClearNumDrained();
				}
				uVar6 += 1;
				ppLVar7 = ppLVar7 + 1;
			} while (uVar6 < liveObj1->numCarriedObjects);
		}
		uVar6 = 0;
		liveObj1->numCarriedObjects = 0;
		liveObj1->flags1 = liveObj1->flags1 & ~LIVEOBJ1_CARRYING;
		if (liveObj1->routingBlocksTotal != 0) {
			iVar5 = 0;
			do {
				bVar1 = (&liveObj1->routeptr_24->byte_11)[iVar5];
				if ((bVar1 == 7) || (bVar1 == 5)) {
					(&liveObj1->routeptr_24->byte_11)[iVar5] = 0;
				}
				uVar6 += 1;
				iVar5 += 0x14;
			} while (uVar6 < liveObj1->routingBlocksTotal);
		}
	}
	return;
}



int __cdecl
lego::game::LiveObject_TryRequestOrDump_FUN_0043a3e0
					(LiveObject *liveObj,Point2I *blockPos,Point2F *param_3,BOOL param_4,BOOL param_5)
{
	float fVar1;
	RoutingBlock *pRVar2;
	short sVar3;
	BOOL BVar4;
	uint uVar5;
	BOOL BVar6;
	float10 fVar7;
	float *local_1c;
	float *local_18;
	int local_14;
	int local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	BVar6 = 0;
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		LiveObject_GetBlockPos(liveObj,&local_14,&local_10);
		if ((local_14 == blockPos->x) && (local_10 == blockPos->y)) {
			BVar6 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
												(liveObj,1,(float *)blockPos,(float *)&blockPos->y,NULL);
		}
		else {
			BVar4 = LiveObject_FUN_004413b0
												(liveObj,local_14,local_10,blockPos->x,blockPos->y,&local_1c,&local_18,
												 &local_c,0,0);
			if (BVar4 != 0) {
				BVar6 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,local_c,local_1c,local_18,NULL);
				std::free(local_1c);
				std::free(local_18);
			}
		}
		if (BVar6 != 0) {
			if (liveObj->objType == OBJECT_VEHICLE) {
				fVar7 = math::Maths_RandRange(0.55,0.75);
				fVar1 = (float)fVar7;
				sVar3 = math::Maths_Rand();
				uVar5 = (int)sVar3 >> 0x1f;
				param_5 = 1;
				switch((((int)sVar3 ^ uVar5) - uVar5 & 3 ^ uVar5) - uVar5) {
				case 0:
					local_8 = 0.5;
					local_4 = fVar1;
					break;
				case 1:
					local_4 = 0.5;
					local_8 = fVar1;
					break;
				case 2:
					local_8 = 0.5;
					local_4 = 1.0 - fVar1;
					break;
				case 3:
					local_4 = 0.5;
					local_8 = 1.0 - fVar1;
				}
			}
			else {
				local_8 = param_3->x;
				local_4 = param_3->y;
			}
			if (param_4 == 0) {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 8;
			}
			else {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 9;
			}
			if (param_3 != NULL) {
				uVar5 = liveObj->routingBlocksTotal;
				pRVar2 = liveObj->routeptr_24;
				pRVar2[uVar5 - 1].worldPos.x = local_8;
				pRVar2[uVar5 - 1].worldPos.y = local_4;
			}
			if (param_5 != 0) {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
						 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 8;
			}
		}
	}
	return BVar6;
}



BOOL __cdecl
lego::game::LiveObject_TryDeposit_FUN_0043a5c0(LiveObject *liveObj1,LiveObject *targetObj)
{
	byte *pbVar1;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	SurfaceMap *pSVar4;
	Container *cont;
	float in_x;
	float in_y;
	LiveObject **ppLVar5;
	LiveObject **ppLVar6;
	LiveObject *local_3c;
	float *local_38;
	float *local_34;
	LiveObject *local_30;
	uint local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = liveObj1;
	if ((liveObj1->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		OVar2 = stats::StatsObject_GetStatsFlags1(liveObj1);
		if (((OVar2 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
			 (OVar2 = stats::StatsObject_GetStatsFlags1(liveObj), liveObj_00 = targetObj,
			 (OVar2 & STATS1_PROCESSORE) != STATS1_NONE)) {
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_2000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_DESPOSIT,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			LiveObject_FUN_00447df0(liveObj,1.0);
			return TRUE;
		}
		BVar3 = LiveObject_FUN_00439e90(targetObj,liveObj->carriedObjects[0],0);
		if ((BVar3 != 0) ||
			 (OVar2 = stats::StatsObject_GetStatsFlags1(liveObj_00),
			 (OVar2 & STATS1_STOREOBJECTS) != STATS1_NONE)) {
			cont = NULL;
			OVar2 = stats::StatsObject_GetStatsFlags1(liveObj_00);
			if ((OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE) {
				if (liveObj_00->objType == OBJECT_BUILDING) {
					cont = res::Building_GetDepositNull(liveObj_00->building);
				}
			}
			else {
				cont = res::Building_GetToolNull
												 (liveObj_00->building,globs::liveGlobs.ToolNullIndexes_TABLE[10]);
			}
			if (cont == NULL) {
				LiveObject_GetPosition(liveObj_00,&local_28,&local_24);
			}
			else {
				res::Container_GetPosition(cont,NULL,&local_c);
				res::Container_GetOrientation(cont,NULL,&local_18,NULL);
				local_28 = local_c.x;
				local_24 = local_c.y;
				if (ABS(local_18.x) <= ABS(local_18.y)) {
					if ((ushort)((ushort)(local_18.y < 0.0) << 8 | (ushort)(local_18.y == 0.0) << 0xe) == 0) {
						liveObj1._0_1_ = 2;
					}
					else {
						liveObj1._0_1_ = 0;
					}
				}
				else {
					if ((ushort)((ushort)(local_18.x < 0.0) << 8 | (ushort)(local_18.x == 0.0) << 0xe) == 0) {
						liveObj1._0_1_ = 3;
					}
					else {
						liveObj1._0_1_ = 1;
					}
				}
			}
			ppLVar6 = &liveObj1;
			ppLVar5 = &targetObj;
			in_x = local_28;
			in_y = local_24;
			pSVar4 = lrr::Lego_GetMap();
			Map3D_WorldToBlockPos_NoZ(pSVar4,in_x,in_y,(int *)ppLVar5,(int *)ppLVar6);
			LiveObject_GetPosition(liveObj,&local_20,&local_1c);
			ppLVar6 = &local_3c;
			ppLVar5 = &local_30;
			pSVar4 = lrr::Lego_GetMap();
			Map3D_WorldToBlockPos_NoZ(pSVar4,local_20,local_1c,(int *)ppLVar5,(int *)ppLVar6);
			if ((local_30 == targetObj) && (local_3c == liveObj1)) {
				BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj,1,(float *)&targetObj,(float *)&liveObj1,&local_28);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj,local_30,local_3c,targetObj,liveObj1,&local_38,&local_34,
													 &local_2c,0,0);
				if (BVar3 == 0) {
					return 0;
				}
				BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj,local_2c,local_38,local_34,&local_28);
				std::free(local_38);
				std::free(local_34);
			}
			if (BVar3 != 0) {
				liveObj->object_2fc = liveObj_00;
				OVar2 = stats::StatsObject_GetStatsFlags1(liveObj_00);
				if ((OVar2 & STATS1_STOREOBJECTS) != STATS1_NONE) {
					liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 9;
					liveObj->object_2fc = liveObj_00;
					return TRUE;
				}
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 7;
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
						 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 4;
				pbVar1 = &liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10;
				*pbVar1 = *pbVar1 | (byte)liveObj1 & 3;
			}
			return TRUE;
		}
	}
	return 0;
}



Container * __cdecl lego::game::LiveObject_GetDepositNull(LiveObject *liveObj)
{
	ObjectType OVar1;
	Container *pCVar2;
	
	pCVar2 = NULL;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_BUILDING) {
		pCVar2 = res::Building_GetDepositNull(liveObj->building);
	}
	else {
		if (OVar1 == OBJECT_ROCKMONSTER) {
			pCVar2 = res::Creature_GetDepositNull(liveObj->rockMonster);
		}
		else {
			if (OVar1 == OBJECT_MINIFIGURE) {
				pCVar2 = res::Creature_GetDepositNull(liveObj->miniFigure);
			}
			else {
				if (OVar1 == OBJECT_VEHICLE) {
					pCVar2 = res::Vehicle_GetDepositNull(liveObj->vehicle);
				}
			}
		}
	}
	if (pCVar2 == NULL) {
		pCVar2 = LiveObject_GetContainer(liveObj);
	}
	return pCVar2;
}



LiveObject * __cdecl
lego::game::LiveObject_FUN_0043a910
					(LiveObject *liveObj,ObjectType objType,int objIndex,int objLevel)
{
	BOOL BVar1;
	int iVar2;
	Container *pCVar3;
	LiveObject *argument1Obj;
	MessageType messageType;
	Vector3F local_c;
	
	BVar1 = LiveObject_CanSpawnCarryableObject(liveObj,objType,objIndex);
	if (BVar1 == 0) {
		return NULL;
	}
	switch(objType) {
	case OBJECT_POWERCRYSTAL:
	case OBJECT_ORE:
		iVar2 = 10;
		break;
	case OBJECT_DYNAMITE:
		iVar2 = 9;
		break;
	case OBJECT_BARRIER:
		iVar2 = 8;
		break;
	default:
		iVar2 = 0;
	}
	pCVar3 = res::Building_GetToolNull
										 (liveObj->building,globs::liveGlobs.ToolNullIndexes_TABLE[iVar2]);
	res::Container_GetPosition(pCVar3,NULL,&local_c);
	pCVar3 = globs::legoGlobs.contCrystal;
	if (objType == OBJECT_POWERCRYSTAL) {
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		Level_SubtractCrystals(1);
	}
	else {
		if (objType == OBJECT_ORE) {
			pCVar3 = globs::legoGlobs.contOresTable[objIndex];
			Level_SubtractOre(objIndex,1);
		}
		else {
			pCVar3 = globs::legoGlobs.contBarrier;
			if ((((objType != OBJECT_BARRIER) &&
					 (pCVar3 = globs::legoGlobs.contDynamite, objType != OBJECT_DYNAMITE)) &&
					(pCVar3 = globs::legoGlobs.contElectricFence, objType != OBJECT_ELECTRICFENCE)) &&
				 (pCVar3 = globs::legoGlobs.contOohScary, objType != OBJECT_OOHSCARY)) {
				return NULL;
			}
		}
	}
	argument1Obj = LiveObject_CreateInWorld(pCVar3,objType,objIndex,objLevel,local_c.x,local_c.y,0.0);
	if (objType == OBJECT_ORE) {
		messageType = MESSAGE_GENERATEORE_COMPLETE;
	}
	else {
		messageType = MESSAGE_GENERATECRYSTAL_COMPLETE;
	}
	Message_AddMessageAction(messageType,argument1Obj,0,NULL);
	if (objType != OBJECT_BARRIER) {
		if (objType == OBJECT_DYNAMITE) {
			res::Container_SetActivity(argument1Obj->other,"Normal");
		}
		return argument1Obj;
	}
	res::Container_SetActivity(argument1Obj->other,"Short");
	return argument1Obj;
}



BOOL __cdecl
lego::game::LiveObject_CanSpawnCarryableObject(LiveObject *liveObj,ObjectType objType,int objIndex)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		if (objType == OBJECT_POWERCRYSTAL) {
			iVar2 = Level_GetCrystalCount(1);
			if (iVar2 != 0) {
				return 1;
			}
		}
		if (objType == OBJECT_ORE) {
			iVar2 = Level_GetOreCount(objIndex);
			if (iVar2 != 0) {
				return 1;
			}
		}
		if (objType == OBJECT_BARRIER) {
			return 1;
		}
		if (objType == OBJECT_DYNAMITE) {
			return 1;
		}
		if (objType == OBJECT_ELECTRICFENCE) {
			return 1;
		}
		if (objType == OBJECT_OOHSCARY) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043ab10(LiveObject *liveObj,LiveObject *liveObj2)
{
	int *piVar1;
	int iVar2;
	
	if ((liveObj->objType == OBJECT_ROCKMONSTER) && (liveObj->stealTableptr_348 == NULL)) {
		piVar1 = (int *)std::malloc(0x18);
		liveObj->stealTableptr_348 = piVar1;
		for (iVar2 = 6; iVar2 != 0; iVar2 += -1) {
			*piVar1 = 0;
			piVar1 = piVar1 + 1;
		}
	}
	if (liveObj2->objType == OBJECT_POWERCRYSTAL) {
		if (liveObj->objType == OBJECT_ROCKMONSTER) {
			liveObj->stealTableptr_348[liveObj2->objLevel] =
					 liveObj->stealTableptr_348[liveObj2->objLevel] + 1;
		}
		else {
			Level_IncCrystals();
		}
	}
	else {
		if ((liveObj2->objType == OBJECT_ORE) && (liveObj->objType != OBJECT_ROCKMONSTER)) {
			Level_IncOre(liveObj2->objIndex);
		}
	}
	liveObj2->carryingThisObject = NULL;
	LiveObject_Remove(liveObj2);
	if (liveObj->objType != OBJECT_ROCKMONSTER) {
		ai::AITask_DoRequestObjectCallbacks(liveObj);
	}
	return;
}



void __cdecl
lego::game::Level_AddCrystals__unusedLiveObject(LiveObject *liveObj_unused,uint crystalCount)
{
	if (crystalCount != 0) {
		do {
			Level_IncCrystals();
			crystalCount -= 1;
		} while (crystalCount != 0);
	}
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	return;
}



void __cdecl lego::game::Level_AddOre__unusedLiveObject(LiveObject *liveObj_unused,uint oreCount)
{
	if (oreCount != 0) {
		do {
			Level_IncOre(ORE_NORMAL);
			oreCount -= 1;
		} while (oreCount != 0);
	}
	return;
}



void __cdecl lego::game::LiveObject_WaterVehicle_Unregister(LiveObject *liveObj)
{
	LiveObject **ppLVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::liveGlobs.uintCount_c5cc != 0) {
		ppLVar1 = globs::liveGlobs.liveObjArray100_c43c;
		do {
			if (liveObj == *ppLVar1) {
				*ppLVar1 = NULL;
			}
			uVar2 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globs::liveGlobs.uintCount_c5cc);
	}
	return;
}



void __cdecl lego::game::LiveObject_WaterVehicle_Register(LiveObject *liveObj)
{
	ObjectStatsFlags1 statsFlags1;
	Point2I objBlockPos;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		statsFlags1 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((statsFlags1 & STATS1_CROSSLAND) == STATS1_NONE) {
			LiveObject_GetBlockPos(liveObj,&objBlockPos.x,&objBlockPos.y);
			if (((globs::legoGlobs.level)->blocks
					 [((globs::legoGlobs.level)->dimensions).width * objBlockPos.y + objBlockPos.x].terrain ==
					 TERRAIN_LAKE) && (globs::liveGlobs.uintCount_c5cc < 100)) {
				globs::liveGlobs.liveObjArray100_c43c[globs::liveGlobs.uintCount_c5cc] = liveObj;
				globs::liveGlobs.uintCount_c5cc += 1;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_RegisterVehicle__callsForWater(LiveObject *liveObj)
{
	LiveObject_WaterVehicle_Register(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043acb0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	int local_10;
	int local_c;
	int local_8;
	int local_4;
	
	if (((((liveObj1->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
			 ((*(byte *)&liveObj1->flags2 & 1) == 0)) &&
			((liveObj1->flags1 & (LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_1000000)) == LIVEOBJ1_NONE)) &&
		 ((((ushort)((ushort)(liveObj1->health < 0.0) << 8 | (ushort)(liveObj1->health == 0.0) << 0xe)
				== 0 && ((liveObj2->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj2->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)))) {
		LiveObject_GetBlockPos(liveObj1,&local_10,&local_c);
		LiveObject_GetBlockPos(liveObj2,&local_8,&local_4);
		if (globs::liveGlobs.Activities_TABLE[36] != liveObj1->aitaskName1) {
			LiveObject_SetActivityUnk(liveObj1,ACTIVITY_STAMP,0);
			LiveObject_Container_ActivityUpdate_Check(liveObj1);
			liveObj1->flags2 = liveObj1->flags2 | LIVEOBJ2_UNK_200000;
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_RockMonster_FUN_0043ad70(LiveObject *liveObj)
{
	ObjectStatsFlags2 sflags2;
	BOOL BVar1;
	SurfaceMap *surfMap;
	float10 fVar2;
	float10 fVar3;
	float *out_x;
	float *out_y;
	Point2I local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		sflags2 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((sflags2 & STATS2_ATTACKPATHS) != STATS2_NONE) {
			fVar2 = stats::StatsObject_GetPainThreshold(liveObj);
			if (((fVar2 < (float10)liveObj->health) &&
					(globs::liveGlobs.Activities_TABLE[36] != liveObj->aitaskName1)) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
				LiveObject_GetBlockPos(liveObj,&local_18.x,&local_18.y);
				BVar1 = Level_Block_IsPath(&local_18);
				if (BVar1 != 0) {
					BVar1 = Level_Block_IsPathBuilding(&local_18);
					if (BVar1 == 0) {
						LiveObject_GetPosition(liveObj,&local_10,&local_c);
						out_y = &local_4;
						out_x = &local_8;
						surfMap = lrr::Lego_GetMap();
						Map3D_BlockToWorldPos(surfMap,local_18.x,local_18.y,out_x,out_y);
						surfMap = lrr::Lego_GetMap();
						fVar3 = Map3D_GetBlockSize(surfMap);
						fVar2 = (float10)SQRT((local_c - local_4) * (local_c - local_4) +
																	(local_10 - local_8) * (local_10 - local_8));
						if ((ushort)((ushort)(fVar3 * (float10)0.3333333 < fVar2) << 8 |
												(ushort)(fVar3 * (float10)0.3333333 == fVar2) << 0xe) == 0) {
							LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAMP,0);
							LiveObject_Container_ActivityUpdate_Check(liveObj);
							liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_200000;
						}
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043aeb0(LiveObject *liveObj)
{
	short sVar1;
	BOOL BVar2;
	Point2I local_8;
	
	LiveObject_GetBlockPos(liveObj,&local_8.x,&local_8.y);
	sVar1 = math::Maths_Rand();
	if ((int)sVar1 % 5 == 0) {
		Level_GenerateFallin_InRadius(&local_8,3,1);
	}
	BVar2 = Level_Block_IsPath(&local_8);
	if (BVar2 != 0) {
		effect::Effect_Spawn_SmashPath(liveObj,NULL);
		ai::AITask_DoClearTypeAction(&local_8,MESSAGE_CLEARREMOVEPATH_COMPLETE);
		Level_BlockUpdateSurface(globs::legoGlobs.level,local_8.x,local_8.y,0);
	}
	Search_LiveObjects_SkipIgnoreMes
						(LiveObject_Callback_MiniFigureWithCrystal_InStampRadius_FUN_0043af50,liveObj);
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_MiniFigureWithCrystal_InStampRadius_FUN_0043af50
					(LiveObject *liveObj,LiveObject *otherLiveObj)
{
	float10 stampRadius;
	Point2F position;
	Point2F otherPosition;
	
	if (((liveObj->objType == OBJECT_MINIFIGURE) &&
			((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
		 (liveObj->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)) {
		LiveObject_GetPosition(otherLiveObj,&otherPosition.x,&otherPosition.y);
		LiveObject_GetPosition(liveObj,&position.x,&position.y);
						// is liveObj within stamp radius
		stampRadius = stats::StatsObject_GetStampRadius(otherLiveObj);
		if ((float10)SQRT((position.y - otherPosition.y) * (position.y - otherPosition.y) +
											(position.x - otherPosition.x) * (position.x - otherPosition.x)) < stampRadius
			 ) {
			LiveObject_DropCarriedObject_FUN_0043a130(liveObj,FALSE);
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
		}
	}
	return 0;
}



LiveObject * __cdecl lego::game::LiveObject_TryGenerateSlug(LiveObject *liveObj,uint objIndex)
{
	short sVar1;
	SurfaceMap *surfMap;
	LiveObject *slugObj;
	float10 fVar2;
	float10 fVar3;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float local_18;
	float local_14;
	Point2I local_10;
	float local_8;
	float local_4;
	
	slugObj = NULL;
	if (globs::liveGlobs.SlugHoles_COUNT != 0) {
		fVar2 = math::Maths_RandRange(0.0,6.283185);
		fVar3 = (float10)fsin(fVar2);
		local_8 = (float)fVar3;
		fVar3 = (float10)fcos((float10)(float)fVar2);
		local_4 = (float)fVar3;
		if (liveObj == NULL) {
			sVar1 = math::Maths_Rand();
			local_10.x = globs::liveGlobs.SlugHoles_TABLE
									 [(uint)(int)sVar1 % globs::liveGlobs.SlugHoles_COUNT].x;
			local_10.y = globs::liveGlobs.SlugHoles_TABLE
									 [(uint)(int)sVar1 % globs::liveGlobs.SlugHoles_COUNT].y;
		}
		else {
			LiveObject_NearestSlugHole_FUN_0044a7b0(liveObj,&local_10);
		}
		out_y = &local_14;
		out_x = &local_18;
		bx = local_10.x;
		by = local_10.y;
		surfMap = lrr::Lego_GetMap();
		Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
		local_18 = local_8 * 12.75 + local_18;
		local_14 = local_4 * 12.75 + local_14;
		slugObj = LiveObject_CreateInWorld
												(globs::legoGlobs.RockMonsterData_TABLE + objIndex,OBJECT_ROCKMONSTER,
												 objIndex,0,local_18,local_14,(float)fVar2);
		if (slugObj != NULL) {
			slugObj->flags1 = slugObj->flags1 | LIVEOBJ1_UNK_100;
			slugObj->flags3 = slugObj->flags3 & ~LIVEOBJ3_POWEROFF;
			LiveObject_SetActivityUnk(slugObj,ACTIVITY_EMERGE,0);
			LiveObject_Container_ActivityUpdate_Check(slugObj);
			ai::AITask_DoAnimationWait(slugObj);
			front::Info_Send(INFO_SLUGEMERGE,NULL,slugObj,NULL);
		}
	}
	return slugObj;
}



LiveObject * __cdecl lego::game::Game_PTL_GenerateRockMonster(void)
{
	short rngX;
	short rngY;
	int objIndex;
	SurfaceMap *pSVar1;
	LiveObject *pLVar2;
	uint local_c;
	int height;
	int width;
	
	objIndex = lrr::Lego_GetEmergeCreature();
	pSVar1 = lrr::Lego_GetMap();
	width = (pSVar1->smallDimensions).width;
	pSVar1 = lrr::Lego_GetMap();
	height = (pSVar1->smallDimensions).height;
	local_c = 0;
	do {
		rngX = math::Maths_Rand();
		rngY = math::Maths_Rand();
		pLVar2 = Game_TryGeneratedRockMonsterLiveObject
											 ((int **)(globs::legoGlobs.RockMonsterData_TABLE + objIndex),
												OBJECT_ROCKMONSTER,objIndex,(int)rngX % width,(int)rngY % height);
		if (pLVar2 != NULL) {
			return pLVar2;
		}
		local_c += 1;
	} while (local_c < 1000);
	return NULL;
}



LiveObject * __cdecl
lego::game::Game_TryGeneratedRockMonsterLiveObject
					(int **objSrc,ObjectType objType,int objIndex,uint bx,uint by)
{
	BOOL BVar1;
	int iVar2;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	Container *cont;
	uint uVar3;
	Point2I *blockPos;
	bool bVar4;
	uint uVar5;
	ObjectType bx_00;
	uint uVar6;
	float *pfVar7;
	float *pfVar8;
	float local_44;
	float local_40;
	float local_3c;
	Point2I local_38;
	float local_30 [4];
	Point2I local_20;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar6 = by;
	bx_00 = bx;
	local_38.x = bx;
	local_38.y = by;
	if ((float)objType != 4.203895e-45) {
		return NULL;
	}
	BVar1 = Level_Block_IsWall(bx,by);
	if (BVar1 == 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsReinforced(bx_00,uVar6);
	if (BVar1 != 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsCorner(bx_00,uVar6);
	if (BVar1 != 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsImmovable(&local_38);
	if (BVar1 != 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsBusy(&local_38);
	if (BVar1 != 0) {
		return NULL;
	}
	uVar5 = 0;
	local_20.x = 0;
	local_20.y = -1;
	local_18 = 1;
	local_14 = 0;
	local_10 = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	local_30[0] = 0.0;
	local_30[1] = 1.570796;
	local_30[2] = 3.141593;
	local_30[3] = 4.712389;
	blockPos = &local_20;
	do {
		blockPos->x = blockPos->x + bx_00;
		uVar3 = blockPos->y + uVar6;
		blockPos->y = uVar3;
		BVar1 = Level_Block_IsGround(blockPos->x,uVar3);
		if (((BVar1 != 0) && (BVar1 = Level_Block_IsAnyFlags1_80000_Foundation(blockPos), BVar1 == 0))
			 && (iVar2 = LiveObject_Routing_GetCrossTerrainType
														 (NULL,blockPos->x,blockPos->y,blockPos->x,blockPos->y,0), iVar2 != 0))
		break;
		uVar5 += 1;
		blockPos = blockPos + 1;
	} while (uVar5 < 4);
	if (3 < uVar5) {
		return NULL;
	}
	pfVar8 = &local_3c;
	pfVar7 = &local_40;
	surfMap = lrr::Lego_GetMap();
	Map3D_BlockToWorldPos(surfMap,bx_00,uVar6,pfVar7,pfVar8);
	uVar6 = (&local_20)[uVar5].y;
	pfVar8 = (float *)&objType;
	pfVar7 = &local_44;
	uVar3 = (&local_20)[uVar5].x;
	surfMap = lrr::Lego_GetMap();
	Map3D_BlockToWorldPos(surfMap,uVar3,uVar6,pfVar7,pfVar8);
	local_44 = (local_40 * 9.0 + local_44 * 10.0) * 0.05263158;
	objType = (ObjectType)((local_3c * 9.0 + (float)objType * 10.0) * 0.05263158);
	liveObj = LiveObject_CreateInWorld
											(objSrc,OBJECT_ROCKMONSTER,objIndex,0,local_44,(float)objType,local_30[uVar5])
	;
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100;
	LiveObject_RockMonster_DoWakeUp(liveObj);
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_EMERGE,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	ai::AITask_DoAnimationWait(liveObj);
	cont = LiveObject_GetContainer(liveObj);
	res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SFX_ROCKMONSTER2,FALSE,TRUE,NULL);
	Level_Block_SetBusy(&local_38,TRUE);
	bVar4 = false;
	(liveObj->point_2f4).x = (float)local_38.x;
	(liveObj->point_2f4).y = (float)local_38.y;
	BVar1 = Object_GetObjectByName("RockMonster",&bx,(int *)&by,NULL);
	if (((BVar1 != 0) && (bx == liveObj->objType)) && (by == liveObj->objIndex)) {
		front::Info_Send(INFO_ROCKMONSTER,NULL,liveObj,NULL);
		bVar4 = true;
	}
	if (!bVar4) {
		BVar1 = Object_GetObjectByName("Lavamonster",&bx,(int *)&by,NULL);
		if (((BVar1 != 0) && (bx == liveObj->objType)) && (by == liveObj->objIndex)) {
			front::Info_Send(INFO_LAVAROCKMONSTER,NULL,liveObj,NULL);
			bVar4 = true;
		}
		if (!bVar4) {
			BVar1 = Object_GetObjectByName("Icemonster",&bx,(int *)&by,NULL);
			if (((BVar1 != 0) && (bx == liveObj->objType)) && (by == liveObj->objIndex)) {
				front::Info_Send(INFO_ICEROCKMONSTER,NULL,liveObj,NULL);
				bVar4 = true;
			}
			if (!bVar4) goto LAB_0043b517;
		}
	}
	front::Info_Send(INFO_GENERICMONSTER,NULL,liveObj,NULL);
LAB_0043b517:
	reward::Rewards_RockMonsterGenerated();
	return liveObj;
}



void __cdecl lego::game::LiveManager_UpdateAll(float elapsedGame)
{
	LiveManagerFlags LVar1;
	LiveManagerFlags LVar2;
	
	if ((globs::liveGlobs.flags & 4) != LIVEMANAGER_NONE) {
		Game_LevelClearBlockFlag2_100_Points28C();
	}
	globs::liveGlobs.flags |= 0x10;
	Search_LiveObjects(Game_LiveObjectLargeCallback,&elapsedGame,FALSE);
	LVar2 = globs::liveGlobs.flags & 0xffffffef;
	LVar1 = globs::liveGlobs.flags & 4;
	globs::liveGlobs.flags = LVar2;
	if (LVar1 != LIVEMANAGER_NONE) {
		Game_UpdateLevelBlocks_PointsAAC();
	}
	if ((globs::liveGlobs.flags & 8) == LIVEMANAGER_NONE) {
		globs::liveGlobs.flags &= 0xfffffffb;
	}
	else {
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		globs::liveGlobs.flags &= 0xfffffff7;
	}
	Flocks_Update_FUN_0044c1c0(&elapsedGame);
	globs::liveGlobs.LiveManager_TimerUnk = globs::liveGlobs.LiveManager_TimerUnk - elapsedGame;
	if ((ushort)((ushort)(globs::liveGlobs.LiveManager_TimerUnk < 0.0) << 8 |
							(ushort)(globs::liveGlobs.LiveManager_TimerUnk == 0.0) << 0xe) != 0) {
		globs::liveGlobs.LiveManager_TimerUnk = 125.0;
		lrr::Lego_UpdateAll3DSounds(TRUE);
	}
	return;
}



void __cdecl lego::game::LiveManager_Cleanup_FUN_0043b5e0(void)
{
	globs::liveGlobs.flags |= 2;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_Release,NULL);
	globs::liveGlobs.flags = globs::liveGlobs.flags & 0xfffffffd;
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_Release(LiveObject *liveObj,void *unused)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_Remove(liveObj);
	return BVar1;
}



void __cdecl
lego::game::LiveManager_DoPickSphereCallbacks_MouseXY
					(uint mouseX,uint mouseY,undefined4 *ref_param_3)
{
	undefined4 *local_c;
	float local_8;
	float local_4;
	
	local_c = ref_param_3;
	*ref_param_3 = 0;
	local_8 = (float)(ulonglong)mouseX;
	local_4 = (float)(ulonglong)mouseY;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_0043b670,&local_c);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_0043b670(LiveObject *liveObj,int **param_2)
{
	BOOL BVar1;
	SurfaceMap *pSVar2;
	Container *cont;
	Point2I *pPVar3;
	uint uVar4;
	uint uVar5;
	Direction rotation;
	Vector3F *pVVar6;
	Viewport *view;
	float10 fVar7;
	uint bx;
	Vector3F *pVVar8;
	float x;
	Vector3F *camera;
	float *out_y;
	float y;
	uint local_d0;
	uint local_cc;
	Point2I *local_c8;
	Viewport *local_c4;
	Vector4F local_c0;
	Vector3F local_b0;
	Vector3F local_a4;
	Point2I local_98;
	Vector3F local_90;
	Vector3F local_84;
	Vector3F local_78 [10];
	
	view = globs::legoGlobs.viewMain;
	local_c0.x = (float)param_2[1];
	local_c0.y = (float)param_2[2];
	rotation = DIRECTION_RIGHT;
	local_c4 = globs::legoGlobs.viewMain;
	local_c0.z = 0.0;
	local_c0.w = 1.0;
	BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj,1);
	if (BVar1 != 0) {
		LiveObject_GetBlockPos(liveObj,&local_98.x,&local_98.y);
		LiveObject_GetPosition(liveObj,&local_78[0].x,&local_78[0].y);
		pSVar2 = lrr::Lego_GetMap();
		fVar7 = Map3D_GetWorldZ(pSVar2,local_78[0].x,local_78[0].y);
		local_78[0].z = (float)fVar7;
		fVar7 = stats::StatsObject_GetCollHeight(liveObj);
		local_78[0].z = (float)((float10)local_78[0].z - fVar7 * (float10)0.5);
		if (liveObj->objType == OBJECT_BUILDING) {
			cont = LiveObject_GetContainer(liveObj);
			uVar5 = 0;
			res::Container_GetOrientation(cont,NULL,&local_b0,NULL);
			if (ABS(local_b0.x) <= ABS(local_b0.y)) {
				if ((ushort)((ushort)(local_b0.y < 0.0) << 8 | (ushort)(local_b0.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_b0.x < 0.0) << 8 | (ushort)(local_b0.x == 0.0) << 0xe) != 0) {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar3 = res::Building_GetShapePoints
												 (globs::legoGlobs.BuildingData_TABLE + liveObj->objIndex,&local_cc);
			pPVar3 = res::SelectPlace_TransformShapePoints(&local_98,pPVar3,local_cc,rotation);
			local_d0 = 0;
			if (local_cc != 0) {
				local_c8 = pPVar3 + 1;
				pVVar6 = local_78;
				uVar4 = local_cc;
				do {
					if (((uVar5 == uVar4 - 1) || (pPVar3->x != local_c8->x)) || (pPVar3->y != local_c8->y)) {
						uVar4 = pPVar3->y;
						bx = pPVar3->x;
						pVVar8 = pVVar6;
						out_y = &pVVar6->y;
						pSVar2 = lrr::Lego_GetMap();
						Map3D_BlockToWorldPos(pSVar2,bx,uVar4,&pVVar8->x,out_y);
						y = pVVar6->y;
						x = pVVar6->x;
						pSVar2 = lrr::Lego_GetMap();
						fVar7 = Map3D_GetWorldZ(pSVar2,x,y);
						pVVar6->z = (float)fVar7;
						fVar7 = stats::StatsObject_GetCollHeight(liveObj);
						local_d0 += 1;
						pVVar6->z = (float)((float10)pVVar6->z - fVar7 * (float10)0.5);
						uVar4 = local_cc;
						pVVar6 = pVVar6 + 1;
					}
					else {
						uVar5 += 1;
						local_c8 = local_c8 + 1;
						pPVar3 = pPVar3 + 1;
					}
					uVar5 += 1;
					local_c8 = local_c8 + 1;
					pPVar3 = pPVar3 + 1;
					view = local_c4;
				} while (uVar5 < uVar4);
			}
		}
		else {
			local_d0 = 1;
		}
		lego::view::Viewport_InverseTransform(view,&local_a4,&local_c0);
		local_c0.z = 1.0;
		lego::view::Viewport_InverseTransform(view,&local_84,&local_c0);
		local_90.x = local_84.x - local_a4.x;
		local_84.y = local_84.y - local_a4.y;
		local_84.z = local_84.z - local_a4.z;
		uVar5 = 0;
		local_90.z = 1.0 / SQRT(local_84.z * local_84.z +
														local_84.y * local_84.y + local_90.x * local_90.x);
		local_90.x = local_90.z * local_90.x;
		local_90.y = local_90.z * local_84.y;
		local_90.z = local_90.z * local_84.z;
		if (local_d0 != 0) {
			pVVar6 = local_78;
			do {
				pVVar8 = &local_90;
				camera = &local_a4;
				fVar7 = stats::StatsObject_GetPickSphere(liveObj);
				BVar1 = math::Maths_RaySphereIntersection(pVVar6,(float)fVar7,camera,pVVar8);
				if (BVar1 != 0) {
					**param_2 = (int)liveObj;
					return TRUE;
				}
				uVar5 += 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar5 < local_d0);
			return 0;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveManager_DoSelection(Viewport *view,Point2F *dragStart,Point2F *dragEnd)
{
	TutorialFlags TVar1;
	SearchViewportWindow_14 search;
	
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar1 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
		search.view = view;
		if (dragEnd->x <= dragStart->x) {
			search.dragStart.x = dragEnd->x;
		}
		else {
			search.dragStart.x = dragStart->x;
		}
		if ((ushort)((ushort)(dragEnd->y < dragStart->y) << 8 |
								(ushort)(dragEnd->y == dragStart->y) << 0xe) == 0) {
			search.dragStart.y = dragStart->y;
		}
		else {
			search.dragStart.y = dragEnd->y;
		}
		if ((ushort)((ushort)(dragStart->x < dragEnd->x) << 8 |
								(ushort)(dragStart->x == dragEnd->x) << 0xe) == 0) {
			search.dragEnd.x = dragStart->x;
		}
		else {
			search.dragEnd.x = dragEnd->x;
		}
		if (dragStart->y <= dragEnd->y) {
			search.dragEnd.y = dragEnd->y;
		}
		else {
			search.dragEnd.y = dragStart->y;
		}
		Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackDoSelection,&search);
		Message_AddMessageAction(MESSAGE_REDUCESELECTION,0,0,NULL);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_CallbackDoSelection(LiveObject *liveObj,SearchViewportWindow_14 *search)
{
	float fVar1;
	Container *cont;
	Vector3F position;
	Vector4F viewObjPos;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,&position);
	lego::view::Viewport_Transform(search->view,&viewObjPos,&position);
	viewObjPos.x = viewObjPos.x / viewObjPos.w;
	viewObjPos.y = viewObjPos.y / viewObjPos.w;
	if (((((search->dragStart).x <= viewObjPos.x) && ((search->dragStart).y <= viewObjPos.y)) &&
			(fVar1 = (search->dragEnd).x,
			(ushort)((ushort)(viewObjPos.x < fVar1) << 8 | (ushort)(viewObjPos.x == fVar1) << 0xe) != 0))
		 && (fVar1 = (search->dragEnd).y,
				(ushort)((ushort)(viewObjPos.y < fVar1) << 8 | (ushort)(viewObjPos.y == fVar1) << 0xe) != 0)
		 ) {
		Message_AddMessageAction(MESSAGE_SELECT,liveObj,1,NULL);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_SwapPolyFP(LiveObject *liveObj,int cameraFrameIndex,BOOL on)
{
	if ((liveObj->objType == OBJECT_MINIFIGURE) ||
		 ((liveObj = liveObj->drivenObject, liveObj != NULL && (liveObj->objType == OBJECT_MINIFIGURE)))
		 ) {
		res::Creature_SwapPolyFP(liveObj->miniFigure,on,cameraFrameIndex);
	}
	return;
}



void __cdecl
lego::game::LiveObject_FP_SetRanges
					(LiveObject *liveObj,Container *resData,float medPolyRange,float highPolyRange,
					BOOL param_5)
{
	LiveObject *pLVar1;
	LiveObjectInfo liveInfo;
	
	liveInfo.point_8.x = medPolyRange;
	liveInfo.point_8.y = highPolyRange;
	liveInfo.liveObj = liveObj;
	liveInfo.vector_10.x = 0.0;
	liveInfo.intbool_4 = param_5;
	liveInfo.vector_10.y = 0.0;
	liveInfo.vector_10.z = 0.0;
	if (((liveObj->objType != OBJECT_MINIFIGURE) && (pLVar1 = liveObj->drivenObject, pLVar1 != NULL))
		 && (pLVar1->objType == OBJECT_MINIFIGURE)) {
		liveInfo.liveObj = pLVar1;
	}
	if (param_5 != 0) {
		res::Container_GetPosition(resData,NULL,&liveInfo.vector_10);
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_FP_Callback_SwapPolyMeshParts,&liveInfo);
	return;
}



BOOL __cdecl
lego::game::LiveObject_FP_Callback_SwapPolyMeshParts(LiveObject *liveObj,LiveObjectInfo *liveInfo)
{
	float fVar1;
	PolyMode PVar2;
	ObjectType OVar3;
	float fVar4;
	float fVar5;
	Container *cont;
	Vector3F vector;
	
	if (liveObj != liveInfo->liveObj) {
		PVar2 = liveObj->polyMode_34c;
		if (liveInfo->intbool_4 == 0) {
			if (PVar2 == POLY_MEDIUM) {
				OVar3 = liveObj->objType;
				if (OVar3 == OBJECT_MINIFIGURE) {
					res::Creature_SwapPolyMedium(liveObj->miniFigure,FALSE);
				}
				else {
					if (OVar3 == OBJECT_ROCKMONSTER) {
						res::Creature_SwapPolyMedium(liveObj->rockMonster,FALSE);
					}
					else {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_SwapPolyMedium(liveObj->vehicle,FALSE);
						}
					}
				}
			}
			else {
				if (PVar2 == POLY_HIGH) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_SwapPolyHigh(liveObj->miniFigure,FALSE);
					}
					else {
						if (OVar3 == OBJECT_ROCKMONSTER) {
							res::Creature_SwapPolyHigh(liveObj->rockMonster,FALSE);
						}
						else {
							if (OVar3 == OBJECT_VEHICLE) {
								res::Vehicle_SwapPolyHigh(liveObj->vehicle,FALSE);
							}
						}
					}
				}
			}
			liveObj->polyMode_34c = POLY_LOW;
		}
		else {
			if (PVar2 == POLY_LOW) {
				cont = LiveObject_GetContainer(liveObj);
				res::Container_GetPosition(cont,NULL,&vector);
				fVar5 = (liveInfo->vector_10).x - vector.x;
				fVar1 = (liveInfo->vector_10).y - vector.y;
				fVar4 = (liveInfo->vector_10).z - vector.z;
				fVar4 = SQRT(fVar4 * fVar4 + fVar1 * fVar1 + fVar5 * fVar5);
				fVar1 = (liveInfo->point_8).y;
				if ((ushort)((ushort)(fVar4 < fVar1) << 8 | (ushort)(fVar4 == fVar1) << 0xe) != 0) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_SwapPolyHigh(liveObj->miniFigure,TRUE);
						liveObj->polyMode_34c = POLY_HIGH;
						return 0;
					}
					if (OVar3 != OBJECT_ROCKMONSTER) {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_SwapPolyHigh(liveObj->vehicle,1);
						}
						liveObj->polyMode_34c = POLY_HIGH;
						return 0;
					}
					res::Creature_SwapPolyHigh(liveObj->rockMonster,TRUE);
					liveObj->polyMode_34c = POLY_HIGH;
					return 0;
				}
				fVar1 = (liveInfo->point_8).x;
				if ((ushort)((ushort)(fVar4 < fVar1) << 8 | (ushort)(fVar4 == fVar1) << 0xe) != 0) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_SwapPolyMedium(liveObj->miniFigure,TRUE);
						liveObj->polyMode_34c = POLY_MEDIUM;
						return 0;
					}
					if (OVar3 != OBJECT_ROCKMONSTER) {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_SwapPolyMedium(liveObj->vehicle,1);
						}
						liveObj->polyMode_34c = POLY_MEDIUM;
						return 0;
					}
					res::Creature_SwapPolyMedium(liveObj->rockMonster,TRUE);
					liveObj->polyMode_34c = POLY_MEDIUM;
					return 0;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(LiveObject *liveObj)
{
	if ((liveObj->flags1 &
			(LIVEOBJ1_LIFTING|LIVEOBJ1_TURNING|LIVEOBJ1_UNK_8|LIVEOBJ1_UNK_10|LIVEOBJ1_REINFORCING|
			 LIVEOBJ1_TURNRIGHT|LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_200|LIVEOBJ1_UNK_1000|LIVEOBJ1_UNK_2000|
			 LIVEOBJ1_CLEARING|LIVEOBJ1_PLACING|LIVEOBJ1_UNK_100000|LIVEOBJ1_UNK_200000|
			 LIVEOBJ1_UNK_400000|LIVEOBJ1_UNK_10000000)) != LIVEOBJ1_NONE) {
		return TRUE;
	}
	return (uint)((liveObj->flags2 &
								(LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_200|LIVEOBJ2_UNK_400000|
								 LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000)) != LIVEOBJ2_NONE);
}



void __cdecl lego::game::LiveObject_FUN_0043bde0(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	uint uVar2;
	uint uVar3;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_PROCESSORE) == STATS1_NONE) {
			uVar3 = liveObj->numCarriedObjects;
		}
		else {
			uVar3 = liveObj->field_328;
			uVar2 = stats::StatsObject_GetMaxCarry(liveObj);
			if (uVar2 <= uVar3) {
				uVar3 = stats::StatsObject_GetMaxCarry(liveObj);
			}
		}
		if (((liveObj->numCarriedObjects < uVar3) ||
				((liveObj->flags1 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE)) ||
			 ((liveObj->flags3 & LIVEOBJ3_UNK_1000000) != LIVEOBJ3_NONE)) {
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_1000000;
		}
		else {
			OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
			if (((OVar1 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
				 (OVar1 = stats::StatsObject_GetStatsFlags1(liveObj),
				 (OVar1 & STATS1_PROCESSORE) != STATS1_NONE)) {
				LiveObject_TryDeposit_FUN_0043a5c0(liveObj,NULL);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043be80(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		pLVar1 = liveObj->carriedObjects[0];
		if ((pLVar1 != NULL) && (pLVar1->objType == OBJECT_POWERCRYSTAL)) {
			liveObj->carriedObjects[0] = NULL;
			liveObj->numCarriedObjects = 0;
			pLVar1->carryingThisObject = NULL;
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
			pLVar1->health = -1.0;
		}
		if (liveObj->stealTableptr_348 != NULL) {
			Level_AddToField9c(*liveObj->stealTableptr_348);
		}
		liveObj->health = -1.0;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
	}
	return;
}



void __cdecl lego::game::LiveObject_TeleportUp(LiveObject *liveObj)
{
	LiveFlags1 *pLVar1;
	LiveObject *pLVar2;
	LiveFlags3 LVar3;
	ObjectType OVar4;
	char *actname;
	ObjectStatsFlags1 OVar5;
	ObjectStatsFlags2 OVar6;
	Container *pCVar7;
	ObjectStatsFlags3 OVar8;
	int iVar9;
	float10 fVar10;
	InfoType infoType;
	float x;
	float y;
	float z;
	int local_10;
	int local_c;
	Point2I local_8;
	
	if (liveObj->objType != OBJECT_BUILDING) {
		if ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) != LIVEOBJ2_NONE) {
			return;
		}
		if ((liveObj->flags1 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
			return;
		}
	}
	if ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe) == 0)
	{
		return;
	}
	OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((((OVar5 & (STATS1_SMALLTELEPORTER|STATS1_BIGTELEPORTER|STATS1_WATERTELEPORTER|
								 STATS1_MANTELEPORTER)) != STATS1_NONE) &&
			(pLVar2 = liveObj->object_3cc, pLVar2 != NULL)) &&
		 ((pLVar2->flags1 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE)) {
		pLVar2->health = -1.0;
		pLVar1 = &liveObj->object_3cc->flags1;
		*pLVar1 = *pLVar1 & ~LIVEOBJ1_UNK_200000;
		LiveObject_FUN_00438720(liveObj);
		LiveObject_SetActivityUnk(liveObj->object_3cc,ACTIVITY_STAND,TRUE);
		LiveObject_Container_ActivityUpdate_Check(liveObj->object_3cc);
	}
	LVar3 = liveObj->flags3;
	if ((LVar3 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
		if (liveObj->drivenObject != NULL) {
			front::Interface_ChangeMenu_IfPrimarySelectedVehicle_IsLiveObject(liveObj);
			liveObj->drivenObject->flags2 = liveObj->drivenObject->flags2 & ~LIVEOBJ2_DRIVING;
			liveObj->drivenObject->drivenObject = NULL;
			liveObj->drivenObject = NULL;
		}
		if ((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_8) != 0)) {
			ObjectRecall_StoreMiniFigure(liveObj);
		}
		if (liveObj->objType == OBJECT_VEHICLE) {
			res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,0);
		}
		LiveObject_FUN_0044b0a0(liveObj);
		if (liveObj->objType == OBJECT_BOULDER) {
			LiveObject_DestroyBoulder_AndCreateExplode(liveObj);
			return;
		}
		if (liveObj->objType == OBJECT_BUILDING) {
			LiveObject_BuildingDestroy(liveObj);
			return;
		}
		LiveObject_Remove(liveObj);
		return;
	}
	OVar4 = liveObj->objType;
	if (OVar4 == OBJECT_ROCKMONSTER) {
		OVar6 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar6 & STATS2_SPLITONZEROHEALTH) == STATS2_NONE) {
			OVar6 = stats::StatsObject_GetStatsFlags2(liveObj);
			if ((OVar6 & STATS2_USEHOLES) == STATS2_NONE) {
				return;
			}
			LiveObject_FUN_00441df0(liveObj,FALSE,TRUE);
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_20000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,FALSE);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			return;
		}
		if ((liveObj->flags1 & LIVEOBJ1_UNK_100000) != LIVEOBJ1_NONE) {
			return;
		}
		LiveObject_UnkActivityCrumble_FUN_004424d0(liveObj);
		return;
	}
	if (((OVar4 != OBJECT_MINIFIGURE) && (OVar4 != OBJECT_VEHICLE)) && (OVar4 != OBJECT_ELECTRICFENCE)
		 ) {
		if (OVar4 != OBJECT_BUILDING) {
LAB_0043c168:
			if (OVar4 != OBJECT_POWERCRYSTAL) {
				return;
			}
			liveObj->flags3 = LVar3 | LIVEOBJ3_UNK_800000;
			return;
		}
		if (((*(byte *)&liveObj->teleporter_field_390 & 4) == 0) &&
			 ((*(byte *)&liveObj->flags4 & 8) == 0)) {
			if (false) goto LAB_0043c168;
			if ((liveObj->flags2 & LIVEOBJ2_UNK_100000) != LIVEOBJ2_NONE) {
				return;
			}
			liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100000;
			LiveObject_Building_Remove_FUN_00409c80(liveObj);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_EXPLODE,0);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			ai::AITask_LiveObject_FUN_00403490(liveObj);
			goto LAB_0043c4a7;
		}
	}
	if ((LVar3 & LIVEOBJ3_UNK_40000) == LIVEOBJ3_NONE) {
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_400000) != LIVEOBJ1_NONE) {
		return;
	}
	actname = liveObj->aitaskName1;
	pCVar7 = LiveObject_GetContainer(liveObj);
	if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_8) != 0) {
		LiveObject_FUN_0044b0a0(liveObj);
	}
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_Building_Remove_FUN_00409c80(liveObj);
	}
	if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_80) != 0) {
		pLVar2 = liveObj->object_2fc;
		if (pLVar2 != NULL) {
			pLVar2->flags4 = pLVar2->flags4 & ~LIVEOBJ4_UNK_80;
		}
		liveObj->object_2fc = NULL;
	}
	if (liveObj->drivenObject != NULL) {
		LiveObject_GetBlockPos(liveObj,&local_10,&local_c);
		OVar8 = stats::StatsObject_GetStatsFlags3(liveObj);
		if (((((OVar8 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				(liveObj->carriedObjects[0] != NULL)) &&
			 (iVar9 = LiveObject_Routing_GetCrossTerrainType
													(liveObj->carriedObjects[0],local_10,local_c,local_10,local_c,1),
			 iVar9 == 0)) {
			liveObj->carriedObjects[0]->health = -1.0;
		}
		OVar5 = stats::StatsObject_GetStatsFlags1(liveObj);
		if (((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
			 (iVar9 = LiveObject_Routing_GetCrossTerrainType
													(liveObj->drivenObject,local_10,local_c,local_10,local_c,1), iVar9 != 0))
		{
			front::Interface_ChangeMenu_IfPrimarySelectedVehicle_IsLiveObject(liveObj);
			liveObj->drivenObject->flags2 = liveObj->drivenObject->flags2 & ~LIVEOBJ2_DRIVING;
			if (liveObj->drivenObject->objType == OBJECT_MINIFIGURE) {
				res::Creature_SetActivity_AndRemoveCarryCameraFrames
									(liveObj->drivenObject->miniFigure,globs::liveGlobs.Activities_TABLE[0],0.0);
			}
			liveObj->drivenObject->drivenObject = NULL;
			liveObj->drivenObject = NULL;
		}
		else {
			liveObj->drivenObject->health = -1.0;
		}
	}
	if (liveObj->objType == OBJECT_ELECTRICFENCE) {
		ElectricFence_LiveObject_Destroy(liveObj);
	}
	LiveObject_GetBlockPos(liveObj,&local_8.x,&local_8.y);
	OVar4 = liveObj->objType;
	if (((OVar4 == OBJECT_MINIFIGURE) || (OVar4 == OBJECT_VEHICLE)) || (OVar4 == OBJECT_BUILDING)) {
		front::Info_Send(INFO_GENERICDEATH,NULL,NULL,&local_8);
	}
	OVar4 = liveObj->objType;
	if (OVar4 == OBJECT_MINIFIGURE) {
		infoType = INFO_LEGOMANDEATH;
LAB_0043c382:
		front::Info_Send(infoType,NULL,NULL,&local_8);
	}
	else {
		if (OVar4 == OBJECT_VEHICLE) {
			infoType = INFO_VEHICLEDEATH;
			goto LAB_0043c382;
		}
		if (OVar4 == OBJECT_BUILDING) {
			infoType = INFO_BUILDINGDEATH;
			goto LAB_0043c382;
		}
	}
	if ((*(byte *)&liveObj->flags2 & 2) == 0) {
		LiveObject_FUN_00441df0(liveObj,FALSE,TRUE);
		res::Container_SetActivity(pCVar7,actname);
		liveObj->aitaskName2 = liveObj->aitaskName1;
	}
	else {
		LiveObject_FUN_00441df0(liveObj,TRUE,TRUE);
	}
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_400000;
	pCVar7 = res::Container_Clone(globs::legoGlobs.contMiniTeleportUp);
	liveObj->resData_2e4 = pCVar7;
	res::Container_SetAnimationTime(pCVar7,0.0);
	res::Container_Hide(liveObj->resData_2e4,FALSE);
	z = 0.0;
	y = 0.0;
	x = 0.0;
	pCVar7 = LiveObject_GetContainer(liveObj);
	res::Container_SetPosition(liveObj->resData_2e4,pCVar7,x,y,z);
	res::Container_SetOrientation(liveObj->resData_2e4,NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
	if (liveObj->objType == OBJECT_BUILDING) {
		fVar10 = stats::StatsObject_GetCollRadius(liveObj);
		if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 | (ushort)(fVar10 == (float10)0.0) << 0xe) !=
				0) {
			fVar10 = (float10)4.0;
		}
		if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 | (ushort)(fVar10 == (float10)0.0) << 0xe) ==
				0) {
			res::Container_AddScale
								(liveObj->resData_2e4,D3DRMCOMBINE_BEFORE,(float)(fVar10 * (float10)0.25),1.0,
								 (float)(fVar10 * (float10)0.25));
		}
	}
LAB_0043c4a7:
	Message_PTL_Deselect_LiveObject(liveObj);
	Message_LiveObject_FUN_00452770(liveObj);
	return;
}



BOOL __cdecl
lego::game::Object_DoOxygenCheck_FUN_0043c4c0
					(ObjectType objType1,int objIndex1,ObjectType objType2,int objIndex2)
{
	int objIndex;
	float10 fVar1;
	float10 fVar2;
	
	objIndex = objIndex1;
	fVar1 = stats::Stats_GetOxygenCoef(objType1,objIndex1);
	if (fVar1 != (float10)0.0) {
		objIndex1 = 0;
		Search_LiveObjects_SkipIgnoreMes(LiveObject_OxygenCallback_FUN_0043c540,&objIndex1);
		fVar1 = stats::Stats_GetOxygenCoef(objType2,objIndex2);
		fVar2 = stats::Stats_GetOxygenCoef(objType1,objIndex);
		fVar1 = fVar2 + (float10)(float)fVar1 + (float10)(float)objIndex1;
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) != 0)
		{
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_OxygenCallback_FUN_0043c540(LiveObject *liveObj,float *param_2)
{
	BOOL BVar1;
	float10 fVar2;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 (BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj,0), BVar1 == 0)) {
		return 0;
	}
	fVar2 = stats::StatsObject_GetOxygenCoef(liveObj);
	*param_2 = (float)(fVar2 + (float10)*param_2);
	return 0;
}



void __cdecl lego::game::LiveManager_UnkRadar_FUN_0043c570(float elapsedGame,BOOL isRadarMapView)
{
	globs::liveGlobs.radarElapsed_67c = elapsedGame + globs::liveGlobs.radarElapsed_67c;
	if ((ushort)((ushort)(globs::liveGlobs.radarElapsed_67c < 25.0) << 8 |
							(ushort)(globs::liveGlobs.radarElapsed_67c == 25.0) << 0xe) == 0) {
		globs::liveGlobs.radarElapsed_67c = 0.0;
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_0043c5b0,&isRadarMapView);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_0043c5b0(LiveObject *liveObj,BOOL *pIsRadarMapView)
{
	int surveyRadius;
	BOOL BVar1;
	SurfaceMap *surfMap;
	RadarMap *radarMap;
	float10 fVar2;
	Point2F *pPVar3;
	float fVar4;
	float fVar5;
	Point2I blockPos;
	Point2F position;
	
	fVar4 = globs::liveGlobs.radarElapsed_67c * 0.04;
	if (((*(byte *)&liveObj->flags5 & LIVEOBJ5_ABILITY_SCANNER) != 0) &&
		 (surveyRadius = stats::StatsObject_GetSurveyRadius(liveObj), surveyRadius != 0)) {
		blockPos.x = surveyRadius;
		if ((liveObj->objType == OBJECT_BUILDING) &&
			 (BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj,FALSE), BVar1 == 0)) {
			return 0;
		}
		if (globs::liveGlobs.radarElapsed_67c == 0.0) {
			LiveObject_GetBlockPos(liveObj,&blockPos.x,&blockPos.y);
			Level_Block_UpdateSurveyRadius_FUN_00434f40(&blockPos,surveyRadius);
			return 0;
		}
						// Radar map is in-view, update rendering right now?
		if (*pIsRadarMapView != FALSE) {
			LiveObject_GetPosition(liveObj,&position.x,&position.y);
			fVar5 = 1.0 - fVar4;
			surfMap = lrr::Lego_GetMap();
			fVar2 = Map3D_GetBlockSize(surfMap);
			pPVar3 = &position;
			fVar4 = (float)(fVar2 * (float10)fVar4 * (float10)blockPos.x);
			radarMap = lrr::Lego_GetRadarMap();
			RadarMap_DrawDotCircle_FUN_0045ddc0(radarMap,pPVar3,fVar4,fVar5);
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043c6a0(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	BOOL BVar2;
	
	if ((((liveObj != NULL) && (liveObj->objType == OBJECT_MINIFIGURE)) &&
			(pAVar1 = liveObj->aitask_2f0, pAVar1 != NULL)) &&
		 (pAVar1->taskType == AITASK_ATTACKROCKMONSTER)) {
		BVar2 = LiveObject_FUN_00472340(liveObj,&pAVar1->object_10->objType);
		if (BVar2 != 0) {
			BVar2 = LiveObject_DoCallbacksSearch_FUN_00471b90(liveObj,liveObj->aitask_2f0->object_10);
			if (BVar2 == 0) {
				return TRUE;
			}
		}
	}
	return 0;
}



uint __cdecl lego::game::LiveObject_GetEquippedBeam(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_LASER);
	if (BVar1 != 0) {
		return 1;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_PUSHERGUN);
	if (BVar1 != 0) {
		return 2;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_FREEZERGUN);
	return -(uint)(BVar1 != 0) & 3;
}



BOOL __cdecl
lego::game::LiveObject_FUN_0043c750(LiveObject *liveObj,LiveObject *object2FC,int param_3)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_CheckCondition_AndIsPowered(object2FC,TRUE);
	if ((BVar1 != 0) && (param_3 != 0)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_Proc_FUN_0043c780(LiveObject *liveObj)
{
	uint uVar1;
	BOOL BVar2;
	
	if (liveObj->object_2fc != NULL) {
		uVar1 = LiveObject_GetEquippedBeam(liveObj);
		BVar2 = LiveObject_FUN_0043c750(liveObj,liveObj->object_2fc,uVar1);
		if (BVar2 != 0) {
			LiveObject_Proc_FUN_00442190(liveObj,liveObj->object_2fc,uVar1);
		}
	}
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000000;
	ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_ATTACKROCKMONSTER,NULL,1);
	return;
}



void __cdecl lego::game::LiveObject_Proc_FUN_0043c7f0(LiveObject *liveObj)
{
	if ((((liveObj != NULL) && (liveObj->objType == OBJECT_MINIFIGURE)) &&
			(liveObj->aitask_2f0 != NULL)) && (liveObj->aitask_2f0->taskType == AITASK_ATTACKROCKMONSTER))
	{
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4000000;
		LiveObject_Proc_FUN_0043c780(liveObj);
	}
	return;
}



void __cdecl lego::game::LiveObject_UpdatePowerConsumption(LiveObject *liveObj)
{
	int iVar1;
	ObjectStatsFlags2 OVar2;
	BOOL BVar3;
	Point2I blockPos;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)) {
		iVar1 = stats::StatsObject_GetCrystalDrain(liveObj);
		LiveObject_GetBlockPos(liveObj,&blockPos.x,&blockPos.y);
		OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_GENERATEPOWER) == STATS2_NONE) {
			OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_SELFPOWERED) == STATS2_NONE) {
				BVar3 = Construction_Level_Blocks_UnkPowerCrystalProc_FUN_00409380(&blockPos,iVar1);
				if (BVar3 == 0) {
					liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_HASPOWER;
					front::Bubble_LiveObject_FUN_00407340(liveObj);
					return;
				}
			}
		}
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_HASPOWER;
		OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_GENERATEPOWER) != STATS2_NONE) {
			BVar3 = LiveObject_CheckCondition_AndIsPowered(liveObj,FALSE);
			if (BVar3 != 0) {
				iVar1 = Level_GetCrystalCount(TRUE);
				if (iVar1 != 0) {
					Construction_Level_Block_FUN_004092e0(&blockPos);
				}
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_CheckCanSteal(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	uint uVar3;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_CANSTEAL) != STATS1_NONE) {
		iVar2 = stats::StatsObject_GetCapacity(liveObj);
		if (((iVar2 != 0) && (liveObj->stealTableptr_348 != NULL)) &&
			 (uVar3 = stats::StatsObject_GetCapacity(liveObj), uVar3 <= (uint)*liveObj->stealTableptr_348)
			 ) {
			return 0;
		}
		if ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043c970(LiveObject *liveObj,float elapsed)
{
	float fVar1;
	float fVar2;
	ObjectType OVar3;
	float fVar4;
	float10 fVar5;
	float10 fVar6;
	
	fVar4 = elapsed + liveObj->elapsedTime2;
	fVar1 = liveObj->elapsedTime2;
	fVar2 = liveObj->elapsedTime1;
	liveObj->elapsedTime2 = fVar4;
	OVar3 = liveObj->objType;
	liveObj->elapsedTime1 = elapsed + liveObj->elapsedTime1;
	liveObj->activityElapsedTime = elapsed + liveObj->activityElapsedTime;
	if (OVar3 == OBJECT_MINIFIGURE) {
		fVar5 = lrr::Lego_GetObjectUpgradeTime(OBJECT_MINIFIGURE);
		if (fVar5 != (float10)0.0) {
			fVar5 = lrr::Lego_GetObjectUpgradeTime(liveObj->objType);
			if ((ushort)((ushort)(fVar5 < (float10)liveObj->elapsedTime2) << 8 |
									(ushort)(fVar5 == (float10)liveObj->elapsedTime2) << 0xe) != 0) {
				fVar6 = lrr::Lego_GetObjectUpgradeTime(liveObj->objType);
				fVar5 = (float10)fVar1;
				if ((ushort)((ushort)(fVar6 < fVar5) << 8 | (ushort)(fVar6 == fVar5) << 0xe) == 0) {
					front::Info_Send(INFO_CANUPGRADEMINIFIGURE,NULL,liveObj,NULL);
				}
			}
		}
		fVar5 = lrr::Lego_GetTrainTime();
		if (fVar5 != (float10)0.0) {
			fVar5 = lrr::Lego_GetTrainTime();
			if ((ushort)((ushort)(fVar5 < (float10)liveObj->elapsedTime1) << 8 |
									(ushort)(fVar5 == (float10)liveObj->elapsedTime1) << 0xe) != 0) {
				fVar5 = lrr::Lego_GetTrainTime();
				if ((ushort)((ushort)(fVar5 < (float10)fVar2) << 8 |
										(ushort)(fVar5 == (float10)fVar2) << 0xe) == 0) {
					front::Info_Send(INFO_CANTRAINMINIFIGURE,NULL,liveObj,NULL);
					return;
				}
			}
		}
	}
	else {
		if (((((OVar3 == OBJECT_POWERCRYSTAL) || (OVar3 == OBJECT_ORE)) || (OVar3 == OBJECT_BARRIER)) ||
				((OVar3 == OBJECT_ELECTRICFENCE &&
				 ((liveObj->flags2 & LIVEOBJ2_UNK_2000000) == LIVEOBJ2_NONE)))) &&
			 ((750.0 <= fVar4 && (fVar1 < 750.0)))) {
			liveObj->elapsedTime2 = 0.0;
			ai::AITask_LiveObject_FUN_004025f0(liveObj);
		}
	}
	return;
}



BOOL __cdecl lego::game::Game_LiveObjectLargeCallback(LiveObject *in_liveObj,float *lpElapsed)
{
	LiveFlags3 *pLVar1;
	LiveFlags4 *pLVar2;
	float elapsed;
	RoutingBlock *pRVar3;
	LiveFlags2 LVar4;
	ObjectType OVar5;
	ushort uVar6;
	ushort uVar7;
	bool bVar8;
	LiveObject *liveObj;
	short sVar9;
	Container *pCVar10;
	SFXType SVar11;
	BOOL BVar12;
	LiveFlags4 LVar13;
	LevelData *pLVar14;
	ObjectStatsFlags1 OVar15;
	LiveFlags3 LVar16;
	Container *pCVar17;
	SurfaceType SVar18;
	int iVar19;
	SurfaceMap *pSVar20;
	ObjectStatsFlags2 OVar21;
	uint uVar22;
	BlockConstruction *pBVar23;
	LiveFlags1 LVar24;
	uint uVar25;
	float10 fVar26;
	longlong lVar27;
	float fVar28;
	float fVar29;
	LiveObject *pLVar30;
	BOOL BVar31;
	float fVar32;
	ActivityType AVar33;
	Vector3F *pVVar34;
	undefined4 uVar35;
	float fVar36;
	float upz;
	float *out_by;
	float local_34;
	Vector3F local_30;
	float local_24;
	Vector3F local_20;
	int local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	elapsed = *lpElapsed;
	bVar8 = true;
	PTRLiveObject_00557090 = in_liveObj;
	LiveObject_FUN_0043c970(in_liveObj,elapsed);
	if ((liveObj->flags4 & LIVEOBJ4_UNK_200000) != LIVEOBJ4_NONE) {
		liveObj->aitaskName1 = NULL;
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_200000;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_368 < 0.0) << 8 |
								(ushort)(liveObj->float_368 == 0.0) << 0xe) != 0) {
			LiveObject_FUN_0044c3d0(liveObj);
		}
		liveObj->float_368 = liveObj->float_368 - elapsed;
		return 0;
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_40000) != LIVEOBJ4_NONE) {
		pCVar10 = LiveObject_GetContainer(liveObj);
		if ((pCVar10 != NULL) &&
			 (SVar11 = stats::StatsObject_GetEngineSound(liveObj), SVar11 != SFX_NULL)) {
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(pCVar10,SVar11,1,1,NULL);
			liveObj->soundHandle_354 = SVar11;
			liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80000;
		}
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40000;
	}
	if ((((byte)globs::legoGlobs.flags2 & GAME2_CALLTOARMS) == 0) ||
		 (BVar12 = LiveObject_MiniFigureHasBeamEquipped2(liveObj), BVar12 == 0)) {
		front::Bubble_LiveObject_MiniFigure_FUN_00407440(liveObj,0);
		LVar13 = liveObj->flags4 & ~LIVEOBJ4_CALLTOARMS_20;
	}
	else {
						// Update MiniFigure with Call-to-arms behavior?
		front::Bubble_LiveObject_MiniFIgure_FUN_004073e0(liveObj);
		LVar13 = liveObj->flags4 | LIVEOBJ4_CALLTOARMS_20;
	}
	liveObj->flags4 = LVar13;
	if ((((liveObj->objType == OBJECT_VEHICLE) &&
			 ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE)) && (liveObj->object_2fc == NULL)) &&
		 (liveObj->drivenObject == NULL)) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		LiveObject_WaterVehicle_Register(liveObj);
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		pLVar14 = lrr::Lego_GetLevel();
		LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
		if ((*(byte *)&pLVar14->blocks[(pLVar14->dimensions).width * (int)local_20.y + (int)local_20.x].
									 flags2 & BLOCK2_EMERGE_TRIGGER) != 0) {
			Level_UnkEmerge_FUN_0042c260(pLVar14,(Point2I *)&local_20,NULL);
		}
	}
	LiveObject_FUN_0043bde0(liveObj);
	if (((liveObj->objType == OBJECT_MINIFIGURE) &&
			((*(byte *)&liveObj->flags2 & LIVEOBJ2_DRIVING) != 0)) &&
		 ((pLVar30 = liveObj->drivenObject, pLVar30 != NULL && (pLVar30->objType == OBJECT_VEHICLE)))) {
		fVar26 = res::Vehicle_GetAnimationTime(pLVar30->vehicle);
		res::Creature_DoCallbacks(liveObj->miniFigure,(float)fVar26);
	}
	else {
		fVar26 = LiveObject_FUN_00447df0(liveObj,elapsed);
		local_10 = (float)fVar26;
	}
	OVar15 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar15 & (STATS1_SMALLTELEPORTER|STATS1_BIGTELEPORTER|STATS1_WATERTELEPORTER|
								STATS1_MANTELEPORTER)) != STATS1_NONE) {
		LiveObject_FUN_0043f450(liveObj);
	}
	if ((liveObj->objType != OBJECT_BUILDING) ||
		 (BVar12 = LiveObject_CheckCondition_AndIsPowered(liveObj,0), BVar12 != 0)) {
		LiveObject_ConsumeOxygen(liveObj,elapsed);
	}
	if (((byte)globs::liveGlobs.flags & 4) == 0) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_40000000;
	}
	else {
		LiveObject_UpdatePowerConsumption(liveObj);
	}
	LVar24 = liveObj->flags1;
	if ((LVar24 & LIVEOBJ1_UNK_400000) != LIVEOBJ1_NONE) {
		if (liveObj->resData_2e4 == NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
			return 0;
		}
		pCVar10 = LiveObject_GetContainer(liveObj);
		res::Container_AddTranslation(pCVar10,D3DRMCOMBINE_AFTER,0.0,0.0,-elapsed);
		fVar26 = res::Container_MoveAnimation(liveObj->resData_2e4,elapsed);
		if ((ushort)((ushort)(fVar26 < (float10)0.0) << 8 | (ushort)(fVar26 == (float10)0.0) << 0xe) !=
				0) {
			return 0;
		}
		liveObj->health = -1.0;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_400000;
		res::Container_Remove(liveObj->resData_2e4);
		return 0;
	}
	if ((LVar24 & LIVEOBJ1_UNK_8) == LIVEOBJ1_NONE) goto LAB_0043d12f;
	if ((LVar24 & LIVEOBJ1_UNK_10) != LIVEOBJ1_NONE) {
		pCVar10 = LiveObject_GetContainer(liveObj);
		pVVar34 = NULL;
		BVar31 = 1;
		BVar12 = 1;
		SVar11 = stats::StatsObject_GetDrillSoundType(liveObj,0);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(pCVar10,SVar11,BVar12,BVar31,pVVar34);
		liveObj->soundHandle_350 = SVar11;
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_100000;
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10;
	}
	pRVar3 = liveObj->routeptr_24;
	if (pRVar3 == NULL) {
LAB_0043d0aa:
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_8;
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000000;
		pCVar10 = LiveObject_GetContainer(liveObj);
		iVar19 = liveObj->soundHandle_350;
LAB_0043d0dd:
		snd::SFX_Sample_Sound3D_StopSound(iVar19);
		pVVar34 = NULL;
		BVar31 = 1;
		BVar12 = 0;
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_100000;
		SVar11 = stats::StatsObject_GetDrillSoundType(liveObj,1);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(pCVar10,SVar11,BVar12,BVar31,pVVar34);
		util::logf_removed(NULL,0,0);
		LVar16 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
LAB_0043d129:
		liveObj->flags3 = LVar16;
	}
	else {
		fVar36 = (float)pRVar3[liveObj->routingBlocksCurrent].blockPos.x;
		fVar28 = (float)pRVar3[liveObj->routingBlocksCurrent].blockPos.y;
		BVar12 = 1;
		LVar16 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = LiveObject_BlockCheck_FUN_004326a0(liveObj,(uint)lVar27,uVar22,LVar16,BVar12);
		if (BVar12 == 0) goto LAB_0043d0aa;
		BVar12 = LiveObject_GetDrillNullPosition(liveObj,&local_30.x,&local_34);
		if (BVar12 == 0) goto LAB_0043d12f;
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			uVar35 = 0;
			pCVar10 = lrr::Lego_GetCurrentCamera_Container();
			pCVar17 = res::Creature_GetDrillNull(liveObj->miniFigure);
			util::logf_removed((char *)pCVar17,pCVar10,uVar35);
		}
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		iVar19 = (int)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		SVar18 = lrr::Lego_GetBlockTerrain((int)lVar27,iVar19);
		fVar26 = stats::StatsObject_GetDrillTimeType(liveObj,SVar18);
		in_liveObj = (LiveObject *)(float)fVar26;
		OVar15 = stats::StatsObject_GetStatsFlags1(liveObj);
		if (((OVar15 & STATS1_SINGLEWIDTHDIG) != STATS1_NONE) &&
			 ((liveObj->flags3 & LIVEOBJ3_UNK_2000000) != LIVEOBJ3_NONE)) {
			in_liveObj = (LiveObject *)((float)in_liveObj * 0.5);
		}
		pLVar30 = in_liveObj;
		fVar29 = elapsed;
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = Level_Block_GetUnkField14Test((uint)lVar27,uVar22,(float)pLVar30,fVar29);
		if (BVar12 == 0) {
			BVar12 = Lego_WorldToBlockPos_NoZ(local_30.x,local_34,(int *)&local_24,(int *)&local_20);
			if (((BVar12 == 0) || (local_24 != fVar36)) || (local_20.x != fVar28)) goto LAB_0043d12f;
			LVar16 = liveObj->flags3 | LIVEOBJ3_UNK_4000;
			goto LAB_0043d129;
		}
		BVar12 = 1;
		LVar16 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = LiveObject_BlockCheck_FUN_004326a0(liveObj,(uint)lVar27,uVar22,LVar16,BVar12);
		if (BVar12 != 0) {
			lVar27 = __ftol((float10)(liveObj->point_2f4).x);
			fVar29 = (float)lVar27;
			local_c.x = fVar29;
			lVar27 = __ftol((float10)(liveObj->point_2f4).y);
			fVar32 = (float)lVar27;
			local_c.y = fVar32;
			if ((liveObj->flags3 & LIVEOBJ3_UNK_2000000) == LIVEOBJ3_NONE) {
				BVar12 = 0;
				pLVar14 = lrr::Lego_GetLevel();
				iVar19 = Level_DestroyWall(pLVar14,(uint)fVar36,(uint)fVar28,BVar12);
			}
			else {
				pLVar14 = lrr::Lego_GetLevel();
				iVar19 = Level_DestroyWallConnection(pLVar14,(uint)fVar29,(uint)fVar32);
			}
			if (iVar19 == 0) goto LAB_0043d12f;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DIG,NULL,1);
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_8;
			Level_Block_SetBusy((Point2I *)&local_c,FALSE);
			if (liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 == 1) {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0;
			}
			pCVar10 = LiveObject_GetContainer(liveObj);
			iVar19 = liveObj->soundHandle_350;
			goto LAB_0043d0dd;
		}
	}
LAB_0043d12f:
	if ((liveObj->flags2 & LIVEOBJ2_UNK_4000) != LIVEOBJ2_NONE) {
		LiveObject_FUN_0044c470(liveObj,elapsed);
	}
	if ((((liveObj->flags2 & LIVEOBJ2_UNK_40000000) != LIVEOBJ2_NONE) &&
			((ushort)((ushort)(elapsed < 0.0) << 8 | (ushort)(elapsed == 0.0) << 0xe) == 0)) &&
		 (pCVar10 = LiveObject_GetContainer(liveObj), pCVar10 != NULL)) {
		res::Container_GetOrientation(pCVar10,NULL,&local_20,&local_c);
		local_c.x = local_c.x * 10.0;
		local_c.y = local_c.y * 10.0;
		local_c.z = local_c.z * 10.0;
		math::Maths_Vector3DRandom(&local_30);
		local_c.y = globs::s_LiveObjectLargeCallback_FLOAT_004a58b0 * 0.1 * (local_30.y + local_c.y);
		local_c.x = globs::s_LiveObjectLargeCallback_FLOAT_004a58b0 * 0.1 * (local_30.x + local_c.x);
		local_c.z = -1.0;
		res::Container_SetOrientation
							(pCVar10,NULL,local_20.x,local_20.y,local_20.z,local_c.x,local_c.y,-1.0);
		globs::s_LiveObjectLargeCallback_FLOAT_004a58b0 =
				 globs::s_LiveObjectLargeCallback_FLOAT_004a58b0 - elapsed * 0.16;
		if (globs::s_LiveObjectLargeCallback_FLOAT_004a58b0 < 0.0) {
			globs::s_LiveObjectLargeCallback_FLOAT_004a58b0 = 1.0;
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_40000000;
		}
	}
	LVar24 = liveObj->flags1;
	if ((LVar24 & LIVEOBJ1_UNK_100000) != LIVEOBJ1_NONE) {
		LiveObject_DestroyRockMonster_FUN_0044c290(liveObj);
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_4000000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_4000000;
		}
		goto LAB_0043f040;
	}
	LVar13 = liveObj->flags4;
	if ((LVar13 & LIVEOBJ4_UNK_1000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_1000 | LIVEOBJ4_UNK_2000;
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_4000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_4000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE) {
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_OPEN,0);
		goto LAB_0043f040;
	}
	LVar4 = liveObj->flags2;
	if ((LVar4 & LIVEOBJ2_UNK_4000) != LIVEOBJ2_NONE) goto LAB_0043f040;
	if ((LVar24 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) {
		uVar6 = (ushort)(liveObj->float_2d4 < 0.0) << 8;
		uVar7 = (ushort)(liveObj->float_2d4 == 0.0) << 0xe;
		if ((LVar24 & LIVEOBJ1_TURNRIGHT) != LIVEOBJ1_NONE) {
			if ((uVar6 | uVar7) == 0) {
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_AddRotation(pCVar10,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,1.570796);
				res::Container_SetAnimationTime(pCVar10,0.0);
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_TURNRIGHT;
			}
			goto LAB_0043f040;
		}
		if ((uVar6 | uVar7) != 0) goto LAB_0043f040;
		pCVar10 = LiveObject_GetContainer(liveObj);
		if ((globs::liveGlobs.Activities_TABLE[9] == liveObj->aitaskName1) ||
			 (globs::liveGlobs.Activities_TABLE[20] == liveObj->aitaskName1)) {
			fVar36 = -1.570796;
		}
		else {
			fVar36 = 1.570796;
		}
		res::Container_AddRotation(pCVar10,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,fVar36);
		LVar24 = liveObj->flags1;
		liveObj->flags1 = LVar24 & ~LIVEOBJ1_TURNING | LIVEOBJ1_MOVING;
		if (liveObj->routingBlocksTotal != 0) {
			if (((LVar24 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) &&
				 (liveObj->objType == OBJECT_MINIFIGURE)) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_RUNPANIC,0);
				goto LAB_0043f040;
			}
LAB_0043e732:
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
			goto LAB_0043f040;
		}
LAB_0043ecae:
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_20) != LIVEOBJ2_NONE) {
		LiveObject_TryDepart_FUN_004499c0(liveObj);
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
LAB_0043eb11:
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_80000000;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_10000000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			pCVar10 = LiveObject_GetContainer(liveObj);
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10000000;
			res::Container_SetOrientation
								(pCVar10,NULL,(float)liveObj->field_2c8,(float)liveObj->field_2cc,0.0,0.0,0.0,-1.0);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_400000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,1);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_400000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_8000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) goto LAB_0043f040;
		liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_8000;
		if (liveObj->object_2fc != NULL) {
			pCVar10 = LiveObject_GetDepositNull(liveObj->object_2fc);
			if (pCVar10 != NULL) {
				res::Container_GetPosition(pCVar10,NULL,&local_c);
				res::Container_GetOrientation(pCVar10,NULL,&local_20,NULL);
				fVar36 = local_c.x;
				fVar28 = local_c.y;
				pSVar20 = lrr::Lego_GetMap();
				fVar26 = Map3D_GetWorldZ(pSVar20,fVar36,fVar28);
				fVar36 = (float)fVar26;
				pCVar17 = NULL;
				fVar28 = local_c.x;
				fVar29 = local_c.y;
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetPosition(pCVar10,pCVar17,fVar28,fVar29,fVar36);
				upz = -1.0;
				fVar32 = 0.0;
				fVar29 = 0.0;
				pCVar17 = NULL;
				fVar36 = local_20.x;
				fVar28 = local_20.y;
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetOrientation(pCVar10,pCVar17,fVar36,fVar28,local_20.z,fVar29,fVar32,upz);
			}
			LiveObject_FUN_00437690(liveObj->object_2fc,0);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
			goto LAB_0043f040;
		}
		goto LAB_0043ecae;
	}
	if ((LVar4 & LIVEOBJ2_UNK_80000000) != LIVEOBJ2_NONE) {
		if (liveObj->object_2fc == NULL) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_80000000;
		}
		else {
			pCVar10 = LiveObject_GetContainer(liveObj);
			pCVar17 = LiveObject_GetContainer(liveObj->object_2fc);
			pLVar30 = liveObj->object_2fc;
			res::Container_GetPosition(pCVar17,NULL,&local_c);
			res::Container_GetOrientation(pCVar17,NULL,&local_30,&local_20);
			res::Container_SetPosition(pCVar10,NULL,local_c.x,local_c.y,local_c.z);
			res::Container_SetOrientation
								(pCVar10,NULL,local_30.x,local_30.y,local_30.z,local_20.x,local_20.y,local_20.z);
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				pLVar30->carriedObjects[pLVar30->numCarriedObjects] = liveObj;
				pLVar30->carriedObjects[pLVar30->numCarriedObjects]->carryingThisObject = pLVar30;
				pLVar30->carriedObjects[(int)(LiveObject *)pLVar30->numCarriedObjects]->carriedObjects[6] =
						 (LiveObject *)pLVar30->numCarriedObjects;
				pLVar30->flags1 = pLVar30->flags1 | LIVEOBJ1_CARRYING;
				LiveObject_FUN_00437690(pLVar30,0);
				pLVar30->numCarriedObjects = pLVar30->numCarriedObjects + 1;
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000000;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_FINDLOAD,NULL,1);
				pLVar30->flags4 = pLVar30->flags4 & ~LIVEOBJ4_UNK_10000;
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_10000000) != LIVEOBJ2_NONE) {
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_10000000,
			 (LVar24 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) {
			pVVar34 = &local_c;
			pCVar17 = NULL;
			liveObj->carriedObjects[0]->flags3 = liveObj->carriedObjects[0]->flags3 & ~LIVEOBJ3_POWEROFF;
			pCVar10 = LiveObject_GetContainer(liveObj->carriedObjects[0]);
			res::Container_GetPosition(pCVar10,pCVar17,pVVar34);
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_CRYSTALRECHARGE,0,0,&local_c);
			LiveObject_SetCrystalPoweredColor(liveObj->carriedObjects[0],1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_800000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,2);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_800000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,2);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_1000000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,3);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_1000000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,3);
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_800) != LIVEOBJ1_NONE) {
		if ((liveObj->objType == OBJECT_ROCKMONSTER) &&
			 (BVar12 = res::Creature_GetThrowNull(liveObj->rockMonster), BVar12 != 0)) {
			LiveObject_FUN_00447a40(liveObj);
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_800;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_4000) != LIVEOBJ1_NONE) {
		pLVar30 = liveObj->object_2fc;
		if ((((pLVar30 != NULL) && ((pLVar30->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) &&
				((pLVar30->flags3 & LIVEOBJ3_UNK_1000000) == LIVEOBJ3_NONE)) &&
			 (pLVar30->numCarriedObjects != pLVar30->field_328)) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_4000 | LIVEOBJ1_UNK_2000;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_2000;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DEPOSITE,liveObj,1);
			LiveObject_ProcCarriedObjects_FUN_0043f160(liveObj);
		}
		else {
			if (liveObj->object_2fc != NULL) {
				pLVar1 = &liveObj->object_2fc->flags3;
				*pLVar1 = *pLVar1 | LIVEOBJ3_UNK_1000000;
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_REST) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_REST;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			LiveObject_FUN_0043aeb0(liveObj);
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200000;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_ATTACKPATH,NULL,1);
			if ((liveObj->flags2 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE) {
				LiveObject_FUN_0043aeb0(liveObj);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_40000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			LiveObject_FUN_004477b0(liveObj);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_40000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			LiveObject_FUN_004477b0(liveObj);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_20000000) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_20000000;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
		OVar21 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((((OVar21 & STATS2_DRAINPOWER) != STATS2_NONE) &&
				(pLVar30 = liveObj->object_2fc, pLVar30 != NULL)) &&
			 ((*(byte *)&pLVar30->flags4 & LIVEOBJ4_UNK_10) == 0)) {
			BVar12 = LiveObject_CheckCondition_AndIsPowered(pLVar30,0);
			if (BVar12 != 0) {
				front::Info_Send(INFO_POWERDRAIN,NULL,liveObj->object_2fc,NULL);
				lrr::LegoGame_SetCallToArmsOn(1);
			}
			pLVar2 = &liveObj->object_2fc->flags4;
			*pLVar2 = *pLVar2 | LIVEOBJ4_UNK_10;
			LiveManager_InitFlagsToggle_AndClearNumDrained();
		}
		if (((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) &&
			 (iVar19 = LiveObject_FUN_00447880(liveObj), iVar19 != 0)) {
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000;
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			if (((liveObj->flags2 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE) &&
				 (iVar19 = LiveObject_FUN_00447880(liveObj), iVar19 != 0)) {
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,1);
			}
			if ((liveObj->flags2 & LIVEOBJ2_UNK_80000) == LIVEOBJ2_NONE) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_1000000;
				if (liveObj->object_2fc != NULL) {
					pLVar2 = &liveObj->object_2fc->flags4;
					*pLVar2 = *pLVar2 & ~LIVEOBJ4_UNK_10;
					LiveManager_InitFlagsToggle_AndClearNumDrained();
					liveObj->object_2fc = NULL;
				}
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,1);
			}
			else {
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetAnimationTime(pCVar10,liveObj->float_2d4);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			BVar12 = LiveObject_Add25EnergyAndSetHealth(liveObj);
			if (BVar12 == 0) {
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetAnimationTime(pCVar10,liveObj->float_2d4);
			}
			else {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_EATING;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_EAT,NULL,1);
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_GOTOEAT,NULL,1);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_40) != LIVEOBJ2_NONE) {
		liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_40;
		if (liveObj->aitask_2f0 != NULL) {
			MiniFigure_EquipTool(liveObj,liveObj->aitask_2f0->toolType);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_GETTOOL,NULL,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_TRAINING;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_TRAIN,NULL,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UPGRADING) == LIVEOBJ2_NONE) {
		if ((LVar24 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
			pCVar10 = LiveObject_GetContainer(liveObj);
			res::Container_ForceAnimationUpdate(pCVar10);
			if ((((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) &&
					((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				 (liveObj->carriedObjects[0] != NULL)) {
				pVVar34 = &local_c;
				pCVar17 = NULL;
				pCVar10 = LiveObject_GetContainer(liveObj->carriedObjects[0]);
				res::Container_GetPosition(pCVar10,pCVar17,pVVar34);
				OVar5 = liveObj->carriedObjects[0]->objType;
				if (OVar5 == OBJECT_ORE) {
					SVar11 = SFX_PLACEORE;
				}
				else {
					if (OVar5 == OBJECT_POWERCRYSTAL) {
						SVar11 = SFX_PLACECRYSTAL;
					}
					else {
						SVar11 = SFX_PLACE;
					}
				}
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SVar11,0,0,&local_c);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_PLACING;
				LiveObject_DropCarriedObject_FUN_0043a130(liveObj,1);
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_1000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_1000;
			}
			goto LAB_0043f040;
		}
		if (liveObj->carryingThisObject != NULL) goto LAB_0043f040;
		if (((LVar24 & LIVEOBJ1_MOVING) != LIVEOBJ1_NONE) &&
			 (BVar12 = LiveObject_FUN_0043c6a0(liveObj), BVar12 != 0)) {
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
			LiveObject_Proc_FUN_0043c7f0(liveObj);
			goto LAB_0043f040;
		}
		LVar24 = liveObj->flags1;
		if ((LVar24 & LIVEOBJ1_MOVING) != LIVEOBJ1_NONE) {
			LiveObject_LargeFlagsSwitch_FUN_00443b70(liveObj,elapsed);
			LiveObject_FUN_004443b0(liveObj,elapsed);
			LiveObject_RockMonster_FUN_0043ad70(liveObj);
			LVar4 = liveObj->flags2;
			if ((LVar4 & LIVEOBJ2_UNK_4000000) != LIVEOBJ2_NONE) {
				BVar12 = LiveObject_FUN_00472340(liveObj,&liveObj->aitask_2f0->object_10->objType);
				if ((BVar12 == 0) ||
					 (BVar12 = LiveObject_DoCallbacksSearch_FUN_00471b90
															 (liveObj,liveObj->aitask_2f0->object_10), BVar12 != 0)) {
					liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000000;
				}
				else {
					LiveObject_Proc_FUN_0043c780(liveObj);
				}
				goto LAB_0043f040;
			}
			LVar24 = liveObj->flags1;
			if ((LVar24 & LIVEOBJ1_UNK_8) != LIVEOBJ1_NONE) {
				lVar27 = __ftol((float10)(liveObj->point_2f4).x);
				local_c.x = (float)lVar27;
				lVar27 = __ftol((float10)(liveObj->point_2f4).y);
				local_c.y = (float)lVar27;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_DRILL,0);
				Level_Block_SetBusy((Point2I *)&local_c,TRUE);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_LIFTING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REVERSE,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_TRAIN,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_10000000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_RECHARGE,0);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_CLEARING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk
									(liveObj,ACTIVITY_CLEAR,(liveObj->objType != OBJECT_MINIFIGURE) - 1 & 2);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_80000000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_FLOATON,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
				if (liveObj->object_2fc != NULL) {
					LiveObject_ClearFlags4_40_AndSameForObject2FC(liveObj,liveObj->object_2fc);
				}
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_REINFORCING) != LIVEOBJ1_NONE) {
				lVar27 = __ftol((float10)(liveObj->point_2f4).x);
				local_c.x = (float)lVar27;
				lVar27 = __ftol((float10)(liveObj->point_2f4).y);
				local_c.y = (float)lVar27;
				Level_Block_SetBusy((Point2I *)&local_c,TRUE);
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REINFORCE,globs::legoGlobs.ReinforceHits);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_PLACE,0);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_UNK_20000) != LIVEOBJ1_NONE) {
				lVar27 = __ftol((float10)(liveObj->point_2f4).x);
				local_20.x = (float)lVar27;
				lVar27 = __ftol((float10)(liveObj->point_2f4).y);
				local_20.y = (float)lVar27;
				OVar21 = stats::StatsObject_GetStatsFlags2(liveObj);
				if (((OVar21 & STATS2_USEHOLES) == STATS2_NONE) &&
					 (BVar12 = Level_Block_IsWall((uint)local_20.x,(uint)local_20.y), BVar12 == 0)) {
					liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_20000;
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_20;
				}
				else {
					BVar12 = Level_Block_IsReinforced((uint)local_20.x,(uint)local_20.y);
					if (BVar12 == 0) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
					}
					else {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTERREIN,0);
						BVar12 = LiveObject_Container_ActivityUpdate_Check(liveObj);
						if (BVar12 == 0) {
							LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
							LiveObject_Container_ActivityUpdate_Check(liveObj);
						}
						OVar21 = stats::StatsObject_GetStatsFlags2(liveObj);
						if ((OVar21 & STATS2_REMOVEREINFORCEMENT) != STATS2_NONE) {
							Level_Block_RemoveReinforcement((Point2I *)&local_20);
						}
					}
				}
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REPAIR,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAMP,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) {
				if (liveObj->objType == OBJECT_MINIFIGURE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_TRAIN,100);
				}
				else {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_UPGRADE,0);
					LiveObject_SetActivityUnk(liveObj->object_2fc,ACTIVITY_UPGRADE,0);
					LiveObject_Container_ActivityUpdate_Check(liveObj->object_2fc);
					liveObj->object_2fc->flags2 = liveObj->object_2fc->flags2 | LIVEOBJ2_UPGRADING;
				}
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_EAT,0);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE) {
				if ((LVar24 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_DESPOSIT,0);
					pLVar30 = liveObj->object_2fc;
					if ((pLVar30 != NULL) &&
						 ((OVar15 = stats::StatsObject_GetStatsFlags1(pLVar30),
							(OVar15 & STATS1_PROCESSCRYSTAL) != STATS1_NONE ||
							(OVar15 = stats::StatsObject_GetStatsFlags1(pLVar30),
							(OVar15 & STATS1_PROCESSORE) != STATS1_NONE)))) {
						pLVar30 = liveObj->object_2fc;
						if (((pLVar30->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE) &&
							 (((pLVar30->flags3 & LIVEOBJ3_UNK_1000000) == LIVEOBJ3_NONE &&
								(pLVar30->numCarriedObjects != pLVar30->field_328)))) {
							pLVar30->flags3 = pLVar30->flags3 | LIVEOBJ3_UNK_1000000;
						}
						else {
							liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_2000 | LIVEOBJ1_UNK_4000;
						}
					}
					goto LAB_0043f040;
				}
				if ((LVar24 & LIVEOBJ1_UNK_800) != LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_THROW,0);
					goto LAB_0043f040;
				}
				if (((LVar24 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) ||
					 ((LVar24 & LIVEOBJ1_REST) != LIVEOBJ1_NONE)) goto LAB_0043f040;
				if ((LVar24 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
					LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
					uVar22 = Level_Block_GetRubbleLayers((Point2I *)&local_20);
					if (((uVar22 < 3) &&
							((globs::legoGlobs.level)->blocks
							 [((globs::legoGlobs.level)->dimensions).width * (int)local_20.y + (int)local_20.x].
							 terrain != TERRAIN_LAKE)) ||
						 ((liveObj->flags3 & LIVEOBJ3_CANROUTERUBBLE) == LIVEOBJ3_NONE)) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRY,0);
					}
					else {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRYRUBBLE,0);
					}
					goto LAB_0043f040;
				}
				if ((LVar24 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
					LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_CANTDO,1);
					goto LAB_0043f040;
				}
				if ((LVar24 & LIVEOBJ1_MOVING) == LIVEOBJ1_NONE) goto LAB_0043f040;
				LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
				if (((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) &&
					 (liveObj->objType == OBJECT_MINIFIGURE)) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_RUNPANIC,0);
					goto LAB_0043f040;
				}
				uVar22 = Level_Block_GetRubbleLayers((Point2I *)&local_20);
				if (((2 < uVar22) ||
						((globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * (int)local_20.y + (int)local_20.x].
						 terrain == TERRAIN_LAKE)) &&
					 ((liveObj->flags3 & LIVEOBJ3_CANROUTERUBBLE) != LIVEOBJ3_NONE)) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTERUBBLE,0);
					goto LAB_0043f040;
				}
				goto LAB_0043e732;
			}
			if ((liveObj->object_2fc == NULL) || (liveObj->object_2fc->carryingThisObject != NULL)) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_200;
				goto LAB_0043f040;
			}
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_COLLECT,0);
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				OVar5 = liveObj->object_2fc->objType;
				if (OVar5 == OBJECT_BOULDER) {
					AVar33 = ACTIVITY_GATHER;
				}
				else {
					if (OVar5 != OBJECT_POWERCRYSTAL) goto LAB_0043e4b7;
					AVar33 = ACTIVITY_EAT;
				}
				LiveObject_SetActivityUnk(liveObj,AVar33,0);
			}
LAB_0043e4b7:
			liveObj->carriedObjects[liveObj->numCarriedObjects] = liveObj->object_2fc;
			liveObj->object_2fc = NULL;
			liveObj->carriedObjects[liveObj->numCarriedObjects]->carryingThisObject = liveObj;
			liveObj->carriedObjects[(int)(LiveObject *)liveObj->numCarriedObjects]->carriedObjects[6] =
					 (LiveObject *)liveObj->numCarriedObjects;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_CARRYING;
			ai::AITask_LiveObject_SetAITaskUnk
								(liveObj,AITASK_COLLECT,liveObj->carriedObjects[liveObj->numCarriedObjects],1);
			ai::AITask_DoAnimationWait(liveObj);
			liveObj->numCarriedObjects = liveObj->numCarriedObjects + 1;
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_200000;
				if (liveObj->objType == OBJECT_VEHICLE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
					LiveObject_Container_ActivityUpdate_Check(liveObj);
				}
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				LiveObject_FUN_00438720(liveObj);
			}
			LiveObject_RockFall_FUN_00443240(liveObj,elapsed);
			pCVar10 = LiveObject_GetContainer(liveObj);
			if (pCVar10 != NULL) {
				res::Container_GetOrientation(pCVar10,NULL,&local_c,NULL);
				res::Container_SetOrientation(pCVar10,NULL,local_c.x,local_c.y,local_c.z,0.0,0.0,-1.0);
			}
			goto LAB_0043f040;
		}
		BVar12 = LiveObject_Reinforcing_FUN_00449c40(liveObj,elapsed,&local_14);
		if (BVar12 != 0) {
			if (local_14 != 0) {
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REINFORCE,NULL,1);
			}
			goto LAB_0043f040;
		}
		LVar24 = liveObj->flags1;
		if ((LVar24 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_100;
				BVar12 = LiveObject_IsRockMonsterCanGather(liveObj);
				if (BVar12 != 0) {
					lVar27 = __ftol((float10)(liveObj->point_2f4).x);
					local_c.x = (float)lVar27;
					lVar27 = __ftol((float10)(liveObj->point_2f4).y);
					local_c.y = (float)lVar27;
					Message_AddMessageAction(MESSAGE_GENERATEROCKMONSTER_COMPLETE,liveObj,0,NULL);
					Level_Block_SetBusy((Point2I *)&local_c,FALSE);
				}
			}
			goto LAB_0043f040;
		}
		LVar4 = liveObj->flags2;
		if ((LVar4 & LIVEOBJ2_UNK_100000) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_100000;
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
			pLVar30 = liveObj->object_2fc;
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_4;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_FINDDRIVER,NULL,1);
			liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_DRIVING;
			pLVar30->flags4 = pLVar30->flags4 & ~LIVEOBJ4_UNK_80;
			if (pLVar30->object_2fc != NULL) {
				pLVar2 = &pLVar30->object_2fc->flags4;
				*pLVar2 = *pLVar2 & ~LIVEOBJ4_UNK_80;
			}
			pLVar30->object_2fc = NULL;
			pLVar30->flags2 = pLVar30->flags2 & ~LIVEOBJ2_UNK_10;
			liveObj->drivenObject = pLVar30;
			pLVar30->drivenObject = liveObj;
			liveObj->object_2fc = NULL;
			front::Interface_ChangeMenu_IfVehicleMounted_IsLiveObject(liveObj->drivenObject);
			LiveObject_RockFall_FUN_00443240(liveObj,elapsed);
			pLVar30->aitaskName2 = NULL;
			LiveObject_Container_ActivityUpdate_Check(pLVar30);
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_DRIVING) != LIVEOBJ2_NONE) goto LAB_0043f040;
		if ((LVar24 & LIVEOBJ1_UNK_20000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_20000;
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_20;
				LiveObject_FUN_0043be80(liveObj);
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_200) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
				pBVar23 = Construction_BlockCheck_FUN_00408ff0((Point2I *)&local_20,NULL);
				if ((pBVar23 != NULL) && ((*(byte *)&pBVar23->flags & 2) != 0)) {
					Level_Block_SetPath((Point2I *)&local_20);
					Construction_Block_FUN_00409040((Point2I *)&local_20);
					front::Info_Send(INFO_PATHCOMPLETED,NULL,NULL,(Point2I *)&local_20);
					ai::AITask_DoAttackPath((Point2I *)&local_20);
				}
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_BUILDPATH,NULL,TRUE);
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_CLEARING) != LIVEOBJ1_NONE) {
			if (liveObj->objType == OBJECT_VEHICLE) {
				LiveObject_RockFall_FUN_00443240(liveObj,elapsed);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CLEARING;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_CLEAR,NULL,1);
				if (liveObj->objType == OBJECT_VEHICLE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				}
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) goto LAB_0043eb11;
		if ((LVar4 & LIVEOBJ2_UNK_100) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_100;
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_10000) != LIVEOBJ1_NONE) {
			sVar9 = math::Maths_Rand();
			if ((int)sVar9 % 10 != 0) {
				LiveObject_FUN_00444520(liveObj);
			}
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10000;
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
			if (((*(byte *)&liveObj->object_3c0->flags2 & 1) == 0) ||
				 ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0)) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_2;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_GETUP,0);
				LiveObject_Container_ActivityUpdate_Check(liveObj);
				liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100;
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
			if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
				LiveObject_GetPosition(liveObj,&local_c.x,&local_c.y);
				BVar12 = 1;
				fVar26 = LiveObject_GetHeading(liveObj);
				LiveObject_SetPositionAndHeading
									(liveObj->object_3c0,local_c.x,local_c.y,(float)fVar26,BVar12);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) goto LAB_0043f040;
			pCVar10 = LiveObject_GetDepositNull(liveObj);
			res::Container_GetPosition(pCVar10,NULL,&local_c);
			LiveObject_SetPositionAndHeading(liveObj,local_c.x,local_c.y,0.0,0);
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1;
			LiveObject_AddDamage2(liveObj->object_3c0,10.0,1,elapsed);
			goto LAB_0043ecae;
		}
		BVar12 = LiveObject_FUN_00433b40(liveObj,elapsed,0);
		if (BVar12 != 0) goto LAB_0043f040;
		iVar19 = LiveObject_FUN_00442dd0(liveObj,elapsed,&local_10);
		if (iVar19 != 0) {
			if (iVar19 == 1) {
				if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
				}
				else {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRY,0);
				}
			}
			else {
				if (iVar19 == 4) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				}
				else {
					if (iVar19 == 2) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_WALK,0);
					}
					else {
						if ((iVar19 == 3) &&
							 (BVar12 = LiveObject_GetDrillNullPosition(liveObj,&local_20.x,(float *)&in_liveObj),
							 BVar12 != 0)) {
							out_by = &local_30.y;
							pVVar34 = &local_30;
							fVar36 = local_20.x;
							pLVar30 = in_liveObj;
							pSVar20 = lrr::Lego_GetMap();
							BVar12 = Map3D_WorldToBlockPos_NoZ
																 (pSVar20,fVar36,(float)pLVar30,(int *)pVVar34,(int *)out_by);
							if ((BVar12 != 0) &&
								 (BVar12 = Level_Block_IsWall((uint)local_30.x,(uint)local_30.y), BVar12 != 0)) {
								SVar18 = lrr::Lego_GetBlockTerrain((int)local_30.x,(int)local_30.y);
								fVar26 = stats::StatsObject_GetDrillTimeType(liveObj,SVar18);
								local_24 = (float)fVar26;
								if ((liveObj->flags4 & LIVEOBJ4_UNK_20000) == LIVEOBJ4_NONE) {
									LiveObject_GetContainer(liveObj);
									BVar12 = 1;
									SVar11 = stats::StatsObject_GetDrillSoundType(liveObj,0);
									iVar19 = snd::SFX_Sample_Random_Play_OrAddToQueue(SVar11,BVar12);
									liveObj->soundHandle_350 = iVar19;
									liveObj->flags4 = liveObj->flags4 | (LIVEOBJ4_UNK_20000|LIVEOBJ4_UNK_100000);
								}
								bVar8 = false;
								LiveObject_SetActivityUnk(liveObj,ACTIVITY_DRILL,0);
								BVar12 = Level_Block_GetUnkField14Test
																	 ((uint)local_30.x,(uint)local_30.y,local_24,elapsed);
								if ((BVar12 != 0) &&
									 (BVar12 = LiveObject_BlockCheck_FUN_004326a0
																			 (liveObj,(uint)local_30.x,(uint)local_30.y,0,1), BVar12 != 0)
									 ) {
									BVar12 = 0;
									pLVar14 = lrr::Lego_GetLevel();
									Level_DestroyWall(pLVar14,(uint)local_30.x,(uint)local_30.y,BVar12);
								}
							}
						}
					}
				}
			}
			if (liveObj->objType == OBJECT_MINIFIGURE) {
				if ((globs::liveGlobs.s_stepCounter_c63c & 3) == 0) {
					snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_STEP,0);
				}
				globs::liveGlobs.s_stepCounter_c63c += 1;
			}
			goto LAB_0043f040;
		}
		LVar24 = liveObj->flags1;
		if ((LVar24 & LIVEOBJ1_UNK_200) != LIVEOBJ1_NONE) {
			if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
				 (liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_200,
				 (LVar24 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) {
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					pLVar30 = liveObj->carriedObjects[0];
					if (pLVar30->objType == OBJECT_BOULDER) {
						uVar35 = FUN_00438e40(liveObj,0x400);
						Message_AddMessageAction(MESSAGE_GATHERROCK_COMPLETE,liveObj,uVar35,NULL);
					}
					else {
						liveObj->carriedObjects[0] = NULL;
						liveObj->numCarriedObjects = 0;
						pLVar30->carryingThisObject = NULL;
						pLVar30->object_300 = NULL;
						ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_COLLECT,pLVar30,1);
						LiveObject_FUN_0043ab10(liveObj,pLVar30);
						liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
					}
				}
				else {
					OVar5 = liveObj->carriedObjects[liveObj->numCarriedObjects - 1]->objType;
					if (OVar5 == OBJECT_POWERCRYSTAL) {
						Level_IncField94();
					}
					else {
						if (OVar5 == OBJECT_ORE) {
							Level_IncFieldA8();
							front::Info_Send(INFO_ORECOLLECTED,NULL,liveObj,NULL);
						}
					}
				}
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_8000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_8000;
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) goto LAB_0043f040;
		if ((LVar24 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
			OVar5 = liveObj->objType;
			if (OVar5 == OBJECT_BUILDING) {
				if ((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE) {
					if ((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE) {
						AVar33 = ACTIVITY_UNPOWERED;
						goto LAB_0043f029;
					}
					goto LAB_0043eff8;
				}
			}
			else {
LAB_0043eff8:
				if ((OVar5 != OBJECT_ROCKMONSTER) ||
					 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)) {
					if ((OVar5 == OBJECT_VEHICLE) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE))
					{
						AVar33 = ACTIVITY_OPEN;
					}
					else {
						AVar33 = ACTIVITY_STAND;
					}
					goto LAB_0043f029;
				}
			}
			AVar33 = ACTIVITY_UNPOWERED;
		}
		else {
			AVar33 = ACTIVITY_CARRYSTAND;
		}
LAB_0043f029:
		LiveObject_SetActivityUnk(liveObj,AVar33,0);
		LiveObject_RockFall_FUN_00443240(liveObj,elapsed);
		goto LAB_0043f040;
	}
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		if (liveObj->object_2fc == NULL) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UPGRADING;
		}
		else {
			fVar26 = res::Creature_GetAnimFloat10(liveObj->miniFigure);
			local_20.x = (float)fVar26;
			fVar26 = stats::StatsObject_GetUpgradeTime(liveObj);
			in_liveObj = (LiveObject *)(float)fVar26;
			fVar26 = stats::StatsObject_GetFunctionCoef(liveObj->object_2fc);
			if (fVar26 * (float10)(float)in_liveObj <= (float10)local_20.x) {
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,1);
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				LiveObject_Container_ActivityUpdate_Check(liveObj);
				uVar25 = liveObj->objLevel + 1;
				uVar22 = stats::Stats_GetLevels(liveObj->objType,liveObj->objIndex);
				if (uVar25 < uVar22) {
					stats::StatsObject_SetObjectLevel(liveObj,uVar25);
					front::HelpWindow_RecallDependencies
										(liveObj->objType,liveObj->objIndex,liveObj->objLevel,0);
				}
				liveObj->object_2fc = NULL;
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
			}
		}
		goto LAB_0043f040;
	}
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			!= 0) goto LAB_0043f040;
	if ((liveObj->object_2fc == NULL) ||
		 (OVar21 = stats::StatsObject_GetStatsFlags2(liveObj->object_2fc),
		 (OVar21 & STATS2_UPGRADEBUILDING) == STATS2_NONE)) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
		goto LAB_0043f040;
	}
	if ((liveObj->object_2fc->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) goto LAB_0043f040;
	ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,1);
	uVar22 = stats::Stats_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,liveObj->field_404);
	uVar25 = Level_GetOreCount(0);
	if (uVar25 < uVar22) {
		uVar22 = stats::Stats_GetUpgradeCostStuds(liveObj->objType,liveObj->objIndex,liveObj->field_404)
		;
		uVar25 = Level_GetOreCount(1);
		if (uVar22 <= uVar25) {
			LiveObject_CompleteVehicleUpgrade(liveObj);
			iVar19 = stats::Stats_GetUpgradeCostStuds
												 (liveObj->objType,liveObj->objIndex,liveObj->field_404);
			BVar12 = 1;
			goto LAB_0043df73;
		}
	}
	else {
		LiveObject_CompleteVehicleUpgrade(liveObj);
		iVar19 = stats::Stats_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,liveObj->field_404);
		BVar12 = 0;
LAB_0043df73:
		Level_SubtractOre(BVar12,iVar19);
	}
	liveObj->object_2fc->object_300 = NULL;
	liveObj->object_2fc = NULL;
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
LAB_0043f040:
	if ((bVar8) && ((liveObj->flags4 & LIVEOBJ4_UNK_20000) != LIVEOBJ4_NONE)) {
		LiveObject_GetContainer(liveObj);
		snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_350);
		BVar12 = 0;
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_100000;
		SVar11 = stats::StatsObject_GetDrillSoundType(liveObj,1);
		snd::SFX_Sample_Random_Play_OrAddToQueue(SVar11,BVar12);
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_20000;
	}
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	if ((liveObj->drivenObject != NULL) && (liveObj->objType != OBJECT_MINIFIGURE)) {
		LiveObject_UpdateDriverObjectPositions_FUN_004437d0(liveObj);
	}
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		LiveObject_UpdateCarrying(liveObj);
	}
	BVar12 = LiveObject_UnkTracker_FUN_00471fa0(liveObj);
	if (BVar12 != 0) {
		LiveObject_FUN_00472280(liveObj,elapsed);
	}
	LiveObject_FUN_004459a0(liveObj);
	LiveObject_Flocks_FUN_0044bef0(liveObj,*lpElapsed);
	LiveObject_UnkUpdateEnergyHealth(liveObj,elapsed);
	if ((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_10000 | LIVEOBJ2_UNK_20000;
	}
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_2;
	LiveObject_TeleportUp(liveObj);
	return 0;
}



void __cdecl lego::game::LiveObject_ProcCarriedObjects_FUN_0043f160(LiveObject *in_liveObj)
{
	LiveObject *pLVar1;
	LiveObject *liveObj2;
	bool bVar2;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar3;
	uint uVar4;
	Container *cont;
	LiveObject *argument1Obj;
	int iVar5;
	int iVar6;
	LiveObject **ppLVar7;
	uint uVar8;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	pLVar1 = in_liveObj->object_2fc;
	OVar3 = stats::StatsObject_GetStatsFlags1(in_liveObj);
	if (((OVar3 & STATS1_PROCESSCRYSTAL) == STATS1_NONE) &&
		 (OVar3 = stats::StatsObject_GetStatsFlags1(in_liveObj),
		 (OVar3 & STATS1_PROCESSORE) == STATS1_NONE)) {
		bVar2 = false;
	}
	else {
		bVar2 = true;
	}
	uVar8 = 0;
	if (in_liveObj->numCarriedObjects != 0) {
		in_liveObj = (LiveObject *)in_liveObj->carriedObjects;
		do {
			liveObj2 = (LiveObject *)in_liveObj->objType;
			liveObj2->object_2fc = NULL;
			if (bVar2) {
				liveObj2->carryingThisObject = NULL;
				liveObj2->object_300 = NULL;
				if (liveObj2->objType == OBJECT_ORE) {
					if ((uVar8 == 0) || (uVar4 = stats::StatsObject_GetMaxCarry(liveObj), uVar4 <= uVar8)) {
						cont = res::Building_GetDepositNull(liveObj->building);
						if (uVar8 == 0) {
							res::Container_GetPosition(cont,NULL,&local_c);
							argument1Obj = LiveObject_CreateInWorld
																			 (globs::legoGlobs.contOresTable[1],OBJECT_ORE,ORE_PROCESSED,0
																				,local_c.x,local_c.y,0.0);
							Message_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,argument1Obj,0,NULL);
							LiveObject_Remove(liveObj2);
							goto LAB_0043f315;
						}
						Level_IncOre(ORE_NORMAL);
					}
					LiveObject_Remove(liveObj2);
				}
				else {
					LiveObject_FUN_0043ab10(liveObj,liveObj2);
					if (liveObj->objType == OBJECT_BUILDING) {
						res::Building_FUN_00408210(liveObj->building,TRUE);
					}
					LiveManager_InitFlagsToggle_AndClearNumDrained();
				}
			}
			else {
				if (pLVar1->numCarriedObjects == pLVar1->field_328) {
					if (uVar8 < liveObj->numCarriedObjects) {
						iVar6 = uVar8 * 4;
						ppLVar7 = liveObj->carriedObjects + uVar8;
						uVar4 = uVar8;
						do {
							pLVar1 = *ppLVar7;
							iVar5 = iVar6 + uVar8 * -4;
							uVar4 += 1;
							iVar6 += 4;
							ppLVar7 = ppLVar7 + 1;
							*(LiveObject **)((int)liveObj + iVar5 + 0x308) = pLVar1;
						} while (uVar4 < liveObj->numCarriedObjects);
					}
					liveObj->numCarriedObjects = liveObj->numCarriedObjects - uVar8;
					return;
				}
				pLVar1->carriedObjects[pLVar1->numCarriedObjects] = liveObj2;
				liveObj2->carryingThisObject = pLVar1;
				liveObj2->carriedObjects[6] = (LiveObject *)pLVar1->numCarriedObjects;
				pLVar1->numCarriedObjects = pLVar1->numCarriedObjects + 1;
				pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_CARRYING;
				Message_AddMessageAction(MESSAGE_CRYSTALTOREFINERY_COMPLETE,0,0,NULL);
				OVar3 = stats::StatsObject_GetStatsFlags1(pLVar1);
				if ((OVar3 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) {
					front::Info_Send(INFO_CRYSTALPOWER,NULL,pLVar1,NULL);
				}
			}
LAB_0043f315:
			uVar8 += 1;
			in_liveObj->objType = OBJECT_NONE;
			in_liveObj = (LiveObject *)&in_liveObj->objIndex;
		} while (uVar8 < liveObj->numCarriedObjects);
	}
	liveObj->numCarriedObjects = 0;
	liveObj->object_2fc = NULL;
	liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
	return;
}



void __cdecl
lego::game::LiveObject_ClearFlags4_40_AndSameForObject2FC
					(LiveObject *unused_liveObj,LiveObject *liveObj)
{
	LiveFlags4 *pLVar1;
	
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
	if (liveObj->object_2fc != NULL) {
		pLVar1 = &liveObj->object_2fc->flags4;
		*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_40;
	}
	return;
}



void __cdecl lego::game::Game_Container_TriggerFrameCallback(Container *cont,void *data)
{
	LiveObject *liveObj;
	
	liveObj = (LiveObject *)res::Container_GetUserData(cont);
	if (liveObj != NULL) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_10000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_QueueTeleport(LiveObject *liveObj,ObjectType objType,int objIndex)
{
	if (globs::legoGlobs.objTeleportQueue_COUNT < 9) {
		globs::legoGlobs.objTeleportQueueTypes_TABLE[globs::legoGlobs.objTeleportQueue_COUNT] = objType;
		globs::legoGlobs.objTeleportQueueIndexes_TABLE[globs::legoGlobs.objTeleportQueue_COUNT] =
				 objIndex;
		globs::legoGlobs.objTeleportQueue_COUNT = globs::legoGlobs.objTeleportQueue_COUNT + 1;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043f450(LiveObject *liveObj)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	ObjectStatsFlags1 OVar3;
	int iVar4;
	int iVar5;
	LiveObject *pLVar6;
	Container *cont;
	SurfaceMap *pSVar7;
	int *piVar8;
	uint uVar9;
	ObjectType *pOVar10;
	float in_x;
	float in_y;
	uint *out_bx;
	Vector3F *out_x;
	uint *out_by;
	float *out_y;
	ObjectType local_2c;
	int local_28;
	Container *local_24;
	uint local_20;
	uint local_1c;
	Vector3F local_18;
	Vector3F local_c;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	local_28 = 0;
	BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj,0);
	if ((((BVar1 != 0) && (globs::legoGlobs.objTeleportQueue_COUNT != 0)) &&
			((liveObj_00->object_3cc == NULL ||
			 ((liveObj_00->object_3cc->flags1 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE)))) &&
		 ((*(byte *)&liveObj_00->flags4 & 0xc0) == 0)) {
		uVar9 = 0;
		iVar4 = 0;
		if (globs::legoGlobs.objTeleportQueue_COUNT != 0) {
			pOVar10 = globs::legoGlobs.objTeleportQueueTypes_TABLE;
			do {
				OVar2 = stats::Stats_GetStatsFlags2(*pOVar10,pOVar10[0x14]);
				if (((((OVar2 & STATS2_USESMALLTELEPORTER) != STATS2_NONE) &&
						 (OVar3 = stats::StatsObject_GetStatsFlags1(liveObj_00),
						 (OVar3 & STATS1_SMALLTELEPORTER) != STATS1_NONE)) ||
						(((OVar2 = stats::Stats_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
							(OVar2 & STATS2_USEBIGTELEPORTER) != STATS2_NONE &&
							(OVar3 = stats::StatsObject_GetStatsFlags1(liveObj_00),
							(OVar3 & STATS1_BIGTELEPORTER) != STATS1_NONE)) ||
						 ((OVar2 = stats::Stats_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
							(OVar2 & STATS2_USEWATERTELEPORTER) != STATS2_NONE &&
							(OVar3 = stats::StatsObject_GetStatsFlags1(liveObj_00),
							(OVar3 & STATS1_WATERTELEPORTER) != STATS1_NONE)))))) ||
					 ((OVar2 = stats::Stats_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
						(OVar2 & STATS2_USELEGOMANTELEPORTER) != STATS2_NONE &&
						(OVar3 = stats::StatsObject_GetStatsFlags1(liveObj_00),
						(OVar3 & STATS1_MANTELEPORTER) != STATS1_NONE)))) {
					iVar4 = stats::Stats_GetCostCrystal(*pOVar10,pOVar10[0x14],0);
					iVar5 = Level_GetCrystalCount(0);
					if (iVar4 <= iVar5) {
						Object_GetObjectByName("Barracks",&local_2c,(int *)&liveObj,NULL);
						BVar1 = Object_DoOxygenCheck_FUN_0043c4c0(*pOVar10,pOVar10[0x14],local_2c,(int)liveObj);
						if (BVar1 != 0) {
							iVar4 = 1;
							break;
						}
					}
				}
				uVar9 += 1;
				pOVar10 = pOVar10 + 1;
				iVar4 = local_28;
			} while (uVar9 < globs::legoGlobs.objTeleportQueue_COUNT);
		}
		if (iVar4 != 0) {
			Object_GetTypeResource
								(globs::legoGlobs.objTeleportQueueTypes_TABLE[uVar9],
								 globs::legoGlobs.objTeleportQueueIndexes_TABLE[uVar9],&local_24);
			pLVar6 = LiveObject_CreateInWorld
												 (local_24,globs::legoGlobs.objTeleportQueueTypes_TABLE[uVar9],
													globs::legoGlobs.objTeleportQueueIndexes_TABLE[uVar9],0,0.0,0.0,0.0);
			liveObj_00->object_3cc = pLVar6;
			iVar4 = stats::Stats_GetCostCrystal
												(globs::legoGlobs.objTeleportQueueTypes_TABLE[uVar9],
												 globs::legoGlobs.objTeleportQueueIndexes_TABLE[uVar9],0);
			Level_SubtractCrystals(iVar4);
			LiveManager_InitFlagsToggle_AndClearNumDrained();
			OVar3 = stats::StatsObject_GetStatsFlags1(liveObj_00);
			if ((OVar3 & STATS1_WATERTELEPORTER) == STATS1_NONE) {
				OVar3 = stats::StatsObject_GetStatsFlags1(liveObj_00->object_3cc);
				if ((OVar3 & STATS1_CANBEDRIVEN) != STATS1_NONE) {
					liveObj_00->object_3cc->flags4 = liveObj_00->object_3cc->flags4 | LIVEOBJ4_UNK_80;
					liveObj_00->flags4 = liveObj_00->flags4 | LIVEOBJ4_UNK_80;
					liveObj_00->object_3cc->object_2fc = liveObj_00;
				}
			}
			else {
				liveObj_00->object_3cc->flags4 = liveObj_00->object_3cc->flags4 | LIVEOBJ4_UNK_40;
				liveObj_00->flags4 = liveObj_00->flags4 | LIVEOBJ4_UNK_40;
				liveObj_00->object_3cc->object_2fc = liveObj_00;
			}
			cont = res::Building_GetDepositNull(liveObj_00->building);
			res::Container_GetPosition(cont,NULL,&local_18);
			res::Container_GetOrientation(cont,NULL,&local_c,NULL);
			if ((globs::legoGlobs.objTeleportQueueTypes_TABLE[uVar9] == OBJECT_VEHICLE) &&
				 (OVar2 = stats::Stats_GetStatsFlags2
														(OBJECT_VEHICLE,globs::legoGlobs.objTeleportQueueIndexes_TABLE[uVar9]),
				 (OVar2 & STATS2_USESMALLTELEPORTER) != STATS2_NONE)) {
				out_by = &local_1c;
				out_bx = &local_20;
				in_x = local_18.x;
				in_y = local_18.y;
				pSVar7 = lrr::Lego_GetMap();
				Map3D_WorldToBlockPos_NoZ(pSVar7,in_x,in_y,(int *)out_bx,(int *)out_by);
				out_y = &local_18.y;
				out_x = &local_18;
				pSVar7 = lrr::Lego_GetMap();
				Map3D_BlockToWorldPos(pSVar7,local_20,local_1c,&out_x->x,out_y);
			}
			LiveObject_SetPositionAndHeading(liveObj_00->object_3cc,local_18.x,local_18.y,0.0,FALSE);
			LiveObject_UnkUpdateOrientation(liveObj_00->object_3cc,0.0,&local_c);
			ObjectRecall_RecallMiniFigure(liveObj_00->object_3cc);
			liveObj_00->object_3cc->flags1 = liveObj_00->object_3cc->flags1 | LIVEOBJ1_UNK_200000;
			LiveObject_SetActivityUnk(liveObj_00->object_3cc,ACTIVITY_TELEPORTIN,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj_00->object_3cc);
			if (liveObj_00->object_3cc->objType == OBJECT_VEHICLE) {
				res::Vehicle_HideWheels(liveObj_00->object_3cc->vehicle,TRUE);
			}
			globs::legoGlobs.objTeleportQueue_COUNT -= 1;
			if (uVar9 < globs::legoGlobs.objTeleportQueue_COUNT) {
				piVar8 = globs::legoGlobs.objTeleportQueueIndexes_TABLE + uVar9 + 1;
				do {
					uVar9 += 1;
					piVar8[-0x15] = piVar8[-0x14];
					piVar8[-1] = *piVar8;
					piVar8 = piVar8 + 1;
				} while (uVar9 < globs::legoGlobs.objTeleportQueue_COUNT);
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_RemoveObject3CC(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackRemoveObject3CC,liveObj);
	return BVar1;
}



BOOL __cdecl
lego::game::LiveObject_CallbackRemoveObject3CC(LiveObject *liveObj,LiveObject *otherObj)
{
	if (liveObj->object_3cc == otherObj) {
		liveObj->object_3cc = NULL;
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_TrainMiniFigure_instantunk(LiveObject *liveObj,TrainedFlags trainFlags)
{
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		liveObj->flags5 = liveObj->flags5 | trainFlags;
		globs::liveGlobs.NERPs_TrainFlags |= trainFlags;
		if ((trainFlags & TRAINED_PILOT) != TRAINED_NONE) {
			front::Info_Send(INFO_TRAINPILOT,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_SAILOR) != TRAINED_NONE) {
			front::Info_Send(INFO_TRAINSAILOR,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_DRIVER) != TRAINED_NONE) {
			front::Info_Send(INFO_TRAINDRIVER,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_DYNAMITE) != TRAINED_NONE) {
			front::Info_Send(INFO_TRAINDYNAMITE,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_REPAIR) != TRAINED_NONE) {
			front::Info_Send(INFO_TRAINREPAIR,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_SCANNER) != TRAINED_NONE) {
			front::Info_Send(INFO_TRAINSCANNER,NULL,liveObj,NULL);
		}
		liveObj->elapsedTime1 = 0.0;
	}
	return;
}



void __cdecl
lego::game::LiveObject_AddDamage2(LiveObject *liveObj,float damage,BOOL param_3,float param_4)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	float10 fVar3;
	longlong lVar4;
	longlong lVar5;
	
	BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj,TRUE);
	if ((BVar1 != 0) && (liveObj->carryingThisObject == NULL)) {
		if ((liveObj->objType == OBJECT_BUILDING) &&
			 ((damage != 0.0 && ((undefined *)liveObj->health == &DAT_42c80000)))) {
			ai::AITask_DoRepair_Target(liveObj,FALSE);
		}
		BVar1 = LiveObject_IsRockMonsterCanGather(liveObj);
		if (BVar1 != 0) {
			fVar3 = stats::StatsObject_GetHealthDecayRate(liveObj);
			lVar4 = __ftol(fVar3 * (float10)0.04 * (float10)param_4 * (float10)10010.0);
			lVar5 = __ftol((float10)damage * (float10)10000.0);
			if ((uint)lVar4 < (uint)lVar5) {
				reward::Rewards_RockMonsterDamageDealt(damage);
			}
		}
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			reward::Rewards_MiniFigureDamageTaken(damage);
		}
		liveObj->health = liveObj->health - damage;
		if ((param_3 != 0) &&
			 ((ushort)((ushort)(damage < 0.0) << 8 | (ushort)(damage == 0.0) << 0xe) == 0)) {
			liveObj->flags2 = liveObj->flags2 | (LIVEOBJ2_UNK_1000|LIVEOBJ2_UNK_2000);
			liveObj->field_3d0 = damage + (float)liveObj->field_3d0;
			front::Bubble_LiveObject_FUN_00407470(liveObj);
		}
		OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
		if (((OVar2 & STATS2_DAMAGECAUSESCALLTOARMS) != STATS2_NONE) &&
			 ((ushort)((ushort)(damage < 0.0) << 8 | (ushort)(damage == 0.0) << 0xe) == 0)) {
			lrr::LegoGame_SetCallToArmsOn(TRUE);
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_UnkUpdateEnergyHealth(LiveObject *in_liveObj,float elapsed)
{
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar1;
	LiveObject *liveObj_00;
	uint uVar2;
	int *piVar3;
	float10 fVar4;
	longlong lVar5;
	BOOL BVar6;
	float fVar7;
	float damage;
	void *local_40;
	undefined local_3c [4];
	int local_38;
	int local_34;
	int local_30;
	int local_2c;
	int local_28;
	int local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	liveObj = in_liveObj;
	damage = 0.0;
	if ((in_liveObj->objType != OBJECT_UPGRADEPART) && (in_liveObj->objType != OBJECT_BOULDER)) {
		if ((ushort)((ushort)(in_liveObj->health < 0.0) << 8 |
								(ushort)(in_liveObj->health == 0.0) << 0xe) == 0) {
			if ((in_liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
				BVar6 = 0;
				fVar7 = elapsed;
				fVar4 = stats::StatsObject_GetHealthDecayRate(in_liveObj);
				LiveObject_AddDamage2(liveObj,(float)(fVar4 * (float10)0.04 * (float10)elapsed),BVar6,fVar7)
				;
			}
		}
		else {
			in_liveObj->health = 0.0;
		}
		uVar2 = 0;
		if ((ushort)((ushort)(liveObj->energy < 0.0) << 8 | (ushort)(liveObj->energy == 0.0) << 0xe) ==
				0) {
			if ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
				fVar4 = stats::StatsObject_GetEnergyDecayRate(liveObj);
				liveObj->energy =
						 (float)((float10)liveObj->energy - fVar4 * (float10)0.04 * (float10)elapsed);
			}
		}
		else {
			liveObj->energy = 0.0;
		}
		LiveObject_GetBlockPos(liveObj,&local_38,&local_34);
		if (((liveObj->carryingThisObject == NULL) &&
				((globs::legoGlobs.level)->blocks
				 [((globs::legoGlobs.level)->dimensions).width * local_34 + local_38].terrain ==
				 TERRAIN_LAVA)) &&
			 ((liveObj->objType == OBJECT_ORE || (liveObj->objType == OBJECT_POWERCRYSTAL)))) {
			Level_AddToField9c(1);
			liveObj->health = -1.0;
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		}
		fVar7 = elapsed;
		BVar6 = LiveObject_GetRockFallInDamage_Unk(liveObj,local_38,local_34,elapsed,&damage);
		if (BVar6 != 0) {
			LiveObject_AddDamage2(liveObj,damage,1,fVar7);
		}
		OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((((OVar1 & STATS2_CANBEHITBYFENCE) != STATS2_NONE) &&
				((liveObj->flags1 & (LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_100000)) == LIVEOBJ1_NONE)) &&
			 ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE)) {
			ElectricFence_LiveObject_FUN_0040dd70(liveObj);
		}
		if (((((globs::legoGlobs.flags2 & GAME2_NOAUTOEAT) == GAME2_NONE) &&
				 (liveObj->objType == OBJECT_MINIFIGURE)) &&
				(((liveObj->energy < liveObj->health * 0.01 * globs::legoGlobs.MinEnergyForEat &&
					(((ushort)((ushort)(liveObj->activityElapsedTime < 125.0) << 8 |
										(ushort)(liveObj->activityElapsedTime == 125.0) << 0xe) == 0 &&
					 (liveObj->activityElapsedTime = 0.0, liveObj->drivenObject == NULL)))) &&
				 (BVar6 = ai::AITask_LiveObject_IsCurrentTaskType(liveObj,AITASK_GOTOEAT), BVar6 == 0)))) &&
			 (liveObj_00 = (LiveObject *)FUN_00438f20(liveObj), liveObj_00 != NULL)) {
			local_20[1] = 0xffffffff;
			local_8 = 0xffffffff;
			local_20[0] = 0;
			local_20[2] = 1;
			local_20[3] = 0;
			local_20[4] = 0;
			local_c = 1;
			local_4 = 0;
			LiveObject_GetBlockPos(liveObj,&local_28,&local_24);
			LiveObject_GetBlockPos(liveObj_00,&local_30,&local_2c);
			piVar3 = local_20;
			do {
				BVar6 = LiveObject_FUN_004413b0
													(liveObj,local_28,local_24,local_30 + *piVar3,piVar3[1] + local_2c,
													 &in_liveObj,&local_40,local_3c,0,0);
				if (BVar6 != 0) {
					std::free(in_liveObj);
					std::free(local_40);
					ai::AITask_DoGotoEat_Target(liveObj,liveObj_00);
					break;
				}
				uVar2 += 1;
				piVar3 = piVar3 + 2;
			} while (uVar2 < 4);
		}
		if ((ushort)((ushort)(liveObj->energy < liveObj->health) << 8 |
								(ushort)(liveObj->energy == liveObj->health) << 0xe) == 0) {
			liveObj->energy = liveObj->health;
		}
		LiveObject_MiniFigurePlayHurtSND(liveObj,elapsed,damage);
		if (((liveObj->flags2 & LIVEOBJ2_UNK_2000) != LIVEOBJ2_NONE) &&
			 ((liveObj->flags2 & LIVEOBJ2_UNK_1000) == LIVEOBJ2_NONE)) {
			lVar5 = __ftol((float10)(float)liveObj->field_3d0);
			effect::DamageFont_DisplayDamage_OverLiveObject(liveObj,(uint)lVar5);
			liveObj->field_3d0 = 0;
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_2000;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_MiniFigurePlayHurtSND(LiveObject *in_liveObj,float elapsed,float damage)
{
	float fVar1;
	float fVar2;
	LiveObject *liveObj;
	BOOL BVar3;
	Container *cont;
	float10 fVar4;
	LiveObject *sfxType;
	BOOL sound3D;
	Vector3F *opt_position;
	
	liveObj = in_liveObj;
	if ((in_liveObj->objType == OBJECT_MINIFIGURE) && (damage != 0.0)) {
		BVar3 = snd::SFX_GetType("SND_Hurt",(SFXType *)&in_liveObj);
		if (BVar3 != 0) {
			if (liveObj->floatSnd_3fc == 0.0) {
				opt_position = NULL;
				sound3D = TRUE;
				BVar3 = FALSE;
				sfxType = in_liveObj;
				cont = LiveObject_GetContainer(liveObj);
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
									(cont,(SFXType)sfxType,BVar3,sound3D,opt_position);
				liveObj->floatSnd_3fc = elapsed + liveObj->floatSnd_3fc;
				fVar4 = snd::SFX_Sample_Random_GetSamplePlayTime((SFXType)in_liveObj);
				liveObj->floatSnd_400 = (float)fVar4;
			}
			else {
				fVar1 = liveObj->floatSnd_3fc - elapsed * -0.04;
				fVar2 = liveObj->floatSnd_400 + liveObj->floatSnd_400;
				liveObj->floatSnd_3fc = fVar1;
				if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
					liveObj->floatSnd_3fc = 0.0;
					liveObj->floatSnd_400 = 0.0;
					return TRUE;
				}
			}
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043fee0(LiveObject *carriedObj)
{
	LiveObject *liveObj;
	Container *pCVar1;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	Container *cont;
	float in_x;
	float in_y;
	int *out_bx;
	int *out_by;
	int local_2c;
	int local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = carriedObj->carryingThisObject;
	if (liveObj != NULL) {
		pCVar1 = LiveObject_GetDepositNull(liveObj);
		if (pCVar1 != NULL) {
			res::Container_GetPosition(pCVar1,NULL,&local_24);
			out_by = &local_28;
			out_bx = &local_2c;
			in_x = local_24.x;
			in_y = local_24.y;
			surfMap = lrr::Lego_GetMap();
			BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,out_bx,out_by);
			if (BVar2 != 0) {
				iVar3 = LiveObject_Routing_GetCrossTerrainType
													(carriedObj,local_2c,local_28,local_2c,local_28,0);
				if (iVar3 != 0) {
					pCVar1 = LiveObject_GetContainer(carriedObj);
					if (pCVar1 != NULL) {
						cont = LiveObject_GetContainer(liveObj);
						if (cont != NULL) {
							carriedObj->carryingThisObject = NULL;
							liveObj->carriedObjects[0] = NULL;
							liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
							liveObj->numCarriedObjects = 0;
							res::Container_GetPosition(cont,NULL,&local_24);
							res::Container_GetOrientation(cont,NULL,&local_c,&local_18);
							res::Container_SetPosition(pCVar1,NULL,local_24.x,local_24.y,local_24.z);
							res::Container_SetOrientation
												(pCVar1,NULL,local_c.x,local_c.y,local_c.z,local_18.x,local_18.y,local_18.z)
							;
							LiveObject_FUN_00437690(liveObj,1);
							ai::AITask_DoAnimationWait(liveObj);
							LiveObject_SetActivityUnk(carriedObj,ACTIVITY_FLOATOFF,0);
							LiveObject_Container_ActivityUpdate_Check(carriedObj);
							ai::AITask_DoAnimationWait(carriedObj);
							carriedObj->object_2fc = liveObj;
							carriedObj->flags4 = carriedObj->flags4 | LIVEOBJ4_UNK_8000;
							return 1;
						}
					}
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_UnkCarryingVehicle_FUN_00440080(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	int *out_bx;
	int *out_by;
	int local_14;
	int local_10;
	Vector3F local_c;
	
	OVar1 = stats::StatsObject_GetStatsFlags3(liveObj);
	if (((((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj->carriedObjects[0] != NULL)) &&
		 (liveObj->carriedObjects[0]->objType == OBJECT_VEHICLE)) {
		cont = LiveObject_GetDepositNull(liveObj);
		if (cont != NULL) {
			res::Container_GetPosition(cont,NULL,&local_c);
			out_by = &local_10;
			out_bx = &local_14;
			surfMap = lrr::Lego_GetMap();
			BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,out_bx,out_by);
			if (BVar2 != 0) {
				iVar3 = LiveObject_Routing_GetCrossTerrainType
													(liveObj->carriedObjects[0],local_14,local_10,local_14,local_10,1);
				if (iVar3 != 0) {
					return TRUE;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryFindLoad_FUN_00440130(LiveObject *in_liveObj,LiveObject *targetObj)
{
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	BOOL BVar3;
	float *out_bx;
	float *out_by;
	uint local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	BVar3 = 0;
	OVar1 = stats::StatsObject_GetStatsFlags3(in_liveObj);
	liveObj_00 = targetObj;
	if ((OVar1 & STATS3_VEHICLECANBECARRIED) != STATS3_NONE) {
		OVar1 = stats::StatsObject_GetStatsFlags3(targetObj);
		if (((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) && (liveObj->carryingThisObject == NULL)) {
			LiveObject_GetBlockPos(liveObj,(int *)&local_14,(int *)&local_10);
			cont = LiveObject_GetDepositNull(liveObj_00);
			if (cont != NULL) {
				res::Container_GetPosition(cont,NULL,&local_c);
				out_by = &local_18;
				out_bx = &local_1c;
				surfMap = lrr::Lego_GetMap();
				BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)out_by);
				if (BVar2 != 0) {
					if ((local_1c == local_14) && (local_18 == local_10)) {
						BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
															(liveObj,1,&local_1c,&local_18,&local_c.x);
					}
					else {
						BVar3 = LiveObject_FUN_004413b0
															(liveObj,local_14,local_10,local_1c,local_18,&in_liveObj,&targetObj,
															 &local_20,0,0);
						if (BVar3 == 0) {
							return 0;
						}
						BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
															(liveObj,local_20,(float *)in_liveObj,(float *)targetObj,&local_c.x);
						std::free(in_liveObj);
						std::free(targetObj);
					}
					if (BVar3 != 0) {
						liveObj->object_2fc = liveObj_00;
						liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0x15;
						LiveObject_FUN_00437690(liveObj_00,1);
						return TRUE;
					}
				}
			}
		}
	}
	return BVar3;
}



BOOL __cdecl lego::game::LiveObject_TryDock_FUN_004402b0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	float *out_bx;
	float *out_by;
	float *local_24;
	uint local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	LiveObject_GetBlockPos(in_liveObj,(int *)&local_14,(int *)&local_10);
	liveObj_00 = (LiveObject *)LiveObject_FUN_00438ca0(liveObj,TRUE);
	if ((liveObj_00 != NULL) && (cont = LiveObject_GetDepositNull(liveObj_00), cont != NULL)) {
		res::Container_GetPosition(cont,NULL,&local_c);
		out_by = &local_18;
		out_bx = &local_1c;
		surfMap = lrr::Lego_GetMap();
		BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)out_by);
		if (BVar1 != 0) {
			if ((local_1c == local_14) && (local_18 == local_10)) {
				BVar1 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,&local_1c,&local_18,&local_c.x);
			}
			else {
				BVar1 = LiveObject_FUN_004413b0
													(liveObj,local_14,local_10,local_1c,local_18,&in_liveObj,&local_24,
													 &local_20,0,0);
				if (BVar1 == 0) {
					return 0;
				}
				BVar1 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj,local_20,(float *)in_liveObj,local_24,&local_c.x);
				std::free(in_liveObj);
				std::free(local_24);
			}
			if (BVar1 != 0) {
				liveObj->object_2fc = liveObj_00;
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0x13;
				return TRUE;
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_TryDock_AtBlockPos_FUN_004403f0(LiveObject *liveObj,Point2I *blockPos)
{
	uint i;
	LiveObject **pLiveObjArr;
	Point2I objBlockPos;
	LiveObject *liveObj_0;
	
	i = 0;
	if (globs::liveGlobs.uintCount_c5cc != 0) {
		pLiveObjArr = globs::liveGlobs.liveObjArray100_c43c;
		do {
			liveObj_0 = *pLiveObjArr;
			if (((liveObj_0 != NULL) &&
					(LiveObject_GetBlockPos(liveObj_0,&objBlockPos.x,&objBlockPos.y),
					objBlockPos.x == blockPos->x)) && (objBlockPos.y == blockPos->y)) {
				liveObj_0->object_2fc = liveObj;
				LiveObject_TryDock_AtObject2FC(liveObj_0);
				*pLiveObjArr = NULL;
			}
			i += 1;
			pLiveObjArr = pLiveObjArr + 1;
		} while (i < globs::liveGlobs.uintCount_c5cc);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00440470(LiveObject *liveObj,BOOL param_2)
{
	LiveObject *pLVar1;
	ObjectStatsFlags1 OVar2;
	Container *pCVar3;
	Container *cont;
	SurfaceMap *pSVar4;
	BOOL BVar5;
	int iVar6;
	float10 fVar7;
	float fVar8;
	float fVar9;
	int *out_bx;
	Vector3F *out_x;
	int *out_by;
	float *out_y;
	int local_28;
	int local_24;
	Point2I local_20;
	Vector3F local_18;
	Vector3F local_c;
	LiveObject *drivenObj;
	
	drivenObj = liveObj->drivenObject;
	OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
		return 0;
	}
	if (drivenObj == NULL) {
		return 0;
	}
	if ((*(byte *)&drivenObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		return 0;
	}
	pCVar3 = LiveObject_GetDepositNull(liveObj);
	cont = LiveObject_GetContainer(drivenObj);
	res::Container_GetPosition(pCVar3,NULL,&local_18);
	out_by = &local_24;
	out_bx = &local_28;
	fVar8 = local_18.x;
	fVar9 = local_18.y;
	pSVar4 = lrr::Lego_GetMap();
	BVar5 = Map3D_WorldToBlockPos_NoZ(pSVar4,fVar8,fVar9,out_bx,out_by);
	if (BVar5 == 0) {
		return 0;
	}
	OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
	if (((OVar2 & STATS1_CROSSLAND) != STATS1_NONE) &&
		 (iVar6 = LiveObject_Routing_GetCrossTerrainType
												(drivenObj,local_28,local_24,local_28,local_24,TRUE), iVar6 != 0)) {
LAB_004405c7:
		liveObj->drivenObject = NULL;
		drivenObj->drivenObject = NULL;
		drivenObj->flags2 = drivenObj->flags2 & ~LIVEOBJ2_DRIVING;
		fVar8 = local_18.x;
		fVar9 = local_18.y;
		pSVar4 = lrr::Lego_GetMap();
		fVar7 = Map3D_GetWorldZ(pSVar4,fVar8,fVar9);
		res::Container_SetPosition(cont,NULL,local_18.x,local_18.y,(float)fVar7);
		res::Container_SetOrientation(cont,NULL,local_c.x,local_c.y,0.0,0.0,0.0,-1.0);
		LiveObject_SetActivityUnk(drivenObj,ACTIVITY_STAND,0);
		drivenObj->aitaskName2 = NULL;
		LiveObject_Container_ActivityUpdate_Check(drivenObj);
		Message_PTL_Deselect_LiveObject(liveObj);
		return 1;
	}
	if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_40) == 0) {
		if ((param_2 == 0) &&
			 (BVar5 = LiveObject_UnkGetTerrainGetOutAtLandBlock_FUN_0043a0d0(liveObj,&local_20),
			 BVar5 != 0)) {
			out_y = &local_18.y;
			out_x = &local_18;
			pSVar4 = lrr::Lego_GetMap();
			Map3D_BlockToWorldPos(pSVar4,local_20.x,local_20.y,&out_x->x,out_y);
			goto LAB_004405c7;
		}
		OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar2 & STATS1_CROSSLAND) == STATS1_NONE) {
			ai::AITask_DoDock(liveObj);
		}
	}
	else {
		pLVar1 = liveObj->object_2fc;
		if (((pLVar1 != NULL) && (pLVar1->objType == OBJECT_BUILDING)) &&
			 (pCVar3 = res::Building_GetEntranceNull(pLVar1->building), pCVar3 != NULL)) {
			res::Container_GetPosition(pCVar3,NULL,&local_18);
			res::Container_GetOrientation(pCVar3,NULL,&local_c,NULL);
			goto LAB_004405c7;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryFindDriver_FUN_00440690(LiveObject *in_liveObj,LiveObject *targetObj)
{
	byte *pbVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags1 OVar4;
	SurfaceMap *pSVar5;
	BOOL BVar6;
	byte bVar7;
	Container *cont;
	float *pfVar8;
	float *pfVar9;
	uint local_44;
	uint local_40;
	uint local_3c;
	uint local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	float local_c;
	float local_8 [2];
	
	liveObj_00 = targetObj;
	liveObj = in_liveObj;
	cont = NULL;
	pAVar2 = in_liveObj->aitask_2f0;
	if (pAVar2 != NULL) {
		if (pAVar2->taskType != AITASK_FINDDRIVER) {
			return 0;
		}
		if (pAVar2->next != NULL) {
			return 0;
		}
	}
	if (in_liveObj->drivenObject != NULL) {
		return 0;
	}
	if (targetObj->drivenObject != NULL) {
		return 0;
	}
	if (in_liveObj->objType != OBJECT_MINIFIGURE) {
		return 0;
	}
	if (((((in_liveObj->flags5 & (LIVEOBJ5_ABILITY_PILOT|LIVEOBJ5_ABILITY_DRIVER)) == LIVEOBJ5_NONE)
			 || (OVar4 = stats::StatsObject_GetStatsFlags1(targetObj),
					(OVar4 & STATS1_CROSSLAND) == STATS1_NONE)) ||
			(OVar4 = stats::StatsObject_GetStatsFlags1(liveObj_00),
			(OVar4 & STATS1_CANBEDRIVEN) == STATS1_NONE)) || ((*(byte *)&liveObj_00->flags4 & 0x40) != 0))
	{
		if ((*(byte *)&liveObj->flags5 & 2) != 0) {
			OVar4 = stats::StatsObject_GetStatsFlags1(liveObj_00);
			if ((((OVar4 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
					((*(byte *)&liveObj_00->flags4 & 0x40) == 0)) ||
				 ((pLVar3 = liveObj_00->object_2fc, pLVar3 == NULL || (pLVar3->objType != OBJECT_BUILDING)))
				 ) {
				if ((((*(byte *)&liveObj->flags5 & 2) != 0) &&
						(OVar4 = stats::StatsObject_GetStatsFlags1(liveObj_00),
						(OVar4 & STATS1_CANBEDRIVEN) != STATS1_NONE)) &&
					 (BVar6 = LiveObject_CheckUnkGetInAtLand_FUN_0043a100(liveObj_00,NULL), BVar6 != 0)) {
					LiveObject_GetBlockPos(liveObj_00,(int *)&local_40,(int *)&local_44);
					BVar6 = LiveObject_BlockRoute_FUN_00446c80(liveObj,local_40,local_44,0,&local_3c,1);
					if (BVar6 != 0) {
						liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y = 0.5;
						liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x = 0.5;
						switch(local_3c) {
						case 0:
							liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y = 0.1;
							break;
						case 1:
							liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x = 0.1;
							break;
						case 2:
							liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y = 0.9;
							break;
						case 3:
							liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x = 0.9;
						}
						liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
								 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 8;
						liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0xc;
						liveObj->object_2fc = liveObj_00;
						return TRUE;
					}
				}
			}
			else {
				cont = res::Building_GetEntranceNull(pLVar3->building);
			}
		}
	}
	else {
		cont = LiveObject_GetContainer(liveObj_00);
	}
	if (cont != NULL) {
		res::Container_GetPosition(cont,NULL,&local_18);
		res::Container_GetOrientation(cont,NULL,&local_24,NULL);
		if (ABS(local_24.x) <= ABS(local_24.y)) {
			if ((ushort)((ushort)(local_24.y < 0.0) << 8 | (ushort)(local_24.y == 0.0) << 0xe) == 0) {
				bVar7 = 0;
			}
			else {
				bVar7 = 2;
			}
		}
		else {
			if ((ushort)((ushort)(local_24.x < 0.0) << 8 | (ushort)(local_24.x == 0.0) << 0xe) == 0) {
				bVar7 = 1;
			}
			else {
				bVar7 = 3;
			}
		}
		pfVar9 = &local_30;
		pfVar8 = &local_34;
		pSVar5 = lrr::Lego_GetMap();
		Map3D_WorldToBlockPos_NoZ(pSVar5,local_18.x,local_18.y,(int *)pfVar8,(int *)pfVar9);
		LiveObject_GetPosition(liveObj,&local_c,local_8);
		pfVar9 = &local_28;
		pfVar8 = &local_2c;
		pSVar5 = lrr::Lego_GetMap();
		Map3D_WorldToBlockPos_NoZ(pSVar5,local_c,local_8[0],(int *)pfVar8,(int *)pfVar9);
		if ((local_2c == local_34) && (local_28 == local_30)) {
			BVar6 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,&local_34,&local_30,&local_18.x);
		}
		else {
			BVar6 = LiveObject_FUN_004413b0
												(liveObj,local_2c,local_28,local_34,local_30,&in_liveObj,&targetObj,
												 &local_38,0,0);
			if (BVar6 == 0) {
				return 0;
			}
			BVar6 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
												(liveObj,local_38,(float *)in_liveObj,(float *)targetObj,&local_18.x);
			std::free(in_liveObj);
			std::free(targetObj);
		}
		if (BVar6 != 0) {
			liveObj->object_2fc = liveObj_00;
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0xc;
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
					 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 4;
			pbVar1 = &liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10;
			*pbVar1 = *pbVar1 | bVar7;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::Game_DoDynamiteExplosionCallbacks
					(LiveObject *liveObj,float damageRadius,float maxDamage,float wakeRadius)
{
	BOOL BVar1;
	SearchDynamiteRadius searchDynamite;
	
	searchDynamite.liveObj = liveObj;
	LiveObject_GetPosition(liveObj,&searchDynamite.position.x,&searchDynamite.position.y);
	searchDynamite.damageRadius = damageRadius;
	searchDynamite.maxDamage = maxDamage;
	searchDynamite.wakeRadius = wakeRadius;
	BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_DynamiteRadius,&searchDynamite);
	return BVar1;
}



// Affect live objects within the radius of an exploding dynamite object

BOOL __cdecl
lego::game::LiveObject_Callback_DynamiteRadius(LiveObject *liveObj,SearchDynamiteRadius *search)
{
	float fVar1;
	float fVar2;
	Point2F distance;
	
	if ((liveObj != search->liveObj) && ((liveObj->flags3 & LIVEOBJ3_UNK_40000) != LIVEOBJ3_NONE)) {
		LiveObject_GetPosition(liveObj,&distance.x,&distance.y);
		fVar2 = distance.y - (search->position).y;
		fVar1 = distance.x - (search->position).x;
		fVar1 = SQRT(fVar1 * fVar1 + fVar2 * fVar2);
		if (fVar1 < search->damageRadius) {
			LiveObject_AddDamage2
								(liveObj,(1.0 - fVar1 / search->damageRadius) * search->maxDamage,TRUE,1.0);
		}
		if ((liveObj->objType == OBJECT_ROCKMONSTER) && (fVar1 < search->wakeRadius)) {
			LiveObject_RockMonster_DoWakeUp(liveObj);
		}
	}
	return 0;
}



void __cdecl
lego::game::Game_DoBirdScarerRadiusCallbacks_FUN_00440b80
					(LiveObject *optor_liveObj,Point2F *optor_position,float radius)
{
	LiveObject *local_18;
	float local_14;
	float local_10;
	float local_c;
	
	local_18 = optor_liveObj;
	if (optor_position == NULL) {
		LiveObject_GetPosition(optor_liveObj,&local_14,&local_10);
	}
	else {
		local_14 = optor_position->x;
		local_10 = optor_position->y;
	}
	local_c = radius;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackProc_FUN_00440be0,&local_18);
	return;
}



BOOL __cdecl
lego::game::LiveObject_CallbackProc_FUN_00440be0(LiveObject *liveObj,LiveObject **search)
{
	float fVar1;
	ObjectStatsFlags2 OVar2;
	Point2F local_10;
	float local_8;
	float local_4;
	
	if (liveObj != *search) {
		OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_SCAREDBYBIGBANGS) != STATS2_NONE) {
			LiveObject_GetPosition(liveObj,&local_8,&local_4);
			local_10.x = local_8 - (float)search[1];
			local_10.y = local_4 - (float)search[2];
			fVar1 = SQRT(local_10.y * local_10.y + local_10.x * local_10.x);
			if (fVar1 < (float)search[3]) {
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					LiveObject_RockMonster_DoWakeUp(liveObj);
				}
				fVar1 = 1.0 / fVar1;
				local_10.x = fVar1 * local_10.x;
				local_10.y = fVar1 * local_10.y;
				LiveObject_FUN_00444720(liveObj,&local_10);
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_SetActivityUnk(LiveObject *liveObj,ActivityType actType,BOOL unkbool2d8)
{
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[actType];
	liveObj->unkbool_2d8 = unkbool2d8;
	liveObj->float_2d4 = 0.0;
	return;
}



void __cdecl lego::game::LiveObject_UpdateCarrying(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	ObjectType OVar1;
	float fVar2;
	float fVar3;
	LiveObject *pLVar4;
	int iVar5;
	Container *cont;
	VehicleData *vehicle;
	LiveObject **local_14;
	uint local_10;
	Vector3F local_c;
	
	local_10 = 0;
	if (in_liveObj->numCarriedObjects != 0) {
		local_14 = in_liveObj->carriedObjects;
		pLVar4 = in_liveObj;
		do {
			liveObj = *local_14;
			if ((liveObj->flags3 & LIVEOBJ3_UNK_2000) == LIVEOBJ3_NONE) {
				OVar1 = in_liveObj->objType;
				if (OVar1 == OBJECT_ROCKMONSTER) {
					pLVar4 = (LiveObject *)res::Creature_GetCarryNull(in_liveObj->rockMonster);
				}
				else {
					if (OVar1 == OBJECT_MINIFIGURE) {
						pLVar4 = in_liveObj->drivenObject;
						if ((pLVar4 == NULL) || (pLVar4->objType != OBJECT_VEHICLE)) {
							pLVar4 = (LiveObject *)res::Creature_GetCarryNull(in_liveObj->miniFigure);
						}
						else {
							iVar5 = stats::StatsObject_GetCarryStart(pLVar4);
							vehicle = in_liveObj->drivenObject->vehicle;
LAB_00440d93:
							pLVar4 = (LiveObject *)res::Vehicle_GetCarryNull(vehicle,iVar5);
						}
					}
					else {
						if (OVar1 == OBJECT_BUILDING) {
							pLVar4 = (LiveObject *)
											 res::Building_GetCarryNull
																 (in_liveObj->building,(int)liveObj->carriedObjects[6]);
						}
						else {
							if (OVar1 == OBJECT_VEHICLE) {
								iVar5 = stats::StatsObject_GetCarryStart(in_liveObj);
								vehicle = in_liveObj->vehicle;
								iVar5 = (int)liveObj->carriedObjects[6]->routing_points_4 + iVar5 + -0x34;
								goto LAB_00440d93;
							}
						}
					}
				}
				if (pLVar4 != NULL) {
					cont = LiveObject_GetContainer(liveObj);
					res::Container_GetPosition(cont,NULL,&liveObj->vector_2a0);
					res::Container_SetPosition(cont,(Container *)pLVar4,0.0,0.0,0.0);
					res::Container_SetOrientation(cont,(Container *)pLVar4,0.0,0.0,1.0,0.0,1.0,0.0);
					res::Container_GetPosition(cont,NULL,&local_c);
					local_c.x = local_c.x - (liveObj->vector_2a0).x;
					local_c.y = local_c.y - (liveObj->vector_2a0).y;
					local_c.z = local_c.z - (liveObj->vector_2a0).z;
					fVar2 = SQRT(local_c.z * local_c.z + local_c.y * local_c.y + local_c.x * local_c.x);
					fVar3 = 1.0 / fVar2;
					liveObj->float_2b8 = fVar2;
					(liveObj->faceDirection).x = fVar3 * local_c.x;
					(liveObj->faceDirection).y = fVar3 * local_c.y;
					(liveObj->faceDirection).z = fVar3 * local_c.z;
				}
			}
			local_10 += 1;
			local_14 = local_14 + 1;
		} while (local_10 < in_liveObj->numCarriedObjects);
	}
	return;
}



void __cdecl
lego::game::LiveObject_InitBoulderMesh_FUN_00440eb0
					(LiveObject *liveObj,Container_Texture *contTexture)
{
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	
	if (liveObj->objType == OBJECT_BOULDER) {
		DVar1 = res::Container_Mesh_GetGroupCount(liveObj->other);
		groupID = D3DRMGROUP_0;
		if (DVar1 != D3DRMGROUP_0) {
			do {
				res::Container_Mesh_SetTexture(liveObj->other,groupID,contTexture);
				groupID += 1;
			} while (groupID < DVar1);
		}
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00440ef0
					(LiveObject *liveObj,undefined4 param_2,undefined4 param_3,undefined4 param_4,
					undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_FUN_004413b0
										(liveObj,param_2,param_3,param_4,param_5,param_6,param_7,param_8,0,0);
	return BVar1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00440f30
					(LiveObject *liveObj,uint param_2,uint param_3,uint param_4,uint param_5,uint **param_6,
					uint **param_7,uint *param_8,undefined *param_9,undefined4 param_10)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	SurfaceMap *pSVar4;
	int iVar5;
	int iVar6;
	uint uVar7;
	uint *puVar8;
	uint *puVar9;
	int iVar10;
	void *pvVar11;
	uint uVar12;
	uint uVar13;
	undefined4 *puVar14;
	uint by1;
	uint *local_ff0;
	uint local_fec;
	uint *local_fe8;
	uint local_fe4;
	uint local_fe0;
	uint local_fdc;
	uint local_fd0 [4];
	uint local_fc0 [9];
	uint local_f9c;
	
	local_fc0[0] = 0;
	local_fc0[1] = 0xffffffff;
	local_fc0[2] = 1;
	local_fc0[3] = 0;
	local_fc0[4] = 0;
	local_fc0[5] = 1;
	local_fc0[6] = 0xffffffff;
	local_fc0[7] = 0;
	local_fec = 0;
	pSVar4 = lrr::Lego_GetMap();
	uVar1 = (pSVar4->smallDimensions).width;
	uVar2 = (pSVar4->smallDimensions).height;
	if (uVar1 <= param_2) {
		return 0;
	}
	if (uVar2 <= param_3) {
		return 0;
	}
	if (param_9 == NULL) {
		if (uVar1 <= param_4) {
			return 0;
		}
		if (uVar2 <= param_5) {
			return 0;
		}
		iVar5 = LiveObject_Routing_GetCrossTerrainType(liveObj,param_4,param_5,param_4,param_5,0);
		if (iVar5 == 0) {
			return 0;
		}
	}
	if (globs::liveGlobs.UnkSurfaceGrid_2_TABLE != NULL) {
		if (globs::liveGlobs.UnkSurfaceGrid_COUNT == uVar2 * uVar1) goto LAB_00441021;
		if (globs::liveGlobs.UnkSurfaceGrid_2_TABLE != NULL) {
			std::free(globs::liveGlobs.UnkSurfaceGrid_2_TABLE);
		}
	}
	globs::liveGlobs.UnkSurfaceGrid_COUNT = uVar2 * uVar1;
	globs::liveGlobs.UnkSurfaceGrid_2_TABLE = std::malloc(globs::liveGlobs.UnkSurfaceGrid_COUNT * 4);
LAB_00441021:
	iVar5 = uVar2 * uVar1;
	puVar14 = (undefined4 *)globs::liveGlobs.UnkSurfaceGrid_2_TABLE;
	if (globs::liveGlobs.UnkSurfaceGrid_2_TABLE != NULL) {
		for (; iVar5 != 0; iVar5 += -1) {
			*puVar14 = 0;
			puVar14 = puVar14 + 1;
		}
		local_fe4 = 0;
		local_f9c = param_3;
		*(undefined4 *)((int)globs::liveGlobs.UnkSurfaceGrid_2_TABLE + (uVar1 * param_3 + param_2) * 4)
				 = 1;
		local_ff0 = local_fd0;
		local_fc0[8] = param_2;
		local_fd0[0] = 1;
		local_fd0[1] = 0;
		uVar12 = 1;
		do {
			local_fe0 = uVar12;
			uVar12 = local_fe0 + 1;
			local_fdc = 0;
			if (*local_ff0 != 0) {
				iVar5 = 0;
				local_fe8 = local_fc0 + local_fe4 * 500 + 9;
				while( true ) {
					do {
						uVar13 = local_fe8[-1];
						by1 = *local_fe8;
						if (iVar5 == 0) {
							by1 -= 1;
						}
						else {
							if (iVar5 == 1) {
								uVar13 += 1;
							}
							else {
								if (iVar5 == 2) {
									by1 += 1;
								}
								else {
									if (iVar5 == 3) {
										uVar13 -= 1;
									}
								}
							}
						}
						if ((uVar13 < uVar1) && (by1 < uVar2)) {
							iVar6 = LiveObject_Routing_GetCrossTerrainType
																(liveObj,uVar13,by1,local_fc0[iVar5 * 2] + uVar13,
																 local_fc0[iVar5 * 2 + 1] + by1,0);
							iVar10 = by1 * uVar1 + uVar13;
							if ((*(int *)((int)globs::liveGlobs.UnkSurfaceGrid_2_TABLE + iVar10 * 4) == 0) &&
								 (iVar6 != 0)) {
								uVar7 = (uint)(local_fe4 == 0);
								uVar3 = local_fd0[uVar7];
								iVar6 = uVar3 + uVar7 * 100;
								local_fc0[iVar6 * 5 + 8] = uVar13;
								local_fc0[iVar6 * 5 + 9] = by1;
								local_fd0[uVar7] = uVar3 + 1;
								*(uint *)((int)globs::liveGlobs.UnkSurfaceGrid_2_TABLE + iVar10 * 4) = uVar12;
								if (param_9 == NULL) {
									if ((uVar13 == param_4) && (by1 == param_5)) {
										local_fec = 1;
									}
								}
								else {
									local_fd0[2] = uVar13;
									local_fd0[3] = by1;
									iVar6 = (*(code *)param_9)(liveObj,local_fd0 + 2,param_10);
									if (iVar6 != 0) {
										local_fec = 1;
										param_4 = uVar13;
										param_5 = by1;
									}
								}
							}
						}
						iVar5 += 1;
					} while (iVar5 < 4);
					local_fdc += 1;
					local_fe8 = local_fe8 + 5;
					if (*local_ff0 <= local_fdc) break;
					iVar5 = 0;
				}
			}
			iVar5 = 0;
			*local_ff0 = 0;
			local_fe4 = (uint)(local_fe4 == 0);
			local_ff0 = local_fd0 + local_fe4;
			if (local_fd0[local_fe4] == 0) {
				local_fec = -1;
			}
		} while (local_fec == 0);
		if (local_fec == -1) {
			return 0;
		}
		local_fd0[0] = uVar12;
		puVar8 = (uint *)std::malloc(uVar12 * 4);
		if ((puVar8 != NULL) && (puVar9 = (uint *)std::malloc(uVar12 * 4), puVar9 != NULL)) {
			local_fec = param_5;
			local_ff0 = puVar9 + local_fe0;
			puVar8[local_fe0] = param_4;
			*local_ff0 = param_5;
			*puVar8 = param_2;
			*puVar9 = param_3;
			if (local_fe0 != 1) {
				pvVar11 = globs::liveGlobs.UnkSurfaceGrid_2_TABLE;
				do {
					local_fdc = 0;
					uVar12 = param_5;
					do {
						uVar13 = param_4;
						if (iVar5 == 0) {
							param_5 = uVar12 - 1;
						}
						else {
							param_5 = uVar12;
							if (iVar5 == 1) {
								uVar13 = param_4 + 1;
							}
							else {
								if (iVar5 == 2) {
									param_5 = uVar12 + 1;
								}
								else {
									if (iVar5 == 3) {
										uVar13 = param_4 - 1;
									}
								}
							}
						}
						if (((uVar13 < uVar1) && (param_5 < uVar2)) &&
							 (uVar12 = local_fec,
							 *(uint *)((int)pvVar11 + (param_5 * uVar1 + uVar13) * 4) == local_fe0)) {
							*(uint *)((int)puVar8 + (-4 - (int)puVar9) + (int)local_ff0) = uVar13;
							local_ff0[-1] = param_5;
							pvVar11 = globs::liveGlobs.UnkSurfaceGrid_2_TABLE;
							param_4 = uVar13;
							local_fec = param_5;
							break;
						}
						param_5 = uVar12;
						iVar5 += 1;
						if (3 < iVar5) {
							iVar5 = 0;
						}
						local_fdc += 1;
						uVar12 = param_5;
					} while ((int)local_fdc < 4);
					local_fe0 -= 1;
					local_ff0 = local_ff0 + -1;
				} while (local_fe0 != 1);
			}
			*param_6 = puVar8;
			*param_7 = puVar9;
			*param_8 = local_fd0[0];
		}
	}
	return TRUE;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl
lego::game::LiveObject_FUN_004413b0
					(LiveObject *liveObj,uint bx,uint by,uint param_4,uint param_5,uint **param_6,
					uint **param_7,float *param_8,code *callback,undefined4 param_10)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	int iVar4;
	float fVar5;
	bool bVar6;
	SurfaceMap *pSVar7;
	int iVar8;
	BOOL BVar9;
	uint uVar10;
	uint *puVar11;
	uint *buffer;
	uint uVar12;
	uint uVar13;
	uint uVar14;
	uint uVar15;
	undefined4 *puVar16;
	uint uVar17;
	int iStack4108;
	uint *puStack4104;
	uint uStack4096;
	float fStack4092;
	float fStack4088;
	uint *puStack4080;
	int iStack4076;
	uint uStack4068;
	uint auStack4060 [2];
	float fStack4052;
	Point2I PStack4048;
	Point2I PStack4040;
	int aiStack4032 [4];
	undefined4 uStack4016;
	undefined4 uStack4012;
	undefined4 uStack4008;
	undefined4 uStack4004;
	uint auStack4000 [999];
	undefined4 uStack4;
	
	uStack4 = 0x4413ba;
	aiStack4032[0] = 0;
	aiStack4032[1] = 0xffffffff;
	aiStack4032[2] = 1;
	aiStack4032[3] = 0;
	uStack4016 = 0;
	uStack4012 = 1;
	uStack4008 = 0xffffffff;
	uStack4004 = 0;
	iStack4076 = 0;
	bVar6 = false;
	pSVar7 = lrr::Lego_GetMap();
	uVar12 = (pSVar7->smallDimensions).width;
	uVar13 = (pSVar7->smallDimensions).height;
	if (uVar12 <= bx) {
		return 0;
	}
	if (uVar13 <= by) {
		return 0;
	}
	if (callback == NULL) {
		if (uVar12 <= param_4) {
			return 0;
		}
		if (uVar13 <= param_5) {
			return 0;
		}
		iVar8 = LiveObject_Routing_GetCrossTerrainType(liveObj,param_4,param_5,param_4,param_5,0);
		if (iVar8 == 0) {
			return 0;
		}
	}
	if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
		if (globs::liveGlobs.UnkSurfaceGrid_COUNT == uVar13 * uVar12) goto LAB_004414be;
		if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
			std::free(globs::liveGlobs.UnkSurfaceGrid_1_TABLE);
		}
	}
	globs::liveGlobs.UnkSurfaceGrid_COUNT = uVar13 * uVar12;
	globs::liveGlobs.UnkSurfaceGrid_1_TABLE = std::malloc(globs::liveGlobs.UnkSurfaceGrid_COUNT * 4);
LAB_004414be:
	iVar8 = uVar13 * uVar12;
	puVar16 = (undefined4 *)globs::liveGlobs.UnkSurfaceGrid_1_TABLE;
	if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
		for (; iVar8 != 0; iVar8 += -1) {
			*puVar16 = 0;
			puVar16 = puVar16 + 1;
		}
		fStack4092 = 1.401298e-45;
		auStack4060[0] = 1;
		puStack4104 = auStack4060;
		uStack4096 = 0;
		*(undefined4 *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE + (uVar12 * by + bx) * 4) =
				 0x3f800000;
		auStack4000[0] = bx;
		auStack4000[1] = by;
		auStack4060[1] = 0;
		do {
			fStack4092 = (float)((int)fStack4092 + 1);
			uStack4068 = 0;
			if (*puStack4104 != 0) {
				puVar11 = auStack4000 + uStack4096 * 500 + 1;
				do {
					fVar2 = *(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE +
														(uVar12 * *puVar11 + puVar11[-1]) * 4);
					iStack4108 = 0;
					do {
						uVar14 = puVar11[-1];
						uVar17 = *puVar11;
						if (iStack4108 == 0) {
							uVar17 -= 1;
						}
						else {
							if (iStack4108 == 1) {
								uVar14 += 1;
							}
							else {
								if (iStack4108 == 2) {
									uVar17 += 1;
								}
								else {
									if (iStack4108 == 3) {
										uVar14 -= 1;
									}
								}
							}
						}
						if ((uVar14 < uVar12) && (uVar17 < uVar13)) {
							fStack4088 = 1.0;
							iVar8 = aiStack4032[iStack4108 * 2];
							iVar4 = aiStack4032[iStack4108 * 2 + 1];
							PStack4040.x = iVar8 + uVar14;
							PStack4040.y = iVar4 + uVar17;
							BVar9 = Level_Block_IsPath(&PStack4040);
							if (BVar9 != 0) {
								fStack4088 = 0.5;
							}
							iVar8 = LiveObject_Routing_GetCrossTerrainType
																(liveObj,uVar14,uVar17,iVar8 + uVar14,iVar4 + uVar17,0);
							if ((iVar8 != 0) &&
								 ((iVar8 = uVar17 * uVar12 + uVar14,
									pfVar1 = (float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE + iVar8 * 4),
									*(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE + iVar8 * 4) == 0.0 ||
									(fVar5 = fStack4088 + fVar2, fVar3 = *pfVar1,
									(ushort)((ushort)(fVar3 < fVar5) << 8 | (ushort)(fVar3 == fVar5) << 0xe) == 0))))
							{
								uVar10 = (uint)(uStack4096 == 0);
								uVar15 = auStack4060[uVar10];
								iVar8 = uVar15 + uVar10 * 100;
								*pfVar1 = fStack4088 + fVar2;
								auStack4000[iVar8 * 5] = uVar14;
								auStack4000[iVar8 * 5 + 1] = uVar17;
								auStack4060[uVar10] = uVar15 + 1;
								if (callback == NULL) {
									if ((uVar14 == param_4) && (uVar17 == param_5)) {
										bVar6 = true;
										fStack4052 = fStack4092;
									}
								}
								else {
									PStack4048.x = uVar14;
									PStack4048.y = uVar17;
									iVar8 = (*callback)(liveObj,&PStack4048,param_10);
									if (iVar8 != 0) {
										iStack4076 = 1;
										param_4 = uVar14;
										param_5 = uVar17;
									}
								}
							}
						}
						iStack4108 += 1;
					} while (iStack4108 < 4);
					uStack4068 += 1;
					puVar11 = puVar11 + 5;
				} while (uStack4068 < *puStack4104);
			}
			*puStack4104 = 0;
			uStack4096 = (uint)(uStack4096 == 0);
			puStack4104 = auStack4060 + uStack4096;
			if (auStack4060[uStack4096] == 0) {
				iStack4076 = -1;
			}
		} while (iStack4076 == 0);
		if (bVar6) {
			iStack4076 = 1;
			fStack4092 = fStack4052;
		}
		if (iStack4076 == -1) {
			return 0;
		}
		puVar11 = (uint *)std::malloc((int)fStack4092 * 4);
		if ((puVar11 != NULL) && (buffer = (uint *)std::malloc((int)fStack4092 * 4), buffer != NULL)) {
			iVar8 = (int)fStack4092 + -1;
			puVar11[iVar8] = param_4;
			puStack4080 = buffer + iVar8;
			*puStack4080 = param_5;
			*puVar11 = bx;
			*buffer = by;
			if (iVar8 != 1) {
				uStack4068 = (int)fStack4092 + -2;
				uVar14 = param_4;
				uVar17 = param_5;
				do {
					puStack4104 = (uint *)0x461c4000;
					iStack4108 = 0;
					do {
						uVar15 = uVar14;
						if (iStack4108 == 0) {
							uVar10 = uVar17 - 1;
						}
						else {
							uVar10 = uVar17;
							if (iStack4108 == 1) {
								uVar15 = uVar14 + 1;
							}
							else {
								if (iStack4108 == 2) {
									uVar10 = uVar17 + 1;
								}
								else {
									if (iStack4108 == 3) {
										uVar15 = uVar14 - 1;
									}
								}
							}
						}
						PStack4048.x = uVar15;
						PStack4048.y = uVar10;
						if (((uVar15 < uVar12) && (uVar10 < uVar13)) &&
							 (((fStack4052 = *(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE +
																				 (uVar17 * uVar12 + uVar14) * 4) -
															 *(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE +
																				 (uVar10 * uVar12 + uVar15) * 4),
								 (ushort)((ushort)(fStack4052 < 0.0) << 8 | (ushort)(fStack4052 == 0.0) << 0xe) == 0
								 && (fStack4052 < (float)puStack4104)) ||
								((fStack4052 == (float)puStack4104 &&
								 (BVar9 = Level_Block_IsPath(&PStack4048), BVar9 != 0)))))) {
							puStack4104 = (uint *)fStack4052;
							auStack4060[0] = uVar15;
							auStack4060[1] = uVar10;
						}
						iStack4108 += 1;
					} while (iStack4108 < 4);
					puStack4080 = puStack4080 + -1;
					*(uint *)(((int)puVar11 - (int)buffer) + (int)puStack4080) = auStack4060[0];
					*puStack4080 = auStack4060[1];
					uStack4068 += -1;
					uVar14 = auStack4060[0];
					uVar17 = auStack4060[1];
				} while (uStack4068 != 0);
			}
			*param_6 = puVar11;
			*param_7 = buffer;
			*param_8 = fStack4092;
			if (((*puVar11 != puVar11[1]) ||
					(uVar12 = (int)(*buffer - buffer[1]) >> 0x1f, (*buffer - buffer[1] ^ uVar12) - uVar12 != 1
					)) && ((*buffer != buffer[1] ||
								 (uVar12 = *puVar11 - puVar11[1], uVar13 = (int)uVar12 >> 0x1f,
								 (uVar12 ^ uVar13) - uVar13 != 1)))) {
				std::free(puVar11);
				std::free(buffer);
				BVar9 = LiveObject_FUN_00440f30
													(liveObj,bx,by,param_4,param_5,param_6,param_7,(uint *)param_8,callback,
													 param_10);
				return BVar9;
			}
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPtr_Alloc_FUN_004419c0
					(LiveObject *liveObj,uint count,float *param_3,float *param_4,float *param_5)
{
	bool bVar1;
	BOOL BVar2;
	RoutingBlock *buffer;
	SurfaceMap *surfMap;
	ObjectStatsFlags1 OVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	Point2F *pPVar7;
	float *pfVar8;
	float10 fVar9;
	Point2F *pPVar10;
	Point2F *pPVar11;
	Point2F *pPVar12;
	uint i;
	int local_14;
	Point2F local_8;
	
	BVar2 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar2 == 0) {
		local_14 = -1;
		bVar1 = false;
		local_8.x = 0.5;
		local_8.y = 0.5;
		if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
			liveObj->object_2fc = NULL;
			liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		}
		buffer = (RoutingBlock *)std::malloc(count * 0x14);
		if ((buffer != NULL) && (i = 0, count != 0)) {
			pPVar7 = &buffer->worldPos;
			iVar6 = (int)param_4 - (int)param_3;
			do {
				pfVar8 = param_3 + 1;
				pPVar7[-1].x = *param_3;
				pPVar7[-1].y = *param_4;
				if ((param_5 == NULL) || (i != count - 1)) {
					if (((liveObj->flags3 & LIVEOBJ3_UNK_1000) == LIVEOBJ3_NONE) &&
						 (OVar3 = stats::StatsObject_GetStatsFlags1(liveObj),
						 (OVar3 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE)) {
						fVar9 = math::Maths_RandRange(0.3,0.7);
						pPVar7->x = (float)fVar9;
						fVar9 = math::Maths_RandRange(0.3,0.7);
						pPVar7->y = (float)fVar9;
					}
					else {
						pPVar7->y = 0.5;
						pPVar7->x = 0.5;
					}
				}
				else {
					pPVar12 = &local_8;
					pPVar11 = NULL;
					pPVar10 = (Point2F *)param_5;
					surfMap = lrr::Lego_GetMap();
					Map3D_FUN_0044fb30(surfMap,pPVar10,pPVar11,pPVar12);
					pPVar7->x = local_8.x;
					pPVar7->y = local_8.y;
				}
				*(undefined *)&pPVar7[1].x = 0;
				*(undefined *)((int)&pPVar7[1].x + 1) = 0;
				iVar4 = local_14;
				if (i < count - 1) {
					iVar4 = Map3D_CheckComparison_FUN_00450b60
														((int)*pfVar8,*(int *)(iVar6 + (int)pfVar8),(int)*param_3,(int)*param_4)
					;
					if (iVar4 == -1) {
						bVar1 = true;
						break;
					}
					if (((i != 0) && (local_14 != iVar4)) &&
						 (iVar5 = LiveObject_Routing_GetCrossTerrainType
																(liveObj,(int)*pfVar8,*(int *)(iVar6 + (int)pfVar8),(int)param_3[-1]
																 ,(int)param_4[-1],0), iVar5 == 2)) {
						*(byte *)&pPVar7[1].x = *(byte *)&pPVar7[1].x | 0x10;
					}
				}
				local_14 = iVar4;
				i += 1;
				param_4 = param_4 + 1;
				pPVar7 = (Point2F *)&pPVar7[2].y;
				param_3 = pfVar8;
			} while (i < count);
		}
		if (!bVar1) {
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_400;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_MOVING;
			liveObj->routeptr_24 = buffer;
			liveObj->routingBlocksTotal = count;
			liveObj->routingBlocksCurrent = 0;
			(liveObj->vector_28c).y = 0.0;
			(liveObj->vector_28c).x = 0.0;
			return TRUE;
		}
		std::free(buffer);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_UnkDoRouting_FUN_00441c00(LiveObject *in_liveObj,BOOL param_2)
{
	LiveFlags4 *pLVar1;
	float fVar2;
	LiveFlags1 LVar3;
	LiveFlags3 LVar4;
	LiveObject *pLVar5;
	uint uVar6;
	byte *pbVar7;
	longlong lVar8;
	Point2I point;
	
	if (in_liveObj->routeptr_24 != NULL) {
		if (param_2 == 0) {
			uVar6 = in_liveObj->routingBlocksCurrent;
			if (uVar6 < in_liveObj->routingBlocksTotal) {
				pbVar7 = &in_liveObj->routeptr_24[uVar6].byte_11;
				do {
					if (*pbVar7 == 3) {
						pLVar5 = in_liveObj->object_2fc;
						if (pLVar5 != NULL) {
							if (pLVar5->objType == OBJECT_BOULDER) {
								LiveObject_DestroyBoulder_AndCreateExplode(pLVar5);
							}
							else {
								pLVar5->object_300 = NULL;
							}
LAB_00441ca7:
							in_liveObj->object_2fc = NULL;
						}
						break;
					}
					if (*pbVar7 == 7) goto LAB_00441ca7;
					uVar6 += 1;
					pbVar7 = pbVar7 + 0x14;
				} while (uVar6 < in_liveObj->routingBlocksTotal);
			}
			if (in_liveObj->objType == OBJECT_ROCKMONSTER) {
				if (((in_liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
					 (in_liveObj->carriedObjects[0]->objType == OBJECT_BOULDER)) {
					LiveObject_DropCarriedObject_FUN_0043a130(in_liveObj,0);
				}
				ai::AITask_LiveObject_FUN_00403b30(in_liveObj,AITASK_GATHER,NULL);
				ai::AITask_LiveObject_FUN_00403b30(in_liveObj,AITASK_REPAIR,NULL);
			}
			if ((*(byte *)&in_liveObj->flags1 & 8) != 0) {
				lVar8 = __ftol((float10)(in_liveObj->point_2f4).x);
				point.x = (int)lVar8;
				lVar8 = __ftol((float10)(in_liveObj->point_2f4).y);
				point.y = (int)lVar8;
				Level_Block_SetBusy(&point,0);
			}
			ai::AITask_Game_UnkLiveObjectHandleDynamite(in_liveObj);
		}
		else {
			if (in_liveObj->objType == OBJECT_MINIFIGURE) {
				res::Creature_SetOrientation
									(in_liveObj->miniFigure,(in_liveObj->point_298).x,(in_liveObj->point_298).y);
				fVar2 = (in_liveObj->point_298).y;
				(in_liveObj->faceDirection).x = (in_liveObj->point_298).x;
				(in_liveObj->faceDirection).y = fVar2;
			}
		}
		std::free(in_liveObj->routeptr_24);
		in_liveObj->routeptr_24 = NULL;
		ai::AITask_LiveObject_FUN_00403a20(in_liveObj,param_2);
	}
	LVar3 = in_liveObj->flags1;
	LVar4 = in_liveObj->flags3;
	pLVar5 = in_liveObj->object_2fc;
	in_liveObj->routingBlocksTotal = 0;
	in_liveObj->routingBlocksCurrent = 0;
	(in_liveObj->vector_28c).y = 0.0;
	(in_liveObj->vector_28c).x = 0.0;
	(in_liveObj->vector_28c).z = 0.0;
	in_liveObj->flags1 = LVar3 & ~(LIVEOBJ1_MOVING|LIVEOBJ1_UNK_800000);
	in_liveObj->flags3 = LVar4 & ~(LIVEOBJ3_UNK_400|LIVEOBJ3_UNK_4000);
	if (pLVar5 != NULL) {
		pLVar1 = &pLVar5->flags4;
		*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_10;
	}
	if ((*(byte *)&in_liveObj->flags1 & 2) != 0) {
		(in_liveObj->faceDirection).x = (in_liveObj->faceDirection).x * -1.0;
		(in_liveObj->faceDirection).y = (in_liveObj->faceDirection).y * -1.0;
		(in_liveObj->faceDirection).z = (in_liveObj->faceDirection).z * -1.0;
		in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_LIFTING;
	}
	LiveObject_SetActivityUnk(in_liveObj,ACTIVITY_STAND,0);
	return;
}



void __cdecl lego::game::LiveObject_FUN_00441df0(LiveObject *liveObj,BOOL param_2,BOOL param_3)
{
	LiveFlags2 *pLVar1;
	LiveFlags3 *pLVar2;
	LiveFlags2 LVar3;
	LiveFlags1 LVar4;
	ObjectStatsFlags2 OVar5;
	longlong lVar6;
	Point2I local_8;
	
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
	if (param_3 != 0) {
		LiveObject_DropCarriedObject_FUN_0043a130(liveObj,FALSE);
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_2;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_GETUP,0);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100;
		LVar3 = liveObj->object_3c0->flags2;
		if ((LVar3 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
			liveObj->object_3c0->flags2 = LVar3 & ~LIVEOBJ2_UNK_1;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,FALSE);
		LVar3 = liveObj->object_3c0->flags2;
		if ((LVar3 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
			liveObj->object_3c0->flags2 = LVar3 & ~LIVEOBJ2_UNK_2;
			LiveObject_SetActivityUnk(liveObj->object_3c0,ACTIVITY_GETUP,FALSE);
			LiveObject_Container_ActivityUpdate_Check(liveObj->object_3c0);
			pLVar1 = &liveObj->object_3c0->flags2;
			*pLVar1 = *pLVar1 | LIVEOBJ2_UNK_100;
		}
	}
	LVar4 = liveObj->flags1;
	liveObj->flags2 =
			 liveObj->flags2 &
			 ~(LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_4000|LIVEOBJ2_UNK_400000|LIVEOBJ2_UNK_800000|
				LIVEOBJ2_UNK_1000000);
	liveObj->flags1 = LVar4 & ~(LIVEOBJ1_UNK_800|LIVEOBJ1_UNK_10000000|LIVEOBJ1_UNK_80000000);
	if ((LVar4 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
		liveObj->flags1 =
				 LVar4 & ~(LIVEOBJ1_UNK_800|LIVEOBJ1_UNK_2000|LIVEOBJ1_UNK_10000000|LIVEOBJ1_UNK_80000000);
		ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DEPOSITE,liveObj,TRUE);
		LiveObject_ProcCarriedObjects_FUN_0043f160(liveObj);
		if (liveObj->object_2fc != NULL) {
			pLVar2 = &liveObj->object_2fc->flags3;
			*pLVar2 = *pLVar2 & ~LIVEOBJ3_UNK_1000000;
		}
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~(LIVEOBJ1_UNK_200|LIVEOBJ1_REST);
	liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
	if ((liveObj->flags2 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200000;
	}
	LVar3 = liveObj->flags2;
	liveObj->flags2 = LVar3 & ~LIVEOBJ2_UNK_40000;
	if ((LVar4 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
		liveObj->flags2 = LVar3 & ~(LIVEOBJ2_UNK_40000|LIVEOBJ2_UNK_80000);
		ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,TRUE);
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_1000000;
	}
	if ((liveObj->flags1 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_EATING;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_40) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_40;
	}
	if ((liveObj->flags2 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_TRAINING;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) {
		if (liveObj->object_2fc != NULL) {
			OVar5 = stats::StatsObject_GetStatsFlags2(liveObj->object_2fc);
			if ((OVar5 & STATS2_UPGRADEBUILDING) != STATS2_NONE) {
				if ((liveObj->object_2fc->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) goto LAB_00442065;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,TRUE);
				liveObj->object_2fc->object_300 = NULL;
				liveObj->object_2fc = NULL;
			}
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
	}
LAB_00442065:
	if ((liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_PLACING;
		LiveObject_DropCarriedObject_FUN_0043a130(liveObj,TRUE);
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~LIVEOBJ1_UNK_1000;
	if ((LVar4 & LIVEOBJ1_REINFORCING) != LIVEOBJ1_NONE) {
		lVar6 = __ftol((float10)(liveObj->point_2f4).x);
		local_8.x = (int)lVar6;
		lVar6 = __ftol((float10)(liveObj->point_2f4).y);
		local_8.y = (int)lVar6;
		liveObj->flags1 = LVar4 & ~(LIVEOBJ1_REINFORCING|LIVEOBJ1_UNK_1000) | LIVEOBJ1_UNK_80000000;
		Level_Block_SetBusy(&local_8,FALSE);
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~LIVEOBJ1_UNK_4000000;
	if ((liveObj->flags2 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
		liveObj->object_2fc = NULL;
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4;
	}
	liveObj->flags1 =
			 LVar4 & ~(LIVEOBJ1_UNK_8000|LIVEOBJ1_UNK_10000|LIVEOBJ1_CLEARING|LIVEOBJ1_UNK_4000000|
								LIVEOBJ1_UNK_80000000);
	liveObj->flags2 =
			 liveObj->flags2 & ~(LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000);
	if (param_2 != 0) {
		ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(liveObj);
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,TRUE);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
	}
	return;
}



void __cdecl lego::game::LiveObject_DestroyBoulder_AndCreateExplode(LiveObject *liveObj)
{
	if ((((byte)globs::liveGlobs.flags & 2) == 0) && (liveObj->objType == OBJECT_BOULDER)) {
		effect::Effect_Spawn_BoulderExplode_AtObjectOther(liveObj);
		LiveObject_Remove(liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Proc_FUN_00442190(LiveObject *liveObj,LiveObject *targetObj,int param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	Container *pCVar5;
	LiveFlags2 LVar6;
	float10 fVar7;
	Container *pCVar8;
	Vector3F *pVVar9;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	if ((((ushort)((ushort)((float)liveObj->field_360 < 0.0) << 8 |
								(ushort)((float)liveObj->field_360 == 0.0) << 0xe) == 0) ||
			(((byte)globs::legoGlobs.flags2 & 4) != 0)) || (targetObj->objType != OBJECT_ROCKMONSTER)) {
		return 0;
	}
	BVar4 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar4 != 0) {
		return 0;
	}
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	pVVar9 = &local_18;
	pCVar8 = NULL;
	pCVar5 = LiveObject_GetContainer(targetObj);
	res::Container_GetPosition(pCVar5,pCVar8,pVVar9);
	pVVar9 = &local_c;
	pCVar8 = NULL;
	pCVar5 = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(pCVar5,pCVar8,pVVar9);
	fVar7 = stats::StatsObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)local_c.z - fVar7 * (float10)0.5);
	fVar7 = stats::StatsObject_GetCollHeight(targetObj);
	fVar7 = (float10)local_18.z - fVar7 * (float10)0.5;
	local_18.z = (float)fVar7;
	fVar7 = fVar7 - (float10)local_c.z;
	fVar1 = (float)((float10)local_18.x - (float10)local_c.x);
	fVar2 = (float)((float10)local_18.y - (float10)local_c.y);
	fVar3 = (float)fVar7;
	fVar7 = (float10)1.0 /
					SQRT(fVar7 * (float10)fVar3 +
							 ((float10)local_18.y - (float10)local_c.y) * (float10)fVar2 +
							 ((float10)local_18.x - (float10)local_c.x) * (float10)fVar1);
	local_24.x = (float)(fVar7 * (float10)fVar1);
	local_24.y = (float)(fVar7 * (float10)fVar2);
	local_24.z = (float)(fVar7 * (float10)fVar3);
	LiveObject_UnkUpdateOrientation(liveObj,0.0,&local_24);
	if (param_3 == 1) {
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_400000;
	}
	else {
		if (param_3 == 2) {
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_800000;
		}
		else {
			if (param_3 != 3) goto LAB_0044233f;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_1000000;
		}
	}
	liveObj->flags2 = LVar6;
LAB_0044233f:
	liveObj->field_3a8 = local_18.x;
	liveObj->field_3ac = local_18.y;
	liveObj->field_39c = local_24.x;
	liveObj->field_3b0 = local_18.z;
	liveObj->field_3a0 = local_24.y;
	liveObj->field_3a4 = local_24.z;
	return TRUE;
}



void __cdecl lego::game::Game_GetWeaponUnk(LiveObject *liveObj,int weaponType)
{
	SurfaceMap *surfMap;
	float weaponType_00;
	float10 fVar1;
	Vector3F local_c;
	
	LiveObject_GetPosition(liveObj,&local_c.x,&local_c.y);
	surfMap = lrr::Lego_GetMap();
	fVar1 = Map3D_GetWorldZ(surfMap,local_c.x,local_c.y);
	weaponType_00 = (float)fVar1;
	fVar1 = stats::StatsObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)weaponType_00 - fVar1 * (float10)0.5);
	switch(weaponType) {
	case 1:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Lazer");
		tools::Weapon_Struct2B0_FUN_0046fdb0
							(liveObj,&local_c,(Vector3F *)&liveObj->field_39c,(uint)weaponType_00,1);
		break;
	case 2:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Pusher");
		tools::Weapon_Struct2B0_FUN_0046fdb0
							(liveObj,&local_c,(Vector3F *)&liveObj->field_39c,(uint)weaponType_00,2);
		break;
	case 3:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Freezer");
		tools::Weapon_Struct2B0_FUN_0046fdb0
							(liveObj,&local_c,(Vector3F *)&liveObj->field_39c,(uint)weaponType_00,3);
		break;
	case 4:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Lazer");
		tools::Weapon_UpdateRoutingUnk_FUN_0046ff30
							(liveObj,&local_c,(Vector3F *)&liveObj->field_3a8,weaponType_00,WEAPONKNOWN_LAZER_4);
	}
	fVar1 = tools::Weapon_GetRechargeTime((int)weaponType_00);
	liveObj->field_360 = (float)fVar1;
	return;
}



void __cdecl lego::game::LiveObject_UnkActivityCrumble_FUN_004424d0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	LiveObject_FUN_00441df0(liveObj,0,1);
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_CRUMBLE,1);
	BVar1 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar1 != 0) {
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100000;
	}
	liveObj->health = -1.0;
	return;
}



void __cdecl lego::game::LiveObject_GetPosition(LiveObject *liveObj,float *out_x,float *out_y)
{
	Container *cont;
	Vector3F vector;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,&vector);
	*out_x = vector.x;
	*out_y = vector.y;
	return;
}



void __cdecl lego::game::LiveObject_GetFaceDirection(LiveObject *liveObj,Point2F *out_direction)
{
	Container *cont;
	Vector3F vecDir;
	float norm;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetOrientation(cont,NULL,&vecDir,NULL);
	norm = 1.0 / SQRT(vecDir.x * vecDir.x + vecDir.y * vecDir.y);
	out_direction->x = norm * vecDir.x;
	out_direction->y = norm * vecDir.y;
	return;
}



void __cdecl
lego::game::LiveObject_UnkUpdateOrientation(LiveObject *liveObj,float theta,Vector3F *dvector)
{
	ObjectType OVar1;
	Vector3F local_18;
	Vector3F local_c;
	
	if (dvector == NULL) {
		local_18.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 1.0;
		local_c.y = 0.0;
		local_c.x = 0.0;
		local_c.z = -1.0;
		math::Maths_Vector3DRotate(&local_18,&local_18,&local_c,theta);
	}
	else {
		local_18.x = dvector->x;
		local_18.y = dvector->y;
		local_18.z = dvector->z;
	}
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		res::Vehicle_SetOrientation(liveObj->vehicle,local_18.x,local_18.y,local_18.z);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			res::Creature_SetOrientation(liveObj->miniFigure,local_18.x,local_18.y);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				res::Creature_SetOrientation(liveObj->rockMonster,local_18.x,local_18.y);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					res::Building_SetOrientation(liveObj->building,local_18.x,local_18.y);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						res::Container_SetOrientation
											(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
					}
				}
			}
		}
	}
	liveObj->float_2b8 = 0.01;
	(liveObj->faceDirection).x = local_18.x;
	(liveObj->faceDirection).y = local_18.y;
	(liveObj->faceDirection).z = local_18.z;
	(liveObj->vector_2a0).x = (liveObj->faceDirection).x * -0.01;
	(liveObj->vector_2a0).y = (liveObj->faceDirection).y * -0.01;
	(liveObj->vector_2a0).z = (liveObj->faceDirection).z * -0.01;
	return;
}



// Returns faceDirection in radians (always positive value between 0 and M_PI*2)

float10 __cdecl lego::game::LiveObject_GetHeading(LiveObject *liveObj)
{
	float10 fVar1;
	Point2F faceDir;
	
	LiveObject_GetFaceDirection(liveObj,&faceDir);
						// Ignoring the insane double-sqrt going on here... shoudn't this be std::atan???
	fVar1 = std::acos((float10)faceDir.y /
										(SQRT((float10)1.0) *
										SQRT((float10)faceDir.y * (float10)faceDir.y +
												 (float10)faceDir.x * (float10)faceDir.x)));
	if (faceDir.x < 0.0) {
		fVar1 = (float10)6.283185 - fVar1;
	}
	return fVar1;
}



BOOL __cdecl lego::game::LiveObject_GetBlockPos(LiveObject *liveObj,int *out_bx,int *out_by)
{
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	Vector3F position;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,&position);
	surfMap = lrr::Lego_GetMap();
	BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,position.x,position.y,out_bx,out_by);
	return BVar1;
}



float10 __cdecl lego::res::SurfaceMap_GetSurfaceZ(float x,float y,SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = game::Map3D_GetWorldZ(surfMap,x,y);
	return fVar1;
}



float10 __cdecl
lego::game::SurfaceMap_LevelCallback_FUN_00442820(float x,float y,SurfaceMap *surfMap)
{
	BOOL BVar1;
	float10 fVar2;
	float z_modifier;
	Point2I blockPos;
	
	z_modifier = 0.0;
	BVar1 = Map3D_WorldToBlockPos(surfMap,x,y,&blockPos.x,&blockPos.y,&z_modifier);
	if (BVar1 != 0) {
		if ((globs::legoGlobs.level)->blocks
				[((globs::legoGlobs.level)->dimensions).width * blockPos.y + blockPos.x].terrain ==
				TERRAIN_LAKE) {
			z_modifier = z_modifier * 8.0;
		}
		else {
			z_modifier = 0.0;
		}
	}
	fVar2 = Map3D_GetWorldZ(surfMap,x,y);
	return fVar2 + (float10)z_modifier;
}



void __cdecl lego::game::LiveObject_FUN_004428b0(LiveObject *liveObj,float x,float y)
{
	ObjectType OVar1;
	Container *cont;
	SurfaceMap *pSVar2;
	VehicleData *vehicle;
	float fVar3;
	float fVar4;
	float fVar5;
	Vector3F local_c;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		cont = res::Vehicle_GetActivityContainer(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			cont = res::Object_GetActivityContainer((BasicObjectData *)liveObj->miniFigure);
		}
		else {
			cont = (Container *)y;
			if (OVar1 == OBJECT_ROCKMONSTER) {
				cont = res::Object_GetActivityContainer((BasicObjectData *)liveObj->rockMonster);
			}
		}
	}
	res::Container_GetPosition(cont,NULL,&local_c);
	if ((x != local_c.x) || (y != local_c.y)) {
		(liveObj->faceDirection).z = 0.0;
		(liveObj->faceDirection).x = x;
		(liveObj->faceDirection).y = y;
		(liveObj->vector_2a0).x = local_c.x;
		(liveObj->vector_2a0).y = local_c.y;
		(liveObj->vector_2a0).z = local_c.z;
		(liveObj->faceDirection).x = (liveObj->faceDirection).x - (liveObj->vector_2a0).x;
		(liveObj->faceDirection).y = (liveObj->faceDirection).y - (liveObj->vector_2a0).y;
		(liveObj->faceDirection).z = (liveObj->faceDirection).z - (liveObj->vector_2a0).z;
		(liveObj->faceDirection).z = 0.0;
		fVar4 = (liveObj->faceDirection).z;
		fVar3 = (liveObj->faceDirection).y;
		fVar5 = (liveObj->faceDirection).x;
		fVar4 = SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar3 * fVar3);
		fVar5 = 1.0 / fVar4;
		liveObj->float_2b8 = fVar4;
		(liveObj->faceDirection).x = fVar5 * (liveObj->faceDirection).x;
		(liveObj->faceDirection).y = (liveObj->faceDirection).y * fVar5;
		(liveObj->faceDirection).z = (liveObj->faceDirection).z * fVar5;
	}
	OVar1 = liveObj->objType;
	if (OVar1 != OBJECT_VEHICLE) {
		if (OVar1 != OBJECT_MINIFIGURE) {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				res::Creature_SetOrientation
									(liveObj->rockMonster,(liveObj->faceDirection).x,(liveObj->faceDirection).y);
				pSVar2 = lrr::Lego_GetMap();
				res::Creature_SetPosition(liveObj->rockMonster,x,y,res::SurfaceMap_GetSurfaceZ,pSVar2);
			}
			return;
		}
		if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_LIFTING) == 0) {
			fVar5 = (liveObj->faceDirection).y;
			fVar4 = (liveObj->faceDirection).x;
		}
		else {
			fVar5 = -(liveObj->faceDirection).y;
			fVar4 = -(liveObj->faceDirection).x;
		}
		res::Creature_SetOrientation(liveObj->miniFigure,fVar4,fVar5);
		pSVar2 = lrr::Lego_GetMap();
		res::Creature_SetPosition(liveObj->miniFigure,x,y,SurfaceMap_LevelCallback_FUN_00442820,pSVar2);
		return;
	}
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_LIFTING) == 0) {
		fVar5 = (liveObj->faceDirection).z;
		fVar4 = (liveObj->faceDirection).y;
		fVar3 = (liveObj->faceDirection).x;
		vehicle = liveObj->vehicle;
	}
	else {
		vehicle = liveObj->vehicle;
		fVar5 = -(liveObj->faceDirection).z;
		fVar4 = -(liveObj->faceDirection).y;
		fVar3 = -(liveObj->faceDirection).x;
	}
	res::Vehicle_SetOrientation(vehicle,fVar3,fVar4,fVar5);
	pSVar2 = lrr::Lego_GetMap();
	res::Vehicle_SetPosition(liveObj->vehicle,x,y,res::SurfaceMap_GetSurfaceZ,pSVar2);
	return;
}



void __cdecl
lego::game::LiveObject_SetPositionAndHeading
					(LiveObject *liveObj,float xPos,float yPos,float heading,BOOL includeHeading)
{
	ObjectType OVar1;
	SurfaceMap *pSVar2;
	float10 fVar3;
	float x;
	float y;
	Vector3F orientation;
	Vector3F axis;
	
	if (includeHeading != 0) {
		orientation.z = 0.0;
		orientation.x = 0.0;
		orientation.y = 1.0;
		axis.y = 0.0;
		axis.x = 0.0;
		axis.z = -1.0;
		math::Maths_Vector3DRotate(&orientation,&orientation,&axis,heading);
	}
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		if (includeHeading != 0) {
			res::Vehicle_SetOrientation(liveObj->vehicle,orientation.x,orientation.y,orientation.z);
		}
		pSVar2 = lrr::Lego_GetMap();
		res::Vehicle_SetPosition(liveObj->vehicle,xPos,yPos,res::SurfaceMap_GetSurfaceZ,pSVar2);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			if (includeHeading != 0) {
				res::Creature_SetOrientation(liveObj->miniFigure,orientation.x,orientation.y);
			}
			pSVar2 = lrr::Lego_GetMap();
			res::Creature_SetPosition
								(liveObj->miniFigure,xPos,yPos,SurfaceMap_LevelCallback_FUN_00442820,pSVar2);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				if (includeHeading != 0) {
					res::Creature_SetOrientation(liveObj->rockMonster,orientation.x,orientation.y);
				}
				pSVar2 = lrr::Lego_GetMap();
				res::Creature_SetPosition(liveObj->rockMonster,xPos,yPos,res::SurfaceMap_GetSurfaceZ,pSVar2)
				;
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					if (includeHeading != 0) {
						res::Building_SetOrientation(liveObj->building,orientation.x,orientation.y);
					}
					pSVar2 = lrr::Lego_GetMap();
					res::Building_SetPosition(liveObj->building,xPos,yPos,res::SurfaceMap_GetSurfaceZ,pSVar2);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						if (includeHeading != 0) {
							res::Container_SetOrientation
												(liveObj->other,NULL,orientation.x,orientation.y,orientation.z,0.0,0.0,-1.0)
							;
						}
						x = xPos;
						y = yPos;
						pSVar2 = lrr::Lego_GetMap();
						fVar3 = Map3D_GetWorldZ(pSVar2,x,y);
						res::Container_SetPosition(liveObj->other,NULL,xPos,yPos,(float)fVar3);
					}
				}
			}
		}
	}
	if (includeHeading != 0) {
		(liveObj->faceDirection).x = orientation.x;
		(liveObj->faceDirection).y = orientation.y;
		(liveObj->faceDirection).z = orientation.z;
	}
	liveObj->float_2b8 = 0.01;
	(liveObj->vector_2a0).x = (liveObj->faceDirection).x * -0.01;
	(liveObj->vector_2a0).y = (liveObj->faceDirection).y * -0.01;
	(liveObj->vector_2a0).z = (liveObj->faceDirection).z * -0.01;
	(liveObj->vector_2a0).x = (liveObj->vector_2a0).x + xPos;
	(liveObj->vector_2a0).y = (liveObj->vector_2a0).y + yPos;
	(liveObj->vector_2a0).z = (liveObj->vector_2a0).z;
	return;
}



int __cdecl lego::game::LiveObject_FUN_00442dd0(LiveObject *in_liveObj,float param_2,float *param_3)
{
	ObjectType OVar1;
	bool bVar2;
	LiveObject *in_liveObj_00;
	Container *cont;
	LiveObject *liveObj;
	BOOL BVar3;
	int iVar4;
	SurfaceMap *pSVar5;
	ObjectStatsFlags1 OVar6;
	CreatureData *creature;
	uint uVar7;
	int iVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	Point2F *out_x;
	code *getSurfaceZFunc;
	float *out_y;
	uint local_50;
	float local_4c;
	uint local_48;
	float local_44;
	Point2F local_40;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	in_liveObj_00 = in_liveObj;
	cont = LiveObject_GetContainer(in_liveObj);
	iVar8 = 0;
	uVar7 = (uint)(in_liveObj_00->forwardSpeed_2c0 < 0);
	local_48 = uVar7;
	LiveObject_Callback_FUN_004468d0(in_liveObj_00,param_2,&local_4c,&local_44);
	res::Container_GetOrientation(cont,NULL,&local_24,&local_c);
	res::Container_GetPosition(cont,NULL,&local_18);
	local_38 = local_18.x;
	local_34 = local_18.y;
	if (in_liveObj_00->rotateSpeed_2c4 != 0.0) {
		fVar9 = 1.0;
		if (in_liveObj_00->objType == OBJECT_VEHICLE) {
			if (uVar7 == 0) {
				fVar9 = 1.0;
			}
			else {
				fVar9 = -1.0;
			}
		}
		res::Container_AddRotation
							(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,fVar9 * param_2 * in_liveObj_00->rotateSpeed_2c4
							);
		iVar8 = 1;
		(in_liveObj_00->faceDirection).x = local_24.x;
		(in_liveObj_00->faceDirection).y = local_24.y;
		(in_liveObj_00->faceDirection).z = local_24.z;
	}
	param_2 = (float)in_liveObj_00->strafeSpeed_2bc;
	if ((param_2 != 0.0) || (in_liveObj_00->forwardSpeed_2c0 != 0)) {
		fVar11 = (float)in_liveObj_00->forwardSpeed_2c0;
		fVar10 = (float)(int)param_2;
		local_2c = 0.0;
		fVar9 = 1.0 / SQRT(fVar11 * fVar11 + fVar10 * fVar10);
		local_28 = fVar9 * fVar11 * local_4c;
		local_30 = fVar9 * fVar10 * local_4c;
		res::Container_AddTranslation(cont,D3DRMCOMBINE_BEFORE,local_30,0.0,local_28);
		iVar8 = 1;
	}
	if (iVar8 == 0) goto LAB_00443210;
	bVar2 = false;
	LiveObject_GetBlockPos(in_liveObj_00,(int *)&local_50,(int *)&in_liveObj);
	LiveObject_GetPosition(in_liveObj_00,&local_40.x,&local_40.y);
	liveObj = (LiveObject *)
						LiveObject_DoCollisionCallbacks_FUN_00446030(in_liveObj_00,&local_40,0.0,1);
	if (liveObj != NULL) {
		LiveObject_GetPosition(liveObj,&local_30,&local_2c);
		local_30 = local_40.x - local_30;
		local_2c = local_40.y - local_2c;
		local_38 = local_40.x - local_38;
		local_34 = local_40.y - local_34;
		fVar9 = 1.0 / SQRT(local_34 * local_34 + local_38 * local_38);
		param_2 = 1.0 / SQRT(local_2c * local_2c + local_30 * local_30);
		fVar9 = param_2 * local_2c * fVar9 * local_34 + param_2 * local_30 * fVar9 * local_38;
		if ((ushort)((ushort)(fVar9 < 0.0) << 8 | (ushort)(fVar9 == 0.0) << 0xe) != 0) {
			bVar2 = true;
		}
	}
	BVar3 = Game_IsNoclipOn();
	if ((BVar3 == 0) &&
		 (((iVar4 = LiveObject_Routing_GetCrossTerrainType
													(in_liveObj_00,local_50,(int)in_liveObj,local_50,(int)in_liveObj,1),
			 iVar4 == 0 || (bVar2)) ||
			(BVar3 = Level_Block_IsSeamWall(local_50,(uint)in_liveObj), BVar3 != 0)))) {
		res::Container_SetPosition(cont,NULL,local_18.x,local_18.y,local_18.z);
		res::Container_SetOrientation
							(cont,NULL,local_24.x,local_24.y,local_24.z,local_c.x,local_c.y,local_c.z);
		(in_liveObj_00->faceDirection).x = local_24.x;
		(in_liveObj_00->faceDirection).y = local_24.y;
		(in_liveObj_00->faceDirection).z = local_24.z;
	}
	else {
		BVar3 = Level_Block_IsWall(local_50,(uint)in_liveObj);
		if (BVar3 != 0) {
			out_y = &local_40.y;
			out_x = &local_40;
			fVar11 = 0.0;
			BVar3 = Level_Block_IsFlags1_2000(local_50,(uint)in_liveObj);
			fVar9 = local_40.x;
			fVar10 = local_40.y;
			pSVar5 = lrr::Lego_GetMap();
			Map3D_FUN_0044fe50(pSVar5,fVar9,fVar10,BVar3,fVar11,&out_x->x,out_y);
		}
		OVar1 = in_liveObj_00->objType;
		if (OVar1 == OBJECT_VEHICLE) {
			pSVar5 = lrr::Lego_GetMap();
			res::Vehicle_SetPosition
								(in_liveObj_00->vehicle,local_40.x,local_40.y,res::SurfaceMap_GetSurfaceZ,pSVar5);
		}
		else {
			if (OVar1 == OBJECT_MINIFIGURE) {
				pSVar5 = lrr::Lego_GetMap();
				creature = in_liveObj_00->miniFigure;
				getSurfaceZFunc = SurfaceMap_LevelCallback_FUN_00442820;
			}
			else {
				if (OVar1 != OBJECT_ROCKMONSTER) goto LAB_004431a9;
				pSVar5 = lrr::Lego_GetMap();
				creature = in_liveObj_00->rockMonster;
				getSurfaceZFunc = res::SurfaceMap_GetSurfaceZ;
			}
			res::Creature_SetPosition(creature,local_40.x,local_40.y,getSurfaceZFunc,pSVar5);
		}
	}
LAB_004431a9:
	BVar3 = Level_Block_IsWall(local_50,(uint)in_liveObj);
	if (((BVar3 != 0) &&
			(BVar3 = LiveObject_BlockCheck_FUN_004326a0(in_liveObj_00,local_50,(uint)in_liveObj,0,1),
			BVar3 != 0)) &&
		 ((in_liveObj_00->objType != OBJECT_MINIFIGURE ||
			(BVar3 = LiveObject_HasToolEquipped(in_liveObj_00,TOOL_DRILL), BVar3 != 0)))) {
		iVar8 = 3;
	}
	if ((local_48 != 0) &&
		 (OVar6 = stats::StatsObject_GetStatsFlags1(in_liveObj_00),
		 (OVar6 & STATS1_CROSSLAND) == STATS1_NONE)) {
		iVar8 = 4;
	}
LAB_00443210:
	in_liveObj_00->strafeSpeed_2bc = 0;
	in_liveObj_00->forwardSpeed_2c0 = 0;
	in_liveObj_00->rotateSpeed_2c4 = 0.0;
	if (iVar8 != 0) {
		*param_3 = local_44;
	}
	return iVar8;
}



void __cdecl lego::game::LiveObject_RockFall_FUN_00443240(LiveObject *in_liveObj,float param_2)
{
	ObjectType OVar1;
	LiveFlags3 LVar2;
	LiveObject *liveObj;
	SurfaceMap *pSVar3;
	Container *pCVar4;
	BOOL BVar5;
	uint by;
	float10 fVar6;
	longlong lVar7;
	float fVar8;
	float fVar9;
	float unkMultiplier;
	Vector3F *out_x;
	float *out_y;
	uint local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	ai::AITask_LiveObject_FUN_00403a70(in_liveObj);
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lrr::Lego_GetMap();
		res::Vehicle_SetPosition
							(liveObj->vehicle,(float)in_liveObj,param_2,res::SurfaceMap_GetSurfaceZ,pSVar3);
		return;
	}
	if (OVar1 == OBJECT_BUILDING) {
		LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lrr::Lego_GetMap();
		res::Building_SetPosition
							(liveObj->building,(float)in_liveObj,param_2,res::SurfaceMap_GetSurfaceZ,pSVar3);
		return;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lrr::Lego_GetMap();
		res::Creature_SetPosition
							(liveObj->rockMonster,(float)in_liveObj,param_2,res::SurfaceMap_GetSurfaceZ,pSVar3);
		return;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		pCVar4 = LiveObject_GetContainer(liveObj);
		res::Container_GetPosition(pCVar4,NULL,&local_18);
		local_2c = local_18.x;
		local_28 = local_18.y;
		LiveObject_GetBlockPos(liveObj,(int *)&local_30,(int *)&in_liveObj);
		BVar5 = Level_Block_IsWall(local_30,(uint)in_liveObj);
		if ((BVar5 != 0) && (BVar5 = Level_Block_IsSeamWall(local_30,(uint)in_liveObj), BVar5 == 0)) {
			out_y = &local_24.y;
			out_x = &local_24;
			unkMultiplier = 0.0;
			BVar5 = Level_Block_IsFlags1_2000(local_30,(uint)in_liveObj);
			fVar8 = local_2c;
			fVar9 = local_28;
			pSVar3 = lrr::Lego_GetMap();
			Map3D_FUN_0044fe50(pSVar3,fVar8,fVar9,BVar5,unkMultiplier,&out_x->x,out_y);
			local_24.x = local_24.x - local_2c;
			local_24.y = local_24.y - local_28;
			fVar9 = param_2 * 0.5;
			fVar8 = SQRT(local_24.y * local_24.y + local_24.x * local_24.x);
			if ((ushort)((ushort)(fVar8 < fVar9) << 8 | (ushort)(fVar8 == fVar9) << 0xe) == 0) {
				local_2c = (fVar9 / fVar8) * local_24.x + local_2c;
				local_28 = (fVar9 / fVar8) * local_24.y + local_28;
			}
		}
		pSVar3 = lrr::Lego_GetMap();
		fVar9 = local_28;
		fVar8 = local_2c;
		fVar6 = res::SurfaceMap_GetSurfaceZ(local_2c,local_28,pSVar3);
		local_c.z = (float)fVar6;
		if (((local_18.x == local_2c) && (local_18.y == local_28)) && (local_18.z == local_c.z)) {
			return;
		}
		pSVar3 = lrr::Lego_GetMap();
		res::Creature_SetPosition
							(liveObj->miniFigure,fVar8,fVar9,SurfaceMap_LevelCallback_FUN_00442820,pSVar3);
		return;
	}
	if ((((OVar1 != OBJECT_POWERCRYSTAL) && (OVar1 != OBJECT_ORE)) &&
			((OVar1 != OBJECT_BARRIER && ((OVar1 != OBJECT_DYNAMITE && (OVar1 != OBJECT_ELECTRICFENCE)))))
			) && (OVar1 != OBJECT_OOHSCARY)) {
		return;
	}
	if (liveObj->carryingThisObject != NULL) {
		return;
	}
	LiveObject_GetBlockPos(liveObj,(int *)&local_30,(int *)&local_2c);
	if ((liveObj->objType == OBJECT_BARRIER) ||
		 (BVar5 = Level_Block_IsFlags1_800(local_30,(uint)local_2c), BVar5 == 0)) {
LAB_00443554:
		if (liveObj->resData_2dc == NULL) goto LAB_00443614;
	}
	else {
		if (liveObj->resData_2dc == NULL) {
			pCVar4 = effect::Effect_Unk_RockFall_FUN_0040c4e0(local_30,(uint)local_2c);
			liveObj->resData_2dc = pCVar4;
			local_24.y = 0.0;
			local_24.x = local_2c;
			LVar2 = liveObj->flags3;
			(liveObj->point_2f4).x = (float)(ulonglong)local_30;
			liveObj->flags3 = LVar2 & ~LIVEOBJ3_UNK_100000;
			(liveObj->point_2f4).y = (float)(ulonglong)(uint)local_2c;
			goto LAB_00443554;
		}
	}
	lVar7 = __ftol((float10)(liveObj->point_2f4).y);
	by = (uint)lVar7;
	lVar7 = __ftol((float10)(liveObj->point_2f4).x);
	BVar5 = Level_Block_IsFlags1_800((uint)lVar7,by);
	if (BVar5 != 0) {
		res::Container_GetPosition(liveObj->resData_2dc,NULL,&local_18);
		fVar8 = local_18.x;
		fVar9 = local_18.y;
		pSVar3 = lrr::Lego_GetMap();
		fVar6 = Map3D_GetWorldZ(pSVar3,fVar8,fVar9);
		fVar6 = fVar6 - (float10)1.2285;
		if ((ushort)((ushort)((float10)local_18.z < fVar6) << 8 |
								(ushort)((float10)local_18.z == fVar6) << 0xe) == 0) {
			local_18.z = (float)fVar6;
		}
		res::Container_SetPosition(liveObj->other,NULL,local_18.x,local_18.y,local_18.z);
		res::Container_SetOrientation(liveObj->other,liveObj->resData_2dc,0.0,0.0,1.0,0.0,1.0,0.0);
		return;
	}
LAB_00443614:
	liveObj->resData_2dc = NULL;
	res::Container_GetPosition(liveObj->other,NULL,&local_24);
	fVar8 = local_24.x;
	fVar9 = local_24.y;
	pSVar3 = lrr::Lego_GetMap();
	fVar6 = Map3D_GetWorldZ(pSVar3,fVar8,fVar9);
	in_liveObj = (LiveObject *)(float)(fVar6 - (float10)1.2285);
	fVar6 = (fVar6 - (float10)1.2285) - (float10)0.5;
	if ((ushort)((ushort)(fVar6 < (float10)local_24.z) << 8 |
							(ushort)(fVar6 == (float10)local_24.z) << 0xe) == 0) {
		local_24.z = local_24.z + param_2;
		if ((ushort)((ushort)(local_24.z < (float)in_liveObj) << 8 |
								(ushort)(local_24.z == (float)in_liveObj) << 0xe) == 0) {
			local_24.z = (float)in_liveObj;
		}
		res::Container_SetPosition(liveObj->other,NULL,local_24.x,local_24.y,local_24.z);
	}
	if ((ushort)((ushort)(local_24.z < (float)in_liveObj - -0.5) << 8 |
							(ushort)(local_24.z == (float)in_liveObj - -0.5) << 0xe) == 0) {
		local_24.z = local_24.z - param_2;
		if (local_24.z < (float)in_liveObj) {
			local_24.z = (float)in_liveObj;
		}
		res::Container_SetPosition(liveObj->other,NULL,local_24.x,local_24.y,local_24.z);
	}
	res::Container_GetOrientation(liveObj->other,NULL,&local_18,&local_c);
	if (0.0 <= local_18.z) {
		if ((ushort)((ushort)(local_18.z < 0.0) << 8 | (ushort)(local_18.z == 0.0) << 0xe) == 0) {
			local_18.z = local_18.z - param_2 * 0.05;
			if (local_18.z < 0.0) {
				local_18.z = 0.0;
			}
			res::Container_SetOrientation
								(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
		}
		return;
	}
	local_18.z = local_18.z - param_2 * -0.05;
	if ((ushort)((ushort)(local_18.z < 0.0) << 8 | (ushort)(local_18.z == 0.0) << 0xe) == 0) {
		local_18.z = 0.0;
	}
	res::Container_SetOrientation(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
	return;
}



void __cdecl lego::game::LiveObject_UpdateDriverObjectPositions_FUN_004437d0(LiveObject *liveObj)
{
	Container *cont;
	Container *cont_00;
	Vector3F local_48;
	Vector3F local_3c;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	cont = LiveObject_GetContainer(liveObj->drivenObject);
	if (liveObj->objType == OBJECT_VEHICLE) {
		cont_00 = res::Vehicle_GetDriverNull(liveObj->vehicle);
		if (cont_00 != NULL) goto LAB_0044380f;
	}
	cont_00 = LiveObject_GetContainer(liveObj);
LAB_0044380f:
	res::Container_GetPosition(cont,NULL,&local_24);
	res::Container_GetPosition(cont_00,NULL,&local_48);
	if (((local_24.x != local_48.x) || (local_24.y != local_48.y)) || (local_24.z != local_48.z)) {
		res::Container_SetPosition(cont,NULL,local_48.x,local_48.y,local_48.z);
	}
	res::Container_GetOrientation(cont,NULL,&local_18,&local_c);
	res::Container_GetOrientation(cont_00,NULL,&local_30,&local_3c);
	if ((((local_18.x != local_30.x) || (local_18.y != local_30.y)) ||
			((local_18.z != local_30.z || ((local_c.x != local_3c.x || (local_c.y != local_3c.y)))))) ||
		 (local_c.z != local_3c.z)) {
		res::Container_SetOrientation
							(cont,NULL,local_30.x,local_30.y,local_30.z,local_3c.x,local_3c.y,local_3c.z);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00443930(LiveObject *liveObj)
{
	short sVar1;
	BOOL BVar2;
	uint uVar3;
	undefined4 unkbool2d8;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		BVar2 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
		if (BVar2 == 0) {
			uVar3 = 0;
			do {
				unkbool2d8 = 1;
				sVar1 = math::Maths_Rand();
				LiveObject_SetActivityUnk(liveObj,(int)sVar1 % 0x15 + ACTIVITY_WAITING1,unkbool2d8);
				BVar2 = LiveObject_Container_ActivityUpdate_Check(liveObj);
				if (BVar2 != 0) {
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_8000;
					return 1;
				}
				uVar3 += 1;
			} while (uVar3 < 5);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_IsRockMonsterCanGather(LiveObject *liveObj)
{
	if ((liveObj->objType == OBJECT_ROCKMONSTER) &&
		 ((liveObj->flags3 & LIVEOBJ3_CANGATHER) != LIVEOBJ3_NONE)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_FUN_004439d0
					(LiveObject *liveObj,Point2I *blockPos,Point2I *out_pointUnkForI,undefined4 unused)
{
	LiveObject *liveObj_00;
	Point2I *pPVar1;
	BOOL BVar2;
	BOOL local_8;
	void *local_4;
	
	pPVar1 = blockPos;
	liveObj_00 = liveObj;
	local_8 = 0;
	BVar2 = LiveObject_FUN_00443b00(liveObj,blockPos,&local_8);
	if (BVar2 != 0) {
		return 0;
	}
	BVar2 = LiveObject_FUN_004413b0
										(liveObj_00,pPVar1->x,pPVar1->y,0,0,&local_4,&blockPos,&liveObj,
										 LiveObject_FUN_00443b00,&local_8);
	if ((BVar2 == 0) &&
		 (BVar2 = LiveObject_FUN_004413b0
												(liveObj_00,pPVar1->x,pPVar1->y,0,0,&local_4,&blockPos,&liveObj,
												 LiveObject_FUN_00443b00,&local_8), BVar2 == 0)) {
		return 0;
	}
	out_pointUnkForI->x = *(int *)((int)local_4 + (int)liveObj * 4 + -4);
	out_pointUnkForI->y = *(int *)((int)blockPos + (int)liveObj * 4 + -4);
	std::free(local_4);
	std::free(blockPos);
	return TRUE;
}



void __cdecl lego::game::LiveObject_RockMonster_DoWakeUp(LiveObject *liveObj)
{
	if (((liveObj->objType == OBJECT_ROCKMONSTER) &&
			((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) &&
		 ((liveObj->flags2 & LIVEOBJ2_UNK_20000000) == LIVEOBJ2_NONE)) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_20000000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_WAKEUP,0);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00443b00
					(LiveObject *liveObj,Point2I *blockPos,BOOL *pAlsoCheckBlockFlags1_10Not8)
{
	BOOL BVar1;
	int iVar2;
	
	if ((*pAlsoCheckBlockFlags1_10Not8 == 0) &&
		 (BVar1 = Level_Block_IsWall(blockPos->x,blockPos->y), BVar1 != 0)) {
		return 0;
	}
	iVar2 = LiveObject_Routing_GetCrossTerrainType
										(liveObj,blockPos->x,blockPos->y,blockPos->x,blockPos->y,TRUE);
	if (((iVar2 != 0) &&
			(BVar1 = LiveObject_GetRockFallInDamage_Unk(liveObj,blockPos->x,blockPos->y,0.0,NULL),
			BVar1 == 0)) && (BVar1 = Level_Block_IsAnyFlags1_80000_Foundation(blockPos), BVar1 == 0)) {
		return TRUE;
	}
	return 0;
}



float __cdecl
lego::game::LiveObject_LargeFlagsSwitch_FUN_00443b70(LiveObject *in_liveObj,float param_2)
{
	float fVar1;
	float fVar2;
	byte bVar3;
	RoutingBlock *pRVar4;
	LiveObject *liveObj;
	short sVar5;
	LiveFlags3 LVar6;
	LiveFlags1 LVar7;
	LiveObject *pLVar8;
	ObjectStatsFlags1 OVar9;
	SurfaceMap *surfMap;
	BOOL BVar10;
	uint uVar11;
	int iVar12;
	float10 in_ST0;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 extraout_ST0_01;
	float10 extraout_ST0_02;
	float10 extraout_ST0_03;
	float10 extraout_ST0_04;
	float10 extraout_ST0_05;
	float10 extraout_ST0_06;
	float10 extraout_ST0_07;
	float10 extraout_ST0_08;
	float10 fVar13;
	float10 extraout_ST1;
	ulonglong uVar14;
	longlong lVar15;
	float *out_bx;
	float *out_by;
	uint local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	Point2F local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	iVar12 = 0;
	pRVar4 = in_liveObj->routeptr_24;
	local_1c = param_2;
	BVar10 = 1;
	if (pRVar4 == NULL) {
		in_ST0 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(in_liveObj,0);
	}
	else {
		if (in_liveObj->objType == OBJECT_VEHICLE) {
			in_liveObj->elapsedTime1 = 0.0;
		}
		if ((in_liveObj->vector_28c).x <= (in_liveObj->vector_28c).y) {
			LVar6 = in_liveObj->flags3;
			if ((LVar6 & LIVEOBJ3_UNK_400) != LIVEOBJ3_NONE) {
				uVar11 = in_liveObj->routingBlocksCurrent;
				in_liveObj->flags3 = LVar6 & ~LIVEOBJ3_UNK_400;
				switch(pRVar4[uVar11].byte_11) {
				case 2:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_REINFORCING;
					break;
				case 3:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_200;
					break;
				case 4:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_CLEARING;
					break;
				case 5:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_800;
					break;
				case 6:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_1000000;
					break;
				case 7:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_2000;
					break;
				case 8:
					LiveObject_DropCarriedObject_FUN_0043a130(in_liveObj,TRUE);
					break;
				case 9:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_PLACING;
					break;
				case 10:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_20000;
					break;
				case 0xb:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_EATING;
					break;
				case 0xc:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_4;
					break;
				case 0xd:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_40;
					break;
				case 0xe:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_TRAINING;
					break;
				case 0xf:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UPGRADING;
					break;
				case 0x10:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_200000;
					break;
				case 0x11:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_4000000;
					break;
				case 0x12:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_10000000;
					break;
				case 0x13:
					LiveObject_TryDock_AtObject2FC(in_liveObj);
					break;
				case 0x14:
					ai::AITask_LiveObject_SetAITaskUnk(in_liveObj,AITASK_ATTACKOBJECT,NULL,1);
					break;
				case 0x15:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_80000000;
				}
				if ((pRVar4[uVar11].flagsByte_10 & 0x20) != 0) {
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_80000;
				}
				in_ST0 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
				if ((liveObj->flags1 & 0x8000000) != LIVEOBJ1_NONE) {
					sVar5 = math::Maths_Rand();
					uVar14 = __ftol((float10)10.0 / (float10)param_2);
					if ((int)((ulonglong)(uint)(int)sVar5 % (uVar14 & 0xffffffff)) != 0) {
						LiveObject_FUN_00433b40(liveObj,150.0,1);
						return (float)extraout_ST0_00;
					}
					liveObj->flags1 = liveObj->flags1 & 0xf7ffffff;
					return (float)extraout_ST0;
				}
				goto LAB_004442ff;
			}
			if (in_liveObj->routingBlocksTotal < 2) {
				in_liveObj->flags3 = LVar6 | LIVEOBJ3_UNK_400;
				pRVar4[in_liveObj->routingBlocksCurrent].flagsByte_10 =
						 pRVar4[in_liveObj->routingBlocksCurrent].flagsByte_10 | 8;
			}
			else {
				uVar11 = in_liveObj->routingBlocksCurrent + 1;
				in_liveObj->routingBlocksCurrent = uVar11;
				if (((pRVar4[uVar11].flagsByte_10 & 0x10) != 0) && (pRVar4[uVar11].byte_11 != 1)) {
					iVar12 = 1;
				}
			}
			uVar11 = in_liveObj->routingBlocksCurrent;
			if (iVar12 != 0) {
				uVar11 += 1;
			}
			if (pRVar4[uVar11].byte_11 == 5) {
				LiveObject_FUN_00447a90(in_liveObj);
			}
			BVar10 = LiveObject_RoutingUnk_FUN_00444940
												 (liveObj,iVar12,liveObj->flags3 & LIVEOBJ3_UNK_8,~liveObj->flags1 >> 10 & 1
												 );
			in_ST0 = extraout_ST0_01;
			if (liveObj->routingBlocksTotal - 1 <= liveObj->routingBlocksCurrent) {
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_400;
			}
		}
		if (BVar10 != 0) {
			if ((((((*(byte *)&liveObj->flags1 & 8) == 0) &&
						(pRVar4[liveObj->routingBlocksCurrent].byte_11 == 1)) &&
					 (BVar10 = LiveObject_GetDrillNullPosition(liveObj,&local_20,&local_24), BVar10 != 0)) &&
					((BVar10 = Lego_WorldToBlockPos_NoZ(local_20,local_24,(int *)&in_liveObj,(int *)&local_2c)
					 , BVar10 != 0 && (BVar10 = Level_Block_IsWall((uint)in_liveObj,local_2c), BVar10 != 0))))
				 && ((in_liveObj == (LiveObject *)pRVar4[liveObj->routingBlocksCurrent].blockPos.x &&
						 (local_2c == pRVar4[liveObj->routingBlocksCurrent].blockPos.y)))) {
				BVar10 = 1;
				LVar6 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
				lVar15 = __ftol((float10)(liveObj->point_2f4).y);
				uVar11 = (uint)lVar15;
				lVar15 = __ftol((float10)(liveObj->point_2f4).x);
				BVar10 = LiveObject_BlockCheck_FUN_004326a0(liveObj,(uint)lVar15,uVar11,LVar6,BVar10);
				if (BVar10 == 0) {
					LVar7 = liveObj->flags1 | LIVEOBJ1_UNK_80000000;
				}
				else {
					LVar7 = liveObj->flags1 | (LIVEOBJ1_UNK_8|LIVEOBJ1_UNK_10);
				}
				liveObj->flags1 = LVar7;
			}
			LiveObject_Callback_FUN_004468d0(liveObj,param_2,&local_28,&local_1c);
			if ((liveObj->flags3 & LIVEOBJ3_UNK_4000) == LIVEOBJ3_NONE) {
				(liveObj->vector_28c).y = local_28 + (liveObj->vector_28c).y;
			}
			fVar1 = (liveObj->vector_28c).y;
			fVar2 = (liveObj->vector_28c).x;
			if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
				fVar1 = (liveObj->vector_28c).y;
				(liveObj->vector_28c).y = (liveObj->vector_28c).x;
				(liveObj->vector_28c).z = fVar1 - (liveObj->vector_28c).x;
			}
			Routing_Calculate_FUN_004067f0
								((RoutingData *)&liveObj->routing_count_0,(liveObj->vector_28c).y,&local_18);
			bVar3 = pRVar4[liveObj->routingBlocksCurrent].byte_11;
			in_ST0 = extraout_ST0_02;
			if (bVar3 == 3) {
				if (liveObj->object_2fc != NULL) {
					LiveObject_GetPosition(liveObj->object_2fc,&local_8,&local_4);
					local_10 = local_8 - local_18.x;
					local_c = local_4 - local_18.y;
					param_2 = SQRT(local_c * local_c + local_10 * local_10);
					in_ST0 = extraout_ST0_03;
					if ((ushort)((ushort)(param_2 < 6.6) << 8 | (ushort)(param_2 == 6.6) << 0xe) != 0) {
						liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_200;
						in_ST0 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
						if ((liveObj->objType == OBJECT_MINIFIGURE) && (param_2 != 0.0)) {
							res::Creature_SetOrientation(liveObj->miniFigure,local_10,local_c);
							(liveObj->faceDirection).x = local_10;
							(liveObj->faceDirection).y = local_c;
							return (float)extraout_ST0_04;
						}
						goto LAB_004442ff;
					}
				}
			}
			else {
				if (bVar3 == 0xc) {
					if (liveObj->object_2fc != NULL) {
						LiveObject_GetPosition(liveObj->object_2fc,&local_8,&local_4);
						param_2 = SQRT((local_18.y - local_4) * (local_18.y - local_4) +
													 (local_18.x - local_8) * (local_18.x - local_8));
						fVar13 = stats::StatsObject_GetCollRadius(liveObj->object_2fc);
						in_ST0 = extraout_ST1;
						if ((ushort)((ushort)((float10)param_2 < fVar13) << 8 |
												(ushort)((float10)param_2 == fVar13) << 0xe) != 0) {
							liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4;
							fVar13 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
							return (float)fVar13;
						}
					}
				}
				else {
					if ((bVar3 == 9) && ((pRVar4[liveObj->routingBlocksCurrent].flagsByte_10 & 0xc) == 0)) {
						uVar11 = ((RoutingData *)&liveObj->routing_count_0)->count;
						local_8 = liveObj->routing_points_4[uVar11 - 1].x;
						local_4 = liveObj->routing_points_4[uVar11 - 1].y;
						param_2 = local_18.x - local_8;
						fVar1 = SQRT((local_18.y - local_4) * (local_18.y - local_4) + param_2 * param_2);
						if ((ushort)((ushort)(fVar1 < 6.0) << 8 | (ushort)(fVar1 == 6.0) << 0xe) != 0) {
							liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_PLACING;
							fVar13 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
							return (float)fVar13;
						}
					}
				}
			}
			if (((((liveObj->flags3 &
						 ~(LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_8|LIVEOBJ3_UNK_10|
							 LIVEOBJ3_UNK_20|LIVEOBJ3_UNK_40|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_200|
							 LIVEOBJ3_UNK_400|LIVEOBJ3_UNK_1000|LIVEOBJ3_UNK_2000|LIVEOBJ3_UNK_4000|
							 LIVEOBJ3_UNK_8000|LIVEOBJ3_UNK_10000|LIVEOBJ3_SIMPLEOBJECT|LIVEOBJ3_UNK_40000|
							 LIVEOBJ3_IGNOREME_UNK|LIVEOBJ3_UNK_100000|LIVEOBJ3_UNK_200000|LIVEOBJ3_UNK_400000|
							 LIVEOBJ3_UNK_800000|LIVEOBJ3_UNK_1000000|LIVEOBJ3_UNK_2000000|LIVEOBJ3_CANGATHER|
							 LIVEOBJ3_UNK_8000000|LIVEOBJ3_CANROUTERUBBLE|LIVEOBJ3_HASPOWER|LIVEOBJ3_UNK_40000000|
							LIVEOBJ3_POWEROFF)) == LIVEOBJ3_NONE) &&
					 (bVar3 = pRVar4[liveObj->routingBlocksCurrent].byte_11, bVar3 != 7)) && (bVar3 != 6)) &&
				 (((bVar3 != 3 && (bVar3 != 5)) &&
					(pLVar8 = (LiveObject *)
										LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_18,0.0,0),
					in_ST0 = extraout_ST0_05, pLVar8 != NULL)))) {
				OVar9 = stats::StatsObject_GetStatsFlags1(liveObj);
				if (((OVar9 & STATS1_BUMPDAMAGE) != STATS1_NONE) && (pLVar8->objType == OBJECT_VEHICLE)) {
					LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_REPAIR,0);
					LiveObject_Container_ActivityUpdate_Check(liveObj);
					liveObj->object_2fc = pLVar8;
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_40000;
					return (float)extraout_ST0_06;
				}
				LiveObject_RoutingUnk_FUN_00444940(liveObj,0,0,0);
				fVar1 = (liveObj->vector_28c).y;
				liveObj->flags3 =
						 liveObj->flags3 |
						 ~(LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_8|LIVEOBJ3_UNK_10|
							 LIVEOBJ3_UNK_20|LIVEOBJ3_UNK_40|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_200|
							 LIVEOBJ3_UNK_400|LIVEOBJ3_UNK_1000|LIVEOBJ3_UNK_2000|LIVEOBJ3_UNK_4000|
							 LIVEOBJ3_UNK_8000|LIVEOBJ3_UNK_10000|LIVEOBJ3_SIMPLEOBJECT|LIVEOBJ3_UNK_40000|
							 LIVEOBJ3_IGNOREME_UNK|LIVEOBJ3_UNK_100000|LIVEOBJ3_UNK_200000|LIVEOBJ3_UNK_400000|
							 LIVEOBJ3_UNK_800000|LIVEOBJ3_UNK_1000000|LIVEOBJ3_UNK_2000000|LIVEOBJ3_CANGATHER|
							 LIVEOBJ3_UNK_8000000|LIVEOBJ3_CANROUTERUBBLE|LIVEOBJ3_HASPOWER|LIVEOBJ3_UNK_40000000|
							LIVEOBJ3_POWEROFF);
				(liveObj->vector_28c).y = local_28 + fVar1;
				in_ST0 = extraout_ST0_07;
			}
			if ((liveObj->flags3 & LIVEOBJ3_UNK_4000) == LIVEOBJ3_NONE) {
				in_ST0 = (float10)LiveObject_FUN_004428b0(liveObj,local_18.x,local_18.y);
			}
			if ((pRVar4[liveObj->routingBlocksTotal - 1].byte_11 == 4) &&
				 (liveObj->objType == OBJECT_VEHICLE)) {
				out_by = &local_4;
				out_bx = &local_8;
				surfMap = lrr::Lego_GetMap();
				Map3D_WorldToBlockPos_NoZ(surfMap,local_18.x,local_18.y,(int *)out_bx,(int *)out_by);
				in_ST0 = extraout_ST0_08;
				if ((local_8 == (float)pRVar4[liveObj->routingBlocksTotal - 1].blockPos.x) &&
					 (local_4 == (float)pRVar4[liveObj->routingBlocksTotal - 1].blockPos.y)) {
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_CLEARING;
					fVar13 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
					return (float)fVar13;
				}
			}
		}
	}
LAB_004442ff:
	return (float)in_ST0;
}



void __cdecl lego::game::LiveObject_TryDock_AtObject2FC(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	pLVar1 = liveObj->object_2fc;
	if ((pLVar1 != NULL) && (pLVar1->objType == OBJECT_BUILDING)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40;
		pLVar1->flags4 = pLVar1->flags4 | LIVEOBJ4_UNK_40;
		ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DOCK,NULL,TRUE);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_004443b0(LiveObject *liveObj,float elapsed)
{
	BOOL BVar1;
	float10 fVar2;
	Point2I blockPos;
	
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 ((liveObj->objType != OBJECT_ROCKMONSTER ||
			(liveObj->carriedObjects[0]->objType == OBJECT_BOULDER)))) {
		fVar2 = stats::StatsObject_GetCarryMinHealth(liveObj);
		if ((fVar2 < (float10)liveObj->health) && ((*(byte *)&liveObj->flags4 & 0x20) == 0)) {
			fVar2 = stats::StatsObject_GetRestPercent(liveObj);
			if ((((float)(fVar2 * (float10)0.01) != 0.0) && ((*(byte *)&liveObj->flags1 & 4) == 0)) &&
				 ((float)(fVar2 * (float10)0.01) * liveObj->health < liveObj->float_33c * 0.04)) {
				LiveObject_GetBlockPos(liveObj,&blockPos.x,&blockPos.y);
				BVar1 = Level_Block_IsLava(&blockPos);
				if (((BVar1 == 0) &&
						((globs::legoGlobs.level)->blocks
						 [((globs::legoGlobs.level)->dimensions).width * blockPos.y + blockPos.x].terrain !=
						 TERRAIN_LAKE)) && (liveObj->routingBlocksCurrent != liveObj->routingBlocksTotal - 1)) {
					liveObj->float_33c = 0.0;
					liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_4000;
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_REST;
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_REST,FALSE);
					LiveObject_Container_ActivityUpdate_Check(liveObj);
				}
			}
			liveObj->float_33c = elapsed + liveObj->float_33c;
			return;
		}
		LiveObject_DropCarriedObject_FUN_0043a130(liveObj,FALSE);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00444520(LiveObject *liveObj)
{
	int iVar1;
	short sVar2;
	BOOL BVar3;
	int iVar4;
	int iVar5;
	SurfaceMap *surfMap;
	uint uVar6;
	uint by;
	float10 fVar7;
	Vector3F *out_vertPoses;
	int local_90;
	float *local_8c;
	int local_88;
	float *local_84;
	uint local_80;
	uint local_7c;
	float local_78;
	float local_74;
	Point2I ANGLES [8];
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	ANGLES[0].x = -1;
	ANGLES[0].y = 0;
	ANGLES[1].x = -1;
	ANGLES[1].y = 1;
	ANGLES[2].x = 0;
	ANGLES[2].y = 1;
	ANGLES[3].x = 1;
	ANGLES[3].y = 1;
	ANGLES[4].x = 1;
	ANGLES[4].y = 0;
	ANGLES[5].x = 1;
	ANGLES[5].y = -1;
	ANGLES[6].x = 0;
	ANGLES[6].y = -1;
	ANGLES[7].x = -1;
	ANGLES[7].y = -1;
	BVar3 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar3 != 0) {
		return 0;
	}
	LiveObject_GetBlockPos(liveObj,&local_90,&local_88);
	local_80 = 0;
	do {
		sVar2 = math::Maths_Rand();
		uVar6 = (int)sVar2 >> 0x1f;
						// positive modulus 8 (???)
		iVar4 = (((int)sVar2 ^ uVar6) - uVar6 & 7 ^ uVar6) - uVar6;
		iVar1 = ANGLES[iVar4].y;
		iVar4 = ANGLES[iVar4].x;
		iVar5 = LiveObject_Routing_GetCrossTerrainType
											(liveObj,local_90 + iVar4,local_88 + iVar1,local_90 + iVar4,local_88 + iVar1,0
											);
		if (iVar5 != 0) {
			out_vertPoses = local_30;
			by = local_88 + iVar1;
			uVar6 = local_90 + iVar4;
			surfMap = lrr::Lego_GetMap();
			Map3D_GetBlockVertexPositions2(surfMap,uVar6,by,out_vertPoses);
			fVar7 = math::Maths_RandRange(local_30[0].x - -1.0,local_18 - 1.0);
			local_78 = (float)fVar7;
			fVar7 = math::Maths_RandRange(local_30[0].y - -1.0,local_14 - 1.0);
			local_74 = (float)fVar7;
			BVar3 = LiveObject_FUN_004413b0
												(liveObj,local_90,local_88,local_90 + iVar4,local_88 + iVar1,&local_8c,
												 &local_84,&local_7c,0,0);
			if (BVar3 != 0) {
				BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj,local_7c,local_8c,local_84,&local_78);
				if (BVar3 != 0) {
					std::free(local_8c);
					std::free(local_84);
					return 1;
				}
				std::free(local_8c);
				std::free(local_84);
			}
		}
		local_80 += 1;
	} while (local_80 < 0x10);
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00444720(LiveObject *liveObj,Point2F *param_2)
{
	BOOL BVar1;
	SurfaceMap *surfMap;
	float in_x;
	float in_y;
	char **out_bx;
	VehicleData **out_by;
	VehicleData **local_20;
	uint local_1c;
	float local_18;
	float local_14;
	char *local_10;
	VehicleData *local_c;
	char *local_8;
	VehicleData *local_4;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockPos(liveObj,(int *)&local_10,(int *)&local_c);
	if (((((liveObj_00->flags1 & LIVEOBJ1_UNK_800000) == LIVEOBJ1_NONE) &&
			 (BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj_00,1), BVar1 != 0)) &&
			(BVar1 = LiveObject_Check_FUN_004294f0(liveObj_00), BVar1 == 0)) &&
		 ((liveObj_00->drivenObject == NULL &&
			(BVar1 = Level_Block_IsWall((uint)local_10,(uint)local_c), BVar1 == 0)))) {
		LiveObject_FUN_00441df0(liveObj_00,1,1);
		LiveObject_GetPosition(liveObj_00,&local_18,&local_14);
		out_bx = &local_8;
		in_x = globs::legoGlobs.MiniFigureRunAway * param_2->x + local_18;
		out_by = &local_4;
		in_y = param_2->y * globs::legoGlobs.MiniFigureRunAway + local_14;
		local_18 = in_x;
		local_14 = in_y;
		surfMap = lrr::Lego_GetMap();
		BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)out_bx,(int *)out_by);
		if (BVar1 != 0) {
			if ((local_8 == local_10) && (local_4 == local_c)) {
				liveObj = (LiveObject *)&local_10;
				local_20 = &local_c;
				local_1c = 1;
			}
			else {
				BVar1 = LiveObject_FUN_004413b0
													(liveObj_00,local_10,local_c,local_8,local_4,&liveObj,&local_20,&local_1c,
													 0,0);
				if (BVar1 == 0) {
					return;
				}
			}
			BVar1 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
												(liveObj_00,local_1c,(float *)liveObj,(float *)local_20,&local_18);
			if (BVar1 != 0) {
				liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].flagsByte_10 =
						 liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].flagsByte_10 | 0x40;
			}
			std::free(liveObj);
			std::free(local_20);
			liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_UNK_800000;
			front::Bubble_LiveObject_MiniFigure_FUN_00407380(liveObj_00);
		}
	}
	return;
}



void __cdecl lego::ai::AI_LiveObject_DoSlip(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_UNK_4000000) == LIVEOBJ1_NONE) && (liveObj->drivenObject == NULL)
		 ) {
		game::LiveObject_FUN_00441df0(liveObj,FALSE,TRUE);
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_4000000;
		game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_SLIP,FALSE);
		game::LiveObject_Container_ActivityUpdate_Check(liveObj);
		AITask_DoAnimationWait(liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_RoutingUnk_FUN_00444940
					(LiveObject *liveObj,int param_2,int param_3,int param_4)
{
	Vector3F *out_vector;
	byte bVar1;
	LiveFlags1 LVar2;
	LiveFlags3 LVar3;
	SurfaceMap *pSVar4;
	uint uVar5;
	float fVar6;
	BOOL BVar7;
	uint uVar8;
	Point2F *pPVar9;
	float fVar10;
	float10 fVar11;
	float fVar12;
	uint uVar13;
	uint by;
	float unkMultiplier;
	float *pfVar14;
	ActivityType AVar15;
	float *pfVar16;
	float local_74;
	float local_70;
	float local_6c;
	float local_68;
	undefined4 local_64;
	BOOL local_60;
	uint local_5c;
	uint local_58;
	Point2F local_54;
	Point2F local_4c;
	Point2F local_44;
	Point2F local_3c;
	float local_34;
	float local_30;
	Vector3F local_2c;
	Point2F local_20 [4];
	
	local_6c = 0.0;
	local_70 = 0.0;
	local_60 = 1;
	uVar8 = liveObj->routeptr_24[liveObj->routingBlocksCurrent].blockPos.x;
	by = liveObj->routeptr_24[liveObj->routingBlocksCurrent].blockPos.y;
	LiveObject_GetBlockPos(liveObj,(int *)&local_58,(int *)&local_5c);
	LiveObject_GetPosition(liveObj,&local_3c.x,&local_3c.y);
	local_44.x = (liveObj->faceDirection).x;
	local_44.y = (liveObj->faceDirection).y;
	out_vector = &liveObj->faceDirection;
	if (param_2 == 0) {
		pfVar16 = &local_4c.y;
		pPVar9 = &local_4c;
		pSVar4 = lrr::Lego_GetMap();
		Map3D_BlockToWorldPos(pSVar4,uVar8,by,&pPVar9->x,pfVar16);
	}
	else {
		pfVar16 = &local_30;
		uVar13 = liveObj->routeptr_24[liveObj->routingBlocksCurrent].blockPos.y;
		pfVar14 = &local_34;
		uVar5 = liveObj->routeptr_24[liveObj->routingBlocksCurrent].blockPos.x;
		pSVar4 = lrr::Lego_GetMap();
		Map3D_BlockToWorldPos(pSVar4,uVar5,uVar13,pfVar14,pfVar16);
		uVar5 = liveObj->routingBlocksCurrent + 1;
		liveObj->routingBlocksCurrent = uVar5;
		pfVar16 = &local_4c.y;
		pPVar9 = &local_4c;
		uVar13 = liveObj->routeptr_24[uVar5].blockPos.x;
		uVar5 = liveObj->routeptr_24[uVar5].blockPos.y;
		pSVar4 = lrr::Lego_GetMap();
		Map3D_BlockToWorldPos(pSVar4,uVar13,uVar5,&pPVar9->x,pfVar16);
		local_58 = uVar8;
		local_5c = by;
	}
	pfVar16 = &local_54.y;
	pPVar9 = &local_54;
	pSVar4 = lrr::Lego_GetMap();
	Map3D_BlockToWorldPos(pSVar4,local_58,local_5c,&pPVar9->x,pfVar16);
	fVar10 = local_6c;
	fVar6 = local_70;
	if (liveObj->routeptr_24[liveObj->routingBlocksCurrent].byte_11 != 1) {
		pfVar16 = &local_74;
		pfVar14 = &local_70;
		fVar10 = local_4c.x;
		fVar6 = local_4c.y;
		pSVar4 = lrr::Lego_GetMap();
		Map3D_WorldToBlockPos_NoZ(pSVar4,fVar10,fVar6,(int *)pfVar14,(int *)pfVar16);
		fVar6 = (float)Level_Block_IsFlags1_2000((uint)local_70,(uint)local_74);
		BVar7 = Level_Block_IsWall((uint)local_70,(uint)local_74);
		fVar10 = local_6c;
		if ((BVar7 != 0) &&
			 (BVar7 = Level_Block_IsSeamWall((uint)local_70,(uint)local_74), fVar10 = local_6c, BVar7 == 0
			 )) {
			BVar7 = Level_Block_IsCornerInner((uint)local_70,(uint)local_74);
			if (BVar7 != 0) {
				if (ABS(local_4c.x - local_54.x) <= ABS(local_4c.y - local_54.y)) {
					local_20[0].x = 0.1;
					local_20[0].y = 0.0;
					local_20[1].x = -0.1;
					local_20[1].y = 0.0;
					local_20[2].x = -0.1;
					local_20[2].y = 0.0;
					local_20[3].x = 0.1;
					local_20[3].y = 0.0;
					uVar8 = Level_Block_GetField3__routingRelated((uint)local_70,(uint)local_74);
					pPVar9 = local_20 + uVar8;
				}
				else {
					local_20[0].x = 0.0;
					local_20[0].y = -0.1;
					local_20[1].x = 0.0;
					local_20[1].y = -0.1;
					local_20[2].x = 0.0;
					local_20[2].y = 0.1;
					local_20[3].x = 0.0;
					local_20[3].y = 0.1;
					uVar8 = Level_Block_GetField3__routingRelated((uint)local_70,(uint)local_74);
					pPVar9 = local_20 + uVar8;
				}
				local_4c.x = pPVar9->x + local_4c.x;
				local_4c.y = pPVar9->y + local_4c.y;
			}
			pfVar16 = &local_4c.y;
			pPVar9 = &local_4c;
			unkMultiplier = 0.05;
			BVar7 = Level_Block_IsFlags1_2000((uint)local_70,(uint)local_74);
			fVar10 = local_4c.x;
			fVar12 = local_4c.y;
			pSVar4 = lrr::Lego_GetMap();
			Map3D_FUN_0044fe50(pSVar4,fVar10,fVar12,BVar7,unkMultiplier,&pPVar9->x,pfVar16);
			fVar10 = 1.401298e-45;
		}
	}
	if (fVar10 == 0.0) {
		pSVar4 = lrr::Lego_GetMap();
		fVar11 = Map3D_GetBlockSize(pSVar4);
		local_6c = (float)(((float10)liveObj->routeptr_24[liveObj->routingBlocksCurrent].worldPos.x -
											 (float10)0.5) * fVar11);
		pSVar4 = lrr::Lego_GetMap();
		fVar11 = Map3D_GetBlockSize(pSVar4);
		local_68 = (float)(((float10)liveObj->routeptr_24[liveObj->routingBlocksCurrent].worldPos.y -
											 (float10)0.5) * fVar11);
		local_4c.x = local_6c + local_4c.x;
		local_4c.y = local_68 + local_4c.y;
	}
	bVar1 = liveObj->routeptr_24[liveObj->routingBlocksCurrent].flagsByte_10;
	if ((bVar1 & 4) == 0) {
		if ((bVar1 & 0x40) == 0) {
			if (((bVar1 & 8) != 0) && ((local_6c != 0.0 || (local_68 != 0.0)))) {
				local_54.x = local_6c;
				local_54.y = local_68;
				goto LAB_00444e0b;
			}
			local_54.x = local_4c.x - local_54.x;
			fVar12 = local_4c.y - local_54.y;
			local_54.y = fVar12;
			if ((fVar10 != 0.0) && (fVar6 == 0.0)) {
				local_54.y = fVar6;
				if (ABS(local_54.x) <= ABS(fVar12)) {
					local_54.x = 0.0;
					local_54.y = fVar12;
				}
				goto LAB_00444e0b;
			}
			if ((local_54.x != 0.0) || (fVar12 != 0.0)) goto LAB_00444e0b;
		}
		local_54.x = local_4c.x - local_3c.x;
		local_54.y = local_4c.y - local_3c.y;
		goto LAB_00444e0b;
	}
	switch(bVar1 & 3) {
	case 0:
		local_54.x = 0.0;
		local_54.y = 1.0;
		param_3 = 0;
		goto LAB_00444e0b;
	case 1:
		local_54.x = 1.0;
		break;
	case 2:
		local_54.x = 0.0;
		local_54.y = -1.0;
		param_3 = 0;
		goto LAB_00444e0b;
	case 3:
		local_54.x = -1.0;
		break;
	default:
		goto switchD_00444cce_caseD_4;
	}
	local_54.y = 0.0;
switchD_00444cce_caseD_4:
	param_3 = 0;
LAB_00444e0b:
	if (param_3 != 0) {
		local_2c.x = local_4c.x - local_3c.x;
		fVar10 = local_4c.y - local_3c.y;
		local_2c.z = 0.0;
		local_64 = 0;
		local_2c.y = 1.0 / SQRT(fVar10 * fVar10 + local_2c.x * local_2c.x);
		local_68 = 1.0 / SQRT(local_44.y * local_44.y + local_44.x * local_44.x);
		fVar6 = 1.0 / SQRT(local_54.y * local_54.y + local_54.x * local_54.x);
		local_2c.x = local_2c.y * local_2c.x;
		local_2c.y = local_2c.y * fVar10;
		local_6c = local_68 * local_44.x;
		local_68 = local_68 * local_44.y;
		local_74 = fVar6 * local_54.y * local_68 + fVar6 * local_54.x * local_6c;
		local_70 = local_2c.y * local_68 + local_2c.x * local_6c + 0.0;
		if (((param_4 == 0) ||
				((ushort)((ushort)(local_74 < 0.7) << 8 | (ushort)(local_74 == 0.7) << 0xe) != 0)) ||
			 (-0.7 <= local_70)) {
			if (((((ushort)((ushort)(local_74 < 0.0) << 8 | (ushort)(local_74 == 0.0) << 0xe) != 0) &&
					 (local_70 < 0.7)) &&
					((ushort)((ushort)(ABS(local_70) < 0.1) << 8 | (ushort)(ABS(local_70) == 0.1) << 0xe) == 0
					)) || (BVar7 = LiveObject_FUN_00445860(liveObj), BVar7 != 0)) {
				if (-0.9 <= local_74) {
					fVar10 = local_2c.x * (liveObj->faceDirection).z;
					fVar6 = local_2c.x * (liveObj->faceDirection).y;
					fVar12 = out_vector->x * local_2c.y;
					local_2c.x = local_2c.y * (liveObj->faceDirection).z -
											 local_2c.z * (liveObj->faceDirection).y;
					local_2c.y = out_vector->x * local_2c.z - fVar10;
					local_2c.z = fVar6 - fVar12;
					math::Maths_Vector3DRotate(out_vector,out_vector,&local_2c,-1.570796);
					if (liveObj->objType != OBJECT_VEHICLE) {
						local_44.x = out_vector->x;
						local_44.y = (liveObj->faceDirection).y;
					}
					if ((ushort)((ushort)(local_2c.z < 0.0) << 8 | (ushort)(local_2c.z == 0.0) << 0xe) == 0) {
						if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
							AVar15 = ACTIVITY_TURNRIGHT;
						}
						else {
							AVar15 = ACTIVITY_CARRYTURNRIGHT;
						}
					}
					else {
						if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
							AVar15 = ACTIVITY_TURNLEFT;
						}
						else {
							AVar15 = ACTIVITY_CARRYTURNLEFT;
						}
					}
					LiveObject_SetActivityUnk(liveObj,AVar15,1);
				}
				else {
					if (liveObj->objType != OBJECT_VEHICLE) {
						local_44.x = -out_vector->x;
						out_vector->x = local_44.x;
						local_44.y = -(liveObj->faceDirection).y;
						(liveObj->faceDirection).y = local_44.y;
					}
					if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
						AVar15 = ACTIVITY_TURNRIGHT;
					}
					else {
						AVar15 = ACTIVITY_CARRYTURNRIGHT;
					}
					LiveObject_SetActivityUnk(liveObj,AVar15,0);
					if (liveObj->objType != OBJECT_VEHICLE) {
						liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_TURNRIGHT;
					}
				}
				LVar2 = liveObj->flags1;
				liveObj->flags1 = LVar2 | LIVEOBJ1_TURNING;
				if (liveObj->objType != OBJECT_VEHICLE) {
					local_60 = 0;
					liveObj->flags1 = LVar2 & ~LIVEOBJ1_MOVING | LIVEOBJ1_TURNING;
				}
			}
		}
		else {
			local_44.x = -local_44.x;
			local_44.y = -local_44.y;
			local_54.x = -local_54.x;
			local_54.y = -local_54.y;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_LIFTING;
		}
	}
	local_6c = SQRT((local_3c.y - local_4c.y) * (local_3c.y - local_4c.y) +
									(local_3c.x - local_4c.x) * (local_3c.x - local_4c.x)) * 0.2;
	if ((ushort)((ushort)(local_6c < 0.1) << 8 | (ushort)(local_6c == 0.1) << 0xe) == 0) {
		fVar10 = (float)std::_finite((double)local_44.x);
		if (fVar10 == 0.0) {
			local_44.x = 1.0;
			local_44.y = fVar10;
		}
		math::Routing_Maths_Vector2DChangeLength(&local_44,local_6c);
		math::Routing_Maths_Vector2DChangeLength(&local_54,local_6c * 1.6);
		Routing_DoMath_FUN_00406750
							((RoutingData *)&liveObj->routing_count_0,&local_3c,&local_44,&local_4c,&local_54,0x32
							);
		LiveObject_FUN_004454a0(liveObj);
	}
	else {
		liveObj->routing_points_4[0].x = local_3c.x;
		liveObj->routing_points_4[0].y = local_3c.y;
		liveObj->routing_count_0 = 0;
	}
	fVar11 = Routing_UpdateDistances_RetTotal((RoutingData *)&liveObj->routing_count_0);
	LVar3 = liveObj->flags3;
	fVar10 = (liveObj->vector_28c).z;
	(liveObj->vector_28c).x = (float)fVar11;
	(liveObj->point_298).x = local_54.x;
	liveObj->flags3 =
			 LVar3 & (LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_8|LIVEOBJ3_UNK_10|
								LIVEOBJ3_UNK_20|LIVEOBJ3_UNK_40|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_200|
								LIVEOBJ3_UNK_400|LIVEOBJ3_UNK_1000|LIVEOBJ3_UNK_2000|LIVEOBJ3_UNK_4000|
								LIVEOBJ3_UNK_8000|LIVEOBJ3_UNK_10000|LIVEOBJ3_SIMPLEOBJECT|LIVEOBJ3_UNK_40000|
								LIVEOBJ3_IGNOREME_UNK|LIVEOBJ3_UNK_100000|LIVEOBJ3_UNK_200000|LIVEOBJ3_UNK_400000|
								LIVEOBJ3_UNK_800000|LIVEOBJ3_UNK_1000000|LIVEOBJ3_UNK_2000000|LIVEOBJ3_CANGATHER|
								LIVEOBJ3_UNK_8000000|LIVEOBJ3_CANROUTERUBBLE|LIVEOBJ3_HASPOWER|LIVEOBJ3_UNK_40000000
							 |LIVEOBJ3_POWEROFF);
	(liveObj->vector_28c).y = fVar10;
	(liveObj->point_298).y = local_54.y;
	return local_60;
}



void __cdecl lego::game::LiveObject_FUN_00445270(LiveObject *liveObj,Point2F *point)
{
	Vector3F *out_vector;
	float fVar1;
	float fVar2;
	float fVar3;
	LiveFlags1 LVar4;
	ActivityType actType;
	float10 fVar5;
	Vector3F local_c;
	
	if (liveObj->objType != OBJECT_MINIFIGURE) {
		return;
	}
	fVar1 = (liveObj->faceDirection).y;
	fVar2 = (liveObj->faceDirection).z;
	out_vector = &liveObj->faceDirection;
	local_c.x = point->x;
	fVar3 = point->y;
	local_c.z = 0.0;
	fVar1 = 1.0 / SQRT(out_vector->x * out_vector->x + fVar2 * fVar2 + fVar1 * fVar1);
	local_c.y = 1.0 / SQRT(fVar3 * fVar3 + local_c.x * local_c.x);
	local_c.x = local_c.y * local_c.x;
	out_vector->x = out_vector->x * fVar1;
	local_c.y = local_c.y * fVar3;
	(liveObj->faceDirection).y = fVar1 * (liveObj->faceDirection).y;
	(liveObj->faceDirection).z = fVar1 * (liveObj->faceDirection).z;
	fVar5 = std::acos((float10)(liveObj->faceDirection).y * (float10)local_c.y +
										(float10)(liveObj->faceDirection).z * (float10)0.0 +
										(float10)out_vector->x * (float10)local_c.x);
	fVar1 = (float)fVar5;
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	if ((ushort)((ushort)(fVar1 < 2.356194) << 8 | (ushort)(fVar1 == 2.356194) << 0xe) == 0) {
		LVar4 = liveObj->flags1;
		out_vector->x = -out_vector->x;
		(liveObj->faceDirection).y = -(liveObj->faceDirection).y;
		liveObj->flags1 = LVar4 | LIVEOBJ1_TURNRIGHT;
	}
	else {
		if ((ushort)((ushort)(fVar1 < 0.7853982) << 8 | (ushort)(fVar1 == 0.7853982) << 0xe) != 0) {
			return;
		}
		fVar1 = local_c.x * (liveObj->faceDirection).z;
		fVar2 = local_c.x * (liveObj->faceDirection).y;
		fVar3 = out_vector->x * local_c.y;
		local_c.x = local_c.y * (liveObj->faceDirection).z - local_c.z * (liveObj->faceDirection).y;
		local_c.y = out_vector->x * local_c.z - fVar1;
		local_c.z = fVar2 - fVar3;
		math::Maths_Vector3DRotate(out_vector,out_vector,&local_c,-1.570796);
		actType = ACTIVITY_TURNLEFT;
		if (local_c.z < 0.0) goto LAB_00445461;
	}
	actType = ACTIVITY_TURNRIGHT;
LAB_00445461:
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		actType = (actType == ACTIVITY_TURNRIGHT) + ACTIVITY_CARRYTURNLEFT;
	}
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_TURNING;
	LiveObject_SetActivityUnk(liveObj,actType,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_FUN_004454a0(LiveObject *in_liveObj)
{
	byte bVar1;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	Point2F *pPVar5;
	uint uVar6;
	float10 fVar7;
	float fVar8;
	uint bx;
	float fVar9;
	LiveObject *by;
	uint *out_bx;
	float *out_x;
	LiveObject **out_by;
	float *out_y;
	uint local_14;
	LiveObject *local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	OVar2 = stats::StatsObject_GetStatsFlags1(in_liveObj);
	if (((((OVar2 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE) &&
			 (bVar1 = liveObj->routeptr_24[liveObj->routingBlocksCurrent].byte_11, bVar1 != 7)) &&
			(bVar1 != 3)) && ((bVar1 != 6 && (bVar1 != 5)))) {
		local_10 = liveObj;
		OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar2 & STATS1_COLLRADIUS) != STATS1_NONE) {
			Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_00445600,&local_10);
		}
		uVar6 = 0;
		if (liveObj->routing_count_0 != 0) {
			pPVar5 = liveObj->routing_points_4;
			do {
				fVar9 = pPVar5->y;
				out_by = &in_liveObj;
				out_bx = &local_14;
				fVar8 = pPVar5->x;
				pSVar3 = lrr::Lego_GetMap();
				Map3D_WorldToBlockPos_NoZ(pSVar3,fVar8,fVar9,(int *)out_bx,(int *)out_by);
				BVar4 = Level_Block_IsSolidBuilding(local_14,(uint)in_liveObj,0);
				if (BVar4 != 0) {
					out_y = &local_4;
					out_x = &local_8;
					bx = local_14;
					by = in_liveObj;
					pSVar3 = lrr::Lego_GetMap();
					Map3D_BlockToWorldPos(pSVar3,bx,(uint)by,out_x,out_y);
					fVar8 = pPVar5->x - local_8;
					fVar9 = pPVar5->y - local_4;
					local_c = SQRT(fVar8 * fVar8 + fVar9 * fVar9);
					pPVar5->x = (1.0 / local_c) * fVar8;
					pPVar5->y = (1.0 / local_c) * fVar9;
					pSVar3 = lrr::Lego_GetMap();
					fVar7 = Map3D_GetBlockSize(pSVar3);
					pPVar5->x = (float)(fVar7 * (float10)0.71 * (float10)pPVar5->x + (float10)local_8);
					pPVar5->y = (float)(fVar7 * (float10)0.71 * (float10)pPVar5->y + (float10)local_4);
				}
				uVar6 += 1;
				pPVar5 = pPVar5 + 1;
			} while (uVar6 < (uint)liveObj->routing_count_0);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00445600(LiveObject *liveObj1,LiveObject **param_2)
{
	float fVar1;
	LiveObject *pLVar2;
	int iVar3;
	float fVar4;
	ObjectStatsFlags1 OVar5;
	uint uVar6;
	float *pfVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar2 = *param_2;
	if ((((liveObj1 != pLVar2) && (liveObj1->carryingThisObject != pLVar2)) &&
			(liveObj1->object_300 != pLVar2)) && ((liveObj1->flags3 & LIVEOBJ3_UNK_2000) == LIVEOBJ3_NONE)
		 ) {
		OVar5 = stats::StatsObject_GetStatsFlags1(liveObj1);
		if ((OVar5 & STATS1_CAUSESLIP) == STATS1_NONE) {
			pLVar2 = *param_2;
			fVar8 = stats::StatsObject_GetCollRadius(pLVar2);
			LiveObject_GetPosition(liveObj1,&local_8,&local_4);
			uVar6 = 1;
			if (1 < pLVar2->routing_count_0 - 1U) {
				pfVar7 = &pLVar2->routing_points_4[1].y;
				do {
					fVar4 = local_4 - *pfVar7;
					fVar1 = local_8 - pfVar7[-1];
					fVar9 = stats::StatsObject_GetCollRadius(liveObj1);
					if ((float10)SQRT(fVar1 * fVar1 + fVar4 * fVar4) < fVar9 + (float10)(float)fVar8) {
						local_10 = pfVar7[-1] - local_8;
						fVar1 = *pfVar7 - local_4;
						local_c = SQRT(fVar1 * fVar1 + local_10 * local_10);
						if (local_c == 0.0) {
							fVar9 = math::Maths_RandRange(0.0,1.0);
							fVar1 = (float)fVar9;
							fVar9 = math::Maths_RandRange(0.0,1.0);
							fVar10 = (float10)1.0 /
											 SQRT(fVar9 * (float10)(float)fVar9 + (float10)fVar1 * (float10)fVar1);
							local_10 = (float)(fVar10 * (float10)fVar1);
							local_c = (float)(fVar10 * (float10)(float)fVar9);
						}
						else {
							local_c = 1.0 / local_c;
							local_10 = local_c * local_10;
							local_c = local_c * fVar1;
						}
						fVar9 = stats::StatsObject_GetCollRadius(liveObj1);
						fVar9 = fVar9 + (float10)(float)fVar8;
						pfVar7[-1] = (pfVar7[-3] +
												 pfVar7[1] + (float)(fVar9 * (float10)local_10 + (float10)local_8)) *
												 0.3333333;
						*pfVar7 = (pfVar7[-2] + pfVar7[2] + (float)fVar9 * local_c + local_4) * 0.3333333;
					}
					uVar6 += 1;
					pfVar7 = pfVar7 + 2;
				} while (uVar6 < pLVar2->routing_count_0 - 1U);
			}
			iVar3 = pLVar2->routing_count_0;
			fVar1 = pLVar2->routing_points_4[iVar3 + -2].y;
			pfVar7 = &pLVar2->routing_points_4[iVar3 + -1].y;
			pfVar7[-1] = (pLVar2->routing_points_4[iVar3 + -2].x - pLVar2->routing_points_4[iVar3 + -3].x)
									 + pfVar7[-3];
			*pfVar7 = pfVar7[-2] + (fVar1 - pfVar7[-4]);
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00445860(LiveObject *liveObj)
{
	BOOL BVar1;
	SurfaceMap *pSVar2;
	float10 fVar3;
	float fVar4;
	float in_y;
	uint *out_bx;
	uint *out_by;
	uint local_20;
	uint local_1c;
	uint local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	LiveObject_GetBlockPos(liveObj,(int *)&local_14,(int *)&local_18);
	BVar1 = Level_Block_IsWall(local_14,local_18);
	if (BVar1 != 0) {
		return 0;
	}
	LiveObject_GetPosition(liveObj,&local_8,&local_4);
	local_10 = (liveObj->faceDirection).x;
	local_c = (liveObj->faceDirection).y;
	fVar4 = 1.0 / SQRT(local_c * local_c + local_10 * local_10);
	pSVar2 = lrr::Lego_GetMap();
	fVar3 = Map3D_GetBlockSize(pSVar2);
	out_by = &local_20;
	local_c = fVar4 * local_c * (float)(fVar3 * (float10)0.3333333);
	local_10 = fVar4 * local_10 * (float)(fVar3 * (float10)0.3333333);
	in_y = local_c + local_4;
	fVar4 = local_10 + local_8;
	out_bx = &local_1c;
	local_8 = fVar4;
	local_4 = in_y;
	pSVar2 = lrr::Lego_GetMap();
	Map3D_WorldToBlockPos_NoZ(pSVar2,fVar4,in_y,(int *)out_bx,(int *)out_by);
	BVar1 = Level_Block_IsWall(local_1c,local_20);
	if ((BVar1 == 0) && (BVar1 = Level_Block_IsSolidBuilding(local_1c,local_20,0), BVar1 == 0)) {
		return 0;
	}
	return TRUE;
}



void __cdecl lego::game::LiveObject_FUN_004459a0(LiveObject *liveObj)
{
	uint uVar1;
	float10 fVar2;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_00445af0,liveObj);
	}
	if (((liveObj->objType == OBJECT_DYNAMITE) || (liveObj->objType == OBJECT_OOHSCARY)) &&
		 ((liveObj->flags3 & LIVEOBJ3_UNK_10000) != LIVEOBJ3_NONE)) {
		uVar1 = res::Container_GetAnimationFrames(liveObj->other);
		fVar2 = res::Container_GetAnimationTime(liveObj->other);
		if ((float10)(ulonglong)uVar1 - (float10)75.0 < fVar2) {
			Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_00445a30,liveObj);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00445a30(LiveObject *liveObj1,LiveObject *liveObj2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F local_18;
	Vector3F local_c;
	
	if ((liveObj1->objType == OBJECT_MINIFIGURE) &&
		 ((*(byte *)&liveObj1->flags5 & LIVEOBJ5_ABILITY_DYNAMITE) != 0)) {
		LiveObject_GetPosition(liveObj1,&local_18.x,&local_18.y);
		LiveObject_GetPosition(liveObj2,&local_18.z,&local_c.x);
		fVar3 = local_18.x - local_18.z;
		fVar1 = local_18.y - local_c.x;
		fVar2 = SQRT(fVar1 * fVar1 + fVar3 * fVar3);
		if (fVar2 < globs::legoGlobs.DynamiteDamageRadius) {
			fVar2 = 1.0 / fVar2;
			local_c.y = fVar2 * fVar3;
			local_c.z = fVar2 * fVar1;
			LiveObject_FUN_00444720(liveObj1,(Point2F *)&local_c.y);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00445af0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	ObjectStatsFlags1 OVar4;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar5;
	uint weaponType;
	float10 fVar6;
	float10 fVar7;
	float in_x;
	float in_y;
	LiveObject *liveObj;
	uint *puVar8;
	float *out_by;
	float fVar9;
	ObjectType local_34;
	int local_30;
	Point2F local_2c;
	Point2F local_24;
	Point2F local_1c;
	uint local_14;
	float local_10;
	Vector3F local_c;
	
	LiveObject_GetPosition(liveObj2,&local_1c.x,&local_1c.y);
	LiveObject_GetPosition(liveObj1,&local_24.x,&local_24.y);
	local_2c.x = local_24.x - local_1c.x;
	local_2c.y = local_24.y - local_1c.y;
	fVar2 = SQRT(local_2c.y * local_2c.y + local_2c.x * local_2c.x);
	fVar6 = stats::StatsObject_GetAlertRadius(liveObj2);
	fVar1 = (float)fVar6;
	if ((liveObj2->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
		if (((((liveObj1->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE) &&
				 ((liveObj1->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)) &&
				((((byte)globs::legoGlobs.flags2 & 1) == 0 || ((*(byte *)&liveObj1->flags4 & 4) == 0)))) &&
			 (liveObj1->drivenObject == NULL)) {
			if (liveObj1->objType == OBJECT_MINIFIGURE) {
				OVar4 = stats::StatsObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_GRABMINIFIGURE) != STATS1_NONE) {
					cont = LiveObject_GetContainer(liveObj2);
					res::Container_GetOrientation(cont,NULL,&local_c,NULL);
					out_by = &local_10;
					puVar8 = &local_14;
					fVar9 = 1.0 / SQRT(local_c.y * local_c.y + local_c.x * local_c.x);
					fVar3 = fVar9 * local_c.y * 15.0 + local_1c.y;
					fVar9 = fVar9 * local_c.x * 15.0 + local_1c.x;
					in_x = fVar9;
					in_y = fVar3;
					surfMap = lrr::Lego_GetMap();
					Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)puVar8,(int *)out_by);
					BVar5 = Level_Block_IsWall(local_14,(uint)local_10);
					if (BVar5 == 0) {
						BVar5 = Level_Block_IsSolidBuilding(local_14,(uint)local_10,1);
						if (BVar5 == 0) {
							fVar9 = local_24.x - fVar9;
							fVar3 = local_24.y - fVar3;
							fVar6 = stats::StatsObject_GetCollRadius(liveObj1);
							if ((float10)SQRT(fVar3 * fVar3 + fVar9 * fVar9) < fVar6) {
								ai::AI_LiveObject_DoThrowLegoman(liveObj2,liveObj1);
								return 0;
							}
						}
					}
				}
				OVar4 = stats::StatsObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_CAUSESLIP) != STATS1_NONE) {
					fVar6 = stats::StatsObject_GetCollRadius(liveObj2);
					fVar7 = stats::StatsObject_GetCollRadius(liveObj1);
					if ((ushort)((ushort)(fVar7 + (float10)(float)fVar6 < (float10)fVar2) << 8 |
											(ushort)(fVar7 + (float10)(float)fVar6 == (float10)fVar2) << 0xe) == 0) {
						ai::AI_LiveObject_DoSlip(liveObj1);
						liveObj2->health = -1.0;
						liveObj2->flags3 = liveObj2->flags3 | LIVEOBJ3_UNK_800000;
					}
				}
				OVar4 = stats::StatsObject_GetStatsFlags1(liveObj2);
				if (((OVar4 & STATS1_CANSCARE) != STATS1_NONE) && (fVar1 != 0.0)) {
					fVar6 = stats::StatsObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						local_2c.x = (1.0 / fVar2) * local_2c.x;
						local_2c.y = (1.0 / fVar2) * local_2c.y;
						LiveObject_FUN_00444720(liveObj1,&local_2c);
					}
				}
			}
			if (((liveObj1->objType == OBJECT_VEHICLE) || (liveObj1->objType == OBJECT_MINIFIGURE)) &&
				 ((liveObj1->flags1 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE)) {
				fVar6 = stats::StatsObject_GetPainThreshold(liveObj2);
				if (fVar6 < (float10)liveObj2->health) {
					fVar6 = stats::StatsObject_GetStampRadius(liveObj2);
					if ((ushort)((ushort)(fVar6 < (float10)fVar2) << 8 |
											(ushort)(fVar6 == (float10)fVar2) << 0xe) == 0) {
						LiveObject_FUN_0043acb0(liveObj2,liveObj1);
					}
				}
			}
			if ((liveObj1->objType == OBJECT_MINIFIGURE) || (liveObj1->objType == OBJECT_VEHICLE)) {
				OVar4 = stats::StatsObject_GetStatsFlags1(liveObj2);
				if (((OVar4 & STATS1_SCAREDBYPLAYER) != STATS1_NONE) &&
					 ((liveObj2->flags1 & 0x8000000) == LIVEOBJ1_NONE)) {
					fVar6 = stats::StatsObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						BVar5 = LiveObject_FUN_00444520(liveObj2);
						if (BVar5 != 0) {
							liveObj2->flags1 = liveObj2->flags1 | 0x8000000;
						}
					}
				}
			}
			if (liveObj1->objType == OBJECT_MINIFIGURE) {
				OVar4 = stats::StatsObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_FLOCKS) != STATS1_NONE) {
					fVar3 = local_24.x - (float)liveObj2->flocksData_32c->field_18;
					local_10 = local_24.y - (float)liveObj2->flocksData_32c->field_20;
					fVar9 = local_10 * local_10;
					fVar6 = stats::StatsObject_GetCollRadius(liveObj1);
					if ((float10)SQRT(fVar9 + fVar3 * fVar3) < fVar6 + (float10)fVar1) {
						fVar9 = 1.0;
						BVar5 = 1;
						liveObj = liveObj1;
						weaponType = tools::Weapon_GetWeaponTypeByName("BatAttack");
						fVar6 = tools::Weapon_GetDamageForLiveObject(weaponType,liveObj);
						LiveObject_AddDamage2(liveObj1,(float)fVar6,BVar5,fVar9);
						liveObj2->flags2 =
								 liveObj2->flags2 |
								 ~(LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_4|LIVEOBJ2_DRIVING|LIVEOBJ2_UNK_10|
									 LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_40|LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|
									 LIVEOBJ2_TRAINING|LIVEOBJ2_UNK_800|LIVEOBJ2_UNK_1000|LIVEOBJ2_UNK_2000|
									 LIVEOBJ2_UNK_4000|LIVEOBJ2_UPGRADING|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000|
									 LIVEOBJ2_UNK_40000|LIVEOBJ2_UNK_80000|LIVEOBJ2_UNK_100000|LIVEOBJ2_UNK_200000|
									 LIVEOBJ2_UNK_400000|LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000|LIVEOBJ2_UNK_2000000
									 |LIVEOBJ2_UNK_4000000|LIVEOBJ2_UNK_8000000|LIVEOBJ2_UNK_10000000|
									 LIVEOBJ2_UNK_20000000|LIVEOBJ2_UNK_40000000|LIVEOBJ2_UNK_80000000);
						if ((*(byte *)&liveObj2->flocksData_32c->field_24 & 1) == 0) {
							ai::AITask_DoFollow_Group(&liveObj2,1,liveObj1);
							puVar8 = &liveObj2->flocksData_32c->field_24;
							*puVar8 = *puVar8 | 1;
						}
					}
				}
			}
			OVar4 = stats::StatsObject_GetStatsFlags1(liveObj2);
			if ((OVar4 & STATS1_CANSCARESCORPION) != STATS1_NONE) {
				BVar5 = Object_GetObjectByName("Scorpion",&local_34,&local_30,NULL);
				if (((BVar5 != 0) && (local_34 == liveObj1->objType)) &&
					 ((local_30 == liveObj1->objIndex && (fVar1 != 0.0)))) {
					fVar6 = stats::StatsObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						local_2c.x = (1.0 / fVar2) * local_2c.x;
						local_2c.y = (1.0 / fVar2) * local_2c.y;
						LiveObject_FUN_00444720(liveObj1,&local_2c);
					}
				}
			}
		}
	}
	else {
		if ((liveObj1->objType == OBJECT_MINIFIGURE) || (liveObj1->objType == OBJECT_VEHICLE)) {
			fVar6 = stats::StatsObject_GetWakeRadius(liveObj2);
			if ((ushort)((ushort)(fVar6 < (float10)fVar2) << 8 | (ushort)(fVar6 == (float10)fVar2) << 0xe)
					== 0) {
				LiveObject_RockMonster_DoWakeUp(liveObj2);
				return 1;
			}
		}
	}
	return 0;
}



LiveObject * __cdecl
lego::game::LiveObject_DoCollisionCallbacks_FUN_00446030
					(LiveObject *liveObj,Point2F *param_2,float param_3,BOOL param_4)
{
	ObjectStatsFlags1 OVar1;
	SearchCollision_14 search;
	
	search.pointf_4 = param_2;
	search.targetObj = liveObj;
	search.float_8 = param_3;
	search.result = NULL;
	search.bool_10 = param_4;
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLBOX) != STATS1_NONE) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackCollisionBox_FUN_004463b0,&search);
	}
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLRADIUS) != STATS1_NONE) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackCollisionRadius_FUN_004460b0,&search);
	}
	return search.result;
}



BOOL __cdecl
lego::game::LiveObject_CallbackCollisionRadius_FUN_004460b0(LiveObject *in_liveObj,int *search)
{
	LiveObject *liveObj;
	float fVar1;
	ObjectStatsFlags1 OVar2;
	Container *cont;
	float *pfVar3;
	int iVar4;
	BOOL BVar5;
	Vector3F *out_vector;
	Point2F *pPVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float local_60;
	float local_5c;
	Point2F local_58;
	Point2F local_50 [3];
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	undefined4 local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	liveObj = (LiveObject *)*search;
	if (((((search[4] == 0) ||
				(OVar2 = stats::StatsObject_GetStatsFlags1(liveObj),
				(OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE)) && (in_liveObj != liveObj)) &&
			((in_liveObj->carryingThisObject != liveObj && (liveObj->carryingThisObject != in_liveObj))))
		 && ((in_liveObj != liveObj->drivenObject &&
				 (((liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
					((in_liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)))))) {
		fVar7 = stats::StatsObject_GetCollHeight(in_liveObj);
		if ((ushort)((ushort)(fVar7 < (float10)(float)search[2]) << 8 |
								(ushort)(fVar7 == (float10)(float)search[2]) << 0xe) == 0) {
			LiveObject_GetPosition(in_liveObj,&local_60,&local_5c);
			cont = LiveObject_GetContainer(in_liveObj);
			local_60 = local_60 - *(float *)search[1];
			local_5c = local_5c - ((float *)search[1])[1];
			fVar1 = SQRT(local_5c * local_5c + local_60 * local_60);
			OVar2 = stats::StatsObject_GetStatsFlags1(in_liveObj);
			if ((OVar2 & STATS1_COLLRADIUS) == STATS1_NONE) {
				OVar2 = stats::StatsObject_GetStatsFlags1(in_liveObj);
				if ((OVar2 & STATS1_COLLBOX) != STATS1_NONE) {
					fVar8 = stats::StatsObject_GetCollRadius(liveObj);
					fVar9 = stats::StatsObject_GetCollRadius(in_liveObj);
					fVar7 = (float10)fVar1;
					if ((ushort)((ushort)(fVar9 + (float10)(float)fVar8 < fVar7) << 8 |
											(ushort)(fVar9 + (float10)(float)fVar8 == fVar7) << 0xe) == 0) {
						pfVar3 = (float *)stats::StatsObject_GetCollBox(in_liveObj);
						local_30.x = *pfVar3 * -0.5;
						iVar4 = stats::StatsObject_GetCollBox(in_liveObj);
						local_30.z = *(float *)(iVar4 + 4) * 0.5;
						pfVar3 = (float *)stats::StatsObject_GetCollBox(in_liveObj);
						local_24 = *pfVar3 * 0.5;
						iVar4 = stats::StatsObject_GetCollBox(in_liveObj);
						local_1c = *(float *)(iVar4 + 4) * 0.5;
						pfVar3 = (float *)stats::StatsObject_GetCollBox(in_liveObj);
						local_18 = *pfVar3 * 0.5;
						iVar4 = stats::StatsObject_GetCollBox(in_liveObj);
						local_10 = *(float *)(iVar4 + 4) * -0.5;
						pfVar3 = (float *)stats::StatsObject_GetCollBox(in_liveObj);
						local_c = *pfVar3 * -0.5;
						iVar4 = stats::StatsObject_GetCollBox(in_liveObj);
						local_4 = *(float *)(iVar4 + 4) * -0.5;
						local_8 = 0;
						local_14 = 0;
						local_20 = 0;
						local_30.y = 0.0;
						pPVar6 = &local_58;
						out_vector = &local_30;
						iVar4 = 4;
						do {
							res::Container_Transform(cont,out_vector,out_vector);
							fVar1 = out_vector->y;
							pPVar6->x = out_vector->x;
							pPVar6->y = fVar1;
							out_vector = out_vector + 1;
							pPVar6 = pPVar6 + 1;
							iVar4 += -1;
						} while (iVar4 != 0);
						local_38 = local_58.x;
						local_34 = local_58.y;
						BVar5 = math::Maths_PointInsidePoly((Point2F *)search[1],&local_58,local_50,4);
						if (BVar5 == 0) {
							fVar7 = math::Collision_Maths_FUN_00408a30((Point2F *)search[1],&local_58,local_50,4);
							fVar8 = stats::StatsObject_GetCollRadius(liveObj);
							if ((ushort)((ushort)(fVar8 < (float10)(float)fVar7) << 8 |
													(ushort)(fVar8 == (float10)(float)fVar7) << 0xe) == 0) {
								search[3] = (int)in_liveObj;
							}
						}
						else {
							search[3] = (int)in_liveObj;
						}
					}
				}
			}
			else {
				fVar8 = stats::StatsObject_GetCollRadius(liveObj);
				fVar9 = stats::StatsObject_GetCollRadius(in_liveObj);
				fVar7 = (float10)fVar1;
				if ((ushort)((ushort)(fVar9 + (float10)(float)fVar8 < fVar7) << 8 |
										(ushort)(fVar9 + (float10)(float)fVar8 == fVar7) << 0xe) == 0) {
					search[3] = (int)in_liveObj;
				}
			}
		}
		if (search[3] != 0) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_CallbackCollisionBox_FUN_004463b0
					(LiveObject *in_liveObj,SearchCollision_14 *search)
{
	float fVar1;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar2;
	float *pfVar3;
	int iVar4;
	BOOL BVar5;
	float *pfVar6;
	int iVar7;
	LiveObject **ppLVar8;
	Point2F *pPVar9;
	Vector3F *out_vector;
	Vector3F *pVVar10;
	float10 fVar11;
	float10 fVar12;
	float local_f8;
	float local_f4;
	Point2F local_f0;
	LiveObject *local_e8 [2];
	Container *local_e0;
	Container *local_dc;
	Vector3F local_d8;
	float local_cc;
	undefined4 local_c8;
	float local_c4;
	float local_c0;
	undefined4 local_bc;
	float local_b8;
	float local_b4;
	Point2F local_b0;
	Point2F local_a8 [4];
	Point2F local_88;
	Point2F local_80 [3];
	float local_68;
	float local_64;
	Vector3F local_60 [4];
	Vector3F local_30 [4];
	
	local_e8[1] = search->targetObj;
	if (((((search->bool_10 == 0) ||
				(OVar2 = stats::StatsObject_GetStatsFlags1(local_e8[1]),
				(OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE)) && (in_liveObj != local_e8[1])) &&
			((in_liveObj->carryingThisObject != local_e8[1] &&
			 (local_e8[1]->carryingThisObject != in_liveObj)))) &&
		 (((local_e8[1]->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			(((in_liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			 (fVar11 = stats::StatsObject_GetCollHeight(in_liveObj),
			 (ushort)((ushort)(fVar11 < (float10)search->float_8) << 8 |
							 (ushort)(fVar11 == (float10)search->float_8) << 0xe) == 0)))))) {
		LiveObject_GetPosition(in_liveObj,&local_f0.x,&local_f0.y);
		LiveObject_GetPosition(local_e8[1],&local_f8,&local_f4);
		local_f8 = local_f8 - search->pointf_4->x;
		local_f4 = local_f4 - search->pointf_4->y;
		local_dc = LiveObject_GetContainer(in_liveObj);
		local_e0 = LiveObject_GetContainer(local_e8[1]);
		OVar2 = stats::StatsObject_GetStatsFlags1(in_liveObj);
		if ((OVar2 & STATS1_COLLRADIUS) == STATS1_NONE) {
			OVar2 = stats::StatsObject_GetStatsFlags1(in_liveObj);
			if ((OVar2 & STATS1_COLLBOX) != STATS1_NONE) {
				local_f0.y = local_f0.y - search->pointf_4->y;
				local_f0.x = local_f0.x - search->pointf_4->x;
				fVar11 = stats::StatsObject_GetCollRadius(in_liveObj);
				local_e8[0] = (LiveObject *)(float)fVar11;
				fVar11 = stats::StatsObject_GetCollRadius(local_e8[1]);
				if ((float10)SQRT(local_f0.x * local_f0.x + local_f0.y * local_f0.y) <
						fVar11 + (float10)(float)local_e8[0]) {
					local_e8[0] = in_liveObj;
					ppLVar8 = local_e8;
					iVar4 = 2;
					pfVar3 = &local_60[0].z;
					do {
						liveObj = *ppLVar8;
						pfVar6 = (float *)stats::StatsObject_GetCollBox(liveObj);
						pfVar3[-2] = *pfVar6 * -0.5;
						iVar7 = stats::StatsObject_GetCollBox(liveObj);
						*pfVar3 = *(float *)(iVar7 + 4) * 0.5;
						pfVar6 = (float *)stats::StatsObject_GetCollBox(liveObj);
						pfVar3[1] = *pfVar6 * 0.5;
						iVar7 = stats::StatsObject_GetCollBox(liveObj);
						pfVar3[3] = *(float *)(iVar7 + 4) * 0.5;
						pfVar6 = (float *)stats::StatsObject_GetCollBox(liveObj);
						pfVar3[4] = *pfVar6 * 0.5;
						iVar7 = stats::StatsObject_GetCollBox(liveObj);
						pfVar3[6] = *(float *)(iVar7 + 4) * -0.5;
						pfVar6 = (float *)stats::StatsObject_GetCollBox(liveObj);
						pfVar3[7] = *pfVar6 * -0.5;
						iVar7 = stats::StatsObject_GetCollBox(liveObj);
						ppLVar8 = ppLVar8 + 1;
						iVar4 += -1;
						pfVar3[9] = *(float *)(iVar7 + 4) * -0.5;
						pfVar3[8] = 0.0;
						pfVar3[5] = 0.0;
						pfVar3[2] = 0.0;
						pfVar3[-1] = 0.0;
						pfVar3 = pfVar3 + 0xc;
					} while (iVar4 != 0);
					pPVar9 = &local_b0;
					pVVar10 = local_30;
					iVar4 = 4;
					do {
						res::Container_Transform(local_e0,pVVar10,pVVar10);
						fVar1 = pVVar10->y;
						pPVar9->x = pVVar10->x;
						pPVar9->y = fVar1;
						pVVar10 = pVVar10 + 1;
						pPVar9 = pPVar9 + 1;
						iVar4 += -1;
					} while (iVar4 != 0);
					pVVar10 = &local_d8;
					out_vector = local_60;
					iVar4 = 4;
					do {
						res::Container_Transform(local_dc,out_vector,out_vector);
						fVar1 = out_vector->y;
						pVVar10->x = out_vector->x;
						pVVar10->y = fVar1;
						out_vector = out_vector + 1;
						pVVar10 = (Vector3F *)&pVVar10->z;
						iVar4 += -1;
					} while (iVar4 != 0);
					pfVar3 = &local_b8;
					iVar4 = 2;
					do {
						*pfVar3 = pfVar3[-8];
						pfVar3[1] = pfVar3[-7];
						pfVar3 = pfVar3 + 10;
						iVar4 += -1;
					} while (iVar4 != 0);
					pVVar10 = &local_d8;
					iVar4 = 4;
					do {
						BVar5 = math::Maths_PointInsidePoly((Point2F *)pVVar10,&local_b0,local_a8,4);
						if (BVar5 != 0) {
							search->result = in_liveObj;
						}
						pVVar10 = (Vector3F *)&pVVar10->z;
						iVar4 += -1;
					} while (iVar4 != 0);
				}
			}
		}
		else {
			local_f0.y = local_f0.y - search->pointf_4->y;
			local_f0.x = local_f0.x - search->pointf_4->x;
			fVar11 = stats::StatsObject_GetCollRadius(in_liveObj);
			local_e8[0] = (LiveObject *)(float)fVar11;
			fVar11 = stats::StatsObject_GetCollRadius(local_e8[1]);
			if ((float10)SQRT(local_f0.x * local_f0.x + local_f0.y * local_f0.y) <
					fVar11 + (float10)(float)local_e8[0]) {
				pfVar3 = (float *)stats::StatsObject_GetCollBox(local_e8[1]);
				local_d8.x = *pfVar3 * -0.5;
				iVar4 = stats::StatsObject_GetCollBox(local_e8[1]);
				local_d8.z = *(float *)(iVar4 + 4) * 0.5;
				pfVar3 = (float *)stats::StatsObject_GetCollBox(local_e8[1]);
				local_cc = *pfVar3 * 0.5;
				iVar4 = stats::StatsObject_GetCollBox(local_e8[1]);
				local_c4 = *(float *)(iVar4 + 4) * 0.5;
				pfVar3 = (float *)stats::StatsObject_GetCollBox(local_e8[1]);
				local_c0 = *pfVar3 * 0.5;
				iVar4 = stats::StatsObject_GetCollBox(local_e8[1]);
				local_b8 = *(float *)(iVar4 + 4) * -0.5;
				pfVar3 = (float *)stats::StatsObject_GetCollBox(local_e8[1]);
				local_b4 = *pfVar3 * -0.5;
				iVar4 = stats::StatsObject_GetCollBox(local_e8[1]);
				local_b0.y = *(float *)(iVar4 + 4) * -0.5;
				local_b0.x = 0.0;
				local_bc = 0;
				local_c8 = 0;
				local_d8.y = 0.0;
				pVVar10 = &local_d8;
				iVar4 = 4;
				pPVar9 = &local_88;
				do {
					res::Container_Transform(local_e0,pVVar10,pVVar10);
					fVar1 = pVVar10->y;
					pPVar9->x = pVVar10->x;
					pPVar9->y = fVar1;
					pVVar10 = pVVar10 + 1;
					iVar4 += -1;
					pPVar9->x = local_f8 + pPVar9->x;
					pPVar9->y = local_f4 + pPVar9->y;
					pPVar9 = pPVar9 + 1;
				} while (iVar4 != 0);
				local_68 = local_88.x;
				local_64 = local_88.y;
				BVar5 = math::Maths_PointInsidePoly(&local_f0,&local_88,local_80,4);
				if (BVar5 == 0) {
					fVar11 = math::Collision_Maths_FUN_00408a30(&local_f0,&local_88,local_80,4);
					fVar12 = stats::StatsObject_GetCollRadius(in_liveObj);
					if ((ushort)((ushort)(fVar12 < (float10)(float)fVar11) << 8 |
											(ushort)(fVar12 == (float10)(float)fVar11) << 0xe) == 0) {
						search->result = in_liveObj;
					}
				}
				else {
					search->result = in_liveObj;
				}
			}
		}
		if (search->result != NULL) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_Callback_FUN_004468d0
					(LiveObject *in_liveObj,float elapsed,float *param_3,float *out_float_4)
{
	LiveFlags1 LVar1;
	ObjectType OVar2;
	ulonglong uVar3;
	LiveObject *liveObj;
	float *pfVar4;
	SurfaceMap *surfMap;
	BOOL BVar5;
	ObjectStatsFlags2 OVar6;
	float10 fVar7;
	Point2I *out_bx;
	int *out_by;
	float *out_unk_z;
	float local_1c;
	Point2I local_18;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 uStack4;
	
	pfVar4 = param_3;
	liveObj = in_liveObj;
	LVar1 = in_liveObj->flags1;
	local_1c = (float)(LVar1 & LIVEOBJ1_CAUGHTINWEB);
	OVar2 = in_liveObj->objType;
	if (OVar2 == OBJECT_VEHICLE) {
		fVar7 = res::Vehicle_GetTransCoef(in_liveObj->vehicle);
		in_liveObj = (LiveObject *)(float)fVar7;
	}
	else {
		if (OVar2 == OBJECT_MINIFIGURE) {
			fVar7 = res::Creature_GetTransCoef(in_liveObj->miniFigure);
			in_liveObj = (LiveObject *)(float)fVar7;
		}
		else {
			if (OVar2 == OBJECT_ROCKMONSTER) {
				fVar7 = res::Creature_GetTransCoef(in_liveObj->rockMonster);
				in_liveObj = (LiveObject *)(float)fVar7;
			}
			else {
				if (OVar2 == OBJECT_BUILDING) {
					fVar7 = res::Building_GetAnimFloat14_zero(in_liveObj->building);
					in_liveObj = (LiveObject *)(float)fVar7;
				}
				else {
					if (((in_liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) ||
						 (OVar2 == OBJECT_UPGRADEPART)) {
						*out_float_4 = elapsed;
						return;
					}
				}
			}
		}
	}
	if ((LVar1 & LIVEOBJ1_UNK_8) == LIVEOBJ1_NONE) {
		if (((LVar1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) || (liveObj->objType == OBJECT_VEHICLE)) {
			fVar7 = stats::StatsObject_GetRouteSpeed(liveObj);
			*param_3 = (float)fVar7;
			if ((LVar1 & LIVEOBJ1_LIFTING) != LIVEOBJ1_NONE) {
				*param_3 = (float)(fVar7 * (float10)0.5);
			}
		}
		else {
			fVar7 = stats::StatsObject_GetRouteSpeed(liveObj);
			*param_3 = (float)(fVar7 * (float10)0.5);
		}
	}
	else {
		fVar7 = stats::StatsObject_GetRouteSpeed(liveObj);
		*param_3 = (float)(fVar7 * (float10)0.05);
	}
	if (local_1c != 0.0) {
		*param_3 = *param_3 * 0.05;
	}
	local_1c = 1.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	out_unk_z = &local_1c;
	out_by = &local_18.y;
	out_bx = &local_18;
	surfMap = lrr::Lego_GetMap();
	BVar5 = Map3D_WorldToBlockPos(surfMap,local_10,local_c,&out_bx->x,out_by,out_unk_z);
	if (BVar5 != 0) {
		local_8 = Level_Block_GetRubbleLayers(&local_18);
		uStack4 = 0;
		uVar3 = (ulonglong)local_8;
		fVar7 = stats::StatsObject_GetRubbleCoef(liveObj);
		param_3 = (float *)(float)((float10)1.0 -
															((float10)1.0 - fVar7) * (float10)((float)uVar3 * 0.25));
		BVar5 = Level_Block_IsPath(&local_18);
		if (BVar5 != 0) {
			fVar7 = stats::StatsObject_GetPathCoef(liveObj);
			param_3 = (float *)(float)(fVar7 * (float10)(float)param_3);
		}
		if ((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((globs::legoGlobs.level)->blocks
				[((globs::legoGlobs.level)->dimensions).width * local_18.y + local_18.x].terrain ==
				TERRAIN_LAKE)) {
			param_3 = (float *)((1.0 - local_1c * 0.8) * (float)param_3);
		}
		BVar5 = Level_Block_IsGround(local_18.x,local_18.y);
		if (BVar5 != 0) {
			*pfVar4 = *pfVar4 * (float)param_3;
		}
	}
	if ((float)in_liveObj == 0.0) {
		*out_float_4 = 1.0;
	}
	else {
		*out_float_4 = *pfVar4 / (float)in_liveObj;
	}
	if (((liveObj->objType == OBJECT_BUILDING) &&
			(OVar6 = stats::StatsObject_GetStatsFlags2(liveObj),
			(OVar6 & STATS2_UPGRADEBUILDING) != STATS2_NONE)) &&
		 ((liveObj->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE)) {
		fVar7 = stats::StatsObject_GetFunctionCoef(liveObj);
		*out_float_4 = (float)(fVar7 * (float10)*out_float_4);
	}
	*out_float_4 = *out_float_4 * elapsed;
	*pfVar4 = *pfVar4 * elapsed;
	return;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPtr_Realloc_FUN_00446b80(LiveObject *liveObj,uint bx,uint by)
{
	uint uVar1;
	uint uVar2;
	RoutingBlock *routeBlocks;
	uint oldCount;
	
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		oldCount = liveObj->routingBlocksTotal;
		routeBlocks = liveObj->routeptr_24;
		uVar1 = routeBlocks[oldCount - 1].blockPos.x;
		uVar2 = routeBlocks[oldCount - 1].blockPos.y;
		if ((((bx == uVar1) && ((by == uVar2 - 1 || (by == uVar2 + 1)))) ||
				((by == uVar2 && ((bx == uVar1 - 1 || (bx == uVar1 + 1)))))) &&
			 (routeBlocks = (RoutingBlock *)std::realloc(routeBlocks,(oldCount + 1) * 0x14),
			 routeBlocks != NULL)) {
			liveObj->routeptr_24 = routeBlocks;
			routeBlocks[liveObj->routingBlocksTotal].blockPos.x = bx;
			liveObj->routeptr_24[liveObj->routingBlocksTotal].blockPos.y = by;
			liveObj->routeptr_24[liveObj->routingBlocksTotal].worldPos.x = 0.5;
			liveObj->routeptr_24[liveObj->routingBlocksTotal].worldPos.y = 0.5;
			liveObj->routeptr_24[liveObj->routingBlocksTotal].flagsByte_10 = 0;
			liveObj->routeptr_24[liveObj->routingBlocksTotal].byte_11 = TRUE;
			liveObj->routingBlocksTotal = liveObj->routingBlocksTotal + 1;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_400;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_BlockRoute_FUN_00446c80
					(LiveObject *liveObj,uint bx,uint by,BOOL param_4,uint *out_param_5,BOOL countIs8)
{
	float fVar1;
	bool bVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	undefined4 uVar5;
	uint by_00;
	int iVar6;
	float **ppfVar7;
	uint uVar8;
	float *pfVar9;
	int *piVar10;
	uint uVar11;
	uint uVar12;
	longlong lVar13;
	float **ppfVar14;
	float **ppfVar15;
	uint *puVar16;
	float *out_x;
	undefined4 callback;
	undefined4 uVar17;
	int *local_11c;
	float *local_118;
	BOOL local_114;
	float local_110;
	float local_10c;
	uint local_108;
	float local_104;
	float local_100;
	undefined4 uStack252;
	uint local_f8;
	uint local_f4;
	float local_f0;
	float local_ec;
	float local_e8;
	float local_e4;
	float local_e0;
	undefined4 local_dc;
	undefined4 local_d8;
	undefined4 local_d4;
	undefined4 local_d0;
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	float local_c0;
	undefined4 local_bc;
	undefined4 local_b8;
	undefined4 local_b4;
	undefined4 local_b0;
	undefined4 local_ac;
	undefined4 local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	undefined4 local_90;
	undefined4 local_8c;
	undefined4 local_88;
	undefined4 local_84;
	int local_80 [8];
	float *local_60 [8];
	float *local_40 [8];
	uint local_20 [8];
	
	local_108 = 0xffffffff;
	local_f8 = 0xffffffff;
	local_f4 = 0xffffffff;
	piVar10 = local_80;
	local_80[0] = 0;
	local_b8 = 0;
	for (iVar6 = 7; piVar10 = piVar10 + 1, iVar6 != 0; iVar6 += -1) {
		*piVar10 = 0;
	}
	local_a4 = 0;
	local_a0 = 0;
	local_8c = 0;
	local_e0 = 0.0;
	local_d4 = 0;
	local_d0 = 0;
	local_c4 = 0;
	local_114 = 0;
	local_c0 = -1.0;
	local_bc = 0xc0000000;
	local_b4 = 0xc0000000;
	local_b0 = 0x3f800000;
	local_ac = 0xbf800000;
	local_a8 = 0x3f800000;
	local_9c = 0x3f800000;
	local_98 = 0xbf800000;
	local_94 = 0x3f800000;
	local_90 = 0xc0000000;
	local_88 = 0xc0000000;
	local_84 = 0xbf800000;
	local_dc = 0xbf800000;
	local_d8 = 0x3f800000;
	local_cc = 0x3f800000;
	local_c8 = 0xbf800000;
	bVar2 = true;
	if (param_4 == 0) {
		local_118 = &local_e0;
		uVar8 = 4;
	}
	else {
		local_118 = &local_c0;
		uVar8 = 8;
	}
	LiveObject_GetBlockPos(liveObj,(int *)&local_110,(int *)&local_10c);
	if (countIs8 == 0) {
		pfVar9 = &local_ec;
		out_x = &local_f0;
		uVar12 = bx;
		uVar11 = by;
		pSVar3 = lrr::Lego_GetMap();
		Map3D_BlockToWorldPos(pSVar3,uVar12,uVar11,out_x,pfVar9);
		LiveObject_GetPosition(liveObj,&local_e8,&local_e4);
		local_104 = SQRT((local_ec - local_e4) * (local_ec - local_e4) +
										 (local_f0 - local_e8) * (local_f0 - local_e8));
		pSVar3 = lrr::Lego_GetMap();
		if (local_104 < pSVar3->BlockSize) {
			bVar2 = false;
		}
	}
	uVar11 = 0;
	uVar12 = local_f4;
	if (uVar8 != 0) {
		local_104 = (float)(ulonglong)bx;
		uStack252 = 0;
		local_100 = (float)(ulonglong)by;
		pfVar9 = local_118;
		do {
			*pfVar9 = *pfVar9 + local_104;
			fVar1 = pfVar9[1];
			pfVar9[1] = fVar1 + local_100;
			if ((((*pfVar9 == (float)(int)local_110) && (fVar1 + local_100 == (float)(int)local_10c)) &&
					(bVar2)) &&
				 ((uVar12 = uVar11, param_4 != 0 ||
					(BVar4 = Level_Block_IsWall((uint)local_110,(uint)local_10c), BVar4 == 0)))) break;
			uVar11 += 1;
			pfVar9 = pfVar9 + 2;
			uVar12 = local_f4;
		} while (uVar11 < uVar8);
	}
	if (uVar12 != 0xffffffff) {
		BVar4 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,&local_110,&local_10c,NULL);
		if (BVar4 == 0) {
			return 0;
		}
		if (out_param_5 != NULL) {
			*out_param_5 = uVar12;
		}
		return 1;
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		local_11c = local_80;
		ppfVar7 = local_40;
		pfVar9 = local_118;
		do {
			if (((float)(int)local_110 != *pfVar9) || ((float)(int)local_10c != pfVar9[1])) {
				lVar13 = __ftol((float10)pfVar9[1]);
				uVar5 = (undefined4)lVar13;
				uVar17 = 0;
				puVar16 = local_20 + uVar12;
				callback = 0;
				ppfVar15 = local_60 + uVar12;
				ppfVar14 = ppfVar7;
				lVar13 = __ftol((float10)*pfVar9);
				BVar4 = LiveObject_FUN_004413b0
													(liveObj,local_110,local_10c,(int)lVar13,uVar5,ppfVar14,ppfVar15,puVar16,
													 callback,uVar17);
				if (BVar4 != 0) {
					*local_11c = 1;
				}
			}
			uVar12 += 1;
			pfVar9 = pfVar9 + 2;
			ppfVar7 = ppfVar7 + 1;
			local_11c = local_11c + 1;
		} while (uVar12 < uVar8);
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		do {
			if ((local_108 != 0xffffffff) && (uVar12 == uVar8)) break;
			uVar11 = uVar12 % uVar8;
			if (local_80[uVar11] != 0) {
				if (uVar12 < uVar8) {
					lVar13 = __ftol((float10)local_118[uVar11 * 2 + 1]);
					by_00 = (uint)lVar13;
					lVar13 = __ftol((float10)local_118[uVar11 * 2]);
					BVar4 = Level_Block_IsWall((uint)lVar13,by_00);
					if (BVar4 != 0) goto LAB_0044704f;
				}
				if (local_20[uVar11] < local_f8) {
					local_108 = uVar11;
					local_f8 = local_20[uVar11];
				}
			}
LAB_0044704f:
			uVar12 += 1;
		} while (uVar12 < uVar8 * 2);
	}
	if (local_108 != 0xffffffff) {
		BVar4 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
											(liveObj,local_20[local_108],local_40[local_108],local_60[local_108],NULL);
		if (BVar4 == 0) {
			local_114 = 0;
		}
		else {
			if (out_param_5 != NULL) {
				*out_param_5 = local_108;
			}
			local_114 = TRUE;
		}
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		ppfVar7 = local_60;
		do {
			if (local_80[uVar12] != 0) {
				std::free(local_40[uVar12]);
				std::free(*ppfVar7);
			}
			uVar12 += 1;
			ppfVar7 = ppfVar7 + 1;
		} while (uVar12 < uVar8);
	}
	return local_114;
}



BOOL __cdecl
lego::game::LiveObject_RouteToDig_FUN_00447100(LiveObject *liveObj,uint bx,uint by,BOOL tunnelDig)
{
	uint uVar1;
	RoutingBlock *pRVar2;
	float fVar3;
	LiveFlags3 LVar4;
	BOOL BVar5;
	float10 fVar6;
	uint local_84;
	int local_80 [4];
	undefined4 local_70;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	int local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	float local_40 [4];
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	BVar5 = LiveObject_BlockCheck_FUN_004326a0(liveObj,bx,by,tunnelDig,TRUE);
	if (BVar5 != 0) {
		BVar5 = LiveObject_BlockRoute_FUN_00446c80(liveObj,bx,by,tunnelDig,&local_84,TRUE);
		if (BVar5 != 0) {
			if (tunnelDig != 0) {
				local_60[0] = 0;
				local_60[1] = 1;
				local_60[2] = 1;
				local_44 = 0;
				local_60[3] = 2;
				local_50 = 2;
				local_80[2] = 0;
				local_4c = 3;
				local_48 = 3;
				local_70 = 0;
				local_80[0] = -1;
				local_80[1] = 0xffffffff;
				local_80[3] = 0xffffffff;
				local_68 = 0xffffffff;
				local_6c = 0;
				local_64 = 0;
				local_40[0] = 0.9;
				local_40[1] = 0.5;
				local_40[2] = 0.1;
				local_40[3] = 0.5;
				local_30 = 0x3f000000;
				local_2c = 0x3dcccccd;
				local_28 = 0x3f000000;
				local_24 = 0x3f666666;
				local_20 = 0x3dcccccd;
				local_1c = 0x3f000000;
				local_18 = 0x3f666666;
				local_14 = 0x3f000000;
				local_10 = 0x3f000000;
				local_c = 0x3f666666;
				local_8 = 0x3f000000;
				local_4 = 0x3dcccccd;
				LiveObject_RoutingPtr_Realloc_FUN_00446b80
									(liveObj,local_80[local_60[local_84] * 2] + bx,
									 local_80[local_60[local_84] * 2 + 1] + by);
				uVar1 = liveObj->routingBlocksTotal;
				pRVar2 = liveObj->routeptr_24;
				fVar3 = local_40[local_84 * 2 + 1];
				pRVar2[uVar1 - 1].worldPos.x = local_40[local_84 * 2];
				pRVar2[uVar1 - 1].worldPos.y = fVar3;
				LVar4 = liveObj->flags3;
				(liveObj->point_2f4).x = (float)(ulonglong)bx;
				liveObj->flags3 = LVar4 | LIVEOBJ3_UNK_2000000;
				(liveObj->point_2f4).y = (float)(ulonglong)by;
				return TRUE;
			}
			LiveObject_RoutingPtr_Realloc_FUN_00446b80(liveObj,bx,by);
			fVar6 = math::Maths_RandRange(0.3,0.7);
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x = (float)fVar6;
			fVar6 = math::Maths_RandRange(0.3,0.7);
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y = (float)fVar6;
			LVar4 = liveObj->flags3;
			(liveObj->point_2f4).x = (float)(ulonglong)bx;
			liveObj->flags3 = LVar4 & ~LIVEOBJ3_UNK_2000000;
			(liveObj->point_2f4).y = (float)(ulonglong)by;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Game_PTL_GatherRock(LiveObject *in_liveObj)
{
	BOOL BVar1;
	LiveObject *liveObj;
	Container_Texture *contTexture;
	float10 fVar2;
	Point2I point;
	
	if ((in_liveObj->flags3 & LIVEOBJ3_CANGATHER) != LIVEOBJ3_NONE) {
		fVar2 = stats::StatsObject_GetCarryMinHealth(in_liveObj);
		if (fVar2 < (float10)in_liveObj->health) {
			BVar1 = LiveObject_FUN_0044a890(in_liveObj,&point.x,&point.y,1,0,0);
			if (BVar1 != 0) {
				liveObj = LiveObject_Create((int **)globs::legoGlobs.contBoulder,OBJECT_BOULDER,0);
				LiveObject_SetPositionAndHeading(liveObj,10000.0,10000.0,0.0,1);
				LiveObject_HideAll(liveObj,1);
				BVar1 = LiveObject_RoutingNoCarry_FUN_00447470(in_liveObj,point.x,point.y,liveObj);
				if (BVar1 != 0) {
					contTexture = lrr::Lego_DynamicPM_GatherRockSurfaceTexture_FUN_00429090(&point);
					LiveObject_InitBoulderMesh_FUN_00440eb0(liveObj,contTexture);
					in_liveObj->float_33c = 0.0;
					return TRUE;
				}
				LiveObject_DestroyBoulder_AndCreateExplode(liveObj);
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_RoutingNoCarry_FUN_00447470
					(LiveObject *liveObj,uint x,uint y,LiveObject *liveObj2)
{
	BOOL BVar1;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,x,y,4.0);
		if (BVar1 != 0) {
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 3;
			liveObj->object_2fc = liveObj2;
			liveObj2->object_300 = liveObj;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Game_PTL_AttackBuilding(LiveObject *liveObj1,LiveObject *targetObj)
{
	short sVar1;
	short sVar2;
	uint uVar3;
	BOOL BVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	Point2I local_70;
	int local_68;
	int local_64;
	int local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (liveObj1->objType == OBJECT_ROCKMONSTER) {
		if (targetObj != NULL) {
			local_60[0] = 2;
			local_60[1] = 0;
			local_60[2] = 0;
			local_60[3] = 2;
			local_50 = 0xfffffffe;
			local_4c = 0;
			local_48 = 0;
			local_44 = 0xfffffffe;
			local_40 = 2;
			local_3c = 0xffffffff;
			local_38 = 2;
			local_34 = 1;
			local_30 = 1;
			local_2c = 2;
			local_28 = 0xffffffff;
			local_24 = 2;
			local_20 = 0xfffffffe;
			local_1c = 1;
			local_18 = 0xfffffffe;
			local_14 = 0xffffffff;
			local_10 = 0xffffffff;
			local_c = 0xfffffffe;
			local_8 = 1;
			local_4 = 0xfffffffe;
			sVar1 = math::Maths_Rand();
			sVar2 = math::Maths_Rand();
			uVar6 = (int)sVar2 >> 0x1f;
			LiveObject_GetBlockPos(targetObj,&local_68,&local_64);
			uVar9 = 0;
			do {
				uVar7 = 0;
				uVar8 = (int)sVar1 % 0xc;
				do {
					uVar3 = uVar8;
					if ((((int)sVar2 ^ uVar6) - uVar6 & 1 ^ uVar6) - uVar6 == 1) {
						uVar3 = 0x18 - uVar8;
					}
					local_70.x = local_60[(uVar3 % 0xc) * 2] + local_68;
					local_70.y = local_60[(uVar3 % 0xc) * 2 + 1] + local_64;
					if (((uVar9 == 1) ||
							(BVar4 = Level_Block_IsAnyFlags1_80000_Foundation(&local_70), BVar4 == 0)) &&
						 (iVar5 = LiveObject_FUN_00447670
																(liveObj1,(float)local_70.x,(float *)local_70.y,targetObj),
						 iVar5 != 0)) {
						return 1;
					}
					uVar7 += 1;
					uVar8 += 1;
				} while (uVar7 < 0xc);
				uVar9 += 1;
				if (1 < uVar9) {
					return 0;
				}
			} while( true );
		}
		LiveObject_DropCarriedObject_FUN_0043a130(liveObj1,0);
	}
	return 0;
}



int __cdecl
lego::game::LiveObject_FUN_00447670
					(LiveObject *in_liveObj,float param_2,float *param_3,LiveObject *liveObj2)
{
	LiveObject *liveObj;
	float fVar1;
	float *pfVar2;
	BOOL BVar3;
	BOOL BVar4;
	float *local_10;
	float local_c;
	float *local_8;
	uint local_4;
	
	liveObj = in_liveObj;
	BVar4 = 0;
	if ((in_liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		BVar3 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(in_liveObj);
		if (BVar3 == 0) {
			LiveObject_GetBlockPos(liveObj2,(int *)&local_c,(int *)&local_8);
			pfVar2 = param_3;
			fVar1 = param_2;
			if ((local_c != param_2) || (local_8 != param_3)) {
				LiveObject_GetBlockPos(liveObj,(int *)&param_2,(int *)&in_liveObj);
				if ((param_2 == fVar1) && (in_liveObj == (LiveObject *)pfVar2)) {
					BVar4 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
														(liveObj,1,&param_2,(float *)&in_liveObj,NULL);
				}
				else {
					BVar4 = LiveObject_FUN_004413b0
														(liveObj,param_2,in_liveObj,fVar1,pfVar2,&param_3,&local_10,&local_4,0,0
														);
					if (BVar4 == 0) {
						return 0;
					}
					BVar4 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,local_4,param_3,local_10,NULL);
					std::free(param_3);
					std::free(local_10);
				}
				if (BVar4 != 0) {
					liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 5;
					liveObj->carriedObjects[0]->object_2fc = liveObj2;
					return BVar4;
				}
			}
		}
	}
	return BVar4;
}



void __cdecl lego::game::LiveObject_FUN_004477b0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	float fVar1;
	float fVar2;
	float10 fVar3;
	float10 fVar4;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	liveObj = in_liveObj->object_2fc;
	in_liveObj->object_2fc = NULL;
	if (liveObj != NULL) {
		LiveObject_GetPosition(liveObj,&local_10.x,&local_10.y);
		LiveObject_GetPosition(in_liveObj,&local_8.x,&local_8.y);
		local_18.x = local_10.x - local_8.x;
		local_18.y = local_10.y - local_8.y;
		fVar2 = local_18.x * local_18.x;
		fVar1 = local_18.y * local_18.y;
		fVar3 = stats::StatsObject_GetCollRadius(liveObj);
		fVar4 = stats::StatsObject_GetCollRadius(in_liveObj);
		if ((float10)SQRT(fVar1 + fVar2) < fVar4 + fVar4 + (float10)(float)fVar3) {
			LiveObject_FUN_00447c10(liveObj,&local_18,1);
			LiveObject_AddDamage2(liveObj,10.0,1,1.0);
		}
	}
	return;
}



int __cdecl lego::game::LiveObject_FUN_00447880(LiveObject *in_liveObj)
{
	LiveObject *opt_liveObj;
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	int iVar3;
	float10 fVar4;
	
	iVar3 = 0;
	opt_liveObj = in_liveObj->object_2fc;
	if ((opt_liveObj != NULL) && ((opt_liveObj->flags2 & LIVEOBJ2_UNK_100000) == LIVEOBJ2_NONE)) {
		OVar1 = stats::StatsObject_GetStatsFlags2(in_liveObj);
		if ((OVar1 & STATS2_DRAINPOWER) == STATS2_NONE) {
			if ((in_liveObj->flags4 & 0x400000) == LIVEOBJ4_NONE) {
				if (in_liveObj->objType == OBJECT_ROCKMONSTER) {
					front::Info_Send(INFO_UNDERATTACK,NULL,opt_liveObj,NULL);
				}
				fVar4 = stats::StatsObject_GetRepairValue(in_liveObj);
				if ((float10)0.0 <= fVar4) {
					opt_liveObj->health = (float)(fVar4 + (float10)opt_liveObj->health);
				}
				else {
					LiveObject_AddDamage2(opt_liveObj,(float)-fVar4,1,1.0);
					opt_liveObj->flags2 = opt_liveObj->flags2 | LIVEOBJ2_UNK_40000000;
				}
				if (opt_liveObj->health < 100.0) {
					ai::AITask_DoRepair_Target(opt_liveObj,0);
				}
				else {
					opt_liveObj->health = (float)&DAT_42c80000;
					iVar3 = 1;
				}
			}
			else {
				LiveObject_FUN_00438ab0(opt_liveObj);
				in_liveObj->flags4 = in_liveObj->flags4 & 0xffbfffff;
			}
		}
		else {
			BVar2 = LiveObject_CheckCondition_AndIsPowered(opt_liveObj,0);
			if (BVar2 == 0) {
				return 1;
			}
			if (globs::legoGlobs.DrainTime <= in_liveObj->elapsedTime2) {
				LiveObject_Weapon_FUN_004375c0(in_liveObj,-1,1.0);
				in_liveObj->elapsedTime2 = 0.0;
			}
		}
		if ((ushort)((ushort)(opt_liveObj->health < 0.0) << 8 |
								(ushort)(opt_liveObj->health == 0.0) << 0xe) == 0) goto LAB_004479d1;
	}
	iVar3 = 1;
LAB_004479d1:
	if (iVar3 != 0) {
		in_liveObj->object_2fc = NULL;
	}
	return iVar3;
}



BOOL __cdecl lego::game::LiveObject_Add25EnergyAndSetHealth(LiveObject *liveObj)
{
	float fVar1;
	
	fVar1 = liveObj->energy - -25.0;
	liveObj->object_2fc = NULL;
	liveObj->energy = fVar1;
	if ((ushort)((ushort)(fVar1 < liveObj->health) << 8 | (ushort)(fVar1 == liveObj->health) << 0xe)
			== 0) {
		liveObj->energy = liveObj->health;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00447a40(LiveObject *liveObj)
{
	LiveObject *liveObj2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		liveObj2 = liveObj->carriedObjects[0];
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
		liveObj->numCarriedObjects = 0;
		liveObj->carriedObjects[0] = NULL;
		liveObj2->flags3 = liveObj2->flags3 | LIVEOBJ3_UNK_2000;
		ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_GATHER,liveObj2,TRUE);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00447a90(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	RoutingBlock *pRVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	SurfaceMap *pSVar6;
	uint bx;
	uint uVar7;
	Point2F *pPVar8;
	Point2F *pPVar9;
	Point2F *pPVar10;
	float *out_y;
	Point2F local_20;
	float local_14;
	float local_10;
	float local_c;
	Point2F local_8;
	
	pLVar1 = liveObj->carriedObjects[0]->object_2fc;
	out_y = &local_20.y;
	pPVar9 = &local_20;
	uVar7 = (liveObj->routeptr_24 + liveObj->routingBlocksTotal)[-1].blockPos.y;
	bx = (liveObj->routeptr_24 + liveObj->routingBlocksTotal)[-1].blockPos.x;
	pSVar6 = lrr::Lego_GetMap();
	Map3D_BlockToWorldPos(pSVar6,bx,uVar7,&pPVar9->x,out_y);
	LiveObject_GetPosition(pLVar1,&local_10,&local_c);
	fVar3 = local_10 - local_20.x;
	fVar5 = local_c - local_20.y;
	pPVar9 = &local_8;
	pPVar8 = &local_20;
	pPVar10 = NULL;
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar3 * fVar3);
	local_14 = fVar4 * fVar5 * 0.1;
	local_20.x = fVar4 * fVar3 * 0.1 + local_20.x;
	local_20.y = local_14 + local_20.y;
	pSVar6 = lrr::Lego_GetMap();
	Map3D_FUN_0044fb30(pSVar6,pPVar8,pPVar10,pPVar9);
	uVar7 = liveObj->routingBlocksTotal;
	pRVar2 = liveObj->routeptr_24;
	pRVar2[uVar7 - 1].worldPos.x = local_8.x;
	pRVar2[uVar7 - 1].worldPos.y = local_8.y;
	liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
			 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 8;
	pLVar1 = liveObj->carriedObjects[0];
	(pLVar1->point_2f4).x = local_10;
	(pLVar1->point_2f4).y = local_c;
	liveObj->carriedObjects[0]->object_2fc = NULL;
	return;
}



void __cdecl lego::game::LiveObject_DoBuildingsCallback_AttackByBoulder(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_BUILDING) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackBoulderAttackBuilding_FUN_00447be0,liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_CallbackBoulderAttackBuilding_FUN_00447be0
					(LiveObject *liveObj,LiveObject *buildingLiveObj)
{
	if (((liveObj->objType == OBJECT_BOULDER) && (liveObj->object_2fc == buildingLiveObj)) &&
		 (liveObj->carryingThisObject != NULL)) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj->carryingThisObject,0);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00447c10(LiveObject *liveObj,Point2F *param_2,BOOL param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	ActivityType actType;
	float10 fVar6;
	
	if (((*(byte *)&liveObj->flags2 & LIVEOBJ2_UNK_2) != 0) && (liveObj->object_3c0 != NULL)) {
		liveObj = liveObj->object_3c0;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_1000) == LIVEOBJ1_NONE) {
		BVar5 = LiveObject_CheckCondition_AndIsPowered(liveObj,1);
		if (BVar5 != 0) {
			if (param_2 == NULL) {
				actType = (-(uint)(param_3 != 0) & 0xfffffff7) + ACTIVITY_STAMP;
			}
			else {
				fVar1 = (liveObj->faceDirection).x;
				fVar2 = (liveObj->faceDirection).y;
				fVar6 = (float10)fcos((float10)0.7853981852531433);
				fVar3 = 1.0 / SQRT(fVar2 * fVar2 + fVar1 * fVar1);
				fVar1 = fVar3 * fVar1;
				fVar3 = fVar3 * fVar2;
				fVar4 = 1.0 - (float)fVar6;
				fVar2 = fVar3 * param_2->y + fVar1 * param_2->x;
				if ((ushort)((ushort)(fVar2 < fVar4) << 8 | (ushort)(fVar2 == fVar4) << 0xe) == 0) {
					actType = ACTIVITY_HITBACK;
				}
				else {
					if (-fVar4 <= fVar2) {
						fVar1 = fVar3 * param_2->x - fVar1 * param_2->y;
						if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
							actType = ACTIVITY_HITRIGHT;
						}
						else {
							actType = ACTIVITY_HITLEFT;
						}
					}
					else {
						actType = ACTIVITY_HITFRONT;
					}
				}
			}
			LiveObject_FUN_00441df0(liveObj,0,1);
			LiveObject_SetActivityUnk(liveObj,actType,1);
			BVar5 = LiveObject_Container_ActivityUpdate_Check(liveObj);
			if (BVar5 == 0) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,1);
				LiveObject_Container_ActivityUpdate_Check(liveObj);
			}
			LiveObject_FUN_00447df0(liveObj,1.0);
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_1000;
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_TeleportDownBuilding(LiveObject *liveObj)
{
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_TELEPORT,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_200000;
	return;
}



float10 __cdecl lego::game::LiveObject_FUN_00447df0(LiveObject *in_liveObj,float elapsed)
{
	ObjectType OVar1;
	LiveObject *in_liveObj_00;
	float elapsed_00;
	float10 fVar2;
	
	elapsed_00 = elapsed;
	in_liveObj_00 = in_liveObj;
	LiveObject_Callback_FUN_004468d0(in_liveObj,elapsed,(float *)&in_liveObj,&elapsed);
	if ((in_liveObj_00->flags1 & LIVEOBJ1_UNK_4000) != LIVEOBJ1_NONE) goto LAB_00447ed1;
	OVar1 = in_liveObj_00->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		fVar2 = res::Vehicle_FUN_0046d480
											(in_liveObj_00->vehicle,elapsed,elapsed_00,in_liveObj_00->unkbool_2d8);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			fVar2 = res::Creature_FUN_00406c60
												(in_liveObj_00->miniFigure,elapsed,in_liveObj_00->unkbool_2d8);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				fVar2 = res::Creature_FUN_00406c60
													(in_liveObj_00->rockMonster,elapsed,in_liveObj_00->unkbool_2d8);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					fVar2 = res::Building_FUN_00408790
														(in_liveObj_00->building,elapsed,in_liveObj_00->unkbool_2d8);
				}
				else {
					if ((in_liveObj_00->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						LiveObject_FUN_00448160(in_liveObj_00,elapsed_00);
						goto LAB_00447ed1;
					}
					if (OVar1 != OBJECT_UPGRADEPART) goto LAB_00447ed1;
					fVar2 = res::Upgrade_DoAnimElapsedCallbacks
														(in_liveObj_00->upgrade,elapsed,in_liveObj_00->unkbool_2d8);
				}
			}
		}
	}
	in_liveObj_00->float_2d4 = (float)fVar2;
LAB_00447ed1:
	if ((ushort)((ushort)(in_liveObj_00->float_2d4 < 0.0) << 8 |
							(ushort)(in_liveObj_00->float_2d4 == 0.0) << 0xe) == 0) {
		ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(in_liveObj_00);
	}
	return (float10)elapsed;
}



BOOL __cdecl lego::game::LiveObject_Container_ActivityUpdate_Check(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	char *pcVar3;
	Container *pCVar4;
	BOOL BVar5;
	char *pcVar6;
	char local_100 [256];
	
	BVar5 = 0;
	pcVar6 = liveObj->aitaskName1;
	if (pcVar6 == liveObj->aitaskName2) {
		return 0;
	}
	if ((((pcVar6 != globs::liveGlobs.Activities_TABLE[0]) &&
			 (pcVar6 != globs::liveGlobs.Activities_TABLE[1])) &&
			(pcVar6 != globs::liveGlobs.Activities_TABLE[4])) &&
		 (((pcVar6 != globs::liveGlobs.Activities_TABLE[6] &&
			 (pcVar6 != globs::liveGlobs.Activities_TABLE[8])) &&
			((pcVar6 != globs::liveGlobs.Activities_TABLE[17] &&
			 ((pcVar6 != globs::liveGlobs.Activities_TABLE[22] &&
				(pcVar6 != globs::liveGlobs.Activities_TABLE[2])))))))) {
		ai::AITask_DoAnimationWait(liveObj);
	}
	switch(liveObj->objType) {
	case OBJECT_VEHICLE:
		BVar5 = res::Vehicle_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->vehicle,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Vehicle_GetCameraNull(liveObj->vehicle,liveObj->index_2e0);
		break;
	case OBJECT_MINIFIGURE:
		BVar5 = res::Creature_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->miniFigure,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Creature_GetCameraNull(liveObj->miniFigure,liveObj->index_2e0);
		break;
	case OBJECT_ROCKMONSTER:
		BVar5 = res::Creature_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->rockMonster,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Creature_GetCameraNull(liveObj->rockMonster,liveObj->index_2e0);
		break;
	case OBJECT_BUILDING:
		BVar5 = res::Building_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->building,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Building_GetCameraNull(liveObj->building,liveObj->index_2e0);
		break;
	default:
		goto switchD_00447f7d_caseD_4;
	}
	liveObj->resData_2dc = pCVar4;
switchD_00447f7d_caseD_4:
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((((OVar1 & STATS1_CANBEDRIVEN) != STATS1_NONE) && (liveObj->drivenObject != NULL)) &&
		 (liveObj->drivenObject->objType == OBJECT_MINIFIGURE)) {
		iVar2 = std::_stricmp(globs::liveGlobs.Activities_TABLE[1],liveObj->aitaskName1);
		pcVar6 = "Activity_";
		if (iVar2 != 0) {
			pcVar6 = liveObj->aitaskName1;
		}
		pcVar3 = Object_GetTypeName(liveObj->objType,liveObj->objIndex);
		std::sprintf(local_100,"%s%s",pcVar6,pcVar3);
		res::Creature_SetActivity_AndRemoveCarryCameraFrames
							(liveObj->drivenObject->miniFigure,local_100,0.0);
		pCVar4 = res::Creature_GetCameraNull
											 (liveObj->drivenObject->miniFigure,liveObj->drivenObject->index_2e0);
		liveObj->drivenObject->resData_2dc = pCVar4;
		liveObj->drivenObject->aitaskName1 = liveObj->drivenObject->aitaskName2;
	}
	liveObj->float_2d4 = 0.0;
	liveObj->aitaskName2 = liveObj->aitaskName1;
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_20000;
	return BVar5;
}



void __cdecl lego::game::LiveObject_FUN_00448160(LiveObject *in_liveObj,float elapsed)
{
	LiveFlags2 *pLVar1;
	ObjectType OVar2;
	LiveObject *liveObj;
	SurfaceMap *pSVar3;
	LiveObject *pLVar4;
	uint uVar5;
	LiveFlags1 LVar6;
	uint by;
	LevelData *level;
	int by_00;
	int bx;
	LiveFlags3 LVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	longlong lVar11;
	float fVar12;
	BOOL BVar13;
	Point2I *out_bx;
	float fVar14;
	float *out_x;
	Container *cont;
	int *out_by;
	Point2F *pPVar15;
	float *out_y;
	char *pcVar16;
	float local_4c;
	float local_48;
	Point2I local_44;
	Point2I local_3c;
	Point2F local_34;
	Point2F local_2c;
	Vector3F local_24;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	OVar2 = in_liveObj->objType;
	if (OVar2 == OBJECT_BOULDER) {
		if ((in_liveObj->flags3 & LIVEOBJ3_UNK_2000) != LIVEOBJ3_NONE) {
			res::Container_GetPosition(in_liveObj->other,NULL,&local_c);
			fVar14 = (liveObj->point_2f4).y;
			fVar12 = (liveObj->point_2f4).x;
			local_24.z = 0.0;
			local_24.x = fVar12;
			local_24.y = fVar14;
			pSVar3 = lrr::Lego_GetMap();
			fVar8 = Map3D_GetWorldZ(pSVar3,fVar12,fVar14);
			in_liveObj = (LiveObject *)(float)fVar8;
			fVar9 = stats::StatsObject_GetCollRadius(liveObj);
			fVar8 = (float10)(float)in_liveObj;
			fVar10 = (fVar8 - fVar9) - (float10)local_c.z;
			fVar14 = (float)((float10)local_24.x - (float10)local_c.x);
			fVar12 = (float)((float10)local_24.y - (float10)local_c.y);
			local_10 = (float)fVar10;
			in_liveObj = (LiveObject *)(elapsed * 3.5);
			local_4c = (float)SQRT(fVar10 * (float10)local_10 +
														 ((float10)local_24.y - (float10)local_c.y) * (float10)fVar12 +
														 ((float10)local_24.x - (float10)local_c.x) * (float10)fVar14);
			elapsed = 1.0 / local_4c;
			local_18 = elapsed * fVar14 * (float)in_liveObj;
			local_c.x = local_18 + local_c.x;
			local_14 = elapsed * fVar12 * (float)in_liveObj;
			local_c.y = local_14 + local_c.y;
			local_c.z = elapsed * local_10 * (float)in_liveObj + local_c.z;
			fVar14 = local_c.x;
			fVar12 = local_c.y;
			local_24.z = local_c.z;
			if (local_4c < (float)in_liveObj) {
				liveObj->carryingThisObject = NULL;
				liveObj->health = -1.0;
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000 | LIVEOBJ3_UNK_800000;
				fVar14 = local_24.x;
				fVar12 = local_24.y;
				local_24.z = (float)(fVar8 - fVar9);
			}
			local_24.y = fVar12;
			local_24.x = fVar14;
			local_34.x = local_24.x;
			out_by = &local_3c.y;
			out_bx = &local_3c;
			local_34.y = local_24.y;
			fVar14 = local_24.x;
			fVar12 = local_24.y;
			local_44.x = (int)in_liveObj;
			pSVar3 = lrr::Lego_GetMap();
			Map3D_WorldToBlockPos_NoZ(pSVar3,fVar14,fVar12,&out_bx->x,out_by);
			fVar14 = local_24.x;
			fVar12 = local_24.y;
			pSVar3 = lrr::Lego_GetMap();
			fVar8 = Map3D_GetWorldZ(pSVar3,fVar14,fVar12);
			elapsed = (float)(fVar8 - (float10)local_24.z);
			pLVar4 = (LiveObject *)
							 LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_34,elapsed,1);
			if (pLVar4 != NULL) {
				liveObj->carryingThisObject = NULL;
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000;
				pPVar15 = &local_2c;
				fVar14 = 0.0;
				BVar13 = 1;
				local_2c.y = 1.0 / SQRT(local_14 * local_14 + local_18 * local_18);
				local_2c.x = local_2c.y * local_18;
				local_2c.y = local_2c.y * local_14;
				uVar5 = tools::Weapon_GetWeaponTypeByName("Boulder");
				tools::Weapon_LiveObject_FUN_0046f530(pLVar4,uVar5,BVar13,fVar14,pPVar15);
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
				liveObj->health = -1.0;
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_BOULDERHIT,0,0,&local_24);
			}
			res::Container_SetPosition(liveObj->other,NULL,local_24.x,local_24.y,local_24.z);
			return;
		}
	}
	else {
		if (OVar2 == OBJECT_POWERCRYSTAL) {
			if (in_liveObj->carryingThisObject == NULL) {
				res::Container_AddRotation(in_liveObj->other,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,elapsed * 0.01)
				;
				return;
			}
		}
		else {
			if ((OVar2 == OBJECT_DYNAMITE) || (OVar2 == OBJECT_OOHSCARY)) {
				if ((in_liveObj->flags3 & LIVEOBJ3_UNK_10000) == LIVEOBJ3_NONE) {
					if ((in_liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
						in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_PLACING;
						in_liveObj->flags3 = in_liveObj->flags3 | LIVEOBJ3_UNK_10000;
						res::Container_SetActivity(in_liveObj->other,"TickDown");
						res::Container_SetAnimationTime(liveObj->other,0.0);
						LiveObject_GetBlockPos(liveObj,&local_44.x,&local_44.y);
						Level_Block_SetFlags1_80000(&local_44,TRUE);
						front::Info_Send(INFO_DYNAMITEPLACED,NULL,liveObj,NULL);
						lVar11 = __ftol((float10)(liveObj->point_2f4).y);
						by_00 = (int)lVar11;
						lVar11 = __ftol((float10)(liveObj->point_2f4).x);
						bx = (int)lVar11;
						pSVar3 = lrr::Lego_GetMap();
						Map3D_Block_ClearHighlight(pSVar3,bx,by_00);
						return;
					}
					res::Container_MoveAnimation(in_liveObj->other,elapsed);
				}
				else {
					if (((ushort)((ushort)(in_liveObj->health < 0.0) << 8 |
											 (ushort)(in_liveObj->health == 0.0) << 0xe) != 0) ||
						 (fVar8 = res::Container_MoveAnimation(in_liveObj->other,elapsed), fVar8 != (float10)0.0
						 )) {
						lVar11 = __ftol((float10)(liveObj->point_2f4).x);
						uVar5 = (uint)lVar11;
						local_3c.x = uVar5;
						lVar11 = __ftol((float10)(liveObj->point_2f4).y);
						by = (uint)lVar11;
						local_3c.y = by;
						if ((uVar5 != 0) && (by != 0)) {
							BVar13 = 0;
							level = lrr::Lego_GetLevel();
							Level_DestroyWall(level,uVar5,by,BVar13);
						}
						if (liveObj->objType == OBJECT_DYNAMITE) {
							LiveObject_GetBlockPos(liveObj,&local_3c.x,&local_3c.y);
							Level_Block_SetFlags1_80000(&local_3c,FALSE);
							Game_DoDynamiteExplosionCallbacks
												(liveObj,globs::legoGlobs.DynamiteDamageRadius,
												 globs::legoGlobs.DynamiteMaxDamage,globs::legoGlobs.DynamiteWakeRadius);
							snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_DYNAMITE,0);
							effect::Effect_Spawn_Explosion(liveObj,NULL);
							lego::view::Camera_Shake(globs::legoGlobs.cameraMain,5.0,50.0);
						}
						else {
							if (liveObj->objType == OBJECT_OOHSCARY) {
								LiveObject_GetPosition(liveObj,&local_c.x,&local_c.y);
								LiveObject_GetBlockPos(liveObj,&local_44.x,&local_44.y);
								pSVar3 = lrr::Lego_GetMap();
								fVar8 = Map3D_GetWorldZ(pSVar3,local_c.x,local_c.y);
								local_c.z = (float)fVar8;
								effect::Effect_Spawn_Particle(MISCOBJECT_BIRDSCARER,&local_c,NULL);
								lego::view::Camera_Shake(globs::legoGlobs.cameraMain,2.0,(float)&DAT_42c80000);
								Level_Block_SetFlags1_80000(&local_44,FALSE);
							}
						}
						liveObj->health = -1.0;
						liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
						return;
					}
				}
			}
			else {
				if (OVar2 == OBJECT_ELECTRICFENCE) {
					if ((in_liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
						in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_PLACING;
						ElectricFence_AssignBlockObject(in_liveObj);
						LiveObject_GetBlockPos(liveObj,&local_44.x,(int *)&in_liveObj);
						out_y = &local_48;
						out_x = &local_4c;
						uVar5 = local_44.x;
						pLVar4 = in_liveObj;
						pSVar3 = lrr::Lego_GetMap();
						Map3D_BlockToWorldPos(pSVar3,uVar5,(uint)pLVar4,out_x,out_y);
						fVar8 = LiveObject_GetHeading(liveObj);
						BVar13 = 1;
						elapsed = (float)(fVar8 - (float10)-0.7853982);
						fVar8 = std::fmod((float10)elapsed,(float10)1.570796370506287);
						LiveObject_SetPositionAndHeading
											(liveObj,local_4c,local_48,(float)((float10)elapsed - fVar8),BVar13);
						Level_Block_SetFenceRequest(local_44.x,(int)in_liveObj,0);
						return;
					}
				}
				else {
					if (OVar2 == OBJECT_BARRIER) {
						fVar8 = res::Container_MoveAnimation(in_liveObj->other,elapsed);
						if (fVar8 == (float10)0.0) {
							return;
						}
						LVar6 = liveObj->flags1;
						if ((LVar6 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
							pcVar16 = "Expand";
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_PLACING | LIVEOBJ1_UNK_100;
							goto LAB_0044872d;
						}
						if ((LVar6 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000;
							pcVar16 = "Long";
							goto LAB_00448783;
						}
						LVar7 = liveObj->flags3;
						if ((LVar7 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
							liveObj->health = (float)&DAT_42c80000;
							liveObj->flags3 = LVar7 & ~LIVEOBJ3_UNK_800000;
							liveObj->flags1 = LVar6 | LIVEOBJ1_UNK_200000;
							res::Container_SetActivity(liveObj->other,"Teleport");
							res::Container_SetAnimationTime(liveObj->other,0.0);
							return;
						}
					}
					else {
						if (OVar2 != OBJECT_SPIDERWEB) {
							if (OVar2 != OBJECT_ICECUBE) {
								if ((((OVar2 != OBJECT_ELECTRICFENCESTUD) && (OVar2 != OBJECT_PUSHER)) &&
										(OVar2 != OBJECT_FREEZER)) && (OVar2 != OBJECT_LASERSHOT)) {
									return;
								}
								res::Container_MoveAnimation(in_liveObj->other,elapsed);
								return;
							}
							fVar8 = res::Container_MoveAnimation(in_liveObj->other,elapsed);
							if (fVar8 == (float10)0.0) {
								return;
							}
							LVar6 = liveObj->flags1;
							if ((LVar6 & LIVEOBJ1_UNK_100) == LIVEOBJ1_NONE) {
								LVar7 = liveObj->flags3;
								if ((LVar7 & LIVEOBJ3_UNK_800000) == LIVEOBJ3_NONE) {
									if ((LVar6 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE) {
										return;
									}
									liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_200000;
									liveObj->health = -1.0;
									liveObj->flags3 = LVar7 | LIVEOBJ3_UNK_800000;
									pLVar1 = &liveObj->object_364->flags2;
									*pLVar1 = *pLVar1 & ~LIVEOBJ2_UNK_8000000;
									return;
								}
								liveObj->health = (float)&DAT_42c80000;
								liveObj->flags3 = LVar7 & ~LIVEOBJ3_UNK_800000;
								liveObj->flags1 = LVar6 | LIVEOBJ1_UNK_200000;
								pcVar16 = "Melt";
LAB_00448783:
								res::Container_SetActivity(liveObj->other,pcVar16);
								res::Container_SetAnimationTime(liveObj->other,0.0);
								return;
							}
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000;
							pcVar16 = "Normal";
LAB_0044872d:
							res::Container_SetActivity(liveObj->other,pcVar16);
							res::Container_SetAnimationTime(liveObj->other,0.0);
							return;
						}
						if (((in_liveObj->flags1 & LIVEOBJ1_CAUGHTINWEB) == LIVEOBJ1_NONE) ||
							 ((in_liveObj->flags1 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE)) {
							cont = in_liveObj->other;
							fVar14 = elapsed;
						}
						else {
							cont = in_liveObj->other;
							fVar14 = 0.0;
						}
						fVar8 = res::Container_MoveAnimation(cont,fVar14);
						if (fVar8 == (float10)0.0) {
							return;
						}
						LVar6 = liveObj->flags1;
						if ((LVar6 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000;
							pcVar16 = "FlapInWind";
							goto LAB_0044872d;
						}
						LVar7 = liveObj->flags3;
						if ((LVar7 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
							liveObj->health = (float)&DAT_42c80000;
							liveObj->flags3 = LVar7 & ~LIVEOBJ3_UNK_800000;
							liveObj->flags1 = LVar6 | LIVEOBJ1_UNK_200000;
							pcVar16 = "Disintegrate";
							goto LAB_00448783;
						}
					}
					if ((LVar6 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
						liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_200000;
						liveObj->health = -1.0;
						liveObj->flags3 = LVar7 | LIVEOBJ3_UNK_800000;
						return;
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::debug::LiveObject_Debug_DropActivateDynamite(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 (liveObj->carriedObjects[0]->objType == OBJECT_DYNAMITE)) {
		(liveObj->carriedObjects[0]->point_2f4).y = 0.0;
		(liveObj->carriedObjects[0]->point_2f4).x = 0.0;
		game::LiveObject_DropCarriedObject_FUN_0043a130(liveObj,TRUE);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_TryDynamite_FUN_00448ac0(LiveObject *liveObj,Point2I *blockPos)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	
	if (liveObj->carriedObjects[0]->objType == OBJECT_DYNAMITE) {
		BVar2 = LiveObject_CanDynamiteBlockPos(liveObj,blockPos->x,blockPos->y);
		if (BVar2 != 0) {
			BVar2 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,blockPos->x,blockPos->y,7.0);
			if (BVar2 != 0) {
				pLVar1 = liveObj->carriedObjects[0];
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 9;
				(pLVar1->point_2f4).x = (float)blockPos->x;
				(pLVar1->point_2f4).y = (float)blockPos->y;
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_PlaceCarriedBirdScarerAt(LiveObject *liveObj,Point2I *blockPos)
{
	float *pfVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	uint local_c;
	int local_8;
	float local_4;
	LiveObject *liveObj_00;
	Point2I *pBlockPos;
	
	pBlockPos = blockPos;
	liveObj_00 = liveObj;
	if (liveObj->carriedObjects[0]->objType == OBJECT_OOHSCARY) {
		pfVar1 = (float *)&blockPos->y;
		BVar3 = Level_Block_IsGround_alt(liveObj,blockPos->x,blockPos->y);
		if (BVar3 != 0) {
			LiveObject_GetBlockPos(liveObj_00,&local_8,(int *)&local_4);
			if ((local_8 == pBlockPos->x) && (local_4 == *pfVar1)) {
				LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj_00,1,(float *)pBlockPos,pfVar1,NULL);
				return 0;
			}
			BVar3 = LiveObject_FUN_004413b0
												(liveObj_00,local_8,local_4,pBlockPos->x,*pfVar1,&liveObj,&blockPos,&local_c
												 ,0,0);
			if (BVar3 != 0) {
				BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj_00,local_c,(float *)liveObj,(float *)blockPos,NULL);
				std::free(liveObj);
				std::free(blockPos);
				if (BVar3 != 0) {
					pLVar2 = liveObj_00->carriedObjects[0];
					liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].byte_11 = 9;
					(pLVar2->point_2f4).x = (float)pBlockPos->x;
					(pLVar2->point_2f4).y = (float)(int)*pfVar1;
					return TRUE;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_PlaceBirdScarer_AndTickDown(LiveObject *liveObj)
{
	BOOL BVar1;
	LiveObject *oohscaryObj;
	float10 fVar2;
	Point2F position;
	Point2I blockPos;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_BIRDSCARER);
	if (BVar1 != 0) {
		LiveObject_GetPosition(liveObj,&position.x,&position.y);
		LiveObject_GetBlockPos(liveObj,&blockPos.x,&blockPos.y);
		fVar2 = LiveObject_GetHeading(liveObj);
		oohscaryObj = LiveObject_CreateInWorld
														(globs::legoGlobs.contOohScary,OBJECT_OOHSCARY,0,0,position.x,position.y
														 ,(float)fVar2);
		Level_Block_SetFlags1_80000(&blockPos,TRUE);
		res::Container_SetActivity(oohscaryObj->other,"TickDown");
		res::Container_SetAnimationTime(oohscaryObj->other,0.0);
		oohscaryObj->flags3 = oohscaryObj->flags3 | LIVEOBJ3_UNK_10000;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryElecFence_FUN_00448d20(LiveObject *liveObj,Point2I *blockPos)
{
	float *pfVar1;
	float fVar2;
	RoutingBlock *pRVar3;
	LiveObject *pLVar4;
	Point2I *pPVar5;
	short sVar6;
	BOOL BVar7;
	uint uVar8;
	float10 fVar9;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	int local_8;
	float local_4;
	
	pPVar5 = blockPos;
	if (liveObj->carriedObjects[0]->objType == OBJECT_ELECTRICFENCE) {
		pfVar1 = (float *)&blockPos->y;
		BVar7 = ElectricFence_CanPlaceFenceAtBlock(blockPos->x,blockPos->y);
		if (BVar7 != 0) {
			LiveObject_GetBlockPos(liveObj,&local_8,(int *)&local_4);
			if ((local_8 == pPVar5->x) && (local_4 == *pfVar1)) {
				BVar7 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,(float *)pPVar5,pfVar1,NULL);
			}
			else {
				BVar7 = LiveObject_FUN_004413b0
													(liveObj,local_8,local_4,pPVar5->x,*pfVar1,&blockPos,&local_18,&local_14,0
													 ,0);
				if (BVar7 == 0) {
					return 0;
				}
				BVar7 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj,local_14,(float *)blockPos,local_18,NULL);
				std::free(blockPos);
				std::free(local_18);
			}
			if (BVar7 != 0) {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 9;
				if (liveObj->objType == OBJECT_VEHICLE) {
					fVar9 = math::Maths_RandRange(0.55,0.75);
					fVar2 = (float)fVar9;
					sVar6 = math::Maths_Rand();
					uVar8 = (int)sVar6 >> 0x1f;
					switch((((int)sVar6 ^ uVar8) - uVar8 & 3 ^ uVar8) - uVar8) {
					case 0:
						local_10 = 0.5;
						local_c = fVar2;
						break;
					case 1:
						local_c = 0.5;
						local_10 = fVar2;
						break;
					case 2:
						local_10 = 0.5;
						local_c = 1.0 - fVar2;
						break;
					case 3:
						local_c = 0.5;
						local_10 = 1.0 - fVar2;
					}
					uVar8 = liveObj->routingBlocksTotal;
					pRVar3 = liveObj->routeptr_24;
					pRVar3[uVar8 - 1].worldPos.x = local_10;
					pRVar3[uVar8 - 1].worldPos.y = local_c;
					liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
							 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 8;
				}
				pLVar4 = liveObj->carriedObjects[0];
				(pLVar4->point_2f4).x = (float)pPVar5->x;
				(pLVar4->point_2f4).y = (float)(int)*pfVar1;
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryBuildPath_FUN_00448f10(LiveObject *liveObj)
{
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_CLEAR,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_200;
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_TryUpgrade_FUN_00448f50
					(LiveObject *in_liveObj,LiveObject *targetObj,int targetObjLevel)
{
	byte *pbVar1;
	float fVar2;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	BOOL BVar3;
	Container *cont;
	SurfaceMap *surfMap;
	byte bVar4;
	BOOL BVar5;
	float *out_bx;
	float *out_by;
	uint local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	int local_1c;
	int local_18 [2];
	float local_10;
	Vector3F local_c;
	
	liveObj_00 = targetObj;
	liveObj = in_liveObj;
	BVar5 = 0;
	if (targetObj->objType == OBJECT_BUILDING) {
		if (in_liveObj->objType == OBJECT_MINIFIGURE) {
			BVar3 = LiveObject_TryTrain_FUN_00449170(in_liveObj,targetObj,1);
			if (BVar3 != 0) {
				return TRUE;
			}
		}
		else {
			if (in_liveObj->objType == OBJECT_VEHICLE) {
				cont = LiveObject_GetDepositNull(targetObj);
				res::Container_GetPosition(cont,NULL,&local_c);
				out_by = &local_28;
				out_bx = &local_2c;
				surfMap = lrr::Lego_GetMap();
				Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)out_by);
				LiveObject_GetBlockPos(liveObj,(int *)&local_24,(int *)&local_20);
				LiveObject_GetBlockPos(liveObj_00,&local_1c,local_18);
				fVar2 = (float)(int)local_2c - (float)local_1c;
				local_10 = (float)(int)local_28 - (float)local_18[0];
				if (ABS(fVar2) <= ABS(local_10)) {
					if ((ushort)((ushort)(local_10 < 0.0) << 8 | (ushort)(local_10 == 0.0) << 0xe) == 0) {
						bVar4 = 0;
					}
					else {
						bVar4 = 2;
					}
				}
				else {
					if ((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) == 0) {
						bVar4 = 1;
					}
					else {
						bVar4 = 3;
					}
				}
				if ((local_24 == local_2c) && (local_20 == local_28)) {
					BVar5 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,&local_2c,&local_28,NULL);
				}
				else {
					BVar5 = LiveObject_FUN_004413b0
														(liveObj,local_24,local_20,local_2c,local_28,&targetObj,&in_liveObj,
														 &local_30,0,0);
					if (BVar5 == 0) {
						return 0;
					}
					BVar5 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
														(liveObj,local_30,(float *)targetObj,(float *)in_liveObj,NULL);
					std::free(targetObj);
					std::free(in_liveObj);
				}
				if (BVar5 != 0) {
					liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0xf;
					pbVar1 = &liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10;
					*pbVar1 = *pbVar1 | 4;
					liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
							 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | bVar4;
					liveObj->field_404 = targetObjLevel;
					liveObj->object_2fc = liveObj_00;
					liveObj_00->object_300 = liveObj;
					return BVar5;
				}
			}
		}
	}
	return BVar5;
}



BOOL __cdecl
lego::game::LiveObject_TryTrain_FUN_00449170
					(LiveObject *liveObj,LiveObject *targetObj,BOOL set_0xE_or0xF)
{
	byte *pbVar1;
	uint uVar2;
	RoutingBlock *pRVar3;
	float fVar4;
	LiveObject *pLVar5;
	BOOL BVar6;
	SurfaceMap *surfMap;
	uint uVar7;
	float10 fVar8;
	uint local_28;
	uint local_24;
	float local_20 [4];
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar5 = targetObj;
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (targetObj->objType == OBJECT_BUILDING)) {
		LiveObject_GetBlockPos(targetObj,(int *)&local_28,(int *)&local_24);
		BVar6 = LiveObject_BlockRoute_FUN_00446c80(liveObj,local_28,local_24,0,(uint *)&targetObj,1);
		if (BVar6 != 0) {
			surfMap = lrr::Lego_GetMap();
			fVar8 = Map3D_GetBlockSize(surfMap);
			local_c = (float)((float10)4.0 / fVar8);
			fVar8 = math::Maths_RandRange(0.1,0.9);
			uVar2 = liveObj->routingBlocksTotal;
			local_20[0] = (float)fVar8;
			local_8 = local_c;
			uVar7 = (int)&targetObj[-1].nextFree + 2U & 3;
			local_20[3] = local_20[0];
			local_10 = local_20[0];
			local_4 = local_20[0];
			local_20[1] = 1.0 - local_c;
			local_20[2] = 1.0 - local_c;
			pRVar3 = liveObj->routeptr_24;
			fVar4 = local_20[uVar7 * 2 + 1];
			pRVar3[uVar2 - 1].worldPos.x = local_20[uVar7 * 2];
			pRVar3[uVar2 - 1].worldPos.y = fVar4;
			if (set_0xE_or0xF == 0) {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0xe;
			}
			else {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0xf;
			}
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
					 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 4;
			pbVar1 = &liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10;
			targetObj._0_1_ = (byte)uVar7;
			*pbVar1 = *pbVar1 | (byte)targetObj;
			liveObj->object_2fc = pLVar5;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryRecharge_FUN_004492d0(LiveObject *liveObj)
{
	BOOL BVar1;
	Point2I local_8;
	
	if ((((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)) &&
		 ((liveObj->carriedObjects[0]->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) {
		BVar1 = LiveObject_FindRechargeSeam_FUN_0044a690(liveObj,&local_8);
		if (BVar1 != 0) {
			BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,local_8.x,local_8.y,3.0);
			if (BVar1 != 0) {
				liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0x12;
				(liveObj->point_2f4).x = (float)local_8.x;
				(liveObj->point_2f4).y = (float)local_8.y;
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryRepair_FUN_00449360
					(LiveObject *in_liveObj,LiveObject *targetObj,BOOL param_3,BOOL param_4)
{
	byte *pbVar1;
	ObjectType OVar2;
	uint uVar3;
	RoutingBlock *pRVar4;
	float fVar5;
	bool bVar6;
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar7;
	BOOL BVar8;
	SurfaceMap *surfMap;
	uint uVar9;
	float10 fVar10;
	uint local_28;
	uint local_24;
	float local_20 [4];
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = targetObj;
	OVar2 = in_liveObj->objType;
	if ((OVar2 != OBJECT_MINIFIGURE) && (OVar2 != OBJECT_ROCKMONSTER)) {
		return 0;
	}
	if (targetObj->objType != OBJECT_BUILDING) {
		return 0;
	}
	if ((OVar2 == OBJECT_ROCKMONSTER) &&
		 (OVar7 = stats::StatsObject_GetStatsFlags2(in_liveObj),
		 (OVar7 & STATS2_DRAINPOWER) == STATS2_NONE)) {
		bVar6 = true;
	}
	else {
		bVar6 = false;
	}
	LiveObject_GetBlockPos(liveObj,(int *)&local_28,(int *)&local_24);
	BVar8 = LiveObject_BlockRoute_FUN_00446c80
										(in_liveObj,local_28,local_24,0,(uint *)&targetObj,
										 (uint)(in_liveObj->objType != OBJECT_ROCKMONSTER));
	if (BVar8 == 0) {
		return 0;
	}
	surfMap = lrr::Lego_GetMap();
	fVar10 = Map3D_GetBlockSize(surfMap);
	local_c = (float)((float10)4.0 / fVar10);
	if (bVar6) {
		fVar10 = (float10)0.5;
	}
	else {
		fVar10 = math::Maths_RandRange(0.2,0.8);
	}
	local_20[0] = (float)fVar10;
	local_8 = local_c;
	uVar9 = (int)&targetObj[-1].nextFree + 2U & 3;
	local_20[1] = 1.0 - local_c;
	local_20[2] = 1.0 - local_c;
	uVar3 = in_liveObj->routingBlocksTotal;
	local_20[3] = (float)fVar10;
	local_10 = (float)fVar10;
	local_4 = (float)fVar10;
	pRVar4 = in_liveObj->routeptr_24;
	fVar5 = local_20[uVar9 * 2 + 1];
	pRVar4[uVar3 - 1].worldPos.x = local_20[uVar9 * 2];
	pRVar4[uVar3 - 1].worldPos.y = fVar5;
	in_liveObj->routeptr_24[in_liveObj->routingBlocksTotal - 1].byte_11 = 6;
	in_liveObj->routeptr_24[in_liveObj->routingBlocksTotal - 1].flagsByte_10 =
			 in_liveObj->routeptr_24[in_liveObj->routingBlocksTotal - 1].flagsByte_10 | 4;
	targetObj._0_1_ = (byte)uVar9;
	pbVar1 = &in_liveObj->routeptr_24[in_liveObj->routingBlocksTotal - 1].flagsByte_10;
	*pbVar1 = *pbVar1 | (byte)targetObj;
	if (param_3 != 0) {
		pbVar1 = &in_liveObj->routeptr_24[in_liveObj->routingBlocksTotal - 1].flagsByte_10;
		*pbVar1 = *pbVar1 | 0x20;
	}
	if (param_4 != 0) {
		in_liveObj->flags4 = in_liveObj->flags4 | 0x400000;
	}
	in_liveObj->object_2fc = liveObj;
	return 1;
}



BOOL __cdecl lego::game::LiveObject_TryReinforce_FUN_00449500(LiveObject *liveObj,Point2I *blockPos)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_CanReinforceBlock(liveObj,blockPos->x,blockPos->y);
	if (BVar1 != 0) {
		BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,blockPos->x,blockPos->y,3.0);
		if (BVar1 != 0) {
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 2;
			(liveObj->point_2f4).x = (float)blockPos->x;
			(liveObj->point_2f4).y = (float)blockPos->y;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryClear_FUN_00449570(LiveObject *liveObj,Point2I *blockPos)
{
	uint uVar1;
	ObjectStatsFlags1 sflags1;
	BOOL BVar2;
	uint local_c;
	Point2I objBlockPos;
	Point2I *blockPos_00;
	LiveObject *liveObj_00;
	
	blockPos_00 = blockPos;
	uVar1 = Level_Block_GetRubbleLayers(blockPos);
	liveObj_00 = liveObj;
	if (uVar1 != 0) {
		sflags1 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((sflags1 & STATS1_CANCLEARRUBBLE) == STATS1_NONE) {
			return 1;
		}
		LiveObject_GetBlockPos(liveObj_00,&objBlockPos.x,&objBlockPos.y);
		if ((objBlockPos.x == blockPos_00->x) && (objBlockPos.y == blockPos_00->y)) {
			BVar2 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
												(liveObj_00,1,(float *)blockPos_00,(float *)&blockPos_00->y,NULL);
		}
		else {
			BVar2 = LiveObject_FUN_004413b0
												(liveObj_00,objBlockPos.x,objBlockPos.y,blockPos_00->x,blockPos_00->y,
												 &blockPos,&liveObj,&local_c,0,0);
			if (BVar2 == 0) {
				return 0;
			}
			BVar2 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
												(liveObj_00,local_c,(float *)blockPos,(float *)liveObj,NULL);
			std::free(blockPos);
			std::free(liveObj);
		}
		if (BVar2 == 0) {
			return 0;
		}
		liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].byte_11 = 4;
		if (liveObj_00->objType == OBJECT_VEHICLE) {
			Level_Block_SetFlags1_80000(blockPos_00,TRUE);
			Level_Block_SetFlags1_10000000(blockPos_00,TRUE);
			return TRUE;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_MiniFigureHasBeamEquipped(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if (liveObj->objType != OBJECT_MINIFIGURE) {
		return 0;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_LASER);
	if (((BVar1 == 0) && (BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_PUSHERGUN), BVar1 == 0)) &&
		 (BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_FREEZERGUN), BVar1 == 0)) {
		return 0;
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_TryAttackRockMonster_FUN_004496f0(LiveObject *liveObj,LiveObject *targetObj)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar1 = targetObj;
	LiveObject_GetBlockPos(targetObj,(int *)&local_10,(int *)&local_c);
	LiveObject_GetBlockPos(liveObj,(int *)&local_8,(int *)&local_4);
	if ((local_8 == local_10) && (local_4 == local_c)) {
		BVar2 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,&local_10,&local_c,NULL);
	}
	else {
		BVar2 = LiveObject_FUN_004413b0
											(liveObj,local_8,local_4,local_10,local_c,&targetObj,&local_18,&local_14,0,0);
		if (BVar2 == 0) {
			return 0;
		}
		BVar2 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
											(liveObj,local_14,(float *)targetObj,local_18,NULL);
		std::free(targetObj);
		std::free(local_18);
	}
	if (BVar2 != 0) {
		liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0x11;
		liveObj->object_2fc = pLVar1;
	}
	return BVar2;
}



BOOL __cdecl
lego::game::LiveObject_TryAttackObject_FUN_004497e0(LiveObject *in_liveObj,LiveObject *targetObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	LiveObject_GetBlockPos(in_liveObj,(int *)&local_8,(int *)&local_4);
	LiveObject_GetBlockPos(targetObj,(int *)&local_10,(int *)&local_c);
	if ((local_8 == local_10) && (local_4 == local_c)) {
		BVar1 = LiveObject_RoutingPtr_Alloc_FUN_004419c0(liveObj,1,&local_10,&local_c,NULL);
	}
	else {
		BVar1 = LiveObject_FUN_004413b0
											(liveObj,local_8,local_4,local_10,local_c,&in_liveObj,&local_18,&local_14,0,0)
		;
		if (BVar1 == 0) {
			return 0;
		}
		BVar1 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
											(liveObj,local_14,(float *)in_liveObj,local_18,NULL);
		std::free(in_liveObj);
		std::free(local_18);
	}
	if (BVar1 != 0) {
		liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0x14;
	}
	return BVar1;
}



BOOL __cdecl
lego::game::LiveObject_TryAttackPath_FUN_004498d0(LiveObject *liveObj,Point2I *blockPos)
{
	LiveObject *liveObj_00;
	Point2I *pPVar1;
	BOOL BVar2;
	float *local_10;
	uint local_c;
	int local_8;
	int local_4;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
	pPVar1 = blockPos;
	if ((local_8 == blockPos->x) && (local_4 == blockPos->y)) {
		BVar2 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
											(liveObj_00,1,(float *)blockPos,(float *)&blockPos->y,NULL);
	}
	else {
		BVar2 = LiveObject_FUN_004413b0
											(liveObj_00,local_8,local_4,blockPos->x,blockPos->y,&liveObj,&local_10,
											 &local_c,0,0);
		if (BVar2 == 0) {
			return 0;
		}
		BVar2 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
											(liveObj_00,local_c,(float *)liveObj,local_10,NULL);
		std::free(liveObj);
		std::free(local_10);
	}
	if (BVar2 != 0) {
		liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].byte_11 = 0x10;
		(liveObj_00->point_2f4).x = (float)pPVar1->x;
		(liveObj_00->point_2f4).y = (float)pPVar1->y;
	}
	return BVar2;
}



BOOL __cdecl lego::game::LiveObject_TryDepart_FUN_004499c0(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	BOOL BVar3;
	float *local_18;
	uint local_14;
	Point2I local_10;
	float local_8;
	float local_4;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	BVar3 = 0;
	OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_USEHOLES) == STATS2_NONE) {
		BVar2 = LiveObject_FUN_0044a890(liveObj_00,&local_10.x,&local_10.y,1,0,1);
		if ((BVar2 != 0) &&
			 (BVar2 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj_00,local_10.x,local_10.y,3.0),
			 BVar2 != 0)) {
			BVar3 = TRUE;
			liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].byte_11 = 10;
			(liveObj_00->point_2f4).x = (float)local_10.x;
			(liveObj_00->point_2f4).y = (float)local_10.y;
		}
	}
	else {
		BVar2 = LiveObject_NearestSlugHole_FUN_0044a7b0(liveObj_00,&local_10);
		if (BVar2 != 0) {
			LiveObject_GetBlockPos(liveObj_00,(int *)&local_8,(int *)&local_4);
			if ((local_8 == (float)local_10.x) && (local_4 == (float)local_10.y)) {
				BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
													(liveObj_00,1,(float *)&local_10,(float *)&local_10.y,NULL);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj_00,local_8,local_4,local_10.x,local_10.y,&liveObj,&local_18,
													 &local_14,0,0);
				if (BVar3 == 0) {
					BVar3 = 0;
				}
				else {
					BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
														(liveObj_00,local_14,(float *)liveObj,local_18,NULL);
					std::free(liveObj);
					std::free(local_18);
				}
			}
			if (BVar3 == 0) {
				return 0;
			}
			liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].byte_11 = 10;
			(liveObj_00->point_2f4).x = (float)local_10.x;
			(liveObj_00->point_2f4).y = (float)local_10.y;
		}
	}
	if (BVar3 != 0) {
		ai::AITask_LiveObject_DoCallbacks_FUN_004029d0(liveObj_00);
	}
	return BVar3;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPointerBlocks_FUN_00449b40
					(LiveObject *liveObj,uint x,uint y,float param_4)
{
	byte *pbVar1;
	uint by;
	BOOL BVar2;
	SurfaceMap *surfMap;
	float10 fVar3;
	
	by = y;
	BVar2 = Level_Block_IsWall(x,y);
	if ((BVar2 != 0) && (BVar2 = LiveObject_BlockRoute_FUN_00446c80(liveObj,x,by,0,&y,1), BVar2 != 0))
	{
		surfMap = lrr::Lego_GetMap();
		fVar3 = Map3D_GetBlockSize(surfMap);
		fVar3 = (float10)param_4 / fVar3;
		liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y = 0.5;
		liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x = 0.5;
		switch(y) {
		case 0:
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y = (float)fVar3;
			break;
		case 1:
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x = (float)fVar3;
			break;
		case 2:
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.y =
					 (float)((float10)1.0 - fVar3);
			break;
		case 3:
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].worldPos.x =
					 (float)((float10)1.0 - fVar3);
		}
		pbVar1 = &liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10;
		*pbVar1 = *pbVar1 | 8;
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Reinforcing_FUN_00449c40
					(LiveObject *liveObj,undefined4 param_2,BOOL *out_bool)
{
	BOOL BVar1;
	longlong lVar2;
	longlong lVar3;
	Point2I local_8;
	
	*out_bool = FALSE;
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_REINFORCING) == 0) {
		return 0;
	}
	lVar2 = __ftol((float10)(liveObj->point_2f4).x);
	local_8.x = (uint)lVar2;
	lVar3 = __ftol((float10)(liveObj->point_2f4).y);
	local_8.y = (int)lVar3;
	BVar1 = LiveObject_CanReinforceBlock(liveObj,(uint)lVar2,local_8.y);
	if (BVar1 == 0) {
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_CANTDO,1);
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_REINFORCING | LIVEOBJ1_UNK_80000000;
	}
	else {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) {
			return 1;
		}
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_REINFORCING;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		Level_Block_Reinforce(local_8.x,local_8.y);
		(liveObj->point_2f4).y = -1.0;
		(liveObj->point_2f4).x = -1.0;
		*out_bool = TRUE;
	}
	Level_Block_SetBusy(&local_8,FALSE);
	return TRUE;
}



void __cdecl lego::game::LiveObject_GoEat_unk(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_800;
	}
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_EATING;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_EAT,0);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		ai::AITask_DoAnimationWait(liveObj);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_TryGoEat_FUN_00449d80(LiveObject *liveObj1,LiveObject *liveObj2)
{
	byte *pbVar1;
	uint uVar2;
	RoutingBlock *pRVar3;
	LiveObject *liveObj;
	LiveObject *pLVar4;
	BOOL BVar5;
	SurfaceMap *surfMap;
	uint uVar6;
	float10 fVar7;
	uint local_28;
	uint local_24;
	float local_20 [4];
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	pLVar4 = liveObj2;
	liveObj = liveObj1;
	if ((liveObj1->objType == OBJECT_MINIFIGURE) && (liveObj2->objType == OBJECT_BUILDING)) {
		LiveObject_GetBlockPos(liveObj2,(int *)&local_28,(int *)&local_24);
		BVar5 = LiveObject_BlockRoute_FUN_00446c80(liveObj,local_28,local_24,0,(uint *)&liveObj1,1);
		if (BVar5 != 0) {
			surfMap = lrr::Lego_GetMap();
			fVar7 = Map3D_GetBlockSize(surfMap);
			fVar7 = (float10)4.0 / fVar7;
			local_20[0] = 0.5;
			local_20[3] = 0.5;
			local_10 = 0x3f000000;
			local_4 = 0x3f000000;
			uVar6 = (int)&liveObj1[-1].nextFree + 2U & 3;
			uVar2 = liveObj->routingBlocksTotal;
			pRVar3 = liveObj->routeptr_24;
			local_20[1] = (float)((float10)1.0 - fVar7);
			local_20[2] = (float)((float10)1.0 - fVar7);
			local_c = (float)fVar7;
			local_8 = (float)fVar7;
			pRVar3[uVar2 - 1].worldPos.x = local_20[uVar6 * 2];
			pRVar3[uVar2 - 1].worldPos.y = local_20[uVar6 * 2 + 1];
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].byte_11 = 0xb;
			liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 =
					 liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10 | 4;
			liveObj1._0_1_ = (byte)uVar6;
			pbVar1 = &liveObj->routeptr_24[liveObj->routingBlocksTotal - 1].flagsByte_10;
			*pbVar1 = *pbVar1 | (byte)liveObj1;
			liveObj->object_2fc = pLVar4;
			return TRUE;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_800;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveManager_AllCallback_FUN_00449ec0(void)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects(LiveObject_Callback_FUN_00449fb0,NULL,FALSE);
	return BVar1;
}



void __cdecl
lego::game::LiveObject_FlocksCallback_FUN_00449ee0
					(Flocks *flockData,FlocksItem *subdata,void *lpContext)
{
	Container *cont;
	SurfaceMap *surfMap;
	LevelData *pLVar1;
	BOOL BVar2;
	FlocksItem **out_bx;
	uint *puVar3;
	uint local_10;
	Vector3F local_c;
	
	cont = subdata->resData_98;
	res::Container_GetPosition(cont,NULL,&local_c);
	puVar3 = &local_10;
	out_bx = &subdata;
	surfMap = lrr::Lego_GetMap();
	Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)puVar3);
	pLVar1 = lrr::Lego_GetLevel();
	if (subdata <= (FlocksItem *)(pLVar1->dimensions).width) {
		pLVar1 = lrr::Lego_GetLevel();
		puVar3 = (uint *)&(pLVar1->dimensions).height;
		if (local_10 < *puVar3 || local_10 == *puVar3) {
			BVar2 = Level_Block_IsMeshHidden((uint)subdata,local_10);
			if (BVar2 == 0) {
				BVar2 = Level_Block_IsNotWallOrGround((uint)subdata,local_10);
				if (BVar2 == 0) {
					res::Container_Hide(cont,0);
					return;
				}
			}
		}
	}
	res::Container_Hide(cont,1);
	return;
}



void __cdecl lego::game::LiveObject_Hide2(LiveObject *liveObj,BOOL hide2)
{
	Container *cont;
	
	cont = LiveObject_GetContainer(liveObj);
	if (cont != NULL) {
		res::Container_Hide2(cont,hide2);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00449fb0(LiveObject *liveObj,void *unused)
{
	bool bVar1;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	ObjectStatsFlags2 OVar4;
	Point2I *pPVar5;
	Point2I *pPVar6;
	uint uVar7;
	Point2I *pPVar8;
	Direction rotation;
	uint uVar9;
	uint y;
	uint x;
	uint local_20;
	BOOL local_1c;
	Point2F local_18;
	Point2I local_10;
	float local_8;
	float local_4;
	
	uVar9 = 0;
	local_1c = 0;
	OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar2 & STATS1_FLOCKS) != STATS1_NONE) {
		Flocks_CallbackForAllSubdata
							(liveObj->flocksData_32c,LiveObject_FlocksCallback_FUN_00449ee0,NULL);
		return 0;
	}
	BVar3 = LiveObject_GetBlockPos(liveObj,(int *)&x,(int *)&y);
	if (BVar3 == 0) {
		LiveObject_HideAll(liveObj,TRUE);
		return 0;
	}
	BVar3 = Level_Block_IsGround(x,y);
	if (BVar3 != 0) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_100000;
	}
	BVar3 = Level_Block_IsNotWallOrGround(x,y);
	if (((BVar3 == 0) && ((liveObj->flags3 & LIVEOBJ3_UNK_100000) == LIVEOBJ3_NONE)) &&
		 ((liveObj->objType != OBJECT_MINIFIGURE ||
			((liveObj->drivenObject == NULL ||
			 (OVar4 = stats::StatsObject_GetStatsFlags2(liveObj->drivenObject),
			 (OVar4 & STATS2_INVISIBLEDRIVER) == STATS2_NONE)))))) {
		BVar3 = 0;
	}
	else {
		BVar3 = 1;
	}
	LiveObject_HideAll(liveObj,BVar3);
	BVar3 = Level_Block_IsMeshHidden(x,y);
	if (((BVar3 != 0) || (BVar3 = Level_Block_IsNotWallOrGround(x,y), BVar3 != 0)) ||
		 ((liveObj->flags3 & LIVEOBJ3_UNK_100000) != LIVEOBJ3_NONE)) {
		rotation = DIRECTION_RIGHT;
		local_1c = 1;
		if (liveObj->objType == OBJECT_BUILDING) {
			LiveObject_GetFaceDirection(liveObj,&local_18);
			LiveObject_GetBlockPos(liveObj,&local_10.x,&local_10.y);
			LiveObject_GetPosition(liveObj,&local_8,&local_4);
			if (ABS(local_18.x) <= ABS(local_18.y)) {
				if ((ushort)((ushort)(local_18.y < 0.0) << 8 | (ushort)(local_18.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_18.x < 0.0) << 8 | (ushort)(local_18.x == 0.0) << 0xe) != 0) {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar5 = res::Building_GetShapePoints
												 (globs::legoGlobs.BuildingData_TABLE + liveObj->objIndex,&local_20);
			pPVar6 = res::SelectPlace_TransformShapePoints(&local_10,pPVar5,local_20,rotation);
			uVar7 = local_20;
			pPVar5 = pPVar6;
			if (local_20 != 0) {
				do {
					pPVar8 = pPVar5 + 1;
					if (((uVar9 == uVar7 - 1) || (pPVar6->x != pPVar8->x)) || (pPVar6->y != pPVar5[1].y)) {
						bVar1 = false;
						BVar3 = Level_Block_IsMeshHidden(pPVar6->x,pPVar6->y);
						uVar7 = local_20;
						if (BVar3 == 0) {
							local_1c = 0;
							break;
						}
					}
					else {
						bVar1 = true;
					}
					if (bVar1) {
						uVar9 += 1;
						pPVar8 = pPVar5 + 2;
						pPVar6 = pPVar6 + 1;
					}
					uVar9 += 1;
					pPVar6 = pPVar6 + 1;
					pPVar5 = pPVar8;
				} while (uVar9 < uVar7);
			}
		}
	}
	LiveObject_Hide2(liveObj,local_1c);
	return 0;
}



void __cdecl lego::game::LiveObject_HideAll(LiveObject *liveObj,BOOL hide)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		res::Vehicle_HideAll(liveObj->vehicle,hide);
		return;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		res::Object_HideAll((BasicObjectData *)liveObj->miniFigure,hide);
		return;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		res::Object_HideAll((BasicObjectData *)liveObj->rockMonster,hide);
		return;
	}
	if (OVar1 == OBJECT_BUILDING) {
		res::Building_HideAll(liveObj->building,hide);
		return;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		res::Object_HideAll((BasicObjectData *)liveObj->upgrade,hide);
		return;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		res::Container_Hide(liveObj->other,hide);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_IsHidden(LiveObject *liveObj)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		OVar1 = res::Vehicle_GetFlag2(liveObj->vehicle);
		return OVar1;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->miniFigure);
		return OVar1;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->rockMonster);
		return OVar1;
	}
	if (OVar1 == OBJECT_BUILDING) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->building);
		return OVar1;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->upgrade);
		return OVar1;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		OVar1 = res::Container_IsHidden(liveObj->other);
	}
	return OVar1;
}



void __cdecl
lego::game::LiveObject_FP_GetPositionAndHeading
					(LiveObject *liveObj,int cameraFrame,Vector3F *out_position,Vector3F *out_dir)
{
	ObjectType OVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Container *pCVar5;
	LiveObject *pLVar6;
	Vector3F local_c;
	
	if ((liveObj->resData_2dc != NULL) && (liveObj->index_2e0 == cameraFrame)) goto LAB_0044a3a2;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		pCVar5 = res::Vehicle_GetCameraNull(liveObj->vehicle,cameraFrame);
LAB_0044a371:
		liveObj->resData_2dc = pCVar5;
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			pCVar5 = res::Creature_GetCameraNull(liveObj->miniFigure,cameraFrame);
			goto LAB_0044a371;
		}
		if (OVar1 != OBJECT_ROCKMONSTER) goto LAB_0044a3a2;
		pCVar5 = res::Creature_GetCameraNull(liveObj->rockMonster,cameraFrame);
		liveObj->resData_2dc = pCVar5;
	}
	if (pCVar5 != NULL) {
		liveObj->index_2e0 = cameraFrame;
	}
LAB_0044a3a2:
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		pLVar6 = (LiveObject *)res::Vehicle_IsCameraFlipDir(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			pLVar6 = (LiveObject *)res::Creature_IsCameraFlipDir(liveObj->miniFigure);
		}
		else {
			pLVar6 = liveObj;
			if (OVar1 == OBJECT_ROCKMONSTER) {
				pLVar6 = (LiveObject *)res::Creature_IsCameraFlipDir(liveObj->rockMonster);
			}
		}
	}
	if (liveObj->resData_2dc != NULL) {
		res::Container_GetPosition(liveObj->resData_2dc,NULL,out_position);
		res::Container_GetOrientation(liveObj->resData_2dc,NULL,out_dir,&local_c);
		fVar2 = 1.0 / SQRT(out_dir->x * out_dir->x + out_dir->z * out_dir->z + out_dir->y * out_dir->y);
		fVar4 = fVar2 * out_dir->x;
		fVar3 = fVar2 * out_dir->y;
		fVar2 = fVar2 * out_dir->z;
		out_dir->x = fVar4;
		out_dir->y = fVar3;
		out_dir->z = fVar2;
		if (pLVar6 != NULL) {
			out_dir->x = fVar4 * -1.0;
			out_dir->y = fVar3 * -1.0;
			out_dir->z = fVar2 * -1.0;
			return;
		}
	}
	return;
}



Container * __cdecl lego::game::LiveObject_GetContainer(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	if (true) {
		switch(liveObj->objType) {
		case OBJECT_VEHICLE:
			pLVar1 = (LiveObject *)res::Vehicle_GetActivityContainer(liveObj->vehicle);
			return (Container *)pLVar1;
		case OBJECT_MINIFIGURE:
			pLVar1 = (LiveObject *)
							 res::Object_GetActivityContainer((BasicObjectData *)liveObj->miniFigure);
			return (Container *)pLVar1;
		case OBJECT_ROCKMONSTER:
			pLVar1 = (LiveObject *)
							 res::Object_GetActivityContainer((BasicObjectData *)liveObj->rockMonster);
			return (Container *)pLVar1;
		case OBJECT_BUILDING:
			pLVar1 = (LiveObject *)res::Object_GetActivityContainer((BasicObjectData *)liveObj->building);
			return (Container *)pLVar1;
		case OBJECT_UPGRADEPART:
			pLVar1 = (LiveObject *)res::Object_GetActivityContainer((BasicObjectData *)liveObj->upgrade);
			return (Container *)pLVar1;
		}
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) == LIVEOBJ3_NONE) {
		return (Container *)liveObj;
	}
	return (Container *)(LiveObject *)liveObj->other;
}



BOOL __cdecl
lego::game::LiveObject_GetDrillNullPosition(LiveObject *liveObj,float *out_x,float *out_y)
{
	ObjectType OVar1;
	Container *cont;
	CreatureData *creature;
	Vector3F vector;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		cont = res::Vehicle_GetDrillNull(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			creature = liveObj->miniFigure;
		}
		else {
			if (OVar1 != OBJECT_ROCKMONSTER) {
				return 0;
			}
			creature = liveObj->rockMonster;
		}
		cont = res::Creature_GetDrillNull(creature);
	}
	if (cont == NULL) {
		return 0;
	}
	res::Container_GetPosition(cont,NULL,&vector);
	*out_x = vector.x;
	*out_y = vector.y;
	return 1;
}



void __cdecl lego::game::LiveObject_FPMove(LiveObject *liveObj,int forward,int strafe,float rotate)
{
	ObjectStatsFlags3 OVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (liveObj->drivenObject != NULL)) {
		liveObj = liveObj->drivenObject;
	}
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
	}
	OVar1 = stats::StatsObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CANSTRAFE) == STATS3_NONE) {
		strafe = 0;
	}
	liveObj->strafeSpeed_2bc = liveObj->strafeSpeed_2bc + strafe;
	liveObj->forwardSpeed_2c0 = liveObj->forwardSpeed_2c0 + forward;
	liveObj->rotateSpeed_2c4 = rotate + liveObj->rotateSpeed_2c4;
	return;
}



void __cdecl lego::game::Level_RegisterRechargeSeam(Point2I *blockPos)
{
	if (globs::liveGlobs.RechargeSeams_COUNT < 10) {
		globs::liveGlobs.RechargeSeams_TABLE[globs::liveGlobs.RechargeSeams_COUNT].x = blockPos->x;
		globs::liveGlobs.RechargeSeams_TABLE[globs::liveGlobs.RechargeSeams_COUNT].y = blockPos->y;
		globs::liveGlobs.RechargeSeams_COUNT += 1;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FindRechargeSeam_FUN_0044a690(LiveObject *liveObj,Point2I *out_seamBlockPos)
{
	float fVar1;
	SurfaceMap *surfMap;
	uint uVar2;
	uint uVar3;
	Point2I *pPVar4;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar2 = 0xffffffff;
	local_14 = 10000.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	uVar3 = 0;
	if (globs::liveGlobs.RechargeSeams_COUNT != 0) {
		pPVar4 = globs::liveGlobs.RechargeSeams_TABLE;
		do {
			by = pPVar4->y;
			bx = pPVar4->x;
			out_y = &local_4;
			out_x = &local_8;
			surfMap = lrr::Lego_GetMap();
			Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
			fVar1 = SQRT((local_c - local_4) * (local_c - local_4) +
									 (local_10 - local_8) * (local_10 - local_8));
			if (fVar1 < local_14) {
				uVar2 = uVar3;
				local_14 = fVar1;
			}
			uVar3 += 1;
			pPVar4 = pPVar4 + 1;
		} while (uVar3 < globs::liveGlobs.RechargeSeams_COUNT);
	}
	if (uVar2 == 0xffffffff) {
		return 0;
	}
	if (out_seamBlockPos != NULL) {
		out_seamBlockPos->x = globs::liveGlobs.RechargeSeams_TABLE[uVar2].x;
		out_seamBlockPos->y = globs::liveGlobs.RechargeSeams_TABLE[uVar2].y;
	}
	return 1;
}



void __cdecl lego::game::Level_RegisterSlimySlugHole(Point2I *position)
{
	if (globs::liveGlobs.SlugHoles_COUNT < 20) {
		globs::liveGlobs.SlugHoles_TABLE[globs::liveGlobs.SlugHoles_COUNT].x = position->x;
		globs::liveGlobs.SlugHoles_TABLE[globs::liveGlobs.SlugHoles_COUNT].y = position->y;
		globs::liveGlobs.SlugHoles_COUNT += 1;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_NearestSlugHole_FUN_0044a7b0(LiveObject *liveObj,Point2I *out_blockPos)
{
	float fVar1;
	SurfaceMap *surfMap;
	uint uVar2;
	uint uVar3;
	Point2I *pPVar4;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar2 = 0xffffffff;
	local_14 = 10000.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	uVar3 = 0;
	if (globs::liveGlobs.SlugHoles_COUNT != 0) {
		pPVar4 = globs::liveGlobs.SlugHoles_TABLE;
		do {
			by = pPVar4->y;
			bx = pPVar4->x;
			out_y = &local_4;
			out_x = &local_8;
			surfMap = lrr::Lego_GetMap();
			Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
			fVar1 = SQRT((local_c - local_4) * (local_c - local_4) +
									 (local_10 - local_8) * (local_10 - local_8));
			if (fVar1 < local_14) {
				uVar2 = uVar3;
				local_14 = fVar1;
			}
			uVar3 += 1;
			pPVar4 = pPVar4 + 1;
		} while (uVar3 < globs::liveGlobs.SlugHoles_COUNT);
	}
	if (uVar2 == 0xffffffff) {
		return 0;
	}
	if (out_blockPos != NULL) {
		out_blockPos->x = globs::liveGlobs.SlugHoles_TABLE[uVar2].x;
		out_blockPos->y = globs::liveGlobs.SlugHoles_TABLE[uVar2].y;
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_0044a890
					(LiveObject *liveObj,int *param_2,int *param_3,BOOL param_4,BOOL param_5,BOOL param_6)
{
	float fVar1;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	float *pfVar5;
	float *pfVar6;
	uint number;
	uint bx;
	uint by;
	longlong lVar7;
	int local_4cc;
	int local_4c8;
	SurfaceMap *local_4c4;
	float local_4c0;
	float local_4bc;
	float local_4b8;
	float local_4b4;
	float local_4b0;
	float local_4ac [299];
	
	local_4c4 = lrr::Lego_GetMap();
	number = 0;
	LiveObject_GetPosition(liveObj,&local_4b8,&local_4b4);
	LiveObject_GetBlockPos(liveObj,&local_4cc,&local_4c8);
	by = local_4c8 - 10;
	iVar3 = local_4cc;
	iVar4 = local_4c8;
	if ((int)by < local_4c8 + 10) {
		do {
			bx = iVar3 - 10;
			if ((int)bx < iVar3 + 10) {
				pfVar5 = local_4ac + number * 3;
				do {
					BVar2 = Level_Block_IsWall(bx,by);
					pfVar6 = pfVar5;
					if (((BVar2 != 0) &&
							((param_6 != 0 || (BVar2 = Level_Block_IsReinforced(bx,by), BVar2 == 0)))) &&
						 ((param_5 != 0 || (BVar2 = Level_Block_IsCorner(bx,by), BVar2 == 0)))) {
						Map3D_BlockToWorldPos(local_4c4,bx,by,&local_4c0,&local_4bc);
						fVar1 = SQRT((local_4bc - local_4b4) * (local_4bc - local_4b4) +
												 (local_4c0 - local_4b8) * (local_4c0 - local_4b8));
						if (((param_4 == 0) || (local_4c4->BlockSize <= fVar1)) && (number < 100)) {
							number += 1;
							pfVar6 = pfVar5 + 3;
							pfVar5[-1] = (float)bx;
							*pfVar5 = (float)by;
							pfVar5[1] = fVar1;
						}
					}
					bx += 1;
					iVar3 = local_4cc;
					iVar4 = local_4c8;
					pfVar5 = pfVar6;
				} while ((int)bx < local_4cc + 10);
			}
			by += 1;
		} while ((int)by < iVar4 + 10);
	}
	if (number == 0) {
		return 0;
	}
	std::qsort(&local_4b0,number,0xc,unk::Lego_QsortCompare_FUN_0044aa60);
	lVar7 = __ftol((float10)local_4b0);
	*param_2 = (int)lVar7;
	lVar7 = __ftol((float10)local_4ac[0]);
	*param_3 = (int)lVar7;
	return 1;
}



BOOL __cdecl lego::unk::Lego_QsortCompare_FUN_0044aa60(int param_1,int param_2)
{
	if ((ushort)((ushort)(*(float *)(param_1 + 8) < *(float *)(param_2 + 8)) << 8 |
							(ushort)(*(float *)(param_1 + 8) == *(float *)(param_2 + 8)) << 0xe) == 0) {
		return 1;
	}
	if (*(float *)(param_1 + 8) < *(float *)(param_2 + 8)) {
		return -1;
	}
	return 0;
}



PolyMeshData * __cdecl
lego::res::Res_LoadPolyMesh
					(CFGProperty *aeRoot,char *rootName,char *dirname,PolyMode polyMode,uint numCameraFrames)
{
	char *pcVar1;
	CFGProperty *prop;
	int iVar2;
	PolyMeshData *lastPolyData;
	uint index;
	PolyMeshData *local_104;
	char local_100 [256];
	
	index = 0;
	lastPolyData = NULL;
	local_104 = NULL;
	if (polyMode != POLY_FP) {
		numCameraFrames = 1;
	}
	if (numCameraFrames != 0) {
		do {
			if (polyMode == POLY_FP) {
				std::sprintf(local_100,"FPPoly::Camera%i",index + 1);
			}
			else {
				if (polyMode == POLY_HIGH) {
					pcVar1 = "HighPoly";
				}
				else {
					if (polyMode != POLY_MEDIUM) goto LAB_0044ab0b;
					pcVar1 = "MediumPoly";
				}
				std::sprintf(local_100,pcVar1);
			}
LAB_0044ab0b:
			pcVar1 = cfg::CFG_JoinPath(rootName,local_100,0);
			for (prop = cfg::CFG_GetChildren(aeRoot,pcVar1); prop != NULL; prop = cfg::CFG_NextFlat(prop))
			{
				pcVar1 = prop->key;
				if (*pcVar1 == '!') {
					if ((globs::mainGlobs.flags & CMD_REDUCEPROMESHES) == CMD_NONE) {
						if (true) {
							pcVar1 = pcVar1 + 1;
						}
						goto LAB_0044ab53;
					}
				}
				else {
LAB_0044ab53:
					iVar2 = std::_stricmp("NULL",prop->value);
					if (iVar2 == 0) {
						lastPolyData = MeshPoly_CreateNull(lastPolyData,pcVar1,index);
					}
					else {
						lastPolyData = MeshPoly_Create(lastPolyData,pcVar1,dirname,prop->value,index);
					}
					if (local_104 == NULL) {
						local_104 = lastPolyData;
					}
				}
			}
			index += 1;
		} while (index < numCameraFrames);
	}
	return local_104;
}



BOOL __cdecl
lego::game::Game_UnkBuildingPlaceDirection
					(ObjectType objType,int objIndex,BOOL param_3,BOOL param_4,Point2F *mouseWorldPos,
					uint mouseBlockX,uint mouseBlockY,BOOL param_8,SelectPlace *selectPlace)
{
	float fVar1;
	float fVar2;
	BOOL BVar3;
	Point2I *shapePoints;
	int iVar4;
	SurfaceMap *surfMap;
	Point2I *shapePoints_00;
	undefined4 uVar5;
	LiveObject *pLVar6;
	ObjectStatsFlags1 OVar7;
	uint uVar8;
	uint uVar9;
	Point2F *out_x;
	float *out_y;
	Point2I local_10;
	Point2F local_8;
	
	uVar8 = mouseBlockY;
	uVar9 = mouseBlockX;
	local_10.x = mouseBlockX;
	local_10.y = mouseBlockY;
	if (objType == OBJECT_BUILDING) {
		if (param_8 != 0) {
			BVar3 = Level_Block_IsGround(mouseBlockX,mouseBlockY);
			if (BVar3 == 0) {
				if ((param_4 == 0) &&
					 (front::Pointer_SetCurrent_IfTimerFinished(POINTER_CANNOTBUILD), param_3 != 0)) {
					Game_SetPointer_AndPlayEnumSFX(1);
				}
				res::SelectPlace_Hide(selectPlace,TRUE);
			}
			else {
				shapePoints = res::Building_GetShapePoints
																(globs::legoGlobs.BuildingData_TABLE + objIndex,&mouseBlockX);
				iVar4 = stats::Stats_GetWaterEntrances(OBJECT_BUILDING,objIndex,0);
				res::SelectPlace_Hide(selectPlace,FALSE);
				out_y = &local_8.y;
				out_x = &local_8;
				surfMap = lrr::Lego_GetMap();
				Map3D_BlockToWorldPos(surfMap,uVar9,uVar8,&out_x->x,out_y);
				fVar1 = mouseWorldPos->x - local_8.x;
				fVar2 = mouseWorldPos->y - local_8.y;
				if (((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) ||
					 (fVar1 <= ABS(fVar2))) {
					if ((0.0 <= fVar1) ||
						 (mouseBlockY = (uint)ABS(fVar1),
						 (ushort)((ushort)((float)mouseBlockY < ABS(fVar2)) << 8 |
										 (ushort)((float)mouseBlockY == ABS(fVar2)) << 0xe) != 0)) {
						if (((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) != 0) ||
							 (fVar2 <= ABS(fVar1))) {
							if ((fVar2 < 0.0) &&
								 (mouseBlockY = (uint)ABS(fVar2),
								 (ushort)((ushort)((float)mouseBlockY < ABS(fVar1)) << 8 |
												 (ushort)((float)mouseBlockY == ABS(fVar1)) << 0xe) == 0)) {
								globs::legoGlobs.placeObjDirection = DIRECTION_DOWN;
							}
						}
						else {
							globs::legoGlobs.placeObjDirection = DIRECTION_UP;
						}
					}
					else {
						globs::legoGlobs.placeObjDirection = DIRECTION_LEFT;
					}
				}
				else {
					globs::legoGlobs.placeObjDirection = DIRECTION_RIGHT;
				}
				uVar9 = 0;
				do {
					shapePoints_00 =
							 (Point2I *)
							 res::SelectPlace_DrawTiles
												 (selectPlace,&local_10,shapePoints,mouseBlockX,
													uVar9 + globs::legoGlobs.placeObjDirection & DIRECTION_LEFT,
													(globs::legoGlobs.level)->surfaceMap,iVar4);
					if (shapePoints_00 != NULL) {
						if ((param_4 == 0) &&
							 (front::Pointer_SetCurrent_IfTimerFinished(POINTER_CANBUILD), param_3 != 0)) {
							uVar5 = Construction_Start(objIndex,&local_10,
																				 uVar9 + globs::legoGlobs.placeObjDirection & DIRECTION_LEFT
																				 ,shapePoints_00,mouseBlockX);
							pLVar6 = LiveObject_FUN_00438da0(NULL,&local_10,OBJECT_ORE,0);
							uVar9 = stats::Stats_GetCostRefinedOre(OBJECT_BUILDING,objIndex,0);
							OVar7 = stats::Stats_GetStatsFlags1(OBJECT_BUILDING,objIndex);
							if ((OVar7 & STATS1_STOREOBJECTS) == STATS1_NONE) {
								Construction_FUN_00408df0(&local_10,(uint *)shapePoints_00,mouseBlockX);
							}
							uVar8 = stats::Stats_GetCostCrystal(OBJECT_BUILDING,objIndex,0);
							Construction_SpawnCarryableObject(&local_10,OBJECT_POWERCRYSTAL,0,0,uVar8);
							if ((pLVar6 == NULL) || (uVar9 == 0)) {
								uVar9 = stats::Stats_GetCostOre(OBJECT_BUILDING,objIndex,0);
								iVar4 = 0;
							}
							else {
								iVar4 = 1;
							}
							Construction_SpawnCarryableObject(&local_10,OBJECT_ORE,iVar4,0,uVar9);
							Construction_FUN_00408c10(uVar5,NULL);
							res::SelectPlace_Hide(selectPlace,TRUE);
							front::Interface_BackToMain();
							Game_SetPointer_AndPlayEnumSFX(0);
							return 0;
						}
						globs::legoGlobs.placeObjDirection =
								 uVar9 + globs::legoGlobs.placeObjDirection & DIRECTION_LEFT;
						break;
					}
					uVar9 += 1;
				} while (uVar9 < 5);
				if (uVar9 != 5) {
					return 1;
				}
				if ((param_4 == 0) &&
					 (front::Pointer_SetCurrent_IfTimerFinished(POINTER_CANNOTBUILD), param_3 != 0)) {
					Game_SetPointer_AndPlayEnumSFX(1);
					front::Text_DisplayMessage(TEXT_CANNOTPLACEBUILDING,FALSE,FALSE);
					return TRUE;
				}
			}
			front::Text_DisplayMessage(TEXT_CANNOTPLACEBUILDING,FALSE,FALSE);
			return TRUE;
		}
		res::SelectPlace_Hide(selectPlace,TRUE);
	}
	return TRUE;
}



void __cdecl lego::front::ObjTts_Initialise(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	int iVar2;
	int (*paiVar3) [15];
	ObjectType local_8;
	int local_4;
	
	paiVar3 = globs::liveGlobs.ObjTtSFX_TABLE;
	for (iVar2 = 300; iVar2 != 0; iVar2 += -1) {
		(*paiVar3)[0] = 0;
		paiVar3 = (int (*) [15])(*paiVar3 + 1);
	}
	iVar2 = 0x14;
	local_8 = 0x14;
	do {
		iVar2 += -1;
		local_4 = 0xf;
	} while (iVar2 != 0);
	keyPath = cfg::CFG_JoinPath(keyBasePath,"ObjTtSFXs",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		BVar1 = game::Object_GetObjectByName(prop->key,&local_8,&local_4,NULL);
		if ((BVar1 != 0) && (BVar1 = snd::SFX_GetType(prop->value,(SFXType *)&keyBasePath), BVar1 != 0))
		{
			globs::liveGlobs.ObjTtSFX_TABLE[local_8][local_4] = (int)keyBasePath;
		}
	}
	return;
}



int __cdecl lego::game::LiveObject_GetObjTtSFX(LiveObject *liveObj)
{
	int local_4;
	
	LiveObject_GetTypeIndex(liveObj,(int *)&liveObj,&local_4);
	return *(int *)(local_4 * 4 + 0x4df814 + (int)liveObj * 0x3c);
}



void __cdecl lego::game::LiveManager_SetFlag20(BOOL state)
{
	if (state != 0) {
		globs::liveGlobs.flags = globs::liveGlobs.flags | LIVEMANAGER_UNK_20;
		return;
	}
	globs::liveGlobs.flags = globs::liveGlobs.flags & ~LIVEMANAGER_UNK_20;
	return;
}



void __cdecl lego::game::LiveObject_FUN_0044b0a0(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	int crystalCount;
	uint uVar2;
	LiveObject *in_liveObj;
	
	pLVar1 = NULL;
	if (((((byte)globs::liveGlobs.flags & LIVEMANAGER_UNK_20) == 0) &&
			(liveObj->objType == OBJECT_VEHICLE)) &&
		 ((liveObj->flags4 & LIVEOBJ4_UNK_800) == LIVEOBJ4_NONE)) {
		if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
			pLVar1 = liveObj->object_2fc;
		}
		in_liveObj = pLVar1;
		if (pLVar1 == NULL) {
			in_liveObj = liveObj;
		}
		uVar2 = (uint)(pLVar1 != NULL);
		crystalCount = stats::Stats_GetCostCrystal(OBJECT_VEHICLE,liveObj->objIndex,0);
		LiveObject_SpawnDropCrystals_FUN_0044b110(in_liveObj,crystalCount,uVar2);
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_800;
	}
	return;
}



void __cdecl
lego::game::LiveObject_SpawnDropCrystals_FUN_0044b110
					(LiveObject *in_liveObj,int crystalCount,BOOL param_3)
{
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	LiveObject *liveObj;
	float10 fVar2;
	float in_x;
	float in_y;
	uint *out_bx;
	uint *out_by;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	uint local_14;
	uint local_10;
	Vector3F local_c;
	
	if (crystalCount != 0) {
		do {
			if (((param_3 == 0) || (in_liveObj->objType != OBJECT_BUILDING)) ||
				 (cont = res::Building_GetEntranceNull(in_liveObj->building), cont == NULL)) {
				LiveObject_GetPosition(in_liveObj,&local_24,&local_20);
			}
			else {
				res::Container_GetPosition(cont,NULL,&local_c);
				local_24 = local_c.x;
				local_20 = local_c.y;
			}
			fVar2 = math::Maths_RandRange(-5.0,5.0);
			local_1c = (float)fVar2;
			fVar2 = math::Maths_RandRange(-5.0,5.0);
			local_18 = (float)fVar2;
			in_y = local_18 + local_20;
			out_by = &local_10;
			out_bx = &local_14;
			in_x = local_1c + local_24;
			surfMap = lrr::Lego_GetMap();
			BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)out_bx,(int *)out_by);
			if ((BVar1 != 0) && (BVar1 = Level_Block_IsGround(local_14,local_10), BVar1 != 0)) {
				local_24 = local_1c + local_24;
				local_20 = local_18 + local_20;
			}
			liveObj = LiveObject_CreateInWorld
													(globs::legoGlobs.contCrystal,OBJECT_POWERCRYSTAL,0,0,local_24,local_20,
													 0.0);
			ai::AITask_DoCollect(liveObj,0.0);
			crystalCount += -1;
		} while (crystalCount != 0);
	}
	return;
}



void __cdecl lego::game::LiveObject_CallsSpawnDropCrystals_FUN_0044b250(LiveObject *liveObj)
{
	if (liveObj->stealTableptr_348 != NULL) {
		LiveObject_SpawnDropCrystals_FUN_0044b110(liveObj,*liveObj->stealTableptr_348,0);
	}
	return;
}



void __cdecl lego::game::LiveObject_GenerateTinyRMs_FUN_0044b270(LiveObject *in_liveObj)
{
	short sVar1;
	BOOL BVar2;
	LiveObject *liveObj;
	bool bVar3;
	char *objName;
	uint uVar4;
	int out_objIndex;
	ObjectType out_objType;
	Container *local_c;
	float local_8;
	float local_4;
	
	bVar3 = false;
	BVar2 = Object_GetObjectByName("RockMonster",&out_objType,&out_objIndex,NULL);
	objName = (char *)in_liveObj;
	if (((BVar2 != 0) && (out_objType == in_liveObj->objType)) &&
		 (out_objIndex == in_liveObj->objIndex)) {
		objName = "TinyRM";
		bVar3 = true;
	}
	if (!bVar3) {
		BVar2 = Object_GetObjectByName("Lavamonster",&out_objType,&out_objIndex,NULL);
		if (((BVar2 != 0) && (out_objType == in_liveObj->objType)) &&
			 (out_objIndex == in_liveObj->objIndex)) {
			objName = "TinyRM";
			bVar3 = true;
		}
		if (((!bVar3) &&
				(BVar2 = Object_GetObjectByName("Icemonster",&out_objType,&out_objIndex,NULL), BVar2 != 0))
			 && ((out_objType == in_liveObj->objType && (out_objIndex == in_liveObj->objIndex)))) {
			objName = "TinyIM";
		}
	}
	BVar2 = Object_GetObjectByName(objName,&out_objType,&out_objIndex,&local_c);
	if (BVar2 != 0) {
		LiveObject_GetPosition(in_liveObj,&local_8,&local_4);
		uVar4 = 0;
		while( true ) {
			sVar1 = math::Maths_Rand();
			liveObj = LiveObject_CreateInWorld
													(local_c,out_objType,out_objIndex,0,local_8,local_4,
													 (float)((int)sVar1 % 7));
			liveObj->health = -1.0;
			BVar2 = LiveObject_TryDepart_FUN_004499c0(liveObj);
			if (BVar2 == 0) break;
			uVar4 += 1;
			in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_20;
			if (2 < uVar4) {
				return;
			}
		}
		LiveObject_Remove(liveObj);
	}
	return;
}



void __cdecl lego::game::Level_GenerateSmallSpiders(uint x,uint y,uint randSeed)
{
	short sVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	LiveObject *pLVar3;
	int iVar4;
	float10 fVar5;
	Vector3F *out_vertPoses;
	int objIndex;
	ObjectType objType;
	Container *objRes;
	Point2F genPos;
	Point2F local_30;
	Point2F local_18;
	
	BVar2 = Object_GetObjectByName("SmallSpider",&objType,&objIndex,&objRes);
	if (BVar2 != 0) {
		out_vertPoses = (Vector3F *)&local_30;
		surfMap = lrr::Lego_GetMap();
		Map3D_GetBlockVertexPositions2(surfMap,x,y,out_vertPoses);
		for (iVar4 = (randSeed & 3) + 2; iVar4 != 0; iVar4 += -1) {
			sVar1 = math::Maths_Rand();
			fVar5 = math::Maths_RandRange(local_30.x - -1.0,local_18.x - 1.0);
			genPos.x = (float)fVar5;
			fVar5 = math::Maths_RandRange(local_30.y - 1.0,local_18.y - -1.0);
			genPos.y = (float)fVar5;
			pLVar3 = LiveObject_CreateInWorld
												 (objRes,objType,objIndex,0,genPos.x,genPos.y,(float)((int)sVar1 % 7));
			pLVar3->flags1 = pLVar3->flags1 | LIVEOBJ1_UNK_10000;
		}
	}
	return;
}



void __cdecl lego::ai::AI_LiveObject_DoThrowLegoman(LiveObject *liveObj1,LiveObject *liveObj2)
{
	BOOL BVar1;
	float10 fVar2;
	
	BVar1 = game::LiveObject_CheckCondition_AndIsPowered(liveObj2,1);
	if ((((BVar1 != 0) && ((liveObj2->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)) &&
			((*(byte *)&liveObj1->flags2 & 1) == 0)) &&
		 ((liveObj2->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE)) {
		BVar1 = game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj1);
		if (BVar1 == 0) {
			fVar2 = stats::StatsObject_GetPainThreshold(liveObj1);
			if (fVar2 < (float10)liveObj1->health) {
				front::Interface_BackToMain_IfLiveObject_IsSelected_OrFlags3_200000(liveObj2);
				game::LiveObject_FUN_00441df0(liveObj2,0,1);
				game::LiveObject_FUN_00441df0(liveObj1,0,1);
				game::LiveObject_SetActivityUnk(liveObj1,ACTIVITY_THROWMAN,1);
				game::LiveObject_Container_ActivityUpdate_Check(liveObj1);
				game::LiveObject_SetActivityUnk(liveObj2,ACTIVITY_THROWNBYROCKMONSTER,1);
				game::LiveObject_Container_ActivityUpdate_Check(liveObj2);
				AITask_DoAnimationWait(liveObj1);
				AITask_DoAnimationWait(liveObj2);
				liveObj1->flags2 = liveObj1->flags2 | LIVEOBJ2_UNK_1;
				liveObj2->flags2 = liveObj2->flags2 | LIVEOBJ2_UNK_2;
				liveObj1->object_3c0 = liveObj2;
				liveObj2->object_3c0 = liveObj1;
			}
		}
	}
	return;
}



BOOL __cdecl lego::tools::Tool_IsBeamWeapon(ToolType toolType)
{
	if (((toolType != TOOL_LASER) && (toolType != TOOL_PUSHERGUN)) && (toolType != TOOL_FREEZERGUN)) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::MiniFigure_EquipTool(LiveObject *liveObj,ToolType toolType)
{
	uint uVar1;
	uint uVar2;
	BOOL BVar3;
	ToolType *pTVar4;
	uint uVar5;
	
	uVar1 = stats::StatsObject_GetNumOfToolsCanCarry(liveObj);
	uVar5 = 0;
	liveObj->field_3f4 = 0;
	if (uVar1 != 0) {
		liveObj->flags4 = liveObj->flags4 & 0xfffffffb;
		uVar2 = LiveObject_GetEquippedBeam(liveObj);
		if ((uVar2 != 0) || (BVar3 = tools::Tool_IsBeamWeapon(toolType), BVar3 != 0)) {
			liveObj->flags4 = liveObj->flags4 | 4;
		}
		BVar3 = tools::Tool_IsBeamWeapon(toolType);
		if ((BVar3 != 0) && (liveObj->numCarriedTools != 0)) {
			pTVar4 = liveObj->carriedTools;
			do {
				BVar3 = tools::Tool_IsBeamWeapon(*pTVar4);
				if (BVar3 != 0) {
					liveObj->carriedTools[uVar5] = toolType;
					return;
				}
				uVar5 += 1;
				pTVar4 = pTVar4 + 1;
			} while (uVar5 < liveObj->numCarriedTools);
		}
		if (uVar1 != 0) {
			uVar5 = liveObj->numCarriedTools;
			if (uVar5 == uVar1) {
				uVar1 = 0;
				if (uVar5 != 1) {
					pTVar4 = liveObj->carriedTools;
					do {
						uVar1 += 1;
						*pTVar4 = pTVar4[1];
						pTVar4 = pTVar4 + 1;
					} while (uVar1 < liveObj->numCarriedTools - 1);
				}
				liveObj->carriedTools[liveObj->numCarriedTools - 1] = toolType;
				return;
			}
			liveObj->carriedTools[uVar5] = toolType;
			liveObj->numCarriedTools = liveObj->numCarriedTools + 1;
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_HasToolEquipped(LiveObject *liveObj,ToolType toolType)
{
	uint uVar1;
	ToolType *pTVar2;
	
	uVar1 = 0;
	if (liveObj->numCarriedTools == 0) {
		return 0;
	}
	pTVar2 = liveObj->carriedTools;
	do {
		if (*pTVar2 == toolType) {
			return 1;
		}
		uVar1 += 1;
		pTVar2 = pTVar2 + 1;
	} while (uVar1 < liveObj->numCarriedTools);
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TaskHasTool_FUN_0044b780(LiveObject *in_liveObj,AITaskType taskType)
{
	LiveObject *liveObj;
	BOOL BVar1;
	
	liveObj = in_liveObj;
	if (in_liveObj->objType == OBJECT_MINIFIGURE) {
		BVar1 = stats::Stats_FindToolFromTaskType(taskType,(ToolType *)&in_liveObj);
		if (BVar1 != 0) {
			BVar1 = LiveObject_HasToolEquipped(liveObj,(ToolType)in_liveObj);
			return BVar1;
		}
	}
	return 1;
}



int __cdecl lego::game::LiveObject_DoGetTool(LiveObject *liveObj,ToolType toolType)
{
	LiveObject *pLVar1;
	Container *cont;
	SurfaceMap *pSVar2;
	BOOL BVar3;
	int iVar4;
	float *pfVar5;
	float *pfVar6;
	uint local_34;
	BOOL local_30;
	float local_2c;
	float local_28;
	Point2F local_24;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	local_30 = 0;
	iVar4 = 0;
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		LiveObject_GetPosition(liveObj,&local_24.x,&local_24.y);
		pLVar1 = Level_GetBuildingAtPosition(&local_24);
		if (pLVar1 != NULL) {
			cont = res::Building_GetToolNull
											 (pLVar1->building,globs::liveGlobs.ToolNullIndexes_TABLE[toolType]);
			res::Container_GetPosition(cont,NULL,&local_c);
			local_14 = local_c.x;
			pfVar6 = &local_28;
			pfVar5 = &local_2c;
			local_10 = local_c.y;
			pSVar2 = lrr::Lego_GetMap();
			Map3D_WorldToBlockPos_NoZ(pSVar2,local_c.x,local_c.y,(int *)pfVar5,(int *)pfVar6);
			pfVar6 = &local_18;
			pfVar5 = &local_1c;
			pSVar2 = lrr::Lego_GetMap();
			Map3D_WorldToBlockPos_NoZ(pSVar2,local_24.x,local_24.y,(int *)pfVar5,(int *)pfVar6);
			if ((local_1c == local_2c) && (local_18 == local_28)) {
				local_30 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
														 (liveObj_00,1,&local_2c,&local_28,&local_14);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj_00,local_1c,local_18,local_2c,local_28,&liveObj,&toolType,
													 &local_34,0,0);
				if (BVar3 != 0) {
					BVar3 = LiveObject_RoutingPtr_Alloc_FUN_004419c0
														(liveObj_00,local_34,(float *)liveObj,(float *)toolType,&local_14);
					std::free(liveObj);
					std::free((void *)toolType);
					local_30 = BVar3;
				}
			}
			iVar4 = local_30;
			if (local_30 != 0) {
				liveObj_00->object_2fc = pLVar1;
				liveObj_00->routeptr_24[liveObj_00->routingBlocksTotal - 1].byte_11 = 0xd;
			}
		}
	}
	return iVar4;
}



void __cdecl lego::game::LiveObject_Flocks_Initialise(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	LiveObject *pLVar1;
	Container *opt_parent;
	Container *child;
	Container *pCVar2;
	Flocks *pFVar3;
	FlocksItem *subdata;
	float10 fVar4;
	float speed;
	float fVar5;
	float fVar6;
	LiveObject *resData;
	Vector3F vector2;
	Vector3F vector1;
	
	liveObj = in_liveObj;
	vector1.x = 0.0;
	vector1.y = 0.0;
	vector1.z = 0.0;
	vector2.x = 0.0;
	vector2.y = 0.0;
	vector2.z = 0.0;
	pLVar1 = (LiveObject *)stats::StatsObject_GetFlocks_Size(in_liveObj);
	opt_parent = LiveObject_GetContainer(in_liveObj);
	child = res::Container_Create(opt_parent);
	pCVar2 = res::GetRoot();
	res::Container_SetParent(child,pCVar2);
	fVar6 = 0.0;
	resData = in_liveObj;
	fVar4 = stats::StatsObject_GetFlocks_Speed(in_liveObj);
	fVar5 = (float)fVar4;
	fVar4 = stats::StatsObject_GetFlocks_Turn(in_liveObj);
	pFVar3 = Flocks_LiveObject_Flocks_CreateData
										 (NULL,NULL,(float)fVar4,fVar5,fVar6,(Container *)resData);
	in_liveObj->flocksData_32c = pFVar3;
	pFVar3->flocksSubdata1->resData_98 = child;
	in_liveObj = pLVar1;
	if (0 < (int)pLVar1) {
		do {
			pCVar2 = res::Container_Clone(opt_parent);
			res::Container_SetParent(pCVar2,child);
			fVar4 = stats::StatsObject_GetFlocks_GoalUpdate(liveObj);
			fVar5 = (float)fVar4;
			fVar4 = stats::StatsObject_GetFlocks_Tightness(liveObj);
			fVar6 = (float)fVar4;
			fVar4 = stats::StatsObject_GetFlocks_Speed(liveObj);
			speed = (float)fVar4;
			fVar4 = stats::StatsObject_GetFlocks_Turn(liveObj);
			subdata = Flocks_LiveObject_Flocks_CreateSubdata
													(&vector1,&vector2,(float)fVar4,speed,fVar6,fVar5,pCVar2);
			Flocks_LiveObject_Flocks_AddSubdata(liveObj->flocksData_32c,subdata);
			in_liveObj = (LiveObject *)((int)&in_liveObj[-1].nextFree + 3);
		} while (in_liveObj != NULL);
	}
	return;
}



void __cdecl
lego::math::FlocksMatrix_FUN_0044ba60(Container *resData,Matrix4F *ref_matrix,float scalar)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F vector;
	Matrix4F matrix_b;
	Matrix4F matrix_a;
	
	fVar1 = ref_matrix->values[3][1];
	fVar2 = ref_matrix->values[3][0];
	fVar3 = ref_matrix->values[3][2];
	ref_matrix->values[3][0] = 0.0;
	ref_matrix->values[3][1] = 0.0;
	ref_matrix->values[3][2] = 0.0;
						// M_PI / 2 (1.570796)
	Matrix_RotX(&matrix_b,1.570796);
	Matrix_Mult(&matrix_a,&matrix_b,ref_matrix);
	Matrix_Copy(ref_matrix,&matrix_a);
	ref_matrix->values[3][0] = fVar2;
	ref_matrix->values[3][1] = fVar3;
	ref_matrix->values[3][2] = -fVar1 - scalar;
	res::Container_AddTransform(resData,D3DRMCOMBINE_REPLACE,ref_matrix);
	return;
}



void __cdecl
lego::game::Flocks_Callback_SubdataOrientationAnim
					(Flocks *flocksData,FlocksItem *subdata,float *pElapsed)
{
	Container *cont;
	float y;
	float x;
	SurfaceMap *pSVar1;
	float10 fVar2;
	float fVar3;
	float fVar4;
	Vector3F *out_vector;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	cont = subdata->resData_98;
	if (pElapsed[3] == 0.0) {
		math::FlocksMatrix_FUN_0044ba60(cont,&subdata->matrix,pElapsed[1]);
		if (pElapsed[2] != 0.0) {
			res::Container_GetOrientation(cont,NULL,&local_24,&local_30);
			local_30.x = local_30.x * 0.5;
			local_30.y = local_30.y * 0.5;
			local_30.z = (local_30.z - 1.0) * 0.5;
			res::Container_SetOrientation
								(cont,NULL,local_24.x,local_24.y,local_24.z,local_30.x,local_30.y,local_30.z);
		}
	}
	else {
		y = (subdata->matrix).values[3][2];
		x = (subdata->matrix).values[3][0];
		local_c.x = 0.0;
		local_c.y = 1.0;
		local_c.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 0.0;
		local_18.z = -1.0;
		fVar3 = x;
		fVar4 = y;
		pSVar1 = lrr::Lego_GetMap();
		fVar2 = Map3D_GetWorldZ(pSVar1,fVar3,fVar4);
		out_vector = &local_30;
		fVar3 = x;
		fVar4 = y;
		pSVar1 = lrr::Lego_GetMap();
		Map3D_FUN_0044fd70(pSVar1,fVar3,fVar4,out_vector);
		math::Maths_Vector3DRotate(&local_24,&local_c,&local_18,-subdata->rotationY_24);
		res::Container_SetOrientation
							(cont,NULL,local_30.x,local_30.y,local_30.z,local_24.x,local_24.y,local_24.z);
		res::Container_GetOrientation(cont,NULL,&local_30,&local_24);
		res::Container_SetOrientation
							(cont,NULL,local_24.x,local_24.y,local_24.z,local_30.x,local_30.y,local_30.z);
		res::Container_SetPosition(cont,NULL,x,y,(float)fVar2);
	}
	if (pElapsed[4] == 0.0) {
		res::Container_MoveAnimation(cont,*pElapsed);
	}
	else {
		if (0.0 <= subdata->rotationX_28) {
			res::Container_MoveAnimation(cont,*pElapsed);
			return;
		}
		fVar2 = res::Container_GetAnimationTime(cont);
		if (fVar2 != (float10)0.0) {
			fVar2 = res::Container_MoveAnimation(cont,*pElapsed);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				res::Container_SetAnimationTime(cont,0.0);
				return;
			}
		}
	}
	return;
}



void __cdecl
lego::game::Flocks_Container_ReleaseCallback(Flocks *flockData,FlocksItem *subdata,void *lpContext)
{
	Container *child;
	
	child = subdata->resData_98;
	if (child != NULL) {
		res::Container_SetParent(child,NULL);
		res::Container_Remove(child);
	}
	return;
}



void __cdecl lego::game::Flocks_Free(Flocks *flockData)
{
	Container *child;
	
	if (flockData != NULL) {
		Flocks_CallbackForAllSubdata(flockData,Flocks_Container_ReleaseCallback,NULL);
		child = flockData->flocksSubdata1->resData_98;
		res::Container_SetParent(child,NULL);
		res::Container_Remove(child);
		flockData->flocksSubdata1->resData_98 = NULL;
		Flocks_FreeData(flockData);
	}
	return;
}



void __cdecl lego::game::LiveObject_Flocks_SetParameters(LiveObject *liveObj,BOOL additive)
{
	Flocks *flocksData;
	float10 fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	
	flocksData = liveObj->flocksData_32c;
	if (additive != 0) {
		fVar1 = stats::StatsObject_GetFlocks_Tightness(liveObj);
		fVar4 = (float)(fVar1 + fVar1);
		fVar1 = stats::StatsObject_GetFlocks_Speed(liveObj);
		fVar3 = (float)(fVar1 + fVar1);
		fVar1 = stats::StatsObject_GetFlocks_Turn(liveObj);
		Flocks_SetParameters1(flocksData,(float)(fVar1 + fVar1),fVar3,fVar4);
		fVar1 = stats::StatsObject_GetFlocks_GoalUpdate(liveObj);
		fVar4 = (float)(fVar1 + fVar1);
		fVar1 = stats::StatsObject_GetFlocks_Tightness(liveObj);
		fVar3 = (float)(fVar1 + fVar1);
		fVar1 = stats::StatsObject_GetFlocks_Speed(liveObj);
		fVar2 = (float)(fVar1 * (float10)3.0);
		fVar1 = stats::StatsObject_GetFlocks_Turn(liveObj);
		Flocks_SetGlobal_AndAllSubdataParameters
							(flocksData,(float)(fVar1 * (float10)4.0),fVar2,fVar3,fVar4);
		return;
	}
	fVar1 = stats::StatsObject_GetFlocks_Tightness(liveObj);
	fVar4 = (float)fVar1;
	fVar1 = stats::StatsObject_GetFlocks_Speed(liveObj);
	fVar3 = (float)fVar1;
	fVar1 = stats::StatsObject_GetFlocks_Turn(liveObj);
	Flocks_SetParameters1(flocksData,(float)fVar1,fVar3,fVar4);
	fVar1 = stats::StatsObject_GetFlocks_GoalUpdate(liveObj);
	fVar4 = (float)fVar1;
	fVar1 = stats::StatsObject_GetFlocks_Tightness(liveObj);
	fVar3 = (float)fVar1;
	fVar1 = stats::StatsObject_GetFlocks_Speed(liveObj);
	fVar2 = (float)fVar1;
	fVar1 = stats::StatsObject_GetFlocks_Turn(liveObj);
	Flocks_SetGlobal_AndAllSubdataParameters(flocksData,(float)fVar1,fVar2,fVar3,fVar4);
	return;
}



void __cdecl lego::game::LiveObject_Flocks_FUN_0044bef0(LiveObject *liveObj,float elapsed)
{
	uint *puVar1;
	Flocks *pFVar2;
	ObjectStatsFlags1 OVar3;
	Container *pCVar4;
	BOOL BVar5;
	float10 fVar6;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_2c;
	Vector3F local_20;
	float local_14;
	float local_10;
	uint local_c;
	uint local_8;
	uint local_4;
	
	OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar3 & STATS1_FLOCKS) != STATS1_NONE) {
		OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
		if ((OVar3 & STATS1_FLOCKS_DEBUG) == STATS1_NONE) {
			pCVar4 = LiveObject_GetContainer(liveObj);
			BVar5 = res::Container_IsHidden(pCVar4);
			if (BVar5 == 0) {
				LiveObject_HideAll(liveObj,1);
			}
		}
		pFVar2 = liveObj->flocksData_32c;
		if ((*(byte *)&pFVar2->field_24 & 1) != 0) {
			pFVar2->field_14 = elapsed + (float)pFVar2->field_14;
		}
		fVar6 = stats::StatsObject_GetFlocks_AttackTime(liveObj);
		if (((ushort)((ushort)(fVar6 < (float10)elapsed) << 8 |
								 (ushort)(fVar6 == (float10)elapsed) << 0xe) != 0) &&
			 ((*(byte *)&liveObj->flags2 & 0x80) == 0)) {
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_FOLLOW,NULL,1);
			puVar1 = &liveObj->flocksData_32c->field_24;
			*puVar1 = *puVar1 & 0xfffffffe;
		}
		out_pos = &local_20;
		opt_ref = NULL;
		pCVar4 = LiveObject_GetContainer(liveObj);
		res::Container_GetPosition(pCVar4,opt_ref,out_pos);
		local_2c.y = -local_20.z;
		local_2c.x = local_20.x;
		local_2c.z = local_20.y;
		BVar5 = res::AnimClone_IsLws__Flic_GetWidth((AnimClone *)liveObj->flocksData_32c);
		if (BVar5 == 0) {
			Flocks_SetVector1(liveObj->flocksData_32c,&local_2c);
			Flocks_SetAllSubdataVectorC(liveObj->flocksData_32c,&local_2c);
			Flocks_SetAllSubdataVector0(liveObj->flocksData_32c,&local_2c);
		}
		if ((*(byte *)&liveObj->flags2 & 0x80) == 0) {
			LiveObject_Flocks_SetParameters(liveObj,0);
		}
		else {
			LiveObject_Flocks_SetParameters(liveObj,TRUE);
			liveObj->flags2 =
					 liveObj->flags2 &
					 (LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_4|LIVEOBJ2_DRIVING|LIVEOBJ2_UNK_10|
						LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_40|LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|LIVEOBJ2_TRAINING|
						LIVEOBJ2_UNK_800|LIVEOBJ2_UNK_1000|LIVEOBJ2_UNK_2000|LIVEOBJ2_UNK_4000|
						LIVEOBJ2_UPGRADING|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000|LIVEOBJ2_UNK_40000|
						LIVEOBJ2_UNK_80000|LIVEOBJ2_UNK_100000|LIVEOBJ2_UNK_200000|LIVEOBJ2_UNK_400000|
						LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000|LIVEOBJ2_UNK_2000000|LIVEOBJ2_UNK_4000000|
						LIVEOBJ2_UNK_8000000|LIVEOBJ2_UNK_10000000|LIVEOBJ2_UNK_20000000|LIVEOBJ2_UNK_40000000|
					 LIVEOBJ2_UNK_80000000);
		}
		Flocks_SetVector2(liveObj->flocksData_32c,&local_2c);
		fVar6 = stats::StatsObject_GetFlocks_Randomness(liveObj);
		Flocks_FUN_0040fe80(liveObj->flocksData_32c,(float)fVar6);
		Flocks_Subdata_UpdateMove(liveObj->flocksData_32c,elapsed);
		local_14 = elapsed;
		fVar6 = stats::StatsObject_GetFlocks_Height(liveObj);
		local_10 = (float)fVar6;
		OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
		local_c = OVar3 >> 0x17 & 1;
		OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
		local_8 = OVar3 >> 0x1a & 1;
		OVar3 = stats::StatsObject_GetStatsFlags1(liveObj);
		local_4 = OVar3 >> 0x1c & 1;
		Flocks_CallbackForAllSubdata
							(liveObj->flocksData_32c,Flocks_Callback_SubdataOrientationAnim,&local_14);
	}
	return;
}



void __cdecl lego::game::LiveObject_FlocksDestroy(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	Flocks **ppFVar2;
	Flocks *pFVar3;
	float10 fVar4;
	Vector3F local_c;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_FLOCKS_QUICKDESTROY) != STATS1_NONE) {
		Flocks_Free(liveObj->flocksData_32c);
		return;
	}
	ppFVar2 = (Flocks **)std::malloc(0x10);
	if (ppFVar2 == NULL) {
		Flocks_Free(liveObj->flocksData_32c);
		return;
	}
	pFVar3 = liveObj->flocksData_32c;
	local_c.x = (pFVar3->flocksSubdata1->vector_0).x;
	local_c.y = (pFVar3->flocksSubdata1->vector_0).y;
	local_c.z = (pFVar3->flocksSubdata1->vector_0).z;
	*ppFVar2 = pFVar3;
	pFVar3 = (Flocks *)stats::StatsObject_GetStatsFlags1(liveObj);
	ppFVar2[2] = pFVar3;
	ppFVar2[1] = (Flocks *)globs::liveGlobs.s_FlocksDestroy_c640;
	fVar4 = stats::StatsObject_GetFlocks_Height(liveObj);
	ppFVar2[3] = (Flocks *)(float)fVar4;
	globs::liveGlobs.s_FlocksDestroy_c640 = ppFVar2;
	Flocks_SetVector1(liveObj->flocksData_32c,&local_c);
	Flocks_SetAllSubdataVector0(liveObj->flocksData_32c,&local_c);
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::game::Flocks_Update_FUN_0044c1c0(float *pElapsed)
{
	FlocksItem *pFVar1;
	BOOL BVar2;
	FlocksItem *pFVar3;
	FlocksItem *buffer;
	FlocksItem *pFVar4;
	float local_14;
	uint local_10;
	uint local_c;
	uint local_8;
	uint local_4;
	
	pFVar3 = NULL;
	buffer = (FlocksItem *)globs::liveGlobs.s_FlocksDestroy_c640;
	if (globs::liveGlobs.s_FlocksDestroy_c640 != NULL) {
		do {
			Flocks_CallbackForAllSubdata
								(*(Flocks **)&buffer->vector_0,Flocks_Callback_FUN_00410000,pElapsed);
			local_14 = *pElapsed;
			local_10 = (uint)(buffer->vector_c).x;
			local_c = (uint)*(float *)((int)&buffer->vector_0 + 8) >> 0x17 & 1;
			local_8 = (uint)*(float *)((int)&buffer->vector_0 + 8) >> 0x1a & 1;
			local_4 = (uint)*(float *)((int)&buffer->vector_0 + 8) >> 0x1c & 1;
			Flocks_CallbackForAllSubdata
								(*(Flocks **)&buffer->vector_0,Flocks_Callback_SubdataOrientationAnim,&local_14);
			BVar2 = Flocks_CompareAllVecs_0_c(*(Flocks **)&buffer->vector_0);
			if (BVar2 == 0) {
				pFVar4 = *(FlocksItem **)((int)&buffer->vector_0 + 4);
			}
			else {
				pFVar4 = *(FlocksItem **)((int)&buffer->vector_0 + 4);
				pFVar1 = pFVar4;
				if (pFVar3 != NULL) {
					*(FlocksItem **)((int)&pFVar3->vector_0 + 4) = pFVar4;
					pFVar1 = (FlocksItem *)globs::liveGlobs.s_FlocksDestroy_c640;
				}
				globs::liveGlobs.s_FlocksDestroy_c640 = (void **)pFVar1;
				Flocks_Free(*(Flocks **)&buffer->vector_0);
				std::free(buffer);
				buffer = pFVar3;
			}
			pFVar3 = buffer;
			buffer = pFVar4;
		} while (pFVar4 != NULL);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_DestroyRockMonster_FUN_0044c290(LiveObject *liveObj)
{
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			== 0) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_100000;
		LiveObject_GenerateTinyRMs_FUN_0044b270(liveObj);
		LiveObject_CallsSpawnDropCrystals_FUN_0044b250(liveObj);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		reward::Rewards_RockMonsterDestroyed();
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0044c2f0(LiveObject *liveObj,float elapsed)
{
	LiveObject *pLVar1;
	float10 fVar2;
	Vector3F position;
	
	if (((liveObj->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE) &&
		 (liveObj->objType == OBJECT_ROCKMONSTER)) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_8000000;
		liveObj->float_368 = elapsed * 25.0;
		LiveObject_GetPosition(liveObj,&position.x,&position.y);
		fVar2 = LiveObject_GetHeading(liveObj);
		pLVar1 = LiveObject_CreateInWorld
											 (globs::legoGlobs.contIceCube,OBJECT_ICECUBE,0,0,position.x,position.y,
												(float)fVar2);
		res::Container_SetActivity(pLVar1->other,"Start");
		res::Container_SetAnimationTime(pLVar1->other,0.0);
		pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_UNK_100;
		liveObj->object_364 = pLVar1;
		pLVar1->object_364 = liveObj;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0044c3d0(LiveObject *liveObj)
{
	LiveFlags3 *pLVar1;
	
	if ((liveObj->object_364->flags1 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE) {
						// 100.0
		liveObj->object_364->health = (float)&DAT_42c80000;
		pLVar1 = &liveObj->object_364->flags3;
		*pLVar1 = *pLVar1 | LIVEOBJ3_UNK_800000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Unk_AndSetVector3B4(LiveObject *liveObj,Point2F *param_2,float param_3)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (((OVar1 != OBJECT_MINIFIGURE) && (OVar1 != OBJECT_ROCKMONSTER)) && (OVar1 != OBJECT_VEHICLE))
	{
		return 0;
	}
	LiveObject_FUN_00441df0(liveObj,0,1);
	(liveObj->vector_3b4).x = param_2->x;
	(liveObj->vector_3b4).y = param_2->y;
	(liveObj->vector_3b4).z = param_3;
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4000;
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_0044c470(LiveObject *liveObj,float elapsed)
{
	float fVar1;
	SurfaceMap *pSVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	int *piVar6;
	int *piVar7;
	Point2F local_18;
	float local_10;
	float local_c;
	int local_8;
	int local_4;
	
	LiveObject_GetPosition(liveObj,&local_18.x,&local_18.y);
	local_10 = (liveObj->vector_3b4).x * elapsed;
	piVar7 = &local_4;
	piVar6 = &local_8;
	local_c = (liveObj->vector_3b4).y * elapsed;
	fVar4 = local_10 + local_18.x;
	fVar5 = local_c + local_18.y;
	local_18.x = fVar4;
	local_18.y = fVar5;
	pSVar2 = lrr::Lego_GetMap();
	Map3D_WorldToBlockPos_NoZ(pSVar2,fVar4,fVar5,piVar6,piVar7);
	iVar3 = LiveObject_Routing_GetCrossTerrainType(liveObj,local_8,local_4,local_8,local_4,1);
	if (iVar3 == 0) {
LAB_0044c517:
		fVar5 = (liveObj->vector_3b4).x;
		fVar1 = (liveObj->vector_3b4).y;
		fVar4 = (liveObj->vector_3b4).y;
		fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar4 * fVar4);
		fVar5 = SQRT(fVar5 * fVar5 + fVar1 * fVar1);
		(liveObj->vector_3b4).x = (liveObj->vector_3b4).x * fVar4;
		(liveObj->vector_3b4).y = fVar4 * (liveObj->vector_3b4).y;
		fVar4 = (liveObj->vector_3b4).x;
		if ((ushort)((ushort)(fVar4 < 0.5) << 8 | (ushort)(fVar4 == 0.5) << 0xe) == 0) {
			(liveObj->vector_3b4).x = 1.0;
			(liveObj->vector_3b4).y = 0.0;
		}
		else {
			if (-0.5 <= (liveObj->vector_3b4).x) {
				fVar4 = (liveObj->vector_3b4).y;
				if ((ushort)((ushort)(fVar4 < 0.5) << 8 | (ushort)(fVar4 == 0.5) << 0xe) == 0) {
					(liveObj->vector_3b4).x = 0.0;
					(liveObj->vector_3b4).y = 1.0;
				}
				else {
					if ((liveObj->vector_3b4).y < -0.5) {
						(liveObj->vector_3b4).x = 0.0;
						(liveObj->vector_3b4).y = -1.0;
					}
				}
			}
			else {
				(liveObj->vector_3b4).x = -1.0;
				(liveObj->vector_3b4).y = 0.0;
			}
		}
		(liveObj->vector_3b4).x = (liveObj->vector_3b4).x * fVar5;
		(liveObj->vector_3b4).y = (liveObj->vector_3b4).y * fVar5;
		LiveObject_GetPosition(liveObj,&local_18.x,&local_18.y);
		local_10 = (liveObj->vector_3b4).x * elapsed;
		piVar7 = &local_4;
		piVar6 = &local_8;
		local_c = (liveObj->vector_3b4).y * elapsed;
		fVar4 = local_10 + local_18.x;
		fVar5 = local_c + local_18.y;
		local_18.x = fVar4;
		local_18.y = fVar5;
		pSVar2 = lrr::Lego_GetMap();
		Map3D_WorldToBlockPos_NoZ(pSVar2,fVar4,fVar5,piVar6,piVar7);
		iVar3 = LiveObject_Routing_GetCrossTerrainType(liveObj,local_8,local_4,local_8,local_4,1);
		if (iVar3 != 0) {
			iVar3 = LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_18,0.0,0);
			if (iVar3 == 0) goto LAB_0044c6eb;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000;
	}
	else {
		iVar3 = LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_18,0.0,0);
		if (iVar3 != 0) goto LAB_0044c517;
LAB_0044c6eb:
		LiveObject_SetPositionAndHeading(liveObj,local_18.x,local_18.y,0.0,0);
	}
	fVar4 = (liveObj->vector_3b4).z;
	if ((ushort)((ushort)(fVar4 < 0.0) << 8 | (ushort)(fVar4 == 0.0) << 0xe) != 0) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000;
	}
	(liveObj->vector_3b4).z = (liveObj->vector_3b4).z - SQRT(local_c * local_c + local_10 * local_10);
	return;
}



void __cdecl lego::game::LiveObject_FUN_0044c760(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	ObjectStatsFlags1 OVar2;
	
	if ((*(byte *)&liveObj->flags4 & 2) != 0) {
		OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar1 & STATS2_CANDOUBLESELECT) != STATS2_NONE) {
			OVar2 = stats::StatsObject_GetStatsFlags1(liveObj);
			if (((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) {
				globs::legoGlobs.flags1 |= GAME1_LASERTRACKER;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_1;
			}
		}
	}
	front::Interface_BackToMain();
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_UnkLaserTrackerToggleUnset_FUN_0044c7c0
					(LiveObject *liveObj,void *unused)
{
	if ((*(byte *)&liveObj->flags4 & 1) != 0) {
		globs::legoGlobs.flags1 &= ~GAME1_LASERTRACKER;
	}
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_1;
	return 0;
}



// Seems to be completely identical to LiveObject_MiniFigureHasBeamEquipped @ 004496a0

BOOL __cdecl lego::game::LiveObject_MiniFigureHasBeamEquipped2(LiveObject *liveObj)
{
	uint uVar1;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		uVar1 = LiveObject_GetEquippedBeam(liveObj);
		if (uVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveManager_CheckMouseIntersections_FUN_0044c810(void)
{
	BOOL BVar1;
	undefined4 local_4;
	
	globs::liveGlobs.flags |= 0x40;
	BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,NULL)
	;
	if (BVar1 == 0) {
		if (globs::liveGlobs.countBuildingsOnly_c438 == 0) {
			local_4 = 1;
			BVar1 = Search_LiveObjects_SkipIgnoreMes
												(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,&local_4);
			if ((BVar1 == 0) && (globs::liveGlobs.count_c434 != 0)) {
				globs::liveGlobs.count_c434 = 0;
				globs::liveGlobs.countBuildingsOnly_c438 = 0;
				Search_LiveObjects_SkipIgnoreMes
									(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,&local_4);
				return;
			}
		}
		else {
			globs::liveGlobs.count_c434 = 0;
			globs::liveGlobs.countBuildingsOnly_c438 = 0;
			Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,NULL);
		}
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_CheckIntersections_FUN_0044c8b0
					(LiveObject *liveObj,BOOL *pFalseForBuildings)
{
	int iVar1;
	uint uVar2;
	BOOL BVar3;
	LiveObject **ppLVar4;
	Vector3F worldMousePos;
	
	iVar1 = 0;
	if (pFalseForBuildings != NULL) {
		iVar1 = *pFalseForBuildings;
	}
	if (iVar1 == 0) {
		if (liveObj->objType != OBJECT_BUILDING) {
			return 0;
		}
	}
	else {
		if (liveObj->objType != OBJECT_MINIFIGURE) {
			return 0;
		}
	}
	uVar2 = 0;
	if (globs::liveGlobs.count_c434 != 0) {
		ppLVar4 = globs::liveGlobs.liveObjArray256_c034;
		do {
			if (*ppLVar4 == liveObj) {
				return 0;
			}
			uVar2 += 1;
			ppLVar4 = ppLVar4 + 1;
		} while (uVar2 < globs::liveGlobs.count_c434);
	}
	if (globs::liveGlobs.count_c434 < 0x100) {
		globs::liveGlobs.liveObjArray256_c034[globs::liveGlobs.count_c434] = liveObj;
		globs::liveGlobs.count_c434 += 1;
		if (liveObj->objType == OBJECT_BUILDING) {
			globs::liveGlobs.countBuildingsOnly_c438 += 1;
		}
		lrr::Lego_GotoInfo(liveObj,NULL,FALSE);
		BVar3 = Map3D_GetIntersections
											((globs::legoGlobs.level)->surfaceMap,globs::legoGlobs.viewMain,
											 globs::INPUT.msx,globs::INPUT.msy,(uint *)&pFalseForBuildings,
											 (uint *)&liveObj,&worldMousePos);
		if (BVar3 != 0) {
			res::Container_SetPosition
								(globs::legoGlobs.contRootLight,NULL,worldMousePos.x,worldMousePos.y,
								 worldMousePos.z - 250.0);
			return TRUE;
		}
	}
	else {
		globs::liveGlobs.count_c434 = 0;
		globs::liveGlobs.countBuildingsOnly_c438 = 0;
	}
	return TRUE;
}



void __cdecl
lego::light::LightEffects_Initialise
					(Container *resRootSpotlight,Container *resRootLight,float initialRed,float initialGreen,
					float initialBlue)
{
	globs::lightGlobs.initialRGB.red = initialRed;
	globs::lightGlobs.initialRGB.green = initialGreen;
	globs::lightGlobs.currentRGB.red = initialRed;
	globs::lightGlobs.currentRGB.green = initialGreen;
	globs::lightGlobs.initialRGB.blue = initialBlue;
	globs::lightGlobs.currentRGB.blue = initialBlue;
	globs::lightGlobs.resSpotlight = resRootSpotlight;
	globs::lightGlobs.resRootLight = resRootLight;
	LightEffects_ResetColor();
	return;
}



// Resets LightEffects to its initialRGB colour value (hardcoded as 0.8:0.8:0.8)

void __cdecl lego::light::LightEffects_ResetColor(void)
{
	res::Container_SetColourAlpha
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.initialRGB.red,
						 globs::lightGlobs.initialRGB.green,globs::lightGlobs.initialRGB.blue,1.0);
	return;
}



void __cdecl lego::light::LightEffects_SetDisabled(BOOL isDisabled)
{
	if (isDisabled != 0) {
		globs::lightGlobs.flags |= LIGHTEFFECTS_DISABLED;
		LightEffects_ResetColor();
		return;
	}
	globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_DISABLED;
	return;
}



BOOL __cdecl lego::light::LightEffects_Load(CFGProperty *root,char *rootPath)
{
	BOOL BVar1;
	
	LightEffects_LoadBlink(root,rootPath);
	LightEffects_LoadFade(root,rootPath);
	BVar1 = LightEffects_LoadMove(root,rootPath);
	return BVar1;
}



BOOL __cdecl lego::light::LightEffects_LoadBlink(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	BOOL BVar2;
	char *pcVar3;
	int iVar4;
	float10 fVar5;
	float10 fVar6;
	float *out_r;
	float *out_g;
	float *out_b;
	float blink_blue;
	float blink_green;
	float blink_red;
	char *stringParts [10];
	
	pcVar3 = rootPath;
	out_b = &blink_blue;
	out_g = &blink_green;
	out_r = &blink_red;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","BlinkRGBMax",0);
	BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,out_r,out_g,out_b);
	if (BVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MaxChangeAllowed",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == NULL) {
			pcVar1 = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MaxChangeAllowed",0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		}
		fVar5 = std::atof(pcVar1);
		rootPath = (char *)(float)fVar5;
		if ((float10)0.0 != fVar5) {
			rootPath = (char *)((float)rootPath * 0.003921569);
		}
		pcVar3 = cfg::CFG_JoinPath(pcVar3,"LightEffects","RandomRangeForTimeBetweenBlinks",0);
		pcVar3 = cfg::CFG_CopyString(root,pcVar3);
		if (pcVar3 != NULL) {
			iVar4 = util::Util_Tokenise(pcVar3,stringParts,":");
			if (iVar4 == 2) {
				fVar5 = std::atof(stringParts[0]);
				fVar6 = std::atof(stringParts[1]);
				std::free(pcVar3);
				LightEffects_SetBlink
									(blink_red,blink_green,blink_blue,(float)rootPath,(float)(fVar5 * (float10)25.0),
									 (float)(fVar6 * (float10)25.0));
				return 1;
			}
			std::free(pcVar3);
		}
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetBlink
					(float red,float green,float blue,float maxChange,float minRange,float maxRange)
{
	globs::lightGlobs.BlinkRGBMax.red = red;
	globs::lightGlobs.BlinkRGBMax.green = green;
	globs::lightGlobs.BlinkRGBMax.blue = blue;
	globs::lightGlobs.RandomRangeForTimeBetweenBlinks.min = minRange;
	globs::lightGlobs.RandomRangeForTimeBetweenBlinks.max = maxRange;
	globs::lightGlobs.MaxChangeAllowed = maxChange;
	globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_HASBLINK;
	return;
}



BOOL __cdecl lego::light::LightEffects_LoadFade(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	BOOL BVar2;
	int iVar3;
	float10 fVar4;
	float10 fVar5;
	float10 fVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float *pfVar10;
	float *pfVar11;
	float *pfVar12;
	float maxFade;
	float minFade;
	float maxTime;
	float minTime;
	float fadeMax_b;
	float fadeMax_g;
	float fadeMax_r;
	float fadeMin_b;
	float fadeMin_g;
	float fadeMin_r;
	char *stringParts [10];
	
	pfVar12 = &fadeMin_b;
	pfVar11 = &fadeMin_g;
	pfVar10 = &fadeMin_r;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","FadeRGBMin",0);
	BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar10,pfVar11,pfVar12);
	if (BVar2 != 0) {
		pfVar12 = &fadeMax_b;
		pfVar11 = &fadeMax_g;
		pfVar10 = &fadeMax_r;
		pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","FadeRGBMax",0);
		BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar10,pfVar11,pfVar12);
		if (BVar2 != 0) {
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForTimeBetweenFades",0);
			pcVar1 = cfg::CFG_CopyString(root,pcVar1);
			if (pcVar1 != NULL) {
				iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
				if (iVar3 == 2) {
					fVar4 = std::atof(stringParts[0]);
					fVar5 = std::atof(stringParts[1]);
					std::free(pcVar1);
					pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForFadeTimeFade",0);
					pcVar1 = cfg::CFG_CopyString(root,pcVar1);
					if (pcVar1 == NULL) {
						return 0;
					}
					iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
					if (iVar3 == 2) {
						fVar6 = std::atof(stringParts[0]);
						fVar7 = std::atof(stringParts[1]);
						std::free(pcVar1);
						pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForHoldTimeOfFade",0);
						pcVar1 = cfg::CFG_CopyString(root,pcVar1);
						if (pcVar1 == NULL) {
							return 0;
						}
						iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
						if (iVar3 == 2) {
							fVar8 = std::atof(stringParts[0]);
							fVar9 = std::atof(stringParts[1]);
							std::free(pcVar1);
							LightEffects_SetFade
												(fadeMin_r,fadeMin_g,fadeMin_b,fadeMax_r,fadeMax_g,fadeMax_b,
												 (float)(fVar4 * (float10)25.0),(float)(fVar5 * (float10)25.0),
												 (float)(fVar6 * (float10)25.0),(float)(fVar7 * (float10)25.0),
												 (float)(fVar8 * (float10)25.0),(float)(fVar9 * (float10)25.0));
							return 1;
						}
					}
				}
						// this will free any of the 3 str mallocs above, if any numParts != 2
				std::free(pcVar1);
			}
		}
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetFade
					(float minRed,float minGreen,float minBlue,float maxRed,float maxGreen,float maxBlue,
					float minTime,float maxTime,float minFade,float maxFade,float minHold,float maxHold)
{
	globs::lightGlobs.FadeRGBMin.red = minRed;
	globs::lightGlobs.FadeRGBMin.green = minGreen;
	globs::lightGlobs.FadeRGBMin.blue = minBlue;
	globs::lightGlobs.FadeRGBMax.red = maxRed;
	globs::lightGlobs.FadeRGBMax.green = maxGreen;
	globs::lightGlobs.FadeRGBMax.blue = maxBlue;
	globs::lightGlobs.RandomRangeForTimeBetweenFades.min = minTime;
	globs::lightGlobs.RandomRangeForTimeBetweenFades.max = maxTime;
	globs::lightGlobs.RandomRangeForFadeTimeFade.min = minFade;
	globs::lightGlobs.RandomRangeForFadeTimeFade.max = maxFade;
	globs::lightGlobs.RandomRangeForHoldTimeOfFade.min = minHold;
	globs::lightGlobs.RandomRangeForHoldTimeOfFade.max = maxHold;
	globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_HASFADE;
	return;
}



BOOL __cdecl lego::light::LightEffects_LoadMove(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	float10 fVar3;
	float10 fVar4;
	float10 fVar5;
	float10 fVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	float10 fVar11;
	float limitX;
	float maxDist;
	float minDist;
	float maxSpeed;
	float minSpeed;
	float maxTime;
	float minTime;
	char *stringParts [10];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForTimeBetweenMoves",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
		if (iVar2 == 2) {
			fVar3 = std::atof(stringParts[0]);
			fVar4 = std::atof(stringParts[1]);
			std::free(pcVar1);
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForSpeedOfMove",0);
			pcVar1 = cfg::CFG_CopyString(root,pcVar1);
			if (pcVar1 == NULL) {
				return 0;
			}
			iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
			if (iVar2 == 2) {
				fVar5 = std::atof(stringParts[0]);
				fVar6 = std::atof(stringParts[1]);
				std::free(pcVar1);
				pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForDistOfMove",0);
				pcVar1 = cfg::CFG_CopyString(root,pcVar1);
				if (pcVar1 == NULL) {
					return 0;
				}
				iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
				if (iVar2 == 2) {
					fVar7 = std::atof(stringParts[0]);
					fVar8 = std::atof(stringParts[1]);
					std::free(pcVar1);
					pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MoveLimit",0);
					pcVar1 = cfg::CFG_CopyString(root,pcVar1);
					if (pcVar1 == NULL) {
						return 0;
					}
					iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
					if (iVar2 == 3) {
						fVar9 = std::atof(stringParts[0]);
						fVar10 = std::atof(stringParts[1]);
						fVar11 = std::atof(stringParts[2]);
						std::free(pcVar1);
						LightEffects_SetMove
											((float)(fVar3 * (float10)25.0),(float)(fVar4 * (float10)25.0),
											 (float)(fVar5 * (float10)25.0),(float)(fVar6 * (float10)25.0),(float)fVar7,
											 (float)fVar8,(float)fVar9,(float)fVar10,(float)fVar11);
						return 1;
					}
				}
			}
		}
						// this will free any of the 4 str mallocs above, if any numParts != 2 (or numParts != 3
						// for limit)
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetMove
					(float minTime,float maxTime,float minSpeed,float maxSpeed,float minDist,float maxDist,
					float limitX,float limitY,float limitZ)
{
	globs::lightGlobs.RandomRangeForTimeBetweenMoves.min = minTime;
	globs::lightGlobs.RandomRangeForTimeBetweenMoves.max = maxTime;
	globs::lightGlobs.RandomRangeForSpeedOfMove.max = maxSpeed;
	globs::lightGlobs.RandomRangeForDistOfMove.min = minDist;
	globs::lightGlobs.RandomRangeForSpeedOfMove.min = minSpeed;
	globs::lightGlobs.RandomRangeForDistOfMove.max = maxDist;
						// Writes position to Vector3F globals::g_Light.resMoveLimit
	res::Container_GetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,
						 &globs::lightGlobs.resPosition);
	globs::lightGlobs.MoveLimit.x = limitX;
	globs::lightGlobs.MoveLimit.y = limitY;
	globs::lightGlobs.MoveLimit.z = limitZ;
	globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_HASMOVE;
	return;
}



// Forces the LightEffect to re-obtain the resRootSpotlight position, and also restarts movement
// effects.

void __cdecl lego::light::LightEffects_InvalidatePosition(void)
{
						// Writes position to Vector3F globals::g_Light.resMoveLimit
	res::Container_GetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,
						 &globs::lightGlobs.resPosition);
	globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_MOVING;
	return;
}



void __cdecl lego::light::LightEffects_Update(float elapsed)
{
	if (((globs::lightGlobs.flags & LIGHTEFFECTS_DISABLED) == LIGHTEFFECTS_NONE) &&
		 (globs::lightGlobs.resSpotlight != NULL)) {
		LightEffects_UpdateBlink(elapsed);
		LightEffects_UpdateFade(elapsed);
		LightEffects_UpdateMove(elapsed);
		LightEffects_UpdateDimmer(elapsed);
		LightEffects_UpdateResource();
	}
	return;
}



void __cdecl lego::light::LightEffects_UpdateResource(void)
{
	float b;
	float g;
	float r;
	
	r = globs::lightGlobs.currentRGB.red;
	g = globs::lightGlobs.currentRGB.green;
	b = globs::lightGlobs.currentRGB.blue;
	if (globs::lightGlobs.currentRGB.red < 0.0) {
		r = 0.0;
	}
	if ((ushort)((ushort)(r < 1.0) << 8 | (ushort)(r == 1.0) << 0xe) == 0) {
		r = 1.0;
	}
	if (globs::lightGlobs.currentRGB.green < 0.0) {
		g = 0.0;
	}
	if ((ushort)((ushort)(g < 1.0) << 8 | (ushort)(g == 1.0) << 0xe) == 0) {
		g = 1.0;
	}
	if (globs::lightGlobs.currentRGB.blue < 0.0) {
		b = 0.0;
	}
	if ((ushort)((ushort)(b < 1.0) << 8 | (ushort)(b == 1.0) << 0xe) == 0) {
		b = 1.0;
	}
	res::Container_SetColourAlpha(globs::lightGlobs.resSpotlight,r,g,b,1.0);
	return;
}



void __cdecl lego::light::LightEffects_UpdateBlink(float elapsed)
{
	float fVar1;
	float fVar2;
	bool bVar3;
	short sVar4;
	float10 fVar5;
	float local_8;
	float local_4;
	
	bVar3 = false;
	if (((byte)globs::lightGlobs.flags & LIGHTEFFECTS_HASBLINK) == 0) {
		return;
	}
	globs::lightGlobs.blinkTime = globs::lightGlobs.blinkTime - elapsed;
	if ((ushort)((ushort)(globs::lightGlobs.blinkTime < 0.0) << 8 |
							(ushort)(globs::lightGlobs.blinkTime == 0.0) << 0xe) == 0) {
		return;
	}
	fVar5 = math::Maths_RandRange
										(globs::lightGlobs.RandomRangeForTimeBetweenBlinks.min,
										 globs::lightGlobs.RandomRangeForTimeBetweenBlinks.max);
	globs::lightGlobs.blinkTime = (float)fVar5;
	sVar4 = math::Maths_Rand();
	fVar2 = (float)((int)sVar4 % 1000) * 0.001;
	elapsed = (globs::lightGlobs.BlinkRGBMax.red + globs::lightGlobs.BlinkRGBMax.red) * fVar2 -
						globs::lightGlobs.BlinkRGBMax.red;
	local_8 = (globs::lightGlobs.BlinkRGBMax.green + globs::lightGlobs.BlinkRGBMax.green) * fVar2 -
						globs::lightGlobs.BlinkRGBMax.green;
	fVar1 = elapsed + globs::lightGlobs.blinkChange;
	local_4 = (globs::lightGlobs.BlinkRGBMax.blue + globs::lightGlobs.BlinkRGBMax.blue) * fVar2 -
						globs::lightGlobs.BlinkRGBMax.blue;
	if (globs::lightGlobs.MaxChangeAllowed <= ABS(fVar1)) {
		LightEffects_UpdateBlink_FlipSign(&elapsed);
		LightEffects_UpdateBlink_FlipSign(&local_8);
		LightEffects_UpdateBlink_FlipSign(&local_4);
		fVar1 = elapsed + globs::lightGlobs.blinkChange;
		if (globs::lightGlobs.MaxChangeAllowed <= ABS(fVar1)) goto LAB_0044d4b5;
	}
	bVar3 = true;
LAB_0044d4b5:
	if (!bVar3) {
		return;
	}
	globs::lightGlobs.currentRGB.red = elapsed + globs::lightGlobs.currentRGB.red;
	globs::lightGlobs.currentRGB.green = local_8 + globs::lightGlobs.currentRGB.green;
	globs::lightGlobs.currentRGB.blue = local_4 + globs::lightGlobs.currentRGB.blue;
	globs::lightGlobs.blinkChange = fVar1;
	return;
}



// ref_value = -ref_value
// NOTES: This function is kind of dumb, the way it negates the value is different depending on the
// sign, but the end result will always be the same.

void __cdecl lego::light::LightEffects_UpdateBlink_FlipSign(float *ref_value)
{
	if (*ref_value < 0.0) {
		*ref_value = *ref_value * -1.0;
		return;
	}
	*ref_value = -*ref_value;
	return;
}



void __cdecl lego::light::LightEffects_UpdateFade(float elapsed)
{
	float fVar1;
	short sVar2;
	float10 fVar3;
	
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_HASFADE) != LIGHTEFFECTS_NONE) {
		if ((globs::lightGlobs.flags & LIGHTEFFECTS_FADING) == LIGHTEFFECTS_NONE) {
			globs::lightGlobs.fadeTime = globs::lightGlobs.fadeTime - elapsed;
			if ((ushort)((ushort)(globs::lightGlobs.fadeTime < 0.0) << 8 |
									(ushort)(globs::lightGlobs.fadeTime == 0.0) << 0xe) != 0) {
				fVar3 = math::Maths_RandRange
													(globs::lightGlobs.RandomRangeForTimeBetweenFades.min,
													 globs::lightGlobs.RandomRangeForTimeBetweenFades.max);
				globs::lightGlobs.fadeTime = (float)fVar3;
				fVar3 = math::Maths_RandRange
													(globs::lightGlobs.RandomRangeForHoldTimeOfFade.min,
													 globs::lightGlobs.RandomRangeForHoldTimeOfFade.max);
				globs::lightGlobs.fadeHoldTime = (float)fVar3;
				sVar2 = math::Maths_Rand();
				globs::lightGlobs.fadePosRGB.red = 0.0;
				globs::lightGlobs.fadePosRGB.green = 0.0;
				globs::lightGlobs.fadePosRGB.blue = 0.0;
				fVar1 = (float)((int)sVar2 % 1000) * 0.001;
				globs::lightGlobs.fadeDestRGB.red =
						 ABS(globs::lightGlobs.FadeRGBMax.red - globs::lightGlobs.FadeRGBMin.red) * fVar1 +
						 globs::lightGlobs.FadeRGBMin.red;
				globs::lightGlobs.fadeDestRGB.green =
						 ABS(globs::lightGlobs.FadeRGBMax.green - globs::lightGlobs.FadeRGBMin.green) * fVar1 +
						 globs::lightGlobs.FadeRGBMin.green;
				globs::lightGlobs.fadeDestRGB.blue =
						 ABS(globs::lightGlobs.FadeRGBMax.blue - globs::lightGlobs.FadeRGBMin.blue) * fVar1 +
						 globs::lightGlobs.FadeRGBMin.blue;
				LightEffects_RandomizeFadeSpeedRGB();
				globs::lightGlobs.flags |= LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_FORWARD;
			}
		}
		else {
			if ((globs::lightGlobs.flags & LIGHTEFFECTS_FADE_FORWARD) == LIGHTEFFECTS_NONE) {
				if ((globs::lightGlobs.flags & LIGHTEFFECTS_FADE_REVERSE) == LIGHTEFFECTS_NONE) {
					globs::lightGlobs.fadeHoldTime = globs::lightGlobs.fadeHoldTime - elapsed;
					if ((ushort)((ushort)(globs::lightGlobs.fadeHoldTime < 0.0) << 8 |
											(ushort)(globs::lightGlobs.fadeHoldTime == 0.0) << 0xe) != 0) {
						LightEffects_RandomizeFadeSpeedRGB();
						globs::lightGlobs.fadePosRGB.red = globs::lightGlobs.fadeDestRGB.red;
						globs::lightGlobs.fadePosRGB.green = globs::lightGlobs.fadeDestRGB.green;
						globs::lightGlobs.fadePosRGB.blue = globs::lightGlobs.fadeDestRGB.blue;
						globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_FADE_REVERSE;
						return;
					}
				}
				else {
					fVar1 = elapsed * globs::lightGlobs.fadeSpeedRGB.red;
					globs::lightGlobs.currentRGB.red = globs::lightGlobs.currentRGB.red - fVar1;
					globs::lightGlobs.fadePosRGB.red = globs::lightGlobs.fadePosRGB.red - fVar1;
					globs::lightGlobs.currentRGB.green =
							 globs::lightGlobs.currentRGB.green - elapsed * globs::lightGlobs.fadeSpeedRGB.green;
					globs::lightGlobs.fadePosRGB.green =
							 globs::lightGlobs.fadePosRGB.green - elapsed * globs::lightGlobs.fadeSpeedRGB.green;
					globs::lightGlobs.currentRGB.blue =
							 globs::lightGlobs.currentRGB.blue - elapsed * globs::lightGlobs.fadeSpeedRGB.blue;
					globs::lightGlobs.fadePosRGB.blue =
							 globs::lightGlobs.fadePosRGB.blue - elapsed * globs::lightGlobs.fadeSpeedRGB.blue;
					if (fVar1 < 0.0) {
						if (globs::lightGlobs.fadePosRGB.red >= 0.0) {
							globs::lightGlobs.currentRGB.red =
									 globs::lightGlobs.currentRGB.red - globs::lightGlobs.fadePosRGB.red;
							globs::lightGlobs.currentRGB.green =
									 globs::lightGlobs.currentRGB.green - globs::lightGlobs.fadePosRGB.green;
							globs::lightGlobs.currentRGB.blue =
									 globs::lightGlobs.currentRGB.blue - globs::lightGlobs.fadePosRGB.blue;
							globs::lightGlobs.flags =
									 globs::lightGlobs.flags & ~(LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_REVERSE);
							return;
						}
					}
					else {
						if ((ushort)((ushort)(globs::lightGlobs.fadePosRGB.red < 0.0) << 8 |
												(ushort)(globs::lightGlobs.fadePosRGB.red == 0.0) << 0xe) != 0) {
							globs::lightGlobs.currentRGB.red =
									 globs::lightGlobs.currentRGB.red - globs::lightGlobs.fadePosRGB.red;
							globs::lightGlobs.currentRGB.green =
									 globs::lightGlobs.currentRGB.green - globs::lightGlobs.fadePosRGB.green;
							globs::lightGlobs.currentRGB.blue =
									 globs::lightGlobs.currentRGB.blue - globs::lightGlobs.fadePosRGB.blue;
							globs::lightGlobs.flags =
									 globs::lightGlobs.flags & ~(LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_REVERSE);
							return;
						}
					}
				}
			}
			else {
				fVar1 = elapsed * globs::lightGlobs.fadeSpeedRGB.red;
				globs::lightGlobs.currentRGB.red = fVar1 + globs::lightGlobs.currentRGB.red;
				globs::lightGlobs.currentRGB.green =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.green + globs::lightGlobs.currentRGB.green;
				globs::lightGlobs.currentRGB.blue =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.blue + globs::lightGlobs.currentRGB.blue;
				globs::lightGlobs.fadePosRGB.red = fVar1 + globs::lightGlobs.fadePosRGB.red;
				globs::lightGlobs.fadePosRGB.green =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.green + globs::lightGlobs.fadePosRGB.green;
				globs::lightGlobs.fadePosRGB.blue =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.blue + globs::lightGlobs.fadePosRGB.blue;
				if (fVar1 < 0.0) {
					if ((ushort)((ushort)(globs::lightGlobs.fadePosRGB.red < globs::lightGlobs.fadeDestRGB.red
															 ) << 8 |
											(ushort)(globs::lightGlobs.fadePosRGB.red == globs::lightGlobs.fadeDestRGB.red
															) << 0xe) != 0) {
						globs::lightGlobs.currentRGB.red =
								 (globs::lightGlobs.fadeDestRGB.red - globs::lightGlobs.fadePosRGB.red) +
								 globs::lightGlobs.currentRGB.red;
						globs::lightGlobs.currentRGB.green =
								 (globs::lightGlobs.fadeDestRGB.green - globs::lightGlobs.fadePosRGB.green) +
								 globs::lightGlobs.currentRGB.green;
						globs::lightGlobs.currentRGB.blue =
								 (globs::lightGlobs.fadeDestRGB.blue - globs::lightGlobs.fadePosRGB.blue) +
								 globs::lightGlobs.currentRGB.blue;
						globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_FADE_FORWARD;
						return;
					}
				}
				else {
					if (globs::lightGlobs.fadePosRGB.red >= globs::lightGlobs.fadeDestRGB.red) {
						globs::lightGlobs.currentRGB.red =
								 globs::lightGlobs.currentRGB.red -
								 (globs::lightGlobs.fadePosRGB.red - globs::lightGlobs.fadeDestRGB.red);
						globs::lightGlobs.currentRGB.green =
								 globs::lightGlobs.currentRGB.green -
								 (globs::lightGlobs.fadePosRGB.green - globs::lightGlobs.fadeDestRGB.green);
						globs::lightGlobs.currentRGB.blue =
								 globs::lightGlobs.currentRGB.blue -
								 (globs::lightGlobs.fadePosRGB.blue - globs::lightGlobs.fadeDestRGB.blue);
						globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_FADE_FORWARD;
						return;
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::light::LightEffects_RandomizeFadeSpeedRGB(void)
{
	float10 fVar1;
	
	fVar1 = math::Maths_RandRange
										(globs::lightGlobs.RandomRangeForFadeTimeFade.min,
										 globs::lightGlobs.RandomRangeForFadeTimeFade.max);
	globs::lightGlobs.fadeSpeedRGB.red = (float)((float10)globs::lightGlobs.fadeDestRGB.red / fVar1);
	globs::lightGlobs.fadeSpeedRGB.green =
			 (float)((float10)globs::lightGlobs.fadeDestRGB.green / fVar1);
	globs::lightGlobs.fadeSpeedRGB.blue = (float)((float10)globs::lightGlobs.fadeDestRGB.blue / fVar1)
	;
	return;
}



void __cdecl lego::light::LightEffects_UpdateMove(float elapsed)
{
	bool bVar1;
	float fVar2;
	BOOL BVar3;
	float10 fVar4;
	Vector3F newPosition;
	Vector3F lastPosition;
	
	bVar1 = false;
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_HASMOVE) == LIGHTEFFECTS_NONE) {
		return;
	}
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_MOVING) == LIGHTEFFECTS_NONE) {
		globs::lightGlobs.moveTime = globs::lightGlobs.moveTime - elapsed;
		if ((ushort)((ushort)(globs::lightGlobs.moveTime < 0.0) << 8 |
								(ushort)(globs::lightGlobs.moveTime == 0.0) << 0xe) == 0) {
			return;
		}
		fVar4 = math::Maths_RandRange
											(globs::lightGlobs.RandomRangeForTimeBetweenMoves.min,
											 globs::lightGlobs.RandomRangeForTimeBetweenMoves.max);
		globs::lightGlobs.moveTime = (float)fVar4;
		fVar4 = math::Maths_RandRange
											(globs::lightGlobs.RandomRangeForSpeedOfMove.min,
											 globs::lightGlobs.RandomRangeForSpeedOfMove.max);
		globs::lightGlobs.moveSpeed = (float)fVar4;
		fVar4 = math::Maths_RandRange
											(globs::lightGlobs.RandomRangeForDistOfMove.min,
											 globs::lightGlobs.RandomRangeForDistOfMove.max);
		globs::lightGlobs.moveDist = (float)fVar4;
						// Randomize + Normalize vector, multiplied by speed.
						// AKA: speed in a random 3D direction.
		math::Maths_Vector3DRandom(&globs::lightGlobs.vectorMove);
		fVar2 = 1.0 / SQRT(globs::lightGlobs.vectorMove.z * globs::lightGlobs.vectorMove.z +
											 globs::lightGlobs.vectorMove.y * globs::lightGlobs.vectorMove.y +
											 globs::lightGlobs.vectorMove.x * globs::lightGlobs.vectorMove.x);
		globs::lightGlobs.vectorMove.x =
				 fVar2 * globs::lightGlobs.vectorMove.x * globs::lightGlobs.moveSpeed;
		globs::lightGlobs.vectorMove.y =
				 fVar2 * globs::lightGlobs.vectorMove.y * globs::lightGlobs.moveSpeed;
		globs::lightGlobs.vectorMove.z =
				 fVar2 * globs::lightGlobs.vectorMove.z * globs::lightGlobs.moveSpeed;
		globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_MOVING;
		return;
	}
	res::Container_GetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,&lastPosition);
	newPosition.x = lastPosition.x + globs::lightGlobs.vectorMove.x;
	newPosition.y = lastPosition.y + globs::lightGlobs.vectorMove.y;
	newPosition.z = lastPosition.z + globs::lightGlobs.vectorMove.z;
	BVar3 = LightEffects_CheckMoveLimit(&newPosition);
	if (BVar3 == 0) {
						// This is the same deal as the `LightEffects_UpdateBlink_FlipSign(float*)` tuple seen
						// in UpdateBlink
						//  it's just that blink doesn't have extra math involved.
		newPosition.x = lastPosition.x - globs::lightGlobs.vectorMove.x;
		newPosition.y = lastPosition.y - globs::lightGlobs.vectorMove.y;
		newPosition.z = lastPosition.z - globs::lightGlobs.vectorMove.z;
		BVar3 = LightEffects_CheckMoveLimit(&newPosition);
		if (BVar3 == 0) goto LAB_0044dae5;
	}
	bVar1 = true;
LAB_0044dae5:
	if (!bVar1) {
		globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_MOVING;
		return;
	}
	res::Container_SetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,newPosition.x,
						 newPosition.y,newPosition.z);
	globs::lightGlobs.moveDist = globs::lightGlobs.moveDist - globs::lightGlobs.moveSpeed;
	if ((ushort)((ushort)(globs::lightGlobs.moveDist < 0.0) << 8 |
							(ushort)(globs::lightGlobs.moveDist == 0.0) << 0xe) == 0) {
		return;
	}
	globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_MOVING;
	return;
}



BOOL __cdecl lego::light::LightEffects_CheckMoveLimit(Vector3F *vector)
{
	float fVar1;
	
	fVar1 = ABS(vector->x - globs::lightGlobs.resPosition.x);
	if ((ushort)((ushort)(fVar1 < globs::lightGlobs.MoveLimit.x) << 8 |
							(ushort)(fVar1 == globs::lightGlobs.MoveLimit.x) << 0xe) == 0) {
		return 0;
	}
	fVar1 = ABS(vector->y - globs::lightGlobs.resPosition.y);
	if ((ushort)((ushort)(fVar1 < globs::lightGlobs.MoveLimit.y) << 8 |
							(ushort)(fVar1 == globs::lightGlobs.MoveLimit.y) << 0xe) == 0) {
		return 0;
	}
	fVar1 = ABS(vector->z - globs::lightGlobs.resPosition.z);
	if ((ushort)((ushort)(fVar1 < globs::lightGlobs.MoveLimit.z) << 8 |
							(ushort)(fVar1 == globs::lightGlobs.MoveLimit.z) << 0xe) == 0) {
		return 0;
	}
	return 1;
}



void __cdecl lego::light::LightEffects_SetDimmerMode(BOOL isDimoutMode)
{
	if (isDimoutMode != 0) {
		globs::lightGlobs.flags =
				 globs::lightGlobs.flags & ~LIGHTEFFECTS_DIMIN_DONE | LIGHTEFFECTS_DIMOUT;
		return;
	}
	globs::lightGlobs.flags =
			 globs::lightGlobs.flags & ~(LIGHTEFFECTS_DIMOUT|LIGHTEFFECTS_DIMOUT_DONE);
	return;
}



void __cdecl lego::light::LightEffects_UpdateDimmer(float elapsed)
{
	float fVar1;
	
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_DIMOUT) == LIGHTEFFECTS_NONE) {
		if ((globs::lightGlobs.flags & LIGHTEFFECTS_DIMIN_DONE) == LIGHTEFFECTS_NONE) {
			fVar1 = elapsed * 0.1;
			globs::lightGlobs.currentRGB.red = fVar1 + globs::lightGlobs.currentRGB.red;
			globs::lightGlobs.currentRGB.green = fVar1 + globs::lightGlobs.currentRGB.green;
			globs::lightGlobs.currentRGB.blue = fVar1 + globs::lightGlobs.currentRGB.blue;
			if (globs::lightGlobs.initialRGB.red <= globs::lightGlobs.currentRGB.red) {
				globs::lightGlobs.flags |= LIGHTEFFECTS_DIMIN_DONE;
						// Uhhh... assigning blue to red??? (this has to be a bug)
						// Actually... why is this only assigning red and no other colors???
				globs::lightGlobs.currentRGB.red = globs::lightGlobs.initialRGB.blue;
			}
		}
	}
	else {
		if ((globs::lightGlobs.flags & LIGHTEFFECTS_DIMOUT_DONE) != LIGHTEFFECTS_NONE) {
			globs::lightGlobs.currentRGB.red = 0.0;
			globs::lightGlobs.currentRGB.green = 0.0;
			globs::lightGlobs.currentRGB.blue = 0.0;
			return;
		}
		fVar1 = elapsed * 0.1;
		globs::lightGlobs.currentRGB.red = globs::lightGlobs.currentRGB.red - fVar1;
		globs::lightGlobs.currentRGB.green = globs::lightGlobs.currentRGB.green - fVar1;
		globs::lightGlobs.currentRGB.blue = globs::lightGlobs.currentRGB.blue - fVar1;
		if ((ushort)((ushort)(globs::lightGlobs.currentRGB.red < 0.0) << 8 |
								(ushort)(globs::lightGlobs.currentRGB.red == 0.0) << 0xe) != 0) {
			globs::lightGlobs.currentRGB.red = 0.0;
			globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_DIMOUT_DONE;
			return;
		}
	}
	return;
}



void __cdecl
lego::front::Loader_Initialise
					(char *loadScreenName,char *shutdownScreenName,Font *font5HI,char *profileName,
					Direction progressDirection,char *progressBarName,Area2F *progressWindow,char *loadingText
					)
{
	char cVar1;
	char *pcVar2;
	undefined4 *puVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	File *f;
	LoaderSection *pLVar7;
	undefined4 *puVar8;
	Loader_Globs *pLVar9;
	char *pcVar10;
	char *stringParts [10];
	char buff [256];
	
	f = NULL;
	pLVar9 = &globs::loaderGlobs;
	for (iVar4 = 0xa4; iVar4 != 0; iVar4 += -1) {
		pLVar9->LoadScreen = NULL;
		pLVar9 = (Loader_Globs *)&pLVar9->font;
	}
	globs::loaderGlobs.LoadScreen = lego::image::Image_LoadBMPScaled(loadScreenName,0,0);
	globs::loaderGlobs.ShutdownScreen = lego::image::Image_LoadBMPScaled(shutdownScreenName,0,0);
	globs::loaderGlobs.font = font5HI;
	globs::loaderGlobs.current = NULL;
	globs::loaderGlobs.ProgressBar = lego::image::Image_LoadBMPScaled(progressBarName,0,0);
	globs::loaderGlobs.ProgressWindow.x = progressWindow->x;
	globs::loaderGlobs.ProgressWindow.y = progressWindow->y;
	globs::loaderGlobs.ProgressWindow.width = progressWindow->width;
	globs::loaderGlobs.ProgressWindow.height = progressWindow->height;
	globs::loaderGlobs.ProgressDirection = progressDirection;
	if (loadingText == NULL) {
		globs::loaderGlobs.LoadingText = NULL;
	}
	else {
		pcVar2 = util::_strdup(loadingText);
		cVar1 = *pcVar2;
		globs::loaderGlobs.LoadingText = pcVar2;
		while (cVar1 != '\0') {
			if (cVar1 == '_') {
				*pcVar2 = ' ';
			}
			pcVar10 = pcVar2 + 1;
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar10;
		}
		lego::image::Font_GetStringInfo(font5HI,&globs::loaderGlobs.LoadingWidth,NULL,"%s",loadingText);
	}
	if (profileName != NULL) {
		f = lego::file::File_Open(profileName,"r");
	}
	pLVar7 = globs::loaderGlobs.sectionList;
	do {
		if (((f == NULL) || (pcVar2 = lego::file::File_GetS(buff,0x100,f), pcVar2 == NULL)) ||
			 (iVar4 = util::Util_Tokenise(buff,stringParts,"="), iVar4 != 2)) {
			pLVar7->name = NULL;
		}
		else {
			uVar5 = 0xffffffff;
			pcVar2 = stringParts[0];
			do {
				if (uVar5 == 0) break;
				uVar5 -= 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar5);
			uVar5 = 0xffffffff;
			pLVar7->name = (char *)puVar3;
			pcVar2 = stringParts[0];
			do {
				pcVar10 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar10 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar10;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar8 = (undefined4 *)(pcVar10 + -uVar5);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar3 = *puVar8;
				puVar8 = puVar8 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar3 = *(undefined *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			uVar5 = std::atoi(stringParts[1]);
			pLVar7->totalSize = uVar5;
			pLVar7->currentSize = 0;
		}
		pLVar7 = pLVar7 + 1;
		if ((LoaderSection *)((int)&globs::loaderGlobs.sectionList[0x31].totalSize + 3) < pLVar7) {
			if (f != NULL) {
				lego::file::File_Close(f);
			}
			lego::file::File_SetLoadCallback(Loader_FileLoadCallback,NULL);
			return;
		}
	} while( true );
}



void __cdecl lego::front::Loader_Shutdown(char *filename)
{
	File *f;
	uint uVar1;
	LoaderSection *pLVar2;
	
	if (filename == NULL) {
		f = NULL;
	}
	else {
		f = lego::file::File_Open(filename,"w");
	}
	pLVar2 = globs::loaderGlobs.sectionList;
	do {
		if (pLVar2->name != NULL) {
			uVar1 = pLVar2->currentSize;
			if (uVar1 == 0) {
				uVar1 = pLVar2->totalSize;
			}
			if (f != NULL) {
				lego::file::File_PrintF(f,"%s%s%i\n",pLVar2->name,"=",uVar1);
			}
			std::free(pLVar2->name);
		}
		pLVar2 = pLVar2 + 1;
	} while (pLVar2 < (LoaderSection *)&globs::loaderGlobs.current);
	if (f != NULL) {
		lego::file::File_Close(f);
	}
	lego::image::Image_Remove(globs::loaderGlobs.LoadScreen);
	if (globs::loaderGlobs.ShutdownScreen != NULL) {
		lego::image::Image_Remove(globs::loaderGlobs.ShutdownScreen);
	}
	return;
}



// Pass NULL to disable progress bar
// Section is either "Game Data" or "Levels::*".
//  But this is not hardcoded by the Loader module.

void __cdecl lego::front::Loader_display_loading_bar(char *section)
{
	char cVar1;
	int iVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	LoaderSection *pLVar6;
	LoaderSection *pLVar7;
	LoaderSection *pLVar8;
	undefined4 *puVar9;
	int iVar10;
	char *pcVar11;
	
	if (section == NULL) {
						// &= ~LOADER_FLAG_ENABLED; (~0x1)
		globs::loaderGlobs.flags = globs::loaderGlobs.flags & 0xfffffffe;
		return;
	}
	iVar10 = 0;
	pLVar8 = globs::loaderGlobs.sectionList;
	pLVar6 = NULL;
	do {
		pLVar7 = pLVar8;
		if ((pLVar8->name != NULL) &&
			 (iVar2 = std::_stricmp(pLVar8->name,section), pLVar7 = pLVar6, iVar2 == 0)) {
			globs::loaderGlobs.current = globs::loaderGlobs.sectionList + iVar10;
			globs::loaderGlobs.sectionList[iVar10].currentSize = 0;
			break;
		}
		pLVar8 = pLVar8 + 1;
		iVar10 += 1;
		pLVar6 = pLVar7;
	} while (pLVar8 < (LoaderSection *)&globs::loaderGlobs.current);
	if ((iVar10 == 50) && (pLVar7 != NULL)) {
		uVar4 = 0xffffffff;
		pcVar11 = section;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar1 != '\0');
		puVar3 = (undefined4 *)std::malloc(~uVar4);
		uVar4 = 0xffffffff;
		pLVar7->name = (char *)puVar3;
		do {
			pcVar11 = section;
			if (uVar4 == 0) break;
			uVar4 -= 1;
			pcVar11 = section + 1;
			cVar1 = *section;
			section = pcVar11;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar9 = (undefined4 *)(pcVar11 + -uVar4);
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
			*puVar3 = *puVar9;
			puVar9 = puVar9 + 1;
			puVar3 = puVar3 + 1;
		}
		for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
			*(undefined *)puVar3 = *(undefined *)puVar9;
			puVar9 = (undefined4 *)((int)puVar9 + 1);
			puVar3 = (undefined4 *)((int)puVar3 + 1);
		}
		pLVar7->currentSize = 0;
		pLVar7->totalSize = 0;
		globs::loaderGlobs.current = pLVar7;
	}
	globs::loaderGlobs.flags |= LOADER_FLAG_ENABLED;
	globs::loaderGlobs.progressLast = -1.0;
	Loader_FileLoadCallback(NULL,0,NULL);
	return;
}



void __cdecl lego::front::Loader_FileLoadCallback(char *filename,uint fileSize,void *data)
{
	float fVar1;
	int y;
	longlong lVar2;
	char *msg;
	char *pcVar3;
	Size2F barSize;
	Point2F barPosition;
	
	if (((byte)globs::loaderGlobs.flags & LOADER_FLAG_ENABLED) != 0) {
		if (((globs::loaderGlobs.current == NULL) ||
				((globs::loaderGlobs.current)->currentSize =
							(globs::loaderGlobs.current)->currentSize + fileSize,
				globs::loaderGlobs.current == NULL)) || ((globs::loaderGlobs.current)->totalSize == 0)) {
			fileSize = 0;
		}
		else {
			fileSize = (uint)((float)(ulonglong)(globs::loaderGlobs.current)->currentSize /
											 (float)(globs::loaderGlobs.current)->totalSize);
		}
						// // minimum increase since last update of progress bar
						// if (floatVal > (loaderGlobs.progressLast - 0.002f))
		if ((ushort)((ushort)((float)fileSize < globs::loaderGlobs.progressLast - -0.002) << 8 |
								(ushort)((float)fileSize == globs::loaderGlobs.progressLast - -0.002) << 0xe) == 0)
		{
			barPosition.y = globs::loaderGlobs.ProgressWindow.y;
			barPosition.x = globs::loaderGlobs.ProgressWindow.x;
			barSize.width = globs::loaderGlobs.ProgressWindow.width;
			barSize.height = globs::loaderGlobs.ProgressWindow.height;
			lego::image::Image_DisplayScaled(globs::loaderGlobs.LoadScreen,NULL,NULL,NULL);
						// if (floatVal > 1.0f) floatVal = 1.0f;
			if ((ushort)((ushort)((float)fileSize < 1.0) << 8 | (ushort)((float)fileSize == 1.0) << 0xe)
					== 0) {
				fileSize = 1065353216;
			}
			switch(globs::loaderGlobs.ProgressDirection) {
			case DIRECTION_UP:
				fVar1 = barSize.height + barPosition.y;
				barPosition.y = fVar1 - barSize.height * (float)fileSize;
				barSize.height = fVar1 - barPosition.y;
				break;
			case DIRECTION_RIGHT:
				barSize.width = barSize.width * (float)fileSize;
				break;
			case DIRECTION_DOWN:
				barSize.height = barSize.height * (float)fileSize;
				break;
			case DIRECTION_LEFT:
				fVar1 = barSize.width + barPosition.x;
				barPosition.x = fVar1 - barSize.width * (float)fileSize;
				barSize.width = fVar1 - barPosition.x;
			}
			if (globs::loaderGlobs.ProgressBar != NULL) {
				lego::image::Image_DisplayScaled(globs::loaderGlobs.ProgressBar,NULL,&barPosition,&barSize);
			}
			if (globs::loaderGlobs.LoadingText != NULL) {
				msg = "%s";
				pcVar3 = globs::loaderGlobs.LoadingText;
				lVar2 = __ftol((float10)globs::loaderGlobs.ProgressWindow.y);
				y = (int)lVar2 + -1;
				lVar2 = __ftol((float10)globs::loaderGlobs.ProgressWindow.width * (float10)0.5 +
											 (float10)globs::loaderGlobs.ProgressWindow.x);
				lego::image::Font_PrintF
									(globs::loaderGlobs.font,(int)lVar2 - (globs::loaderGlobs.LoadingWidth >> 1),y,msg
									 ,pcVar3);
			}
			main::Main_LoopUpdate(0);
			globs::loaderGlobs.progressLast = (float)fileSize;
		}
	}
	return;
}



void __cdecl lego::front::Loader_display_shutdown(void)
{
	if (globs::loaderGlobs.ShutdownScreen != NULL) {
		lego::image::Image_DisplayScaled(globs::loaderGlobs.ShutdownScreen,NULL,NULL,NULL);
		ddraw::DirectDraw_Flip();
		return;
	}
	return;
}



SurfaceMap * __cdecl
lego::game::Map3D_LoadSurfaceMap
					(Container *in_resData,char *filename,float blockSize,float roughLevel)
{
	uint *out_height;
	Size2I *out_width;
	SurfaceBlock *pSVar1;
	Point2F *pPVar2;
	ushort uVar3;
	MapFileInfo *mapFileInfo;
	SurfaceMap *surfMap;
	uint uVar4;
	IDirect3DRMMaterial2 *pIVar5;
	SurfaceMapStruct38 *pSVar6;
	Container *pCVar7;
	SurfaceBlock *pSVar8;
	D3DRMGroupIndex group;
	int iVar9;
	uint uVar10;
	uint uVar11;
	SurfaceMapStruct38 *pSVar12;
	undefined4 *puVar13;
	uint uVar14;
	float10 fVar15;
	float10 fVar16;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar11 = 0;
	mapFileInfo = (MapFileInfo *)lego::file::File_LoadBinary(filename,NULL);
	if (mapFileInfo != NULL) {
		surfMap = (SurfaceMap *)std::malloc(0x73d4);
		if (surfMap != NULL) {
			out_height = (uint *)&(surfMap->dimensions).height;
			out_width = &surfMap->dimensions;
			surfMap->BlockSize = blockSize;
			surfMap->RoughLevel = roughLevel;
			MapFile_GetDimensions(mapFileInfo,(uint *)out_width,out_height);
			uVar4 = out_width->width - 1;
			uVar10 = *out_height - 1;
			(surfMap->smallDimensions).width = uVar4;
			(surfMap->smallDimensions).height = uVar10;
			(surfMap->worldDimensions_fnegx).width = -((float)(ulonglong)uVar4 * blockSize * 0.5);
			surfMap->field_2c = 0;
			(surfMap->worldDimensions_fnegx).height = (float)(ulonglong)uVar10 * blockSize * 0.5;
			puVar13 = (undefined4 *)surfMap->texsNum;
			for (iVar9 = 0x20; iVar9 != 0; iVar9 += -1) {
				*puVar13 = 0;
				puVar13 = puVar13 + 1;
			}
			surfMap->flags_73d0 = SURFMAP_NONE;
			surfMap->smallCoordsNum = 0;
			surfMap->largeCoordsNum = 0;
			surfMap->float_20 = 0.0;
			pIVar5 = res::Material_Create(1.0,1.0,1.0,0.0,0.0,0.0,0.0);
			pSVar6 = surfMap->table38_719c;
			surfMap->rmMaterial2 = pIVar5;
			pSVar12 = pSVar6;
			for (iVar9 = 0x8c; iVar9 != 0; iVar9 += -1) {
				pSVar12->groupID = D3DRMGROUP_0;
				pSVar12 = (SurfaceMapStruct38 *)&pSVar12->timer;
			}
			puVar13 = surfMap->flat_40b4;
			for (iVar9 = 0x80; iVar9 != 0; iVar9 += -1) {
				*puVar13 = 0;
				puVar13 = puVar13 + 1;
			}
			iVar9 = 10;
			do {
				pSVar6->groupID = D3DRMGROUP_ALLGROUPS;
				pSVar6 = pSVar6 + 1;
				iVar9 += -1;
			} while (iVar9 != 0);
			pCVar7 = res::Container_MakeMesh2(in_resData,CONTAINER_MESHTYPE_TRANSPARENT);
			surfMap->contMesh_73cc = pCVar7;
			pCVar7 = res::Container_MakeMesh2(in_resData,CONTAINER_MESHTYPE_IMMEDIATE);
			surfMap->contMesh_24 = pCVar7;
			if (pCVar7 != NULL) {
				pSVar8 = (SurfaceBlock *)std::malloc(out_width->width * (surfMap->dimensions).height * 0x28)
				;
				surfMap->blocks3D = pSVar8;
				if (pSVar8 != NULL) {
					local_18 = 0;
					local_14 = 1;
					local_10 = 3;
					local_c = 1;
					local_8 = 2;
					local_4 = 3;
					if ((surfMap->smallDimensions).width * (surfMap->smallDimensions).height != 0) {
						do {
							group = res::Container_Mesh_AddGroup(surfMap->contMesh_24,4,2,3,&local_18);
							res::Container_Mesh_HideGroup(surfMap->contMesh_24,group,TRUE);
							res::Container_Mesh_SetQuality(surfMap->contMesh_24,group,QUALITY_GOURAUD);
							uVar11 += 1;
						} while (uVar11 < (uint)((surfMap->smallDimensions).width *
																		(surfMap->smallDimensions).height));
					}
					uVar11 = 0;
					if ((surfMap->dimensions).height != 0) {
						do {
							uVar10 = out_width->width;
							uVar4 = 0;
							if (uVar10 != 0) {
								do {
									surfMap->blocks3D[uVar11 * uVar10 + uVar4].byteflags_19 =
											 SURFMAP_STRUCT28_UNK_20|SURFMAP_STRUCT28_UNK_40;
									surfMap->blocks3D[uVar11 * out_width->width + uVar4].texture = TEXTURE_GROUND;
									iVar9 = out_width->width;
									pSVar8 = surfMap->blocks3D;
									uVar3 = MapFile_GetBlock(mapFileInfo,uVar4,uVar11,iVar9);
									pSVar8[uVar11 * iVar9 + uVar4].heightValue = (byte)uVar3;
									pPVar2 = &surfMap->blocks3D[uVar11 * out_width->width + uVar4].textuv_1c;
									fVar15 = math::Maths_RandRange(0.0,1.0);
									pPVar2->x = (float)fVar15;
									fVar15 = math::Maths_RandRange(0.0,1.0);
									fVar16 = (float10)1.0 /
													 SQRT((float10)pPVar2->x * (float10)pPVar2->x + fVar15 * fVar15);
									pPVar2->x = (float)(fVar16 * (float10)pPVar2->x);
									pPVar2->y = (float)(fVar16 * fVar15);
									iVar9 = uVar11 * out_width->width + uVar4;
									pPVar2 = &surfMap->blocks3D[iVar9].textuv_1c;
									pPVar2->x = surfMap->blocks3D[iVar9].textuv_1c.x * 0.3;
									pPVar2->y = pPVar2->y * 0.3;
									iVar9 = uVar11 * out_width->width + uVar4;
									uVar4 += 1;
									surfMap->blocks3D[iVar9].highlight = 0;
									uVar10 = out_width->width;
								} while (uVar4 < uVar10);
							}
							uVar11 += 1;
						} while (uVar11 < (uint)(surfMap->dimensions).height);
					}
					Map3D_LoadRough_FUN_0044e790(surfMap);
					filename = NULL;
					if ((surfMap->smallDimensions).height != 0) {
						do {
							blockSize = 0.0;
							if ((surfMap->smallDimensions).width != 0) {
								do {
									pSVar8 = surfMap->blocks3D + (int)filename * out_width->width + (int)blockSize;
									pSVar1 = surfMap->blocks3D +
													 (int)(filename + 1) * out_width->width + (int)blockSize;
									uVar11 = (uint)pSVar8->heightValue - (uint)pSVar1[1].heightValue;
									uVar14 = (uint)pSVar8[1].heightValue - (uint)pSVar1->heightValue;
									uVar10 = (int)uVar11 >> 0x1f;
									uVar4 = (int)uVar14 >> 0x1f;
									if ((uVar11 ^ uVar10) - uVar10 < (uVar14 ^ uVar4) - uVar4) {
										Map3D_Block_ShiftVertices_AndInitPlaneNormals
															(surfMap,(uint)blockSize,(uint)filename,TRUE);
									}
									else {
										Map3D_Block_InitPlaneNormals(surfMap,(uint)blockSize,(uint)filename);
									}
									blockSize = (float)((int)blockSize + 1);
								} while ((uint)blockSize < (uint)(surfMap->smallDimensions).width);
							}
							filename = filename + 1;
						} while (filename < (char *)(surfMap->smallDimensions).height);
					}
					std::free(mapFileInfo);
					return surfMap;
				}
				res::Container_Remove(surfMap->contMesh_24);
			}
			std::free(surfMap);
		}
		std::free(mapFileInfo);
	}
	return NULL;
}



void __cdecl lego::game::Map3D_LoadRough_FUN_0044e790(SurfaceMap *surfMap)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	int iVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	float10 extraout_ST0;
	longlong lVar10;
	longlong lVar11;
	uint local_d8;
	uint local_d4;
	int local_d0;
	float local_b0 [5];
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	local_b0[0] = 0.0;
	fVar5 = surfMap->RoughLevel;
	local_b0[1] = 0.0;
	local_b0[2] = 1.0;
	local_b0[3] = 0.0;
	local_b0[4] = 1.0;
	local_9c = 0x3f800000;
	local_98 = 0;
	local_94 = 0x3f800000;
	local_d8 = 0;
	if ((surfMap->smallDimensions).height != 0) {
		do {
			local_d4 = 0;
			if ((surfMap->smallDimensions).width != 0) {
				do {
					pfVar7 = local_b0;
					fVar9 = (float10)(ulonglong)local_d4;
					pfVar8 = &local_90[0].position.y;
					local_d0 = 4;
					do {
						fVar1 = pfVar7[1];
						fVar2 = surfMap->BlockSize;
						fVar3 = pfVar7[1];
						fVar4 = (surfMap->worldDimensions_fnegx).height;
						pfVar8[-1] = (float)((fVar9 + (float10)*pfVar7) * (float10)surfMap->BlockSize +
																(float10)(surfMap->worldDimensions_fnegx).width);
						*pfVar8 = fVar4 - (fVar1 + (float)(ulonglong)local_d8) * fVar2;
						lVar10 = __ftol((float10)fVar3);
						iVar6 = (surfMap->dimensions).width;
						lVar11 = __ftol((float10)*pfVar7);
						fVar2 = -((float)(uint)surfMap->blocks3D
																	 [(local_d8 + (int)lVar10) * iVar6 + local_d4 + (int)lVar11].
																	 heightValue * fVar5);
						fVar1 = surfMap->float_20;
						pfVar8[1] = fVar2;
						if (fVar2 < fVar1) {
							surfMap->float_20 = fVar2;
						}
						pfVar7 = pfVar7 + 2;
						pfVar8 = pfVar8 + 9;
						local_d0 += -1;
						fVar9 = extraout_ST0;
					} while (local_d0 != 0);
					res::Container_Mesh_SetVertices
										(surfMap->contMesh_24,local_d8 * (surfMap->smallDimensions).width + local_d4,0,4
										 ,local_90);
					local_d4 += 1;
				} while (local_d4 < (uint)(surfMap->smallDimensions).width);
			}
			local_d8 += 1;
		} while (local_d8 < (uint)(surfMap->smallDimensions).height);
	}
	return;
}



void __cdecl lego::game::Map3D_Free(SurfaceMap *surfMap)
{
	res::Container_Remove(surfMap->contMesh_24);
	res::Container_Remove(surfMap->contMesh_73cc);
	std::free(surfMap->blocks3D);
	std::free(surfMap);
	return;
}



void __cdecl lego::game::Map3D_SetArray40B4_IndexToTrue(SurfaceMap *surfMap,uint index)
{
	surfMap->flat_40b4[index & 0xff] = 1;
	return;
}



void __cdecl
lego::game::Map3D_FadeInBlock(SurfaceMap *surfMap,int x,int y,SurfaceTexture texture,byte field3)
{
	SurfaceTexture SVar1;
	uint uVar2;
	D3DRMGroupIndex DVar3;
	float *pfVar4;
	Container_Texture *ref_itext;
	float *pfVar5;
	int iVar6;
	SurfaceMapStruct38 *pSVar7;
	uint local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	local_a4 = 1;
	local_9c = 1;
	iVar6 = (surfMap->smallDimensions).width;
	local_a8 = 0;
	local_a0 = 3;
	local_98 = 2;
	local_94 = 3;
	SVar1 = surfMap->blocks3D[y * (surfMap->dimensions).width + x].texture;
	if ((SVar1 != texture) && (surfMap->flat_40b4[SVar1] == 0)) {
		uVar2 = 0;
		pSVar7 = surfMap->table38_719c;
		do {
			if ((*(byte *)&pSVar7->flags & 1) == 0) {
				if (pSVar7->groupID == D3DRMGROUP_ALLGROUPS) {
					DVar3 = res::Container_Mesh_AddGroup(surfMap->contMesh_73cc,4,2,3,&local_a8);
					pSVar7->groupID = DVar3;
				}
				else {
					res::Container_Mesh_HideGroup(surfMap->contMesh_73cc,pSVar7->groupID,0);
				}
				res::Container_Mesh_GetVertices(surfMap->contMesh_24,y * iVar6 + x,0,4,local_90);
				pfVar5 = &pSVar7->pointfsTable_10[0].y;
				iVar6 = 4;
				pfVar4 = &local_90[0].tv;
				do {
					pfVar5[-1] = pfVar4[-1];
					*pfVar5 = *pfVar4;
					pfVar5 = pfVar5 + 2;
					iVar6 += -1;
					pfVar4 = pfVar4 + 9;
				} while (iVar6 != 0);
				ref_itext = res::DynamicPM_SurfaceTextureGrid_GetTexture
															((SurfaceTextureGrid *)surfMap->field_2c,
															 surfMap->blocks3D[y * (surfMap->dimensions).width + x].texture);
				res::Container_Mesh_SetTexture(surfMap->contMesh_73cc,pSVar7->groupID,ref_itext);
				uVar2 = pSVar7->flags;
				(pSVar7->blockPos).x = x;
				(pSVar7->blockPos).y = y;
				pSVar7->timer = 0.05;
				pSVar7->flags = uVar2 | 1;
				break;
			}
			uVar2 += 1;
			pSVar7 = pSVar7 + 1;
		} while (uVar2 < 10);
	}
	Map3D_UpdateBlockVisual(surfMap,x,y,texture,field3);
	return;
}



BOOL __cdecl lego::game::Map3D_IsBlockMeshHidden(SurfaceMap *surfMap,int bx,int by)
{
	BOOL BVar1;
	
	BVar1 = res::Container_Mesh_IsGroupHidden
										(surfMap->contMesh_24,(surfMap->smallDimensions).width * by + bx);
	return BVar1;
}



void __cdecl lego::game::Map3D_UpdateAll_BlockTexturesAndVertices(SurfaceMap *surfMap)
{
	uint y;
	uint x;
	
	y = 0;
	if ((surfMap->dimensions).height != 0) {
		do {
			x = 0;
			if ((surfMap->dimensions).width != 0) {
				do {
					Map3D_Block_UpdateTextureAndVertices(surfMap,x,y);
					x += 1;
				} while (x < (uint)(surfMap->dimensions).width);
			}
			y += 1;
		} while (y < (uint)(surfMap->dimensions).height);
	}
	return;
}



BOOL __cdecl
lego::game::Map3D_CheckBuildingTolerance
					(SurfaceMap *surfMap,Point2I *shapePoints,uint shapeCount,float buildTolerance,
					float buildMaxVariation)
{
	bool bVar1;
	int *piVar2;
	Point2I *pPoint;
	uint j;
	float *pfVar3;
	float maxZ;
	float minZ;
	int k;
	uint i;
	int local_80 [5];
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	int local_60 [5];
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F vertPoses [4];
	
	local_4c = 3;
	local_3c = 3;
	local_34 = 3;
	local_80[0] = 0;
	local_80[1] = 0;
	local_80[2] = 1;
	local_80[3] = 0;
	local_80[4] = 1;
	local_6c = 1;
	local_68 = 0;
	local_64 = 1;
	local_60[0] = 0;
	local_60[1] = 1;
	local_60[2] = 0;
	local_60[3] = 2;
	local_60[4] = 0;
	local_48 = 1;
	local_44 = 2;
	local_40 = 1;
	local_38 = 2;
	bVar1 = false;
	minZ = 10000.0;
	maxZ = -10000.0;
	i = 0;
	if (shapeCount != 0) {
		pPoint = shapePoints + 1;
		do {
			if (((i == shapeCount - 1) || (shapePoints->x != pPoint->x)) || (shapePoints->y != pPoint->y))
			{
				Map3D_GetBlockVertexPositions2(surfMap,shapePoints->x,shapePoints->y,vertPoses);
				j = 0;
				piVar2 = local_60 + 1;
				do {
					if (buildMaxVariation < ABS(vertPoses[piVar2[-1]].z - vertPoses[*piVar2].z)) {
						return 0;
					}
					j += 1;
					piVar2 = piVar2 + 2;
				} while (j < 6);
				pfVar3 = &vertPoses[0].z;
				piVar2 = local_80;
				k = 4;
				do {
					if ((surfMap->blocks3D
							 [(piVar2[1] + shapePoints->y) * (surfMap->dimensions).width + *piVar2 +
								shapePoints->x].byteflags_19 & SURFMAP_STRUCT28_UNK_8) != SURFMAP_STRUCT28_NONE) {
						if (*pfVar3 < minZ) {
							minZ = *pfVar3;
						}
						if ((ushort)((ushort)(*pfVar3 < maxZ) << 8 | (ushort)(*pfVar3 == maxZ) << 0xe) == 0) {
							maxZ = *pfVar3;
						}
						bVar1 = true;
					}
					piVar2 = piVar2 + 2;
					pfVar3 = pfVar3 + 3;
					k += -1;
				} while (k != 0);
			}
			else {
				i += 1;
				pPoint = pPoint + 1;
				shapePoints = shapePoints + 1;
			}
			i += 1;
			pPoint = pPoint + 1;
			shapePoints = shapePoints + 1;
		} while (i < shapeCount);
	}
	if ((bVar1) &&
		 ((ushort)((ushort)(maxZ - minZ < buildTolerance) << 8 |
							(ushort)(maxZ - minZ == buildTolerance) << 0xe) == 0)) {
		return 0;
	}
	return 1;
}



void __cdecl
lego::game::Map3D_FUN_0044ed90
					(SurfaceMap *surfMap,Point2I *shapePoints,uint shapeCount,float param_4)
{
	int iVar1;
	float *pfVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	int *piVar6;
	int iVar7;
	int *piVar8;
	Point2I *pPVar9;
	uint uVar10;
	Point2I *pPVar11;
	float local_230;
	Point2I *local_22c;
	uint local_228;
	uint local_224;
	uint local_220;
	uint local_218;
	float local_214;
	Vector3F *local_210;
	int local_200 [5];
	undefined4 local_1ec;
	undefined4 local_1e8;
	undefined4 local_1e4;
	Vector3F local_1e0 [40];
	
	fVar4 = param_4 * 0.5;
	local_200[2] = 1;
	local_200[4] = 1;
	local_1ec = 1;
	local_1e4 = 1;
	local_224 = 0;
	local_228 = 0;
	local_230 = 0.0;
	local_200[0] = 0;
	local_200[1] = 0;
	local_200[3] = 0;
	local_1e8 = 0;
	local_214 = 10000.0;
	local_22c = (Point2I *)0xc61c4000;
	local_220 = 0;
	local_218 = 0;
	if (shapeCount != 0) {
		local_210 = local_1e0;
		pPVar9 = shapePoints + 1;
		pPVar11 = globs::s_SurfaceMap_Points10;
		do {
			if (((local_218 == shapeCount - 1) || (shapePoints->x != pPVar9->x)) ||
				 (shapePoints->y != pPVar9->y)) {
				pPVar11->x = shapePoints->x;
				uVar10 = shapePoints->y;
				pPVar11->y = uVar10;
				Map3D_GetBlockVertexPositions2(surfMap,pPVar11->x,uVar10,local_210);
				uVar10 = 0;
				piVar8 = local_200;
				do {
					iVar3 = uVar10 + local_220 * 4;
					if ((surfMap->blocks3D
							 [(piVar8[1] + pPVar11->y) * (surfMap->dimensions).width + pPVar11->x + *piVar8].
							 byteflags_19 & SURFMAP_STRUCT28_UNK_8) == SURFMAP_STRUCT28_NONE) {
						local_230 = local_1e0[iVar3].z + local_230;
						local_224 += 1;
					}
					else {
						pfVar2 = &local_1e0[iVar3].z;
						if (local_1e0[iVar3].z < local_214) {
							local_214 = *pfVar2;
						}
						if ((ushort)((ushort)(*pfVar2 < (float)local_22c) << 8 |
												(ushort)(*pfVar2 == (float)local_22c) << 0xe) == 0) {
							local_22c = (Point2I *)*pfVar2;
						}
						local_228 += 1;
					}
					uVar10 += 1;
					piVar8 = piVar8 + 2;
				} while (uVar10 < 4);
				local_220 += 1;
				local_210 = local_210 + 4;
				pPVar11 = pPVar11 + 1;
			}
			else {
				local_218 += 1;
				pPVar9 = pPVar9 + 1;
				shapePoints = shapePoints + 1;
			}
			local_218 += 1;
			pPVar9 = pPVar9 + 1;
			shapePoints = shapePoints + 1;
		} while (local_218 < shapeCount);
	}
	local_230 = local_230 / (float)(ulonglong)local_224;
	if (local_228 != 0) {
		if ((ushort)((ushort)(fVar4 + local_230 < (float)local_22c) << 8 |
								(ushort)(fVar4 + local_230 == (float)local_22c) << 0xe) == 0) {
			local_230 = (float)local_22c - fVar4;
		}
		if (local_230 - fVar4 < local_214) {
			local_230 = fVar4 + local_214;
		}
	}
	local_218 = 0;
	if (local_220 != 0) {
		local_22c = globs::s_SurfaceMap_Points10;
		do {
			local_228 = 0;
			piVar8 = &local_22c->y;
			piVar6 = local_200;
			do {
				iVar3 = piVar6[1];
				iVar7 = *piVar6;
				if ((surfMap->blocks3D
						 [(iVar3 + *piVar8) * (surfMap->dimensions).width + local_22c->x + iVar7].byteflags_19 &
						SURFMAP_STRUCT28_UNK_8) == SURFMAP_STRUCT28_NONE) {
					iVar1 = local_228 + local_218 * 4;
					fVar5 = local_1e0[iVar1].z - local_230;
					if (fVar4 < ABS(fVar5)) {
						Map3D_Unk_ChangeWallDepth
											(surfMap,local_22c->x + iVar7,*piVar8 + iVar3,
											 ((fVar5 / fVar5) * fVar4 + local_230) - local_1e0[iVar1].z);
					}
					iVar7 = (*piVar8 + iVar3) * (surfMap->dimensions).width + local_22c->x + iVar7;
					surfMap->blocks3D[iVar7].byteflags_19 =
							 surfMap->blocks3D[iVar7].byteflags_19 | SURFMAP_STRUCT28_UNK_8;
				}
				local_228 += 1;
				piVar6 = piVar6 + 2;
			} while (local_228 < 4);
			local_218 += 1;
			local_22c = local_22c + 1;
		} while (local_218 < local_220);
	}
	return;
}



void __cdecl
lego::game::Map3D_Block_ShiftVertices_AndInitPlaneNormals
					(SurfaceMap *surfMap,uint bx,uint by,BOOL shiftUp)
{
	SurfaceMapStruct28Flags *pSVar1;
	int iVar2;
	D3DRMGroupIndex groupID;
	D3DRMVertex *pDVar3;
	D3DRMVertex *pDVar4;
	D3DRMVertex vertices [4];
	D3DRMVertex vertexSwap;
	SurfaceMapStruct28Flags bVar2;
	
	if (((shiftUp != 0) &&
			((surfMap->blocks3D[by * (surfMap->dimensions).width + bx].byteflags_19 &
			 SURFMAP_STRUCT28_UNK_1) == SURFMAP_STRUCT28_NONE)) ||
		 ((shiftUp == 0 &&
			((surfMap->blocks3D[by * (surfMap->dimensions).width + bx].byteflags_19 &
			 SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE)))) {
		groupID = (surfMap->smallDimensions).width * by + bx;
		res::Container_Mesh_GetVertices(surfMap->contMesh_24,groupID,0,4,vertices);
		iVar2 = by * (surfMap->dimensions).width + bx;
		bVar2 = surfMap->blocks3D[iVar2].byteflags_19;
		pSVar1 = &surfMap->blocks3D[iVar2].byteflags_19;
		if ((bVar2 & SURFMAP_STRUCT28_UNK_1) == SURFMAP_STRUCT28_NONE) {
						// Shift vertices up one
						// 
						//  memcpy(&vertexSwap,  &vertices[3], sizeof(D3DRMVertex));
						//  memcpy(&vertices[3], &vertices[2], sizeof(D3DRMVertex));
						//  memcpy(&vertices[2], &vertices[1], sizeof(D3DRMVertex));
						//  memcpy(&vertices[1], &vertices[0], sizeof(D3DRMVertex));
						//  memcpy(&vertices[0], &vertexSwap,  sizeof(D3DRMVertex));
			*pSVar1 = bVar2 | SURFMAP_STRUCT28_UNK_1;
			pDVar3 = vertices + 3;
			pDVar4 = &vertexSwap;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices + 2;
			pDVar4 = vertices + 3;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices + 1;
			pDVar4 = vertices + 2;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices;
			pDVar4 = vertices + 1;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices;
		}
		else {
						// Shift vertices down one
						// 
						//  memcpy(&vertexSwap,  &vertices[0], sizeof(D3DRMVertex));
						//  memcpy(&vertices[0], &vertices[1], sizeof(D3DRMVertex));
						//  memcpy(&vertices[1], &vertices[2], sizeof(D3DRMVertex));
						//  memcpy(&vertices[2], &vertices[3], sizeof(D3DRMVertex));
						//  memcpy(&vertices[3], &vertexSwap,  sizeof(D3DRMVertex));
			*pSVar1 = bVar2 & ~SURFMAP_STRUCT28_UNK_1;
			pDVar3 = vertices;
			pDVar4 = &vertexSwap;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices + 1;
			pDVar4 = vertices;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices + 2;
			pDVar4 = vertices + 1;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices + 3;
			pDVar4 = vertices + 2;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar4->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			}
			pDVar3 = vertices + 3;
		}
		pDVar4 = &vertexSwap;
		for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
			(pDVar3->position).x = (pDVar4->position).x;
			pDVar4 = (D3DRMVertex *)&(pDVar4->position).y;
			pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
		}
		res::Container_Mesh_SetVertices(surfMap->contMesh_24,groupID,0,4,vertices);
		Map3D_Block_InitPlaneNormals(surfMap,bx,by);
						// Perform action in a square: { { 0, 0 }, { 1, 0 },
						//                               { 0, 1 }, { 1, 1 } }
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,bx,by);
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,bx + 1,by);
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,bx + 1,by + 1);
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,bx,by + 1);
	}
	return;
}



void __cdecl
lego::game::Map3D_SetFlags2_AndStruct28_SetFlag19_4(SurfaceMap *surfMap,uint bx,uint by)
{
	SurfaceMapStruct28Flags *pByteFlags19;
	
	pByteFlags19 = &surfMap->blocks3D[(surfMap->dimensions).width * by + bx].byteflags_19;
	*pByteFlags19 = *pByteFlags19 | SURFMAP_STRUCT28_UNK_4;
	surfMap->flags_73d0 = surfMap->flags_73d0 | SURFMAP_UNK_2;
	return;
}



void __cdecl lego::game::Map3D_Update(SurfaceMap *surfMap,float elapsedGame)
{
	int idx;
	uint width;
	uint by;
	uint bx;
	
						// 0x2 = needs some UpdateBlockTextureAndVertices(?)
	if ((*(byte *)&surfMap->flags_73d0 & SURFMAP_UNK_2) != 0) {
		by = 0;
		if ((surfMap->dimensions).height != 0) {
			do {
				width = (surfMap->dimensions).width;
				bx = 0;
				if (width != 0) {
					do {
						// 0x4 = needs UpdateBlockTextureAndVertices
						if ((surfMap->blocks3D[by * width + bx].byteflags_19 & SURFMAP_STRUCT28_UNK_4) !=
								SURFMAP_STRUCT28_NONE) {
							Map3D_Block_UpdateTextureAndVertices(surfMap,bx,by);
							idx = by * (surfMap->dimensions).width + bx;
						// ~0x4
							surfMap->blocks3D[idx].byteflags_19 =
									 surfMap->blocks3D[idx].byteflags_19 & ~SURFMAP_STRUCT28_UNK_4;
						}
						width = (surfMap->dimensions).width;
						bx += 1;
					} while (bx < width);
				}
				by += 1;
			} while (by < (uint)(surfMap->dimensions).height);
		}
		surfMap->flags_73d0 = surfMap->flags_73d0 & ~SURFMAP_UNK_2;
	}
	Map3D_Update_Pass1_CoordsTextureUVs(surfMap,elapsedGame);
	Map3D_Update_Pass2_VertexColors(surfMap,elapsedGame);
	return;
}



void __cdecl lego::game::Map3D_Update_Pass2_VertexColors(SurfaceMap *surfMap,float elapsedGame)
{
	float fVar1;
	float *pfVar2;
	float *pfVar3;
	int iVar4;
	int index;
	float *pfVar5;
	D3DRMVertex vertices [4];
	
	index = 10;
	pfVar5 = (float *)&surfMap->table38_719c[0].blockPos.y;
	do {
		if ((*(byte *)(pfVar5 + 10) & 1) != 0) {
			res::Container_Mesh_GetVertices
								(surfMap->contMesh_24,
								 (surfMap->smallDimensions).width * (int)*pfVar5 + (int)pfVar5[-1],0,4,vertices);
			pfVar3 = &vertices[0].tv;
			iVar4 = 4;
			pfVar2 = pfVar5;
			do {
				pfVar3[-1] = pfVar2[1];
				*pfVar3 = pfVar2[2];
				pfVar3 = pfVar3 + 9;
				iVar4 += -1;
				pfVar2 = pfVar2 + 2;
			} while (iVar4 != 0);
			res::Container_Mesh_SetVertices
								(surfMap->contMesh_73cc,(D3DRMGroupIndex)pfVar5[-3],0,4,vertices);
			res::Container_Mesh_SetColourAlpha
								(surfMap->contMesh_73cc,(D3DRMGroupIndex)pfVar5[-3],1.0,1.0,1.0,1.0 - pfVar5[-2]);
			fVar1 = pfVar5[-2] - elapsedGame * -0.04;
			pfVar5[-2] = fVar1;
			if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
				res::Container_Mesh_HideGroup(surfMap->contMesh_73cc,(D3DRMGroupIndex)pfVar5[-3],TRUE);
				pfVar5[10] = (float)((uint)pfVar5[10] & 0xfffffffe);
			}
		}
		pfVar5 = pfVar5 + 0xe;
		index += -1;
	} while (index != 0);
	return;
}



void __cdecl
lego::game::Map3D_AddTextureCoordMapping
					(SurfaceMap *surfMap,SurfaceTexture texA,SurfaceTexture texB)
{
	uint texNum;
	uint i;
	uint texId;
	
	texId = (uint)texA;
	i = 0;
	texNum = (uint)surfMap->texsNum[texId];
						// check if mapping has already been created. If so, end operation
	if (texNum != 0) {
		do {
						// mapping already exists at index?
			if (surfMap->texsGrid[texId][i] == texB) {
				return;
			}
			i += 1;
		} while (i < texNum);
	}
						// mapping not found, add texB to end of texA[] list
	surfMap->texsGrid[texId][texNum] = texB;
	surfMap->texsNum[texId] = surfMap->texsNum[texId] + 1;
						// now create the reverse mapping, add texA to end of texB[] list
	texId = (uint)texB;
	surfMap->texsGrid[texId][surfMap->texsNum[texId]] = texA;
	surfMap->texsNum[texId] = surfMap->texsNum[texId] + 1;
	return;
}



void __cdecl lego::game::Map3D_SetField_2c(SurfaceMap *surfMap,undefined4 field2c)
{
	surfMap->field_2c = field2c;
	return;
}



void __cdecl
lego::game::Map3D_UpdateBlockVisual
					(SurfaceMap *surfMap,uint x,uint y,SurfaceTexture texure,byte field3)
{
	byte bVar1;
	Container_Texture *ref_itext;
	uint uVar2;
	D3DRMGroupIndex groupID;
	float *pfVar3;
	byte local_94 [4];
	D3DRMVertex vertices [4];
	
	_field3 = (uint)field3;
	uVar2 = (surfMap->smallDimensions).width;
	if ((x < uVar2) && (y < (uint)(surfMap->smallDimensions).height)) {
		groupID = y * uVar2 + x;
		local_94[0] = 1;
		local_94[1] = 3;
		local_94[2] = 2;
		local_94[3] = 0;
		ref_itext = res::DynamicPM_SurfaceTextureGrid_GetTexture
													((SurfaceTextureGrid *)surfMap->field_2c,texure);
		surfMap->blocks3D[y * (surfMap->dimensions).width + x].texture = texure;
		if ((surfMap->blocks3D[y * (surfMap->dimensions).width + x].byteflags_19 &
				SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE) {
			_field3 = (uint)(byte)(field3 + 1);
		}
		res::Container_Mesh_SetTexture(surfMap->contMesh_24,groupID,ref_itext);
		if ((surfMap->blocks3D[y * (surfMap->dimensions).width + x].byteflags_19 &
				SURFMAP_STRUCT28_UNK_10) == SURFMAP_STRUCT28_NONE) {
			res::Container_Mesh_GetVertices(surfMap->contMesh_24,groupID,0,4,vertices);
			uVar2 = 0;
			pfVar3 = &vertices[0].tv;
			do {
				bVar1 = local_94[uVar2 - _field3 & 3];
				uVar2 += 1;
				pfVar3[-1] = (float)(uint)(bVar1 >> 1);
				*pfVar3 = (float)(uint)(bVar1 & 1);
				pfVar3 = pfVar3 + 9;
			} while (uVar2 < 4);
			res::Container_Mesh_SetVertices(surfMap->contMesh_24,groupID,0,4,vertices);
		}
	}
	return;
}



void __cdecl
lego::game::Map3D_Unk_ChangeWallDepth(SurfaceMap *surfMap,uint bx,uint by,float digDepth)
{
	float *pfVar1;
	uint by_00;
	int i;
	uint uVar2;
	uint uVar3;
	Point2F *pPVar4;
	longlong lVar5;
	Vector3F vertPoses [1];
	Point2F OFFSETS_M1 [4];
	Vector3F *pVertPos;
	
	uVar2 = 0;
	vertPoses[0].z = digDepth;
	OFFSETS_M1[0].x = 0.0;
	OFFSETS_M1[0].y = 0.0;
	OFFSETS_M1[1].x = -1.0;
	OFFSETS_M1[1].y = 0.0;
	OFFSETS_M1[2].x = -1.0;
	OFFSETS_M1[2].y = -1.0;
	OFFSETS_M1[3].x = 0.0;
	OFFSETS_M1[3].y = -1.0;
	vertPoses[0].x = 0.0;
	vertPoses[0].y = 0.0;
						// for (uint i = 0; i < 4; i++)
						//   OFFSETS_M1[i].x += (float)bx, OFFSETS_M1[i].y += (float)by;
	i = 4;
	pfVar1 = &OFFSETS_M1[0].y;
	do {
		i += -1;
		pfVar1[-1] = (float)(ulonglong)bx + pfVar1[-1];
		*pfVar1 = *pfVar1 + (float)(ulonglong)by;
		pfVar1 = pfVar1 + 2;
	} while (i != 0);
						// for (uint vertIdx = 0; vertIdx < 4; vertIdx++)
						//   SurfaceMap_Block_SetIndexVertexPosition(surfMap,
						//           OFFSETS_M1[i].x, OFFSETS_M1[i].y, vertIdx, vertPoses);
	pPVar4 = OFFSETS_M1;
	do {
		pVertPos = vertPoses;
		uVar3 = uVar2;
		lVar5 = __ftol((float10)pPVar4->y);
		by_00 = (uint)lVar5;
		lVar5 = __ftol((float10)pPVar4->x);
		Map3D_Block_SetIndexVertexPosition(surfMap,(uint)lVar5,by_00,uVar3,pVertPos);
		uVar2 += 1;
		pPVar4 = pPVar4 + 1;
	} while (uVar2 < 4);
	for (uVar2 = by - 1; uVar2 <= by; uVar2 += 1) {
		for (uVar3 = bx - 1; uVar3 <= bx; uVar3 += 1) {
			Map3D_Block_InitPlaneNormals(surfMap,uVar3,uVar2);
		}
	}
	return;
}



void __cdecl lego::game::Map3D_SetPerspectiveCorrectionAll(SurfaceMap *surfMap,BOOL on)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	
	uVar2 = 0;
	if ((surfMap->smallDimensions).height != 0) {
		do {
			uVar1 = (surfMap->smallDimensions).width;
			uVar3 = 0;
			if (uVar1 != 0) {
				do {
					res::Container_Mesh_SetPerspectiveCorrection
										(surfMap->contMesh_24,uVar2 * uVar1 + uVar3,on);
					uVar1 = (surfMap->smallDimensions).width;
					uVar3 += 1;
				} while (uVar3 < uVar1);
			}
			uVar2 += 1;
		} while (uVar2 < (uint)(surfMap->smallDimensions).height);
	}
	return;
}



WallHighlightType __cdecl
lego::game::Map3D_Block_SetHighlightType
					(SurfaceMap *surfMap,int bx,int by,WallHighlightType highlightType)
{
	byte bVar1;
	int idx;
	
	idx = (surfMap->dimensions).width * by + bx;
	bVar1 = surfMap->blocks3D[idx].highlight;
	surfMap->blocks3D[idx].highlight = (byte)highlightType;
	Map3D_Block_SetColour
						(surfMap,bx,by,TRUE,globs::constant::c_wallHighlightColours[highlightType].red,
						 globs::constant::c_wallHighlightColours[highlightType].green,
						 globs::constant::c_wallHighlightColours[highlightType].blue);
	return (uint)bVar1;
}



WallHighlightType __cdecl
lego::game::Map3D_Block_GetHighlightType(SurfaceMap *surfMap,int bx,int by)
{
	return (uint)surfMap->blocks3D[(surfMap->dimensions).width * by + bx].highlight;
}



void __cdecl lego::game::Map3D_Block_ClearHighlight(SurfaceMap *surfMap,int bx,int by)
{
						// clear block colour
	Map3D_Block_SetColour(surfMap,bx,by,FALSE,1.0,1.0,1.0);
	surfMap->blocks3D[(surfMap->dimensions).width * by + bx].highlight = WALLHIGHLIGHT_NONE;
	return;
}



void __cdecl
lego::game::Map3D_Block_SetColour
					(SurfaceMap *surfMap,int bx,int by,BOOL setColour,float r,float g,float b)
{
	D3DRMGroupIndex groupID;
	
	groupID = (surfMap->smallDimensions).width * by + bx;
	if (setColour != 0) {
		res::Container_Mesh_SetColourAlpha(surfMap->contMesh_24,groupID,r,g,b,1.0);
		return;
	}
	res::Container_Mesh_SetColourAlpha(surfMap->contMesh_24,groupID,1.0,1.0,1.0,1.0);
	surfMap->blocks3D[(surfMap->dimensions).width * by + bx].highlight = WALLHIGHLIGHT_NONE;
	return;
}



BOOL __cdecl
lego::game::Map3D_BlockToWorldPos(SurfaceMap *surfMap,uint bx,uint by,float *out_x,float *out_y)
{
	if ((bx < (uint)(surfMap->smallDimensions).width) &&
		 (by < (uint)(surfMap->smallDimensions).height)) {
		*out_x = surfMap->BlockSize * 0.5 +
						 (float)(ulonglong)bx * surfMap->BlockSize + (surfMap->worldDimensions_fnegx).width;
		*out_y = (surfMap->worldDimensions_fnegx).height -
						 (surfMap->BlockSize * 0.5 + (float)(ulonglong)by * surfMap->BlockSize);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::Map3D_WorldToBlockPos_NoZ
					(SurfaceMap *surfMap,float in_x,float in_y,int *out_bx,int *out_by)
{
	BOOL BVar1;
	
						// The final argument here ((float *)&out_y) is a dummy argument that won't output the
						// pointed-to value
	BVar1 = Map3D_WorldToBlockPos(surfMap,in_x,in_y,out_bx,out_by,(float *)&out_by);
	return BVar1;
}



BOOL __cdecl
lego::game::Map3D_WorldToBlockPos
					(SurfaceMap *surfMap,float in_x,float in_y,int *out_bx,int *out_by,float *out_unk_z)
{
	float fVar1;
	int iVar2;
	int iVar3;
	longlong lVar4;
	
	lVar4 = __ftol(((float10)in_x - (float10)(surfMap->worldDimensions_fnegx).width) /
								 (float10)surfMap->BlockSize);
	iVar2 = (int)lVar4;
	lVar4 = __ftol(((float10)(surfMap->worldDimensions_fnegx).height - (float10)in_y) /
								 (float10)surfMap->BlockSize);
	iVar3 = (int)lVar4;
	if (out_bx != NULL) {
		*out_bx = iVar2;
	}
	if (out_by != NULL) {
		*out_by = iVar3;
	}
	if ((((-1 < iVar2) && (iVar2 < (surfMap->smallDimensions).width)) && (-1 < iVar3)) &&
		 (iVar3 < (surfMap->smallDimensions).height)) {
		if (out_unk_z != NULL) {
			fVar1 = surfMap->BlockSize * 0.5;
			in_x = (in_x - ((float)iVar2 * surfMap->BlockSize + (surfMap->worldDimensions_fnegx).width)) /
						 fVar1;
			fVar1 = -((in_y - ((surfMap->worldDimensions_fnegx).height - (float)iVar3 * surfMap->BlockSize
												)) / fVar1);
			if ((ushort)((ushort)(in_x < 1.0) << 8 | (ushort)(in_x == 1.0) << 0xe) == 0) {
				in_x = 2.0 - in_x;
			}
			if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
				fVar1 = 2.0 - fVar1;
			}
			if (in_x < fVar1) {
				fVar1 = in_x;
			}
			*out_unk_z = fVar1;
		}
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::game::Map3D_FUN_0044fad0(SurfaceMap *surfMap,float in_x,float in_y,int *out_x,int *out_y)
{
	int iVar1;
	int iVar2;
	int iVar3;
	longlong lVar4;
	
	lVar4 = __ftol(((float10)in_x - (float10)(surfMap->worldDimensions_fnegx).width) /
								 (float10)surfMap->BlockSize);
	iVar3 = (int)lVar4;
	lVar4 = __ftol(((float10)(surfMap->worldDimensions_fnegx).height - (float10)in_y) /
								 (float10)surfMap->BlockSize);
	iVar2 = (int)lVar4;
	if (iVar3 < 0) {
		iVar3 = 0;
	}
	iVar1 = (surfMap->smallDimensions).width;
	if (iVar1 <= iVar3) {
		iVar3 = iVar1 + -1;
	}
	if (iVar2 < 0) {
		iVar2 = 0;
	}
	iVar1 = (surfMap->smallDimensions).height;
	if (iVar1 <= iVar2) {
		iVar2 = iVar1 + -1;
	}
	if (out_x != NULL) {
		*out_x = iVar3;
	}
	if (out_y != NULL) {
		*out_y = iVar2;
	}
	return;
}



BOOL __cdecl
lego::game::Map3D_FUN_0044fb30
					(SurfaceMap *surfMap,Point2F *param_2,Point2F *param_3,Point2F *param_4)
{
	float fVar1;
	Point2F *pPVar2;
	Point2F *pPVar3;
	BOOL BVar4;
	Point2F *local_8;
	float fStack4;
	SurfaceMap *surfMap_00;
	
	pPVar2 = param_2;
	surfMap_00 = surfMap;
	BVar4 = Map3D_WorldToBlockPos_NoZ(surfMap,param_2->x,param_2->y,(int *)&surfMap,(int *)&param_2);
	pPVar3 = param_4;
	if (BVar4 != 0) {
		if (param_3 != NULL) {
			local_8 = param_2;
			fStack4 = 0.0;
			param_3->x = (float)ZEXT48(surfMap);
			param_3->y = (float)ZEXT48(param_2);
		}
		if (param_4 != NULL) {
			Map3D_BlockToWorldPos(surfMap_00,(uint)surfMap,(uint)param_2,(float *)&local_8,&fStack4);
			pPVar3->x = pPVar2->x - (float)local_8;
			pPVar3->y = pPVar2->y - fStack4;
			fVar1 = 1.0 / surfMap_00->BlockSize;
			pPVar3->x = fVar1 * pPVar3->x - -0.5;
			pPVar3->y = fVar1 * pPVar3->y - -0.5;
		}
	}
	return 0;
}



float10 __cdecl lego::game::Map3D_GetWorldZ(SurfaceMap *surfMap,float x,float y)
{
	SurfaceMap *surfMap_00;
	BOOL BVar1;
	float10 fVar2;
	uint local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	surfMap_00 = surfMap;
	local_34 = 0.0;
	BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,x,y,(int *)&local_38,(int *)&surfMap);
	if (BVar1 != 0) {
		BVar1 = Map3D_GetBlockVertexPositions2(surfMap_00,local_38,(uint)surfMap,&local_30);
		if (BVar1 == 0) {
			if (surfMap_00->BlockSize <= (x - local_30.x) + (local_30.y - y)) {
				local_30.z = (local_4 - local_10) + (local_1c - local_10) + local_10;
			}
			else {
				local_10 = (local_4 - local_30.z) + (local_1c - local_30.z) + local_30.z;
			}
		}
		else {
			if (surfMap_00->BlockSize <= (local_24 - x) + (local_20 - y)) {
				local_1c = (local_10 - local_4) + (local_30.z - local_4) + local_4;
			}
			else {
				local_4 = (local_10 - local_1c) + (local_30.z - local_1c) + local_1c;
			}
		}
		fVar2 = ((float10)local_10 - (float10)local_4) *
						(((float10)local_18 - (float10)local_c) / ((float10)x - (float10)local_c)) +
						(float10)local_4;
		return (((float10)local_30.y - (float10)local_8) / ((float10)y - (float10)local_8)) *
					 ((((float10)local_1c - (float10)local_30.z) *
						 (((float10)x - (float10)local_30.x) / ((float10)local_24 - (float10)local_30.x)) +
						(float10)local_30.z) - fVar2) + fVar2;
	}
	return (float10)local_34;
}



void __cdecl
lego::game::Map3D_FUN_0044fd70(SurfaceMap *surfMap,float in_x,float in_y,Vector3F *out_vector)
{
	BOOL BVar1;
	int iVar2;
	SurfaceBlock *pSVar3;
	uint local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	SurfaceMap *surfMap_00;
	
	surfMap_00 = surfMap;
	BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)&local_34,(int *)&surfMap);
	if (BVar1 == 0) {
		return;
	}
	BVar1 = Map3D_GetBlockVertexPositions2(surfMap_00,local_34,(uint)surfMap,&local_30);
	if (BVar1 == 0) {
		iVar2 = (surfMap_00->dimensions).width;
		if ((local_30.y - in_y) + (in_x - local_30.x) < surfMap_00->BlockSize) {
LAB_0044fe14:
			pSVar3 = surfMap_00->blocks3D + iVar2 * (int)surfMap + local_34;
			goto LAB_0044fe28;
		}
	}
	else {
		iVar2 = (surfMap_00->dimensions).width;
		if (surfMap_00->BlockSize <= (local_20 - in_y) + (local_24 - in_x)) goto LAB_0044fe14;
	}
	pSVar3 = (SurfaceBlock *)&surfMap_00->blocks3D[iVar2 * (int)surfMap + local_34].vector_c;
LAB_0044fe28:
	out_vector->x = (pSVar3->vector_0).x;
	out_vector->y = (pSVar3->vector_0).y;
	out_vector->z = (pSVar3->vector_0).z;
	return;
}



BOOL __cdecl
lego::game::Map3D_FUN_0044fe50
					(SurfaceMap *surfMap,float in_x,float in_y,BOOL condition,float unkMultiplier,float *out_x
					,float *out_y)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	SurfaceMap *surfMap_00;
	BOOL BVar4;
	SurfaceBlock *pSVar5;
	int iVar6;
	int iVar7;
	uint local_68;
	Point2F local_64;
	Point2F local_5c;
	Point2F local_54;
	Point2F local_4c;
	Point2F local_44;
	float local_3c;
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24 [9];
	
	surfMap_00 = surfMap;
	BVar4 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)&local_68,(int *)&surfMap);
	if (BVar4 == 0) {
		return 0;
	}
	BVar4 = Map3D_GetBlockVertexPositions2(surfMap_00,local_68,(uint)surfMap,&local_30);
	if (BVar4 == 0) {
		iVar6 = (surfMap_00->dimensions).width;
		if ((in_x - local_30.x) + (local_30.y - in_y) < surfMap_00->BlockSize) {
			pSVar5 = surfMap_00->blocks3D + iVar6 * (int)surfMap + local_68;
			local_3c = (pSVar5->vector_0).x;
			local_38 = (pSVar5->vector_0).y;
			local_34 = (pSVar5->vector_0).z;
			goto LAB_0044ff78;
		}
		pSVar5 = (SurfaceBlock *)&surfMap_00->blocks3D[iVar6 * (int)surfMap + local_68].vector_c;
	}
	else {
		iVar6 = (surfMap_00->dimensions).width;
		if ((local_24[0] - in_x) + (local_24[1] - in_y) < surfMap_00->BlockSize) {
			pVVar1 = &surfMap_00->blocks3D[iVar6 * (int)surfMap + local_68].vector_c;
			local_3c = pVVar1->x;
			local_38 = pVVar1->y;
			local_34 = pVVar1->z;
			goto LAB_0044ff78;
		}
		pSVar5 = surfMap_00->blocks3D + iVar6 * (int)surfMap + local_68;
	}
	local_3c = (pSVar5->vector_0).x;
	local_38 = (pSVar5->vector_0).y;
	local_34 = (pSVar5->vector_0).z;
LAB_0044ff78:
	if (condition == 0) {
		if (ABS(local_3c) <= ABS(local_38)) {
			if (0.0 <= local_38) {
				iVar6 = 0;
				iVar7 = 1;
			}
			else {
				iVar6 = 2;
				iVar7 = 3;
			}
		}
		else {
			if (0.0 <= local_3c) {
				iVar6 = 1;
				iVar7 = 2;
			}
			else {
				iVar6 = 0;
				iVar7 = 3;
			}
		}
	}
	else {
		if (BVar4 == 0) {
			iVar6 = 1;
			iVar7 = 3;
		}
		else {
			iVar6 = 0;
			iVar7 = 2;
		}
	}
	local_54.x = local_24[iVar6 * 3 + -3];
	local_54.y = local_24[iVar6 * 3 + -2];
	local_4c.x = in_x;
	local_5c.x = local_24[iVar7 * 3 + -3] - local_54.x;
	local_5c.y = local_24[iVar7 * 3 + -2] - local_54.y;
	local_4c.y = in_y;
	local_64.x = local_3c;
	local_64.y = local_38;
	math::Maths_Vector2DIntersection(&local_44,&local_54,&local_5c,&local_4c,&local_64);
	fVar3 = unkMultiplier * surfMap_00->BlockSize;
	fVar2 = 1.0 / SQRT(local_64.y * local_64.y + local_64.x * local_64.x);
	*out_x = local_44.x - fVar2 * local_64.x * fVar3;
	*out_y = local_44.y - fVar2 * local_64.y * fVar3;
	return 1;
}



float10 __cdecl lego::game::Map3D_UnkCameraXYFunc_RetZunk(SurfaceMap *surfMap,float x,float y)
{
	SurfaceMap *pSVar1;
	BOOL BVar2;
	float *pfVar3;
	float *pfVar4;
	int iVar5;
	float10 fVar6;
	float10 extraout_ST0;
	longlong lVar7;
	uint local_68;
	int local_64;
	float local_60;
	undefined4 uStack92;
	float local_58;
	undefined4 uStack84;
	float local_50 [5];
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	float local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pSVar1 = surfMap;
	local_58 = 0.0;
	BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,x,y,(int *)&local_68,(int *)&surfMap);
	if (BVar2 != 0) {
		uStack92 = 0;
		local_58 = (float)local_68;
		fVar6 = (float10)ZEXT48(surfMap);
		uStack84 = 0;
		local_60 = (float)(ulonglong)local_68;
		local_50[0] = 0.0;
		local_50[1] = 0.0;
		local_50[2] = 1.0;
		local_50[3] = 0.0;
		local_50[4] = 1.0;
		local_3c = 0x3f800000;
		local_38 = 0;
		local_34 = 0x3f800000;
		pfVar3 = local_50;
		local_64 = 4;
		pfVar4 = &local_2c;
		do {
			pfVar4[-1] = (*pfVar3 + local_60) * pSVar1->BlockSize + (pSVar1->worldDimensions_fnegx).width;
			*pfVar4 = (float)((float10)(pSVar1->worldDimensions_fnegx).height -
											 ((float10)pfVar3[1] + fVar6) * (float10)pSVar1->BlockSize);
			lVar7 = __ftol((float10)pfVar3[1]);
			iVar5 = (int)(surfMap->texsGrid[-1] + (int)lVar7 + 0x4c) * (pSVar1->dimensions).width +
							local_68;
			lVar7 = __ftol((float10)*pfVar3);
			pfVar3 = pfVar3 + 2;
			local_58 = (float)(uint)pSVar1->blocks3D[iVar5 + (int)lVar7].heightValue;
			local_64 += -1;
			pfVar4[1] = -((float)(int)local_58 * pSVar1->RoughLevel);
			pfVar4 = pfVar4 + 3;
			fVar6 = extraout_ST0;
		} while (local_64 != 0);
		if (pSVar1->BlockSize <= (local_24 - x) + (local_20 - y)) {
			fVar6 = (float10)local_4;
			local_1c = (float)(((float10)local_10 - fVar6) + ((float10)local_28 - fVar6) + fVar6);
		}
		else {
			fVar6 = ((float10)local_10 - (float10)local_1c) + ((float10)local_28 - (float10)local_1c) +
							(float10)local_1c;
		}
		fVar6 = ((float10)local_10 - fVar6) *
						(((float10)local_18 - (float10)local_c) / ((float10)x - (float10)local_c)) + fVar6;
		return (((float10)local_2c - (float10)local_8) / ((float10)y - (float10)local_8)) *
					 ((((float10)local_1c - (float10)local_28) *
						 (((float10)x - (float10)local_30) / ((float10)local_24 - (float10)local_30)) +
						(float10)local_28) - fVar6) + fVar6;
	}
	return (float10)local_58;
}



void __cdecl lego::game::Map3D_FUN_00450320(SurfaceMap *surfMap,int sx,int sy,Vector3F *out_vector)
{
	D3DRMVertex local_24;
	
	res::Container_Mesh_GetVertices
						(surfMap->contMesh_24,sy * (surfMap->smallDimensions).width + sx,
						 surfMap->blocks3D[(surfMap->dimensions).width * sy + sx].byteflags_19 & 1,1,&local_24);
	out_vector->x = local_24.position.x;
	out_vector->y = local_24.position.y;
	out_vector->z = local_24.position.z;
	return;
}



// Returns TRUE if vertexes are shiftded down once,
//  or FALSE if in original position.

BOOL __cdecl
lego::game::Map3D_GetBlockVertexPositions2
					(SurfaceMap *surfMap,uint bx,uint by,Vector3F *out_vertPoses)
{
	uint width;
	D3DRMVertex vertices [4];
	
	width = (surfMap->smallDimensions).width;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		res::Container_Mesh_GetVertices(surfMap->contMesh_24,by * width + bx,0,4,vertices);
		if ((surfMap->blocks3D[(surfMap->dimensions).width * by + bx].byteflags_19 &
				SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE) {
						// Return vertices shifted down once.
			out_vertPoses->x = vertices[1].position.x;
			out_vertPoses->y = vertices[1].position.y;
			out_vertPoses->z = vertices[1].position.z;
			out_vertPoses[1].x = vertices[2].position.x;
			out_vertPoses[1].y = vertices[2].position.y;
			out_vertPoses[1].z = vertices[2].position.z;
			out_vertPoses[2].x = vertices[3].position.x;
			out_vertPoses[2].y = vertices[3].position.y;
			out_vertPoses[2].z = vertices[3].position.z;
			out_vertPoses[3].x = vertices[0].position.x;
			out_vertPoses[3].y = vertices[0].position.y;
			out_vertPoses[3].z = vertices[0].position.z;
			return TRUE;
		}
						// Return vertices in original position.
		out_vertPoses->x = vertices[0].position.x;
		out_vertPoses->y = vertices[0].position.y;
		out_vertPoses->z = vertices[0].position.z;
		out_vertPoses[1].x = vertices[1].position.x;
		out_vertPoses[1].y = vertices[1].position.y;
		out_vertPoses[1].z = vertices[1].position.z;
		out_vertPoses[2].x = vertices[2].position.x;
		out_vertPoses[2].y = vertices[2].position.y;
		out_vertPoses[2].z = vertices[2].position.z;
		out_vertPoses[3].x = vertices[3].position.x;
		out_vertPoses[3].y = vertices[3].position.y;
		out_vertPoses[3].z = vertices[3].position.z;
						// result = FALSE;
		width = 0;
	}
						// return result;
	return width;
}



void __cdecl
lego::game::Map3D_GetBlockVertexPositions1
					(SurfaceMap *surfMap,uint bx,uint by,Vector3F *out_vertPoses)
{
	D3DRMVertex vertices [4];
	
	res::Container_Mesh_GetVertices
						(surfMap->contMesh_24,by * (surfMap->smallDimensions).width + bx,0,4,vertices);
	out_vertPoses->x = vertices[0].position.x;
	out_vertPoses->y = vertices[0].position.y;
	out_vertPoses->z = vertices[0].position.z;
	out_vertPoses[1].x = vertices[1].position.x;
	out_vertPoses[1].y = vertices[1].position.y;
	out_vertPoses[1].z = vertices[1].position.z;
	out_vertPoses[2].x = vertices[2].position.x;
	out_vertPoses[2].y = vertices[2].position.y;
	out_vertPoses[2].z = vertices[2].position.z;
	out_vertPoses[3].x = vertices[3].position.x;
	out_vertPoses[3].y = vertices[3].position.y;
	out_vertPoses[3].z = vertices[3].position.z;
	return;
}



BOOL __cdecl lego::game::Map3D_IsInsideDimensions(SurfaceMap *surfMap,uint bx,uint by)
{
	if ((uint)(surfMap->smallDimensions).width <= bx) {
		return 0;
	}
	return (uint)(by < (uint)(surfMap->smallDimensions).height);
}



BOOL __cdecl
lego::game::Map3D_GetIntersections
					(SurfaceMap *surfMap,Viewport *view,uint mouseX,uint mouseY,uint *out_bx,uint *out_by,
					Vector3F *out_vector)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	int iVar6;
	float *pfVar7;
	Vector3F *vector;
	Point2I blockPos;
	Point2I loopOffset;
	Point2F mousePos;
	Vector3F xformVecZ1;
	Vector3F xformVecZ0;
	Vector4F xformPoly;
	Vector4F xformMouseZ0;
	Vector4F xformMouseZ1;
	Point2F polyPoints [5];
	Vector3F vertPoses [4];
	
	mousePos.x = (float)(ulonglong)mouseX;
	blockPos.x = mouseY;
	blockPos.y = 0;
	mousePos.y = (float)(ulonglong)mouseY;
						// xformMouseZ0 = Vector4F{mouseX, mouseY, 0.0, 1.0};
						// xformMouseZ1 = Vector4F{mouseX, mouseY, 1.0, 1.0};
	xformMouseZ0.z = 0.0;
	xformMouseZ0.w = 1.0;
	xformMouseZ1.z = 1.0;
	xformMouseZ1.w = 1.0;
	xformMouseZ0.x = mousePos.x;
	xformMouseZ0.y = mousePos.y;
	xformMouseZ1.x = mousePos.x;
	xformMouseZ1.y = mousePos.y;
	lego::view::Viewport_InverseTransform(view,&xformVecZ0,&xformMouseZ0);
	lego::view::Viewport_InverseTransform(view,&xformVecZ1,&xformMouseZ1);
	fVar2 = xformVecZ1.x - xformVecZ0.x;
	fVar1 = xformVecZ1.y - xformVecZ0.y;
	fVar3 = xformVecZ1.z - xformVecZ0.z;
	fVar4 = 1.0 / SQRT(fVar3 * fVar3 + fVar1 * fVar1 + fVar2 * fVar2);
	xformVecZ1.x = fVar4 * fVar2;
	xformVecZ1.y = fVar4 * fVar1;
	xformVecZ1.z = fVar4 * fVar3;
	BVar5 = Map3D_Intersections_Sub1_FUN_00450820
										(surfMap,&xformVecZ0,&xformVecZ1,out_vector,&blockPos,0x14);
	if (BVar5 == 0) {
		return 0;
	}
						// Do a 2D loop in range: (-2,-2) -> (2,2)
	loopOffset.y = -2;
	do {
		loopOffset.x = -2;
		do {
			if (((uint)(loopOffset.x + blockPos.x) < (uint)(surfMap->smallDimensions).width) &&
				 ((uint)(blockPos.y + loopOffset.y) < (uint)(surfMap->smallDimensions).height)) {
				Map3D_GetBlockVertexPositions2
									(surfMap,loopOffset.x + blockPos.x,blockPos.y + loopOffset.y,vertPoses);
				vector = vertPoses;
				iVar6 = 4;
				pfVar7 = &polyPoints[0].y;
				do {
					lego::view::Viewport_Transform(view,&xformPoly,vector);
					vector = vector + 1;
					iVar6 += -1;
					pfVar7[-1] = xformPoly.x / xformPoly.w;
					*pfVar7 = xformPoly.y / xformPoly.w;
					pfVar7 = pfVar7 + 2;
				} while (iVar6 != 0);
				polyPoints[4].x = polyPoints[0].x;
				polyPoints[4].y = polyPoints[0].y;
				BVar5 = math::Maths_PointInsidePoly(&mousePos,polyPoints,polyPoints + 1,4);
				if (BVar5 != 0) {
					*out_bx = loopOffset.x + blockPos.x;
					*out_by = blockPos.y + loopOffset.y;
					Map3D_Intersections_Sub2_FUN_004518a0
										(surfMap,*out_bx,blockPos.y + loopOffset.y,&xformVecZ0,&xformVecZ1,out_vector);
					return TRUE;
				}
			}
			loopOffset.x += 1;
		} while (loopOffset.x < 3);
		loopOffset.y += 1;
		if (2 < loopOffset.y) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Map3D_Intersections_Sub1_FUN_00450820
					(SurfaceMap *surfMap,Vector3F *rayOrigin,Vector3F *ray,Vector3F *out_endPoint,
					Point2I *out_blockPos,int unkCount)
{
	BOOL BVar1;
	float10 fVar2;
	Vector3F planePoint;
	Vector3F planeNormal;
	
	planePoint.x = 0.0;
	planePoint.y = 0.0;
	planePoint.z = -50.0;
	planeNormal.x = 0.0;
	planeNormal.y = 0.0;
	planeNormal.z = -1.0;
	if (unkCount != 0) {
		do {
			math::Maths_RayPlaneIntersection(out_endPoint,rayOrigin,ray,&planePoint,&planeNormal);
			fVar2 = Map3D_GetWorldZ(surfMap,out_endPoint->x,out_endPoint->y);
			planePoint.z = (float)fVar2;
			unkCount += -1;
		} while (unkCount != 0);
	}
	BVar1 = Map3D_WorldToBlockPos_NoZ
										(surfMap,out_endPoint->x,out_endPoint->y,&out_blockPos->x,&out_blockPos->y);
	return BVar1;
}



void __cdecl
lego::game::Map3D_AddCoordsInRadius_AndDoCallbacks
					(SurfaceMap *surfMap,int in_bx,int in_by,int radius,XYCallback opt_callback)
{
	int rel_y;
	int abs_x;
	int abs_y;
	int neg_radius;
	int rel_x;
	
	neg_radius = -radius;
	if (-radius == radius || SBORROW4(neg_radius,radius) != radius * -2 < 0) {
		abs_y = neg_radius + in_by;
		rel_y = neg_radius;
		do {
			if (neg_radius <= radius) {
				abs_x = neg_radius + in_bx;
				rel_x = neg_radius;
				do {
					if ((((rel_x * rel_x + rel_y * rel_y <= radius * radius) && (-1 < abs_x)) &&
							(abs_x < (surfMap->smallDimensions).width)) &&
						 ((-1 < abs_y && (abs_y < (surfMap->smallDimensions).height)))) {
						Map3D_DoForBlockIndex_Mesh_FUN_00474df0(surfMap,abs_x,abs_y,0);
						if (opt_callback != NULL) {
							(*opt_callback)(abs_x,abs_y);
						}
						surfMap->smallCoordsTable[surfMap->smallCoordsNum].sx = (short)rel_x + (short)in_bx;
						surfMap->smallCoordsTable[surfMap->smallCoordsNum].sy = (short)rel_y + (short)in_by;
						surfMap->smallCoordsNum = surfMap->smallCoordsNum + 1;
					}
					rel_x += 1;
					abs_x += 1;
				} while (rel_x <= radius);
			}
			rel_y += 1;
			abs_y += 1;
		} while (rel_y <= radius);
	}
	return;
}



void __cdecl
lego::game::Map3D_DoForBlockIndex_Mesh_FUN_00474df0(SurfaceMap *surfMap,int x,int y,BOOL state)
{
	res::Container_Mesh_HideGroup(surfMap->contMesh_24,y * (surfMap->smallDimensions).width + x,state)
	;
	return;
}



void __cdecl lego::game::Map3D_AddBlockCoord(SurfaceMap *surfMap,int cx,int vy)
{
	Map3D_DoForBlockIndex_Mesh_FUN_00474df0(surfMap,cx,vy,0);
	surfMap->smallCoordsTable[surfMap->smallCoordsNum].sx = (short)cx;
	surfMap->smallCoordsTable[surfMap->smallCoordsNum].sy = (short)vy;
	surfMap->smallCoordsNum = surfMap->smallCoordsNum + 1;
	return;
}



void __cdecl lego::game::Map3D_DoForCoordsAndClear_Mesh_FUN_00474df0(SurfaceMap *surfMap)
{
	uint uVar1;
	Coord2I *coord;
	
	uVar1 = 0;
	if (surfMap->smallCoordsNum != 0) {
		coord = surfMap->smallCoordsTable;
		do {
			Map3D_DoForBlockIndex_Mesh_FUN_00474df0
								(surfMap,(uint)(ushort)coord->sx,(uint)(ushort)coord->sy,TRUE);
			uVar1 += 1;
			coord = coord + 1;
		} while (uVar1 < surfMap->smallCoordsNum);
	}
	surfMap->smallCoordsNum = 0;
	return;
}



void __cdecl
lego::game::Map3D_BlockVertexToWorldPos
					(SurfaceMap *surfMap,uint bx,uint by,float *out_x,float *out_y,float *out_z)
{
	uint uVar1;
	uint uVar2;
	uint index;
	D3DRMVertex vertices [1];
	
	uVar1 = (surfMap->dimensions).width;
	if (uVar1 <= bx) {
		return;
	}
	if ((uint)(surfMap->dimensions).height <= by) {
		return;
	}
	uVar2 = (surfMap->smallDimensions).width;
	index = 0;
	if (bx == uVar2) {
		if (by == (surfMap->smallDimensions).height) {
			bx -= 1;
			by -= 1;
			index = 2;
			goto LAB_00450ae4;
		}
		if (bx == uVar2) {
			bx -= 1;
			index = 1;
			goto LAB_00450ae4;
		}
	}
	if (by == (surfMap->smallDimensions).height) {
		by -= 1;
		index = 0xffffffff;
	}
LAB_00450ae4:
	if ((surfMap->blocks3D[by * uVar1 + bx].byteflags_19 & SURFMAP_STRUCT28_UNK_1) !=
			SURFMAP_STRUCT28_NONE) {
		index += 1;
	}
	if (index == 0xffffffff) {
		index = 3;
	}
	res::Container_Mesh_GetVertices(surfMap->contMesh_24,by * uVar2 + bx,index,1,vertices);
	*out_x = vertices[0].position.x;
	*out_y = vertices[0].position.y;
	*out_z = vertices[0].position.z;
	return;
}



float10 __cdecl lego::game::Map3D_GetBlockSize(SurfaceMap *surfMap)
{
	return (float10)surfMap->BlockSize;
}



int __cdecl
lego::game::Map3D_CheckComparison_FUN_00450b60(int param_1,int param_2,int param_3,int param_4)
{
	int iVar1;
	int iVar2;
	
	iVar2 = -1;
	if (param_1 == param_3) {
		if (param_2 + -1 == param_4) {
			return 0;
		}
		if (param_2 + 1 == param_4) {
			return 2;
		}
	}
	else {
		iVar1 = param_1 + 1;
		if (param_2 == param_4) {
			if (iVar1 == param_3) {
				return 1;
			}
			if (param_1 + -1 == param_3) {
				return 3;
			}
		}
		else {
			if (iVar1 == param_3) {
				if (param_2 + -1 == param_4) {
					return 4;
				}
				if ((iVar1 == param_3) && (param_2 + 1 == param_4)) {
					return 5;
				}
			}
			if (param_1 + -1 == param_3) {
				if (param_2 + 1 == param_4) {
					return 6;
				}
				if ((param_1 + -1 == param_3) && (param_2 + -1 == param_4)) {
					iVar2 = 7;
				}
			}
		}
	}
	return iVar2;
}



void __cdecl
lego::game::Map3D_Block_TextCoords_FUN_00450c20(SurfaceMap *surfMap,uint bx,uint by,BOOL param_4)
{
	uint uVar1;
	int idx;
	uint uVar2;
	ushort *puVar3;
	
	if (param_4 == 0) {
		if ((surfMap->blocks3D[by * (surfMap->dimensions).width + bx].byteflags_19 &
				SURFMAP_STRUCT28_UNK_10) != SURFMAP_STRUCT28_NONE) {
			uVar1 = surfMap->largeCoordsNum;
			uVar2 = 0;
			if (uVar1 != 0) {
				puVar3 = (ushort *)&surfMap->largeCoordsTable[0].sy;
				while ((puVar3[-1] != bx || (*puVar3 != by))) {
					uVar2 += 1;
					puVar3 = puVar3 + 2;
					if (uVar1 <= uVar2) {
						return;
					}
				}
				surfMap->largeCoordsNum = uVar1 - 1;
				surfMap->largeCoordsTable[uVar2].sx = surfMap->largeCoordsTable[uVar1 - 1].sx;
				surfMap->largeCoordsTable[uVar2].sy = surfMap->largeCoordsTable[surfMap->largeCoordsNum].sy;
				idx = by * (surfMap->dimensions).width + bx;
				surfMap->blocks3D[idx].byteflags_19 =
						 surfMap->blocks3D[idx].byteflags_19 & ~SURFMAP_STRUCT28_UNK_10;
			}
		}
	}
	else {
		if ((surfMap->blocks3D[by * (surfMap->dimensions).width + bx].byteflags_19 &
				SURFMAP_STRUCT28_UNK_10) == SURFMAP_STRUCT28_NONE) {
			surfMap->largeCoordsTable[surfMap->largeCoordsNum].sx = (short)bx;
			surfMap->largeCoordsTable[surfMap->largeCoordsNum].sy = (short)by;
			idx = by * (surfMap->dimensions).width + bx;
			surfMap->largeCoordsNum = surfMap->largeCoordsNum + 1;
			surfMap->blocks3D[idx].byteflags_19 =
					 surfMap->blocks3D[idx].byteflags_19 | SURFMAP_STRUCT28_UNK_10;
			return;
		}
	}
	return;
}



void __cdecl lego::game::Map3D_Coords_SetEmissive(SurfaceMap *surfMap,BOOL doEmissive)
{
	uint uVar1;
	Coord2I *pCVar2;
	
	if ((doEmissive != 0) && ((*(byte *)&surfMap->flags_73d0 & 4) == 0)) {
		uVar1 = 0;
		if (surfMap->largeCoordsNum != 0) {
			pCVar2 = surfMap->largeCoordsTable;
			do {
				res::Container_Mesh_SetEmissive
									(surfMap->contMesh_24,
									 (uint)(ushort)pCVar2->sy * (surfMap->smallDimensions).width +
									 (uint)(ushort)pCVar2->sx,0.3,0.3,0.3);
				uVar1 += 1;
				pCVar2 = pCVar2 + 1;
			} while (uVar1 < surfMap->largeCoordsNum);
		}
		surfMap->flags_73d0 = surfMap->flags_73d0 | 4;
		return;
	}
	if ((doEmissive == 0) && ((*(byte *)&surfMap->flags_73d0 & 4) != 0)) {
		uVar1 = 0;
		if (surfMap->largeCoordsNum != 0) {
			pCVar2 = surfMap->largeCoordsTable;
			do {
				res::Container_Mesh_SetEmissive
									(surfMap->contMesh_24,
									 (uint)(ushort)pCVar2->sy * (surfMap->smallDimensions).width +
									 (uint)(ushort)pCVar2->sx,0.0,0.0,0.0);
				uVar1 += 1;
				pCVar2 = pCVar2 + 1;
			} while (uVar1 < surfMap->largeCoordsNum);
		}
		surfMap->flags_73d0 = surfMap->flags_73d0 & 0xfffffffb;
	}
	return;
}



void __cdecl lego::game::Map3D_Update_Pass1_CoordsTextureUVs(SurfaceMap *surfMap,float elapsedGame)
{
	Point2F *pPVar1;
	SurfaceMapStruct28Flags SVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	ushort *pCoordY;
	int sxOff;
	D3DRMGroupIndex groupID;
	uint dirOff;
	uint sx;
	uint sy;
	int syOff;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	uint local_11c;
	Point2F baseUV;
	Point2F randUV;
	Point2F *pOffset_F;
	Point2I *pOffset_I;
	uint dirIndex;
	uint tableIndex;
	Point2F OFFSETS_F [4];
	Point2I OFFSETS_I [4];
	D3DRMVertex vertices [4];
	int sxDiff;
	
	if ((ushort)((ushort)(elapsedGame < 0.001) << 8 | (ushort)(elapsedGame == 0.001) << 0xe) == 0) {
		OFFSETS_I[1].x = 1;
		OFFSETS_I[2].x = 1;
		OFFSETS_I[2].y = 1;
		OFFSETS_I[3].y = 1;
		OFFSETS_F[0].x = 0.0;
		OFFSETS_F[0].y = 1.0;
		OFFSETS_F[1].x = 1.0;
		OFFSETS_F[1].y = 1.0;
		OFFSETS_F[2].x = 1.0;
		OFFSETS_F[2].y = 0.0;
		OFFSETS_F[3].x = 0.0;
		OFFSETS_F[3].y = 0.0;
		OFFSETS_I[0].x = 0;
		OFFSETS_I[0].y = 0;
		OFFSETS_I[1].y = 0;
		OFFSETS_I[3].x = 0;
		tableIndex = 0;
		if (surfMap->largeCoordsNum != 0) {
			fVar5 = 50.0 / elapsedGame;
			pCoordY = (ushort *)&surfMap->largeCoordsTable[0].sy;
			fVar6 = 1.0 / (fVar5 - -1.0);
			do {
				sy = (uint)*pCoordY;
				sx = (uint)pCoordY[-1];
				groupID = (surfMap->smallDimensions).width * sy + sx;
				SVar2 = surfMap->blocks3D[sy * (surfMap->dimensions).width + sx].byteflags_19;
				res::Container_Mesh_GetVertices(surfMap->contMesh_24,groupID,0,4,vertices);
				pOffset_F = OFFSETS_F;
				pOffset_I = OFFSETS_I;
				dirIndex = 0;
				local_11c = 0;
				do {
					dirOff = dirIndex;
					if ((SVar2 & SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE) {
						dirOff = dirIndex + 1 & 3;
					}
					syOff = sy + *(int *)((int)&OFFSETS_I[0].y + local_11c);
					sxDiff = pOffset_I->x;
					sxOff = syOff * (surfMap->dimensions).width + sx + sxDiff;
					fVar3 = vertices[dirOff].tu;
					randUV.x = surfMap->blocks3D[sxOff].textuv_1c.x + pOffset_F->x;
					fVar4 = vertices[dirOff].tv;
					randUV.y = surfMap->blocks3D[sxOff].textuv_1c.y +
										 *(float *)((int)&OFFSETS_F[0].y + local_11c);
					fVar7 = SQRT((fVar4 - randUV.y) * (fVar4 - randUV.y) +
											 (fVar3 - randUV.x) * (fVar3 - randUV.x));
					baseUV.x = randUV.x;
					baseUV.y = randUV.y;
					if (((ushort)((ushort)(fVar7 < 0.36) << 8 | (ushort)(fVar7 == 0.36) << 0xe) != 0) &&
						 (baseUV.x = fVar3, baseUV.y = fVar4, fVar7 < 0.05)) {
						fVar8 = math::Maths_RandRange(0.0,1.0);
						fVar3 = (float)fVar8;
						fVar8 = math::Maths_RandRange(0.0,1.0);
						pPVar1 = &surfMap->blocks3D[syOff * (surfMap->dimensions).width + sx + sxDiff].textuv_1c
						;
						fVar9 = (float10)1.0 /
										SQRT(fVar8 * (float10)(float)fVar8 + (float10)fVar3 * (float10)fVar3);
						fVar10 = ((float10)pPVar1->x + fVar9 * (float10)fVar3) * (float10)0.3;
						fVar3 = (pPVar1->y + (float)(fVar9 * (float10)(float)fVar8)) * 0.3;
						randUV.y = fVar3 + *(float *)((int)&OFFSETS_F[0].y + local_11c);
						randUV.x = (float)(fVar10 + (float10)pOffset_F->x);
						pPVar1->x = (float)fVar10;
						pPVar1->y = fVar3;
					}
					local_11c += 8;
					pOffset_I = pOffset_I + 1;
					pOffset_F = pOffset_F + 1;
					vertices[dirOff].tu = fVar6 * (fVar5 * baseUV.x + randUV.x);
					dirIndex += 1;
					vertices[dirOff].tv = fVar6 * (fVar5 * baseUV.y + randUV.y);
				} while (local_11c < 0x20);
				res::Container_Mesh_SetVertices(surfMap->contMesh_24,groupID,0,4,vertices);
				tableIndex += 1;
				pCoordY = pCoordY + 2;
			} while (tableIndex < surfMap->largeCoordsNum);
		}
	}
	return;
}



void __cdecl lego::game::Map3D_Block_UpdateTextureAndVertices(SurfaceMap *surfMap,uint bx,uint by)
{
	float fVar1;
	float fVar2;
	float *pfVar3;
	BOOL BVar4;
	uint by_00;
	int iVar5;
	float *pfVar6;
	Vector3F *pVVar7;
	Direction DVar8;
	float *pfVar9;
	uint uVar10;
	float *pfVar11;
	longlong lVar12;
	longlong lVar13;
	longlong lVar14;
	Direction direction;
	uint vertIndex;
	Vector3F *pVVar15;
	int local_a0;
	int local_94;
	float local_80 [5];
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	Vector3F local_60;
	undefined4 local_54;
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F local_30 [4];
	
	DVar8 = DIRECTION_UP;
	local_80[0] = 0.0;
	local_80[1] = 0.0;
	local_80[2] = -1.0;
	local_80[3] = 0.0;
	local_80[4] = -1.0;
	local_6c = 0xbf800000;
	local_68 = 0;
	local_64 = 0xbf800000;
	local_60.x = 0.0;
	local_60.y = 0.0;
	local_60.z = 0.0;
	local_54 = 0;
	local_50 = 0;
	local_4c = 0;
	local_48 = 0;
	local_44 = 0;
	local_40 = 0;
	local_3c = 0;
	local_38 = 0;
	local_34 = 0;
	iVar5 = 4;
	pfVar3 = local_80 + 1;
	do {
		iVar5 += -1;
		pfVar3[-1] = pfVar3[-1] + (float)(ulonglong)bx;
		*pfVar3 = (float)(ulonglong)by + *pfVar3;
		pfVar3 = pfVar3 + 2;
	} while (iVar5 != 0);
	pfVar3 = local_80;
	pVVar7 = local_30;
	do {
		direction = DVar8;
		pVVar15 = pVVar7;
		lVar12 = __ftol((float10)pfVar3[1]);
		uVar10 = (uint)lVar12;
		lVar12 = __ftol((float10)*pfVar3);
		Map3D_Block_GetUnkDirectionVector0_or_C(surfMap,(uint)lVar12,uVar10,direction,pVVar15);
		DVar8 += DIRECTION_RIGHT;
		pVVar7 = pVVar7 + 1;
		pfVar3 = pfVar3 + 2;
	} while (DVar8 < DIRECTION__COUNT);
	pfVar3 = local_80;
	local_a0 = 4;
	pfVar9 = &local_60.z;
	do {
		lVar12 = __ftol((float10)pfVar3[1]);
		lVar13 = __ftol((float10)*pfVar3);
		pfVar11 = local_80;
		pfVar6 = &local_30[0].z;
		local_94 = 4;
		do {
			lVar14 = __ftol((float10)pfVar11[1]);
			uVar10 = (uint)lVar14;
			lVar14 = __ftol((float10)*pfVar11);
			BVar4 = Map3D_BlockPair_HasTextureMatch(surfMap,(uint)lVar13,(uint)lVar12,(uint)lVar14,uVar10)
			;
			if (BVar4 == 0) {
				fVar1 = pfVar6[-1];
				fVar2 = *pfVar6;
				pfVar9[-2] = pfVar6[-2] + pfVar9[-2];
				pfVar9[-1] = fVar1 + pfVar9[-1];
				*pfVar9 = fVar2 + *pfVar9;
			}
			pfVar11 = pfVar11 + 2;
			pfVar6 = pfVar6 + 3;
			local_94 += -1;
		} while (local_94 != 0);
		pfVar3 = pfVar3 + 2;
		local_a0 += -1;
		fVar1 = 1.0 / SQRT(pfVar9[-2] * pfVar9[-2] + *pfVar9 * *pfVar9 + pfVar9[-1] * pfVar9[-1]);
		*pfVar9 = fVar1 * *pfVar9;
		pfVar9[-2] = fVar1 * pfVar9[-2];
		pfVar9[-1] = fVar1 * pfVar9[-1];
		pfVar9 = pfVar9 + 3;
	} while (local_a0 != 0);
	uVar10 = 0;
	pfVar3 = local_80;
	pVVar7 = &local_60;
	do {
		vertIndex = uVar10;
		pVVar15 = pVVar7;
		lVar12 = __ftol((float10)pfVar3[1]);
		by_00 = (uint)lVar12;
		lVar12 = __ftol((float10)*pfVar3);
		Map3D_Block_SetIndexVertexNormal(surfMap,(uint)lVar12,by_00,vertIndex,pVVar15);
		uVar10 += 1;
		pVVar7 = pVVar7 + 1;
		pfVar3 = pfVar3 + 2;
	} while (uVar10 < 4);
	return;
}



BOOL __cdecl
lego::game::Map3D_BlockPair_HasTextureMatch(SurfaceMap *surfMap,uint bx1,uint by1,uint bx2,uint by2)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	SurfaceTexture tex1;
	SurfaceTexture tex2;
	
	if (((((by1 != by2) || (bx1 != bx2)) && (uVar3 = (surfMap->smallDimensions).width, bx1 < uVar3))
			&& ((uVar1 = (surfMap->smallDimensions).height, by1 < uVar1 && (bx2 < uVar3)))) &&
		 (by2 < uVar1)) {
		iVar2 = (surfMap->dimensions).width;
		tex1 = surfMap->blocks3D[by1 * iVar2 + bx1].texture;
		tex2 = surfMap->blocks3D[by2 * iVar2 + bx2].texture;
						// Find a texture coord match for the 2 block positions
		by1 = (uint)tex1;
		if ((tex1 != TEXTURE__INVALID) && (tex2 != TEXTURE__INVALID)) {
			uVar3 = 0;
						// if (surfMap->texsNum[tex1] != 0)
			if (surfMap->texsNum[by1] != 0) {
				do {
						// if (surfMap->texsGrid[tex1][i] == tex2)
					if (surfMap->texsGrid[by1][uVar3] == tex2) {
						return TRUE;
					}
					uVar3 += 1;
				} while (uVar3 < surfMap->texsNum[by1]);
				return 0;
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::Map3D_Block_SetIndexVertexNormal
					(SurfaceMap *surfMap,uint bx,uint by,uint vertIndex,Vector3F *vertNormal)
{
	D3DRMGroupIndex groupID;
	D3DRMVertex vertices [1];
	uint width;
	
	width = (surfMap->smallDimensions).width;
	groupID = by * width + bx;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		if ((surfMap->blocks3D[(surfMap->dimensions).width * by + bx].byteflags_19 &
				SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE) {
			vertIndex = vertIndex + 1 & 3;
		}
		res::Container_Mesh_GetVertices(surfMap->contMesh_24,groupID,vertIndex,1,vertices);
		vertices[0].normal.x = vertNormal->x;
		vertices[0].normal.y = vertNormal->y;
		vertices[0].normal.z = vertNormal->z;
		res::Container_Mesh_SetVertices(surfMap->contMesh_24,groupID,vertIndex,1,vertices);
	}
	return;
}



BOOL __cdecl
lego::game::Map3D_Block_GetUnkDirectionVector0_or_C
					(SurfaceMap *surfMap,uint bx,uint by,Direction direction,Vector3F *out_vector)
{
	SurfaceBlock *pSVar1;
	Vector3F *pVVar2;
	float fVar3;
	int iVar4;
	
	if ((bx < (uint)(surfMap->smallDimensions).width) &&
		 (by < (uint)(surfMap->smallDimensions).height)) {
		pSVar1 = surfMap->blocks3D + by * (surfMap->dimensions).width + bx;
		if ((pSVar1->byteflags_19 & SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE) {
			direction = direction + DIRECTION_RIGHT & DIRECTION_LEFT;
		}
		if (direction == DIRECTION_UP) {
			out_vector->x = (pSVar1->vector_0).x;
			out_vector->y = (pSVar1->vector_0).y;
			out_vector->z = (pSVar1->vector_0).z;
		}
		if (direction == DIRECTION_DOWN) {
			pVVar2 = &surfMap->blocks3D[by * (surfMap->dimensions).width + bx].vector_c;
			out_vector->x = pVVar2->x;
			out_vector->y = pVVar2->y;
			out_vector->z = pVVar2->z;
		}
		if ((direction == DIRECTION_RIGHT) || (direction == DIRECTION_LEFT)) {
			pSVar1 = surfMap->blocks3D + by * (surfMap->dimensions).width + bx;
			out_vector->x = (pSVar1->vector_0).x;
			out_vector->y = (pSVar1->vector_0).y;
			out_vector->z = (pSVar1->vector_0).z;
			iVar4 = by * (surfMap->dimensions).width + bx;
			pVVar2 = &surfMap->blocks3D[iVar4].vector_c;
			out_vector->x = surfMap->blocks3D[iVar4].vector_c.x + out_vector->x;
			out_vector->y = pVVar2->y + out_vector->y;
			fVar3 = pVVar2->z + out_vector->z;
			out_vector->z = fVar3;
			fVar3 = 1.0 / SQRT(out_vector->x * out_vector->x +
												 fVar3 * fVar3 + out_vector->y * out_vector->y);
			out_vector->x = fVar3 * out_vector->x;
			out_vector->y = fVar3 * out_vector->y;
			out_vector->z = fVar3 * out_vector->z;
		}
		return TRUE;
	}
	out_vector->z = 0.0;
	out_vector->y = 0.0;
	out_vector->x = 0.0;
	return 0;
}



void __cdecl
lego::game::Map3D_Block_SetIndexVertexPosition
					(SurfaceMap *surfMap,uint bx,uint by,uint vertIndex,Vector3F *vertPosition)
{
	D3DRMGroupIndex groupID;
	D3DRMVertex vertices [1];
	uint width;
	
	width = (surfMap->smallDimensions).width;
	groupID = by * width + bx;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		if ((surfMap->blocks3D[(surfMap->dimensions).width * by + bx].byteflags_19 &
				SURFMAP_STRUCT28_UNK_1) != SURFMAP_STRUCT28_NONE) {
			vertIndex = vertIndex + 1 & 3;
		}
		res::Container_Mesh_GetVertices(surfMap->contMesh_24,groupID,vertIndex,1,vertices);
		vertices[0].position.x = vertPosition->x + vertices[0].position.x;
		vertices[0].position.y = vertPosition->y + vertices[0].position.y;
		vertices[0].position.z = vertPosition->z + vertices[0].position.z;
		res::Container_Mesh_SetVertices(surfMap->contMesh_24,groupID,vertIndex,1,vertices);
	}
	return;
}



void __cdecl lego::game::Map3D_Block_InitPlaneNormals(SurfaceMap *surfMap,uint bx,uint by)
{
	D3DRMVertex vertices [4];
	uint width;
	
	width = (surfMap->smallDimensions).width;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		res::Container_Mesh_GetVertices(surfMap->contMesh_24,by * width + bx,0,4,vertices);
						// (&surfMap->ptr_28[sy * surfMap->dimensions.width + sx].vector_0,
						//   &vertices[0].position, &vertices[1].position, &vertices[2].position)
		math::Maths_PlaneNormal
							(&surfMap->blocks3D[by * (surfMap->dimensions).width + bx].vector_0,
							 &vertices[0].position,&vertices[1].position,&vertices[3].position);
						// (&surfMap->ptr_28[sy * surfMap->dimensions.width + sx].vector_c,
						//   &vertices[1].position, &vertices[2].position, &vertices[3].position)
						// 
						// NOTE: index is shift one after the previous call
		math::Maths_PlaneNormal
							(&surfMap->blocks3D[by * (surfMap->dimensions).width + bx].vector_c,
							 &vertices[1].position,&vertices[2].position,&vertices[3].position);
	}
	return;
}



void __cdecl
lego::game::MapFile_GetDimensions(MapFileInfo *mapFileInfo,uint *out_width,uint *out_height)
{
	*out_width = (mapFileInfo->dimensions).width;
	*out_height = (mapFileInfo->dimensions).height;
	return;
}



ushort __cdecl lego::game::MapFile_GetBlock(MapFileInfo *mapFile,int x,int y,int width)
{
	return mapFile->blocks[width * y + x];
}



BOOL __cdecl
lego::game::Map3D_Intersections_Sub2_FUN_004518a0
					(SurfaceMap *surfMap,uint bx,uint by,Vector3F *param_4,Vector3F *param_5,
					Vector3F *out_vector)
{
	SurfaceBlock *pSVar1;
	Vector3F *pVVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	bool bVar9;
	int iVar10;
	BOOL BVar11;
	Point2F local_88;
	Vector3F local_7c;
	Point2F local_70;
	Point2F local_68;
	float local_60;
	float local_5c;
	float local_58;
	float local_54;
	Vector3F local_50;
	Vector3F local_44;
	int local_38;
	BOOL local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	Vector3F local_18;
	float local_c;
	float local_8;
	
	local_34 = Map3D_GetBlockVertexPositions2(surfMap,bx,by,&local_30);
	bVar9 = false;
	local_38 = 0;
	iVar10 = by * (surfMap->dimensions).width + bx;
	pSVar1 = surfMap->blocks3D + iVar10;
	local_7c.x = surfMap->blocks3D[iVar10].vector_0.x;
	local_7c.y = (pSVar1->vector_0).y;
	local_7c.z = (pSVar1->vector_0).z;
	BVar11 = math::Maths_RayPlaneIntersection(&local_50,param_4,param_5,&local_30,&local_7c);
	if (BVar11 != 0) {
		if (local_34 == 0) {
			local_68.x = local_24;
			local_68.y = local_20;
		}
		else {
			local_68.x = local_18.x;
			local_68.y = local_18.y;
		}
		local_88.x = local_50.x;
		local_88.y = local_50.y;
		BVar11 = math::Maths_PointInsidePoly(&local_88,&local_70,&local_68,3);
		if (BVar11 != 0) {
			bVar9 = true;
		}
	}
	iVar10 = by * (surfMap->dimensions).width + bx;
	pVVar2 = &surfMap->blocks3D[iVar10].vector_c;
	local_7c.x = surfMap->blocks3D[iVar10].vector_c.x;
	local_7c.y = pVVar2->y;
	local_7c.z = pVVar2->z;
	BVar11 = math::Maths_RayPlaneIntersection(&local_44,param_4,param_5,&local_18,&local_7c);
	if (BVar11 != 0) {
		if (local_34 == 0) {
			local_68.x = local_18.x;
			local_68.y = local_18.y;
			local_60 = local_c;
			local_5c = local_8;
			local_58 = local_24;
			local_54 = local_20;
		}
		else {
			local_68.x = local_24;
			local_68.y = local_20;
			local_60 = local_18.x;
			local_5c = local_18.y;
			local_58 = local_30.x;
			local_54 = local_30.y;
		}
		local_88.x = local_44.x;
		local_88.y = local_44.y;
		local_70.x = local_58;
		local_70.y = local_54;
		BVar11 = math::Maths_PointInsidePoly(&local_88,&local_70,&local_68,3);
		if (BVar11 != 0) {
			local_38 = 1;
		}
	}
	if (!bVar9) {
		if (local_38 == 0) {
			return 0;
		}
		if (true) goto LAB_00451c3e;
	}
	if (local_38 == 0) {
		if (bVar9) {
			out_vector->x = local_50.x;
			out_vector->y = local_50.y;
			out_vector->z = local_50.z;
			return TRUE;
		}
	}
	else {
		fVar3 = local_50.x - param_4->x;
		fVar4 = local_44.x - param_4->x;
		fVar8 = local_50.y - param_4->y;
		fVar5 = local_44.y - param_4->y;
		fVar7 = local_50.z - param_4->z;
		fVar6 = local_44.z - param_4->z;
		fVar3 = SQRT(fVar7 * fVar7 + fVar8 * fVar8 + fVar3 * fVar3);
		fVar4 = SQRT(fVar6 * fVar6 + fVar5 * fVar5 + fVar4 * fVar4);
		if ((ushort)((ushort)(fVar4 < fVar3) << 8 | (ushort)(fVar4 == fVar3) << 0xe) == 0) {
			out_vector->x = local_50.x;
			out_vector->y = local_50.y;
			out_vector->z = local_50.z;
			return TRUE;
		}
	}
LAB_00451c3e:
	out_vector->x = local_44.x;
	out_vector->y = local_44.y;
	out_vector->z = local_44.z;
	return TRUE;
}



PolyMeshData * __cdecl
lego::res::MeshPoly_Create
					(PolyMeshData *lastPolyData,char *partName,char *dirname,char *meshFilename,uint index)
{
	char cVar1;
	Container *pCVar2;
	PolyMeshData *pPVar3;
	undefined4 *puVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char filenameBuffer [256];
	
	std::sprintf(filenameBuffer,"%s\\%s",dirname,meshFilename);
	pCVar2 = Container_Load(NULL,filenameBuffer,"LWO",1);
	if (pCVar2 == NULL) {
		pCVar2 = Container_Load(NULL,filenameBuffer,"MESH",1);
		if (pCVar2 == NULL) {
			return NULL;
		}
	}
	pPVar3 = (PolyMeshData *)std::malloc(0x18);
	pPVar3->flags = 2;
	if (lastPolyData != NULL) {
		lastPolyData->next = pPVar3;
	}
	pPVar3->contMeshOrigin = pCVar2;
	uVar5 = 0xffffffff;
	pPVar3->next = NULL;
	pPVar3->index = index;
	pcVar8 = partName;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar1 != '\0');
	puVar4 = (undefined4 *)std::malloc(~uVar5);
	uVar5 = 0xffffffff;
	pPVar3->partName = (char *)puVar4;
	do {
		pcVar8 = partName;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar8 = partName + 1;
		cVar1 = *partName;
		partName = pcVar8;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	puVar7 = (undefined4 *)(pcVar8 + -uVar5);
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
		*puVar4 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar4 = puVar4 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar4 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	pPVar3->contMeshTarget = NULL;
	return pPVar3;
}



PolyMeshData * __cdecl
lego::res::MeshPoly_CreateNull(PolyMeshData *lastPolyData,char *partName,uint index)
{
	char cVar1;
	PolyMeshData *pPVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	
	pPVar2 = (PolyMeshData *)std::malloc(0x18);
	pPVar2->flags = 2;
	if (lastPolyData != NULL) {
		lastPolyData->next = pPVar2;
	}
	pPVar2->index = index;
	uVar4 = 0xffffffff;
	pPVar2->next = NULL;
	pPVar2->contMeshOrigin = NULL;
	pcVar7 = partName;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (cVar1 != '\0');
	puVar3 = (undefined4 *)std::malloc(~uVar4);
	uVar4 = 0xffffffff;
	pPVar2->partName = (char *)puVar3;
	do {
		pcVar7 = partName;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar7 = partName + 1;
		cVar1 = *partName;
		partName = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar3 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar3 = puVar3 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar3 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	pPVar2->contMeshTarget = NULL;
	return pPVar2;
}



PolyMeshData * __cdecl lego::res::MeshPoly_Duplicate(PolyMeshData *polyData)
{
	PolyMeshData *pPVar1;
	int iVar2;
	int iVar3;
	uint *puVar4;
	PolyMeshData *pPVar5;
	Container **ppCVar6;
	
	iVar2 = 0;
	pPVar1 = polyData;
	if (polyData != NULL) {
		do {
			pPVar1 = pPVar1->next;
			iVar2 += 1;
		} while (pPVar1 != NULL);
	}
	if (iVar2 == 0) {
		return NULL;
	}
	pPVar1 = (PolyMeshData *)std::malloc(iVar2 * 0x18);
	iVar2 = 0;
	if (polyData != NULL) {
		puVar4 = &pPVar1->flags;
		do {
			pPVar5 = polyData;
			ppCVar6 = (Container **)(puVar4 + -4);
			for (iVar3 = 6; iVar3 != 0; iVar3 += -1) {
				*ppCVar6 = pPVar5->contMeshOrigin;
				pPVar5 = (PolyMeshData *)&pPVar5->contMeshTarget;
				ppCVar6 = ppCVar6 + 1;
			}
			puVar4[-3] = 0;
			iVar2 += 1;
			*puVar4 = *puVar4 & 0xfffffffd | 1;
			puVar4[1] = (uint)(puVar4 + 2);
			polyData = polyData->next;
			puVar4 = puVar4 + 6;
		} while (polyData != NULL);
	}
	pPVar1->flags = pPVar1->flags | 2;
	pPVar1[iVar2 + -1].next = NULL;
	return pPVar1;
}



void __cdecl
lego::res::MeshPoly_Container_SwapFrame
					(PolyMeshData *polyData,Container *contAct,BOOL restore,int frameIndex)
{
	char *name;
	Container *contTarget;
	
	if (polyData != NULL) {
		do {
			if (frameIndex == polyData->index) {
				if (polyData->contMeshTarget == NULL) {
					name = Container_FormatPartName(contAct,polyData->partName,NULL);
					contTarget = Container_SearchTree(contAct,name,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
					polyData->contMeshTarget = contTarget;
				}
				if (polyData->contMeshTarget != NULL) {
					Container_Mesh_Swap(polyData->contMeshTarget,polyData->contMeshOrigin,restore);
				}
			}
			polyData = polyData->next;
		} while (polyData != NULL);
	}
	return;
}



void __cdecl lego::res::MeshPoly_RemoveTarget(PolyMeshData *polyData)
{
	if (polyData != NULL) {
		do {
			polyData->contMeshTarget = NULL;
			polyData = polyData->next;
		} while (polyData != NULL);
	}
	return;
}



void __cdecl lego::res::MeshPoly_Destroy(PolyMeshData *polyData)
{
	PolyMeshData **ppPVar1;
	PolyMeshData *pPVar2;
	PolyMeshData *pPVar3;
	PolyMeshData *pPVar4;
	
	pPVar3 = NULL;
	pPVar2 = polyData;
	pPVar4 = pPVar3;
	if (polyData != NULL) {
		do {
			if ((*(byte *)&pPVar2->flags & 1) == 0) {
				if (pPVar2->partName != NULL) {
					std::free(pPVar2->partName);
				}
				if (pPVar2->contMeshOrigin != NULL) {
					Container_Remove(pPVar2->contMeshOrigin);
				}
			}
			pPVar3 = pPVar2;
			if (((*(byte *)&pPVar2->flags & 2) == 0) && (pPVar3 = pPVar4, pPVar4 != NULL)) {
				pPVar4->next = pPVar2->next;
			}
			ppPVar1 = &pPVar2->next;
			pPVar2 = *ppPVar1;
			pPVar4 = pPVar3;
		} while (*ppPVar1 != NULL);
	}
	if ((pPVar3 != NULL) && (polyData != NULL)) {
		do {
			pPVar2 = polyData->next;
			std::free(polyData);
			polyData = pPVar2;
		} while (pPVar2 != NULL);
	}
	return;
}



void __cdecl lego::game::Message_Initialise(void)
{
	globs::messageGlobs.messageName[0] = "Message_Null";
	globs::messageGlobs.messageName[1] = "Message_Select";
	globs::messageGlobs.messageName[2] = "Message_Selected";
	globs::messageGlobs.messageName[3] = "Message_ClearSelection";
	globs::messageGlobs.messageName[4] = "Message_Deselect";
	globs::messageGlobs.messageName[5] = "Message_Goto";
	globs::messageGlobs.messageName[6] = "Message_RockMonsterGoto";
	globs::messageGlobs.messageName[7] = "Message_RockMonsterGotoComplete";
	globs::messageGlobs.messageName[8] = "Message_UserGoto";
	globs::messageGlobs.messageName[9] = "Message_FirstPerson";
	globs::messageGlobs.messageName[10] = "Message_TrackObject";
	globs::messageGlobs.messageName[11] = "Message_TopView";
	globs::messageGlobs.messageName[12] = "Message_PlaySample";
	globs::messageGlobs.messageName[13] = "Message_Dig";
	globs::messageGlobs.messageName[14] = "Message_DigComplete";
	globs::messageGlobs.messageName[15] = "Message_Repair";
	globs::messageGlobs.messageName[16] = "Message_RepairComplete";
	globs::messageGlobs.messageName[17] = "Message_Reinforce";
	globs::messageGlobs.messageName[18] = "Message_ReinforceComplete";
	globs::messageGlobs.messageName[19] = "Message_RockFall";
	globs::messageGlobs.messageName[20] = "Message_RockFallComplete";
	globs::messageGlobs.messageName[21] = "Message_GenerateCrystal";
	globs::messageGlobs.messageName[22] = "Message_GenerateCrystalComplete";
	globs::messageGlobs.messageName[23] = "Message_CollectCrystal";
	globs::messageGlobs.messageName[24] = "Message_CollectCrystalComplete";
	globs::messageGlobs.messageName[25] = "Message_CrystalToRefinery";
	globs::messageGlobs.messageName[26] = "Message_CrystalToRefineryComplete";
	globs::messageGlobs.messageName[27] = "Message_GenerateOre";
	globs::messageGlobs.messageName[28] = "Message_GenerateOreComplete";
	globs::messageGlobs.messageName[29] = "Message_CollectOre";
	globs::messageGlobs.messageName[30] = "Message_CollectOreComplete";
	globs::messageGlobs.messageName[31] = "Message_GenerateRockMonster";
	globs::messageGlobs.messageName[32] = "Message_GenerateRockMonsterComplete";
	globs::messageGlobs.messageName[33] = "Message_GatherRock";
	globs::messageGlobs.messageName[34] = "Message_GatherRockComplete";
	globs::messageGlobs.messageName[35] = "Message_PickRandomFloor";
	globs::messageGlobs.messageName[36] = "Message_PickRandomFloorComplete";
	globs::messageGlobs.messageName[37] = "Message_AttackBuilding";
	globs::messageGlobs.messageName[38] = "Message_AttackBuildingComplete";
	globs::messageGlobs.messageName[39] = "Message_Clear";
	globs::messageGlobs.messageName[40] = "Message_ClearComplete";
	globs::messageGlobs.messageName[41] = "Message_GetIn";
	globs::messageGlobs.messageName[42] = "Message_ManSelectedAndMonsterClicked";
	globs::messageGlobs.messageName[43] = "Message_FollowAttack";
	globs::messageGlobs.messageName[44] = "Message_CollectTool";
	globs::messageGlobs.messageName[45] = "Message_ReduceSelection";
	globs::messageGlobs.messageName[46] = "Message_ClearFallIn";
	globs::messageGlobs.messageName[47] = "Message_ClearFallInComplete";
	globs::messageGlobs.messageName[48] = "Message_BuildPath";
	globs::messageGlobs.messageName[49] = "Message_BuildPathComplete";
	globs::messageGlobs.messageName[50] = "Message_Train";
	globs::messageGlobs.messageName[51] = "Message_TrainComplete";
	globs::messageGlobs.messageName[52] = "Message_GenerateCrystalAndOre";
	globs::messageGlobs.messageName[53] = "Message_GenerateCrystalAndOreComplete";
	globs::messageGlobs.messageName[54] = "Message_GenerateFromCryOre";
	globs::messageGlobs.messageName[55] = "Message_GenerateFromCryOreComplete";
	globs::messageGlobs.messageName[56] = "Message_Upgrade";
	globs::messageGlobs.messageName[57] = "Message_UpgradeComplete";
	globs::messageGlobs.messageName[58] = "Message_ClearBuilding";
	globs::messageGlobs.messageName[59] = "Message_ClearBuildingComplete";
	globs::messageGlobs.messageName[60] = "Message_ClearInitial";
	globs::messageGlobs.messageName[61] = "Message_ClearInitialComplete";
	globs::messageGlobs.messageName[62] = "Message_ClearRemovePath";
	globs::messageGlobs.messageName[63] = "Message_ClearRemovePathComplete";
	globs::messageGlobs.messageName[64] = "Message_Debug_DestroyAll";
	return;
}



void __cdecl lego::game::Message_LiveObject_FUN_00452220(LiveObject *liveObj)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	MessageAction *pMVar5;
	MessageAction *pMVar6;
	
	uVar4 = 0;
	uVar2 = globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool];
	if (uVar2 != 0) {
		do {
			uVar3 = uVar2;
			if (liveObj ==
					globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool][uVar4].argumentObj)
			{
				uVar3 = uVar2 - 1;
				pMVar5 = globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool + -1] +
								 uVar2 + 0x7ff;
				pMVar6 = globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool] + uVar4;
				for (iVar1 = 5; iVar1 != 0; iVar1 += -1) {
					pMVar6->event = pMVar5->event;
					pMVar5 = (MessageAction *)&pMVar5->argumentObj;
					pMVar6 = (MessageAction *)&pMVar6->argumentObj;
				}
				globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = uVar3;
			}
			uVar4 += 1;
			uVar2 = uVar3;
		} while (uVar4 < uVar3);
	}
	return;
}



int __cdecl lego::game::Message_LookupPTLEventIndex(char *ptlName)
{
	int cmpResult;
	char **ppcVar1;
	int index;
	
	index = 0;
	ppcVar1 = globs::messageGlobs.messageName;
	do {
		cmpResult = std::_stricmp(*ppcVar1 + 8,ptlName);
		if (cmpResult == 0) {
			return index;
		}
		ppcVar1 = ppcVar1 + 1;
		index += 1;
	} while (ppcVar1 < &globs::messageGlobs.reserved1);
	return cmpResult;
}



void __cdecl
lego::game::Message_Debug_RegisterSelectedUnitHotkey
					(KeysByte key,MessageType messageType,LiveObject *argumentObj,undefined4 argument2,
					Point2I *opt_position)
{
	uint uVar1;
	
	globs::messageGlobs.hotkeyList[globs::messageGlobs.hotkeyCount] = key;
	uVar1 = globs::messageGlobs.hotkeyCount;
	globs::messageGlobs.hotkeyMessages[globs::messageGlobs.hotkeyCount].event = messageType;
	globs::messageGlobs.hotkeyMessages[uVar1].argument2 = argument2;
	globs::messageGlobs.hotkeyMessages[uVar1].argumentObj = argumentObj;
	if (opt_position != NULL) {
		globs::messageGlobs.hotkeyMessages[uVar1].position.x = opt_position->x;
		globs::messageGlobs.hotkeyMessages[uVar1].position.y = opt_position->y;
	}
	globs::messageGlobs.hotkeyCount += 1;
	return;
}



void __cdecl
lego::game::Message_AddMessageAction
					(MessageType messageType,LiveObject *argument1Obj,undefined4 argument2,
					Point2I *opt_blockPos)
{
	MessageAction *pMVar1;
	uint uVar2;
	BOOL BVar3;
	
	BVar3 = globs::messageGlobs.messageX2Bool;
	uVar2 = globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool];
	if (uVar2 < 0x800) {
		globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = uVar2 + 1;
		pMVar1 = globs::messageGlobs.messageTableX2[BVar3] + uVar2;
		pMVar1->event = MESSAGE_NULL;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argumentObj = NULL;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argument2 = 0;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].position.x = 0;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].position.y = 0;
		pMVar1->event = messageType;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argumentObj = argument1Obj;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argument2 = argument2;
		if (opt_blockPos != NULL) {
			globs::messageGlobs.messageTableX2[BVar3][uVar2].position.x = opt_blockPos->x;
			globs::messageGlobs.messageTableX2[BVar3][uVar2].position.y = opt_blockPos->y;
		}
	}
	return;
}



void __cdecl lego::game::Message_PTL_Update(void)
{
	BOOL BVar1;
	undefined4 *puVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	
	if (((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
		 (uVar4 = 0, globs::messageGlobs.hotkeyCount != 0)) {
		puVar2 = &globs::messageGlobs.hotkeyMessages[0].argument2;
		do {
			if (globs::INPUT.Key_Map[globs::messageGlobs.hotkeyList[uVar4]] != false) {
				Message_AddMessageAction(puVar2[-2],puVar2[-1],*puVar2,(Point2I *)(puVar2 + 1));
			}
			uVar4 += 1;
			puVar2 = puVar2 + 5;
		} while (uVar4 < globs::messageGlobs.hotkeyCount);
	}
	uVar4 = 0;
	if (globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] != 0) {
		do {
			PTL_EventToAction(globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool] +
												uVar4);
			uVar4 += 1;
		} while (uVar4 < globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool]);
	}
	BVar1 = globs::messageGlobs.messageX2Bool;
	uVar4 = globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool];
	globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = 0;
	globs::messageGlobs.messageX2Bool = ZEXT14(globs::messageGlobs.messageX2Bool == 0);
	globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = 0;
	if (uVar4 != 0) {
		ppLVar3 = (LiveObject **)&globs::messageGlobs.messageTableX2[BVar1][0].argument2;
		do {
			if (true) {
				switch(ppLVar3[-2]) {
				case (LiveObject *)0x1:
					Message_PTL_Select_LiveObject(ppLVar3[-1],(int)*ppLVar3);
					break;
				case (LiveObject *)0x3:
					Message_PTL_ClearSelection();
					break;
				case (LiveObject *)0x4:
					Message_PTL_Deselect_LiveObject(ppLVar3[-1]);
					break;
				case (LiveObject *)0x5:
				case (LiveObject *)0x6:
					ai::AITask_Game_PTL_GotoOrRMGoto(ppLVar3[-1],(Point2I *)(ppLVar3 + 1),*ppLVar3);
					break;
				case (LiveObject *)0x8:
					ai::AITask_Game_PTL_UserGoto
										(globs::messageGlobs.selectedUnitList,globs::messageGlobs.selectedUnitCount,
										 (Point2I *)(ppLVar3 + 1),(BOOL)*ppLVar3);
					break;
				case (LiveObject *)0x9:
					Message_PTL_FirstPerson((int)*ppLVar3);
					break;
				case (LiveObject *)0xa:
					if (globs::messageGlobs.selectedUnitCount != 0) {
						Game_TrackObjectInRadar(globs::messageGlobs.selectedUnitList[0]);
					}
					break;
				case (LiveObject *)0xb:
					lrr::Lego_SetViewMode(VIEW_TOPDOWN,NULL,0);
					break;
				case (LiveObject *)0xc:
					snd::SFX_Sample_Random_Play_OrAddToQueue((SFXType)*ppLVar3,FALSE);
					break;
				case (LiveObject *)0x13:
					Game_PTL_RockFall((uint)ppLVar3[1],(uint)ppLVar3[2],(uint)*ppLVar3 & 0xffff,
														(uint)*ppLVar3 >> 0x10);
					break;
				case (LiveObject *)0x15:
					Level_GenerateCrystal((Point2I *)(ppLVar3 + 1),0,NULL,TRUE);
					break;
				case (LiveObject *)0x17:
					ai::AITask_DoCollect(ppLVar3[-1],0.0);
					break;
				case (LiveObject *)0x19:
					ai::AITask_Game_PTL_CrystalToRefinery(ppLVar3[-1],*ppLVar3);
					break;
				case (LiveObject *)0x1b:
					Level_GenerateOre((Point2I *)(ppLVar3 + 1),0,NULL,TRUE);
					break;
				case (LiveObject *)0x1d:
					ai::AITask_DoCollect(ppLVar3[-1],0.0);
					break;
				case (LiveObject *)0x1f:
					Game_PTL_GenerateRockMonster();
					break;
				case (LiveObject *)0x21:
					Game_PTL_GatherRock(ppLVar3[-1]);
					break;
				case (LiveObject *)0x23:
					Message_PTL_PickRandomFloor(ppLVar3[-1]);
					break;
				case (LiveObject *)0x25:
					Game_PTL_AttackBuilding(ppLVar3[-1],*ppLVar3);
					break;
				case (LiveObject *)0x2b:
					ai::AITask_Game_PTL_FollowAttack(ppLVar3[-1],*ppLVar3);
					break;
				case (LiveObject *)0x2d:
					Message_PTL_ReduceSelection();
					break;
				case (LiveObject *)0x34:
					Game_PTL_GenerateCrystalsAndOre((Point2I *)(ppLVar3 + 1),0);
					break;
				case (LiveObject *)0x36:
					Game_PTL_GenerateFromCryOre((Point2I *)(ppLVar3 + 1));
					break;
				case (LiveObject *)0x40:
					Message_PTL_Debug_DestroyAll();
				}
			}
			ppLVar3 = ppLVar3 + 5;
			uVar4 -= 1;
		} while (uVar4 != 0);
	}
	return;
}



void __cdecl lego::game::Message_PTL_PickRandomFloor(LiveObject *liveObj)
{
	short rng;
	SurfaceMap *pSVar1;
	BOOL BVar2;
	uint uVar3;
	Point2I blockPos;
	int height;
	bool success;
	int width;
	
	pSVar1 = lrr::Lego_GetMap();
	width = (pSVar1->smallDimensions).width;
	pSVar1 = lrr::Lego_GetMap();
	height = (pSVar1->smallDimensions).height;
	success = false;
	uVar3 = 0;
	do {
		rng = math::Maths_Rand();
		blockPos.x = (int)rng % width;
		rng = math::Maths_Rand();
		blockPos.y = (int)rng % height;
		BVar2 = Level_Block_IsGround(blockPos.x,blockPos.y);
		if (BVar2 != 0) {
			success = true;
			break;
		}
		uVar3 += 1;
	} while (uVar3 < 1000);
	if (success) {
		Message_AddMessageAction(MESSAGE_PICKRANDOMFLOOR_COMPLETE,liveObj,0,&blockPos);
	}
	return;
}



void __cdecl lego::game::Message_LiveObject_FUN_00452770(LiveObject *liveObj)
{
	Message_LiveObject_FUN_00452220(liveObj);
	Message_PTL_Deselect_LiveObject(liveObj);
	if (globs::legoGlobs.objectFP == liveObj) {
		lrr::Lego_SetViewMode(VIEW_TOPDOWN,NULL,0);
		globs::legoGlobs.objectFP = NULL;
	}
	if ((globs::legoGlobs.cameraRadar)->trackObj == liveObj) {
		(globs::legoGlobs.cameraRadar)->trackObj = NULL;
		LiveObject_GetPosition
							(liveObj,&globs::legoGlobs.tvFaceDirection_338.x,
							 &globs::legoGlobs.tvFaceDirection_338.y);
		globs::legoGlobs.flags1 |= GAME1_UNK_4000;
	}
	return;
}



BOOL __cdecl lego::game::Message_CopySelectedUnits(LiveObject **out_unitsTable,uint *out_unitsCount)
{
	LiveObject *pLVar1;
	uint uVar2;
	int iVar3;
	LiveObject **ppLVar4;
	
	if (globs::messageGlobs.selectedUnitCount != 0) {
		*out_unitsCount = globs::messageGlobs.selectedUnitCount;
		pLVar1 = (LiveObject *)std::malloc(globs::messageGlobs.selectedUnitCount * 4);
		*out_unitsTable = pLVar1;
		ppLVar4 = globs::messageGlobs.selectedUnitList;
		for (uVar2 = *out_unitsCount & 0x3fffffff; uVar2 != 0; uVar2 -= 1) {
			pLVar1->objType = (ObjectType)*ppLVar4;
			ppLVar4 = ppLVar4 + 1;
			pLVar1 = (LiveObject *)&pLVar1->objIndex;
		}
		for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
			*(undefined *)&pLVar1->objType = *(undefined *)ppLVar4;
			ppLVar4 = (LiveObject **)((int)ppLVar4 + 1);
			pLVar1 = (LiveObject *)((int)&pLVar1->objType + 1);
		}
		return TRUE;
	}
	return 0;
}



// Returns the table of selected units, and can return the number of units in the table with
// out_count

LiveObject ** __cdecl lego::game::Message_GetSelectedUnits2(uint *out_count)
{
	if (globs::messageGlobs.selectedUnitCount != 0) {
		if (out_count != NULL) {
			*out_count = globs::messageGlobs.selectedUnitCount;
		}
		return globs::messageGlobs.selectedUnitList;
	}
	if (out_count != NULL) {
		*out_count = 0;
	}
	return NULL;
}



BOOL __cdecl lego::game::Message_IsAnyUnitsSelected(void)
{
	return (uint)(globs::messageGlobs.selectedUnitCount != 0);
}



LiveObject * __cdecl lego::game::Message_GetPrimarySelectedUnit(void)
{
						// Return the first-selected Object if count is non-zero (otherwise address is masked
						// against 0x0)
	return (LiveObject *)
				 (-(uint)(globs::messageGlobs.selectedUnitCount != 0) &
				 (uint)globs::messageGlobs.selectedUnitList[0]);
}



LiveObject ** __cdecl lego::game::Message_GetSelectedUnits(void)
{
	return globs::messageGlobs.selectedUnitList;
}



uint __cdecl lego::game::Message_GetNumSelectedUnits(void)
{
	return globs::messageGlobs.selectedUnitCount;
}



void __cdecl lego::game::Message_CleanupSelectedUnitsCount(void)
{
	globs::messageGlobs.selectedUnitCount = 0;
	return;
}



BOOL __cdecl
lego::game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(LiveObject *liveObj,uint *out_index)
{
	LiveFlags3 LVar1;
	
	if (out_index != NULL) {
		LVar1 = LiveObject_FindIndexOfInTable
											(globs::messageGlobs.selectedUnitList,globs::messageGlobs.selectedUnitCount,
											 liveObj,out_index);
		return LVar1;
	}
	return liveObj->flags3 & LIVEOBJ3_UNK_200000;
}



BOOL __cdecl
lego::game::LiveObject_FindIndexOfInTable
					(LiveObject **objsTable,uint objsCount,LiveObject *thisObj,uint *out_index)
{
	uint i;
	
	i = 0;
	if (objsCount == 0) {
		return 0;
	}
	do {
		if (*objsTable == thisObj) {
			if (out_index != NULL) {
				*out_index = i;
			}
			return TRUE;
		}
		i += 1;
		objsTable = objsTable + 1;
	} while (i < objsCount);
	return 0;
}



BOOL __cdecl lego::game::Message_LiveObject_Check_FUN_00452950(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,NULL);
	if ((BVar1 == 0) && ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_2) == 0)) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::game::Message_PTL_Select_LiveObject(LiveObject *liveObj,int param_2)
{
	BOOL BVar1;
	
	BVar1 = Message_LiveObject_DoSelect_FUN_004529a0(liveObj,param_2,1);
	return BVar1;
}



BOOL __cdecl
lego::game::Message_LiveObject_DoSelect_FUN_004529a0(LiveObject *liveObj,BOOL param_2,BOOL param_3)
{
	BOOL BVar1;
	ObjectStatsFlags1 sflags1;
	Container *cont;
	Point2F local_14;
	Vector3F local_c;
	
	if (liveObj->carryingThisObject != NULL) {
		liveObj = liveObj->carryingThisObject;
	}
	BVar1 = Message_LiveObject_Check_FUN_00452b30(liveObj);
	if (BVar1 != 0) {
		if (param_2 == 0) {
			BVar1 = Message_LiveObject_Check_FUN_00452950(liveObj);
			if (BVar1 != 0) {
				LiveObject_FUN_0044c760(liveObj);
				return 0;
			}
		}
		BVar1 = Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,NULL);
		if ((BVar1 == 0) && (globs::messageGlobs.selectedUnitCount < 100)) {
			Search_LiveObjects_SkipIgnoreMes
								(LiveObject_Callback_UnkLaserTrackerToggleUnset_FUN_0044c7c0,NULL);
			globs::messageGlobs.selectedUnitList[globs::messageGlobs.selectedUnitCount] = liveObj;
			globs::messageGlobs.selectedUnitCount += 1;
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_200000;
			if ((liveObj->objType != OBJECT_BUILDING) &&
				 (((liveObj->flags1 & (LIVEOBJ1_UNK_2000|LIVEOBJ1_UNK_4000000|LIVEOBJ1_REST)) ==
					 LIVEOBJ1_NONE && ((liveObj->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)))) {
				LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
				ai::AITask_VariousGatherTasks_FUN_00403a90(liveObj);
				if ((liveObj->objType == OBJECT_MINIFIGURE) && (param_3 != 0)) {
					res::Container_GetOrientation((globs::legoGlobs.cameraMain)->cont4,NULL,&local_c,NULL);
					local_14.x = -local_c.x;
					local_14.y = -local_c.y;
					LiveObject_FUN_00441df0(liveObj,FALSE,FALSE);
					LiveObject_FUN_00445270(liveObj,&local_14);
				}
			}
			if ((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_80) != 0) {
				sflags1 = stats::StatsObject_GetStatsFlags1(liveObj);
				if (((sflags1 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) {
					cont = LiveObject_GetContainer(liveObj);
					res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SFX_YESSIR,FALSE,TRUE,NULL);
					return TRUE;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Message_LiveObject_Check_FUN_00452b30(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->flags3 & LIVEOBJ3_CANSELECT) != LIVEOBJ3_NONE) {
		BVar1 = LiveObject_CheckCondition_AndIsPowered(liveObj,TRUE);
		if ((((BVar1 != 0) && ((*(byte *)&liveObj->flags2 & 10) == 0)) &&
				((liveObj->flags1 & (LIVEOBJ1_UNK_4000000|LIVEOBJ1_REST)) == LIVEOBJ1_NONE)) &&
			 ((liveObj->objType != OBJECT_VEHICLE ||
				((liveObj->flags1 & LIVEOBJ1_CLEARING) == LIVEOBJ1_NONE)))) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::Message_PTL_ReduceSelection(void)
{
	LiveObject *pLVar1;
	ObjectType OVar2;
	LiveObject *pLVar3;
	bool bVar4;
	bool bVar5;
	bool bVar6;
	bool bVar7;
	bool bVar8;
	bool bVar9;
	bool bVar10;
	bool bVar11;
	int iVar12;
	ObjectStatsFlags1 OVar13;
	LiveObject **ppLVar14;
	uint uVar15;
	InterfaceMenuType interfaceMenuType;
	
	uVar15 = 0;
	bVar5 = false;
	bVar6 = false;
	bVar8 = false;
	bVar7 = false;
	bVar9 = false;
	bVar10 = false;
	bVar11 = false;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar14 = globs::messageGlobs.selectedUnitList;
		do {
			pLVar1 = *ppLVar14;
			if ((pLVar1->objType == OBJECT_MINIFIGURE) && (pLVar1->drivenObject == NULL)) {
				bVar5 = true;
				break;
			}
			OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
			if ((OVar13 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
				OVar2 = pLVar1->objType;
				if (OVar2 == OBJECT_VEHICLE) {
					OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
						bVar7 = true;
					}
					else {
						bVar6 = true;
					}
				}
				else {
					if (OVar2 == OBJECT_BUILDING) {
						bVar9 = true;
					}
					else {
						if ((OVar2 == OBJECT_ELECTRICFENCE) &&
							 ((pLVar1->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE)) {
							bVar10 = true;
						}
					}
				}
			}
			else {
				if (pLVar1->drivenObject == NULL) {
					bVar8 = true;
				}
				else {
					OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
						bVar7 = true;
					}
					else {
						bVar6 = true;
					}
				}
			}
			uVar15 += 1;
			ppLVar14 = ppLVar14 + 1;
		} while (uVar15 < globs::messageGlobs.selectedUnitCount);
	}
	uVar15 = 0;
	if (bVar5) {
		front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
		bVar7 = false;
		bVar6 = false;
		bVar8 = false;
		bVar9 = false;
		bVar10 = false;
	}
	else {
		if (bVar6) {
			front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
			bVar7 = false;
			bVar8 = false;
			bVar9 = false;
			bVar10 = false;
		}
		else {
			if (bVar7) {
				front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
				bVar8 = false;
				bVar9 = false;
				bVar10 = false;
			}
			else {
				if (bVar8) {
					front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_UNMANNEDVEHICLE,NULL);
					bVar9 = false;
					bVar10 = false;
				}
				else {
					if (bVar9) {
						front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDING,NULL);
						bVar10 = false;
					}
					else {
						bVar11 = !bVar10;
						if (bVar11) {
							interfaceMenuType = INTERFACE_MENU_MAIN;
						}
						else {
							interfaceMenuType = INTERFACE_MENU_ELECTRICFENCE;
						}
						front::Interface_OpenMenu_FUN_0041b200(interfaceMenuType,NULL);
					}
				}
			}
		}
	}
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar14 = globs::messageGlobs.selectedUnitList;
		do {
			pLVar1 = *ppLVar14;
			bVar4 = false;
			if ((bVar5) && ((pLVar1->objType != OBJECT_MINIFIGURE || (pLVar1->drivenObject != NULL))))
			goto LAB_00452e44;
			if (bVar6) {
				OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
				if ((OVar13 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
LAB_00452df3:
					if (pLVar1->objType != OBJECT_VEHICLE) goto LAB_00452e44;
				}
				else {
					OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
LAB_00452de2:
						bVar4 = true;
					}
LAB_00452de7:
					pLVar3 = pLVar1->drivenObject;
joined_r0x00452e42:
					if (pLVar3 == NULL) goto LAB_00452e44;
				}
			}
			else {
				if (bVar7) {
					OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
					if ((OVar13 & STATS1_CANBEDRIVEN) == STATS1_NONE) goto LAB_00452df3;
					OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) != STATS1_NONE) ||
						 ((*(byte *)&pLVar1->flags4 & 0x40) != 0)) goto LAB_00452de2;
					goto LAB_00452de7;
				}
				if (bVar8) {
					OVar13 = stats::StatsObject_GetStatsFlags1(pLVar1);
					if ((OVar13 & STATS1_CANBEDRIVEN) != STATS1_NONE) {
						pLVar3 = pLVar1->drivenObject;
						goto joined_r0x00452e42;
					}
				}
				else {
					if ((!bVar9) || (pLVar1->objType == OBJECT_BUILDING)) {
						if (!bVar10) goto LAB_00452e49;
						if (pLVar1->objType == OBJECT_ELECTRICFENCE) {
							pLVar3 = (LiveObject *)(pLVar1->flags2 & LIVEOBJ2_UNK_2000000);
							goto joined_r0x00452e42;
						}
					}
				}
LAB_00452e44:
				bVar4 = true;
			}
LAB_00452e49:
			if ((bVar4) || (bVar11)) {
				iVar12 = globs::messageGlobs.selectedUnitCount - 1;
				globs::messageGlobs.selectedUnitCount = globs::messageGlobs.selectedUnitCount - 1;
				*ppLVar14 = globs::messageGlobs.selectedUnitList[iVar12];
				uVar15 -= 1;
				pLVar1->flags3 = pLVar1->flags3 & ~LIVEOBJ3_UNK_200000;
				ppLVar14 = ppLVar14 + -1;
			}
			uVar15 += 1;
			ppLVar14 = ppLVar14 + 1;
		} while (uVar15 < globs::messageGlobs.selectedUnitCount);
	}
	return;
}



void __cdecl lego::game::Message_PTL_ClearSelection(void)
{
	LiveFlags4 *pLVar1;
	LiveObject **ppLVar2;
	uint uVar3;
	
	uVar3 = 0;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar2 = globs::messageGlobs.selectedUnitList;
		do {
			if (((*ppLVar2)->flags3 & LIVEOBJ3_UNK_200000) != LIVEOBJ3_NONE) {
				pLVar1 = &(*ppLVar2)->flags4;
				*pLVar1 = *pLVar1 | LIVEOBJ4_UNK_2;
			}
			(*ppLVar2)->flags3 = (*ppLVar2)->flags3 & ~LIVEOBJ3_UNK_200000;
			(*ppLVar2)->flags4 = (*ppLVar2)->flags4 & ~LIVEOBJ4_UNK_1;
			uVar3 += 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar3 < globs::messageGlobs.selectedUnitCount);
	}
	globs::messageGlobs.selectedUnitCount = 0;
	return;
}



BOOL __cdecl lego::game::Message_PTL_Deselect_LiveObject(LiveObject *liveObj)
{
	int iVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	
	pLVar2 = liveObj;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		BVar3 = Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,(uint *)&liveObj);
		if (BVar3 != 0) {
			if (liveObj == NULL) {
				front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_MAIN,NULL);
			}
						// param_1 is no longer liveObject, transformed by first function call of this function
			iVar1 = globs::messageGlobs.selectedUnitCount - 1;
			globs::messageGlobs.selectedUnitCount = globs::messageGlobs.selectedUnitCount - 1;
			globs::messageGlobs.selectedUnitList[(int)liveObj] =
					 globs::messageGlobs.selectedUnitList[iVar1];
			pLVar2->flags3 = pLVar2->flags3 & ~LIVEOBJ3_UNK_200000;
			return TRUE;
		}
	}
	return 0;
}



uint __cdecl lego::game::Message_PTL_Debug_DestroyAll(void)
{
	LiveObject *pLVar1;
	ObjectStatsFlags1 OVar2;
	uint index;
	
	index = globs::messageGlobs.selectedUnitCount;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		do {
			OVar2 = stats::StatsObject_GetStatsFlags1(globs::messageGlobs.selectedUnitList[0]);
			if (((OVar2 & STATS1_CANBEDRIVEN) != STATS1_NONE) &&
				 (pLVar1 = globs::messageGlobs.selectedUnitList[0]->drivenObject, pLVar1 != NULL)) {
				pLVar1->flags2 = pLVar1->flags2 & ~LIVEOBJ2_DRIVING;
				globs::messageGlobs.selectedUnitList[0]->drivenObject->drivenObject = NULL;
			}
			if (globs::messageGlobs.selectedUnitList[0]->objType == OBJECT_BUILDING) {
				LiveObject_BuildingDestroy(globs::messageGlobs.selectedUnitList[0]);
			}
			else {
				if (globs::messageGlobs.selectedUnitList[0]->objType == OBJECT_ELECTRICFENCE) {
					ElectricFence_LiveObject_Destroy(globs::messageGlobs.selectedUnitList[0]);
				}
				LiveObject_Remove(globs::messageGlobs.selectedUnitList[0]);
			}
			index -= 1;
		} while (index != 0);
	}
	return globs::messageGlobs.selectedUnitCount;
}



BOOL __cdecl lego::game::Message_PTL_FirstPerson(int camField14)
{
	LiveObject *liveObj;
	LiveObject **ppLVar1;
	uint uVar2;
	
	if (((globs::legoGlobs.objectFP != NULL) &&
			((*(byte *)&(globs::legoGlobs.objectFP)->flags3 & LIVEOBJ3_UNK_10) != 0)) &&
		 ((liveObj = globs::legoGlobs.objectFP,
			(globs::legoGlobs.objectFP)->objType == OBJECT_MINIFIGURE ||
			((globs::legoGlobs.objectFP)->drivenObject != NULL)))) {
LAB_00453096:
		lrr::Lego_SetViewMode(VIEW_FIRSTPERSON,liveObj,camField14);
		return TRUE;
	}
	uVar2 = 0;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar1 = globs::messageGlobs.selectedUnitList;
		do {
			liveObj = *ppLVar1;
			if ((liveObj->objType == OBJECT_MINIFIGURE) && (liveObj->drivenObject != NULL)) {
				liveObj = liveObj->drivenObject;
			}
			if (((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_10) != 0) &&
				 ((liveObj->objType == OBJECT_MINIFIGURE || (liveObj->drivenObject != NULL))))
			goto LAB_00453096;
			uVar2 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globs::messageGlobs.selectedUnitCount);
	}
	return 0;
}



BOOL __cdecl lego::nerps::NERPsFile_LoadScriptFile(char *filename)
{
	int iVar1;
	NERPsFile_Globs *pNVar2;
	NERPsRuntime_Globs *pNVar3;
	int local_4;
	
	pNVar2 = &globs::nerpsfileGlobs;
	for (iVar1 = 0x2d; iVar1 != 0; iVar1 += -1) {
		pNVar2->Camera_IsLockedOn = 0;
		pNVar2 = (NERPsFile_Globs *)&pNVar2->Camera_LockedOnTarget;
	}
	local_4 = TRUE;
	front::Text_Clear();
	globs::nerpsfileGlobs.fileSize = 0;
	pNVar3 = &globs::nerpsruntimeGlobs;
	for (iVar1 = 0xb; iVar1 != 0; iVar1 += -1) {
		pNVar3->registers[0] = 0;
		pNVar3 = (NERPsRuntime_Globs *)(pNVar3->registers + 1);
	}
	globs::nerpsfileGlobs.fileData = NULL;
	globs::nerpsruntimeGlobs.messagePermit = TRUE;
	funcs::NERPFunc__SetMessagePermit(&local_4);
	globs::nerpsfileGlobs.fileData =
			 lego::file::File_LoadBinary(filename,&globs::nerpsfileGlobs.fileSize);
	return (uint)((byte *)globs::nerpsfileGlobs.fileData != NULL);
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl lego::nerps::NERPsFile_LoadMessageFile(char *filename)
{
	undefined4 *puVar1;
	NERPMessageSound *pNVar2;
	char cVar3;
	byte bVar4;
	IDirectDrawSurface4 **ppIVar5;
	char *buffer;
	Image *pIVar6;
	void *pvVar7;
	char *pcVar8;
	int iVar9;
	NERPMessageSound *pNVar10;
	uint uVar11;
	char **ppcVar12;
	char **ppcVar13;
	uint uVar14;
	byte *pbVar15;
	bool bVar16;
	uint uStack8464;
	uint uStack8460;
	char **ppcStack8456;
	int iStack8452;
	char acStack8448 [128];
	Image aIStack8320 [4];
	char acStack8192 [4096];
	char local_1000 [4092];
	undefined4 uStack4;
	
	uStack4 = 0x45313a;
	bVar16 = true;
	uStack8464 = 0;
	buffer = (char *)lego::file::File_LoadBinary(filename,&uStack8460);
	if (buffer == NULL) {
		globs::nerpsfileGlobs.messageBuffer = buffer;
		globs::nerpsfileGlobs.soundsUNKCOUNT = globs::nerpsfileGlobs.soundCount;
		return 0;
	}
	globs::nerpsfileGlobs.messageBuffer = buffer;
	if (uStack8460 != 0) {
		iStack8452 = 0;
		uVar14 = uStack8460;
		do {
			if (*buffer == '_') {
				*buffer = ' ';
			}
			bVar4 = *buffer;
			pIVar6 = (Image *)(uVar14 & 0xffffff00 | (uint)bVar4);
			if (bVar4 < 0x20) {
				*buffer = 0;
				bVar16 = true;
			}
			else {
				if (bVar16) {
					if (bVar4 == ':') {
						pIVar6 = aIStack8320;
						pbVar15 = (byte *)buffer + 1;
						std::sscanf((char *)pbVar15,"%s",pIVar6);
						buffer = (char *)pbVar15;
						if (pIVar6 != NULL) {
							uVar14 = 0xffffffff;
							pIVar6 = aIStack8320;
							do {
								if (uVar14 == 0) break;
								uVar14 -= 1;
								ppIVar5 = &pIVar6->surface;
								pIVar6 = (Image *)((int)&pIVar6->surface + 1);
							} while (*(char *)ppIVar5 != '\0');
							bVar16 = false;
							buffer = (char *)(pbVar15 + (~uVar14 - 1));
							bVar4 = *buffer;
							for (; (pIVar6 = (Image *)(uint)bVar4, bVar4 < 0x21 &&
										 ((uint)((int)buffer - (int)globs::nerpsfileGlobs.messageBuffer) < uStack8460));
									buffer = (char *)((byte *)buffer + 1)) {
								if (bVar4 == '\r') {
									bVar16 = true;
								}
								*buffer = 0;
								bVar4 = ((byte *)buffer)[1];
							}
							std::sscanf(buffer,"%s",acStack8448);
							if ((pIVar6 != NULL) && (!bVar16)) {
								uVar14 = 0xffffffff;
								pcVar8 = acStack8448;
								do {
									if (uVar14 == 0) break;
									uVar14 -= 1;
									cVar3 = *pcVar8;
									pcVar8 = pcVar8 + 1;
								} while (cVar3 != '\0');
								buffer = (char *)((byte *)buffer + (~uVar14 - 1));
								pIVar6 = lego::image::Image_LoadBMPScaled(acStack8448,0,0);
								if (pIVar6 != NULL) {
									pvVar7 = std::malloc(globs::nerpsfileGlobs.messageCount * 8 + 8);
									uVar14 = 0;
									bVar16 = globs::nerpsfileGlobs.messageCount == 0;
									if (!bVar16) {
										do {
											puVar1 = (undefined4 *)((int)globs::nerpsfileGlobs.messageList + uVar14 * 8);
											uVar14 += 1;
											*(undefined4 *)((int)pvVar7 + uVar14 * 8 + -8) = *puVar1;
											*(undefined4 *)((int)pvVar7 + uVar14 * 8 + -4) = puVar1[1];
										} while (uVar14 < globs::nerpsfileGlobs.messageCount);
										bVar16 = globs::nerpsfileGlobs.messageCount == 0;
									}
									if (!bVar16) {
										std::free(globs::nerpsfileGlobs.messageList);
									}
									*(byte **)((int)pvVar7 + globs::nerpsfileGlobs.messageCount * 8) = pbVar15;
									*(Image **)((int)pvVar7 + globs::nerpsfileGlobs.messageCount * 8 + 4) = pIVar6;
									pIVar6 = (Image *)(globs::nerpsfileGlobs.messageCount + 1);
									globs::nerpsfileGlobs.messageCount = (uint)pIVar6;
									globs::nerpsfileGlobs.messageList = pvVar7;
								}
							}
						}
					}
					iVar9 = iStack8452;
					if (*buffer == '$') {
						pbVar15 = (byte *)buffer + 1;
						std::sscanf((char *)pbVar15,"%s",local_1000);
						buffer = (char *)pbVar15;
						if (pIVar6 != NULL) {
							uVar14 = 0xffffffff;
							pcVar8 = local_1000;
							do {
								if (uVar14 == 0) break;
								uVar14 -= 1;
								cVar3 = *pcVar8;
								pcVar8 = pcVar8 + 1;
							} while (cVar3 != '\0');
							bVar16 = false;
							buffer = (char *)(pbVar15 + (~uVar14 - 1));
							bVar4 = *buffer;
							for (; (bVar4 < 0x21 &&
										 ((uint)((int)buffer - (int)globs::nerpsfileGlobs.messageBuffer) < uStack8460));
									buffer = (char *)((byte *)buffer + 1)) {
								if (bVar4 == '\r') {
									bVar16 = true;
								}
								*buffer = 0;
								bVar4 = ((byte *)buffer)[1];
							}
							pcVar8 = acStack8192;
							std::sscanf(buffer,"%s",pcVar8);
							if ((pcVar8 != NULL) && (!bVar16)) {
								uVar14 = 0xffffffff;
								pcVar8 = acStack8192;
								do {
									if (uVar14 == 0) break;
									uVar14 -= 1;
									cVar3 = *pcVar8;
									pcVar8 = pcVar8 + 1;
								} while (cVar3 != '\0');
								buffer = (char *)((byte *)buffer + (~uVar14 - 1));
								iVar9 = snd::Sound3D_Load(acStack8192,1,0,0);
								if (iVar9 != 0) {
									pNVar10 = (NERPMessageSound *)
														std::malloc(globs::nerpsfileGlobs.soundCount * 8 + 8);
									bVar16 = globs::nerpsfileGlobs.soundCount == 0;
									uVar14 = 0;
									if (!bVar16) {
										do {
											pNVar2 = globs::nerpsfileGlobs.soundList + uVar14;
											uVar11 = uVar14 + 1;
											pNVar10[uVar14].key = pNVar2->key;
											pNVar10[uVar14].sampleIndex = pNVar2->sampleIndex;
											uVar14 = uVar11;
										} while (uVar11 < globs::nerpsfileGlobs.soundCount);
										bVar16 = globs::nerpsfileGlobs.soundCount == 0;
									}
									if (!bVar16) {
										std::free(globs::nerpsfileGlobs.soundList);
									}
									pNVar10[globs::nerpsfileGlobs.soundCount].key = (char *)pbVar15;
									pNVar10[globs::nerpsfileGlobs.soundCount].sampleIndex = iVar9;
									globs::nerpsfileGlobs.soundCount += 1;
									globs::nerpsfileGlobs.soundList = pNVar10;
									globs::nerpsfileGlobs.soundsUNKCOUNT = globs::nerpsfileGlobs.soundCount;
								}
							}
						}
					}
					else {
						ppcVar12 = (char **)std::malloc(iStack8452 + 4);
						if (iVar9 != 0) {
							ppcVar13 = ppcVar12;
							uVar14 = uStack8464;
							do {
								*ppcVar13 = *(char **)(((int)ppcStack8456 - (int)ppcVar12) + (int)ppcVar13);
								ppcVar13 = ppcVar13 + 1;
								uVar14 -= 1;
							} while (uVar14 != 0);
						}
						if (iVar9 != 0) {
							std::free(ppcStack8456);
						}
						*(char **)((int)ppcVar12 + iVar9) = buffer;
						uStack8464 += 1;
						iStack8452 = iVar9 + 4;
						ppcStack8456 = ppcVar12;
					}
				}
				bVar16 = false;
			}
			buffer = (char *)((byte *)buffer + 1);
			uVar14 = (int)buffer - (int)globs::nerpsfileGlobs.messageBuffer;
		} while (uVar14 < uStack8460);
	}
	globs::nerpsfileGlobs.messageLineCount = uStack8464;
	globs::nerpsfileGlobs.messageLineList = ppcStack8456;
	return 1;
}



char * __cdecl lego::nerps::NERPsFile_GetMessageLine(uint lineIndex)
{
	if (lineIndex < globs::nerpsfileGlobs.messageLineCount) {
		return globs::nerpsfileGlobs.messageLineList[lineIndex];
	}
	return NULL;
}



BOOL __cdecl lego::nerps::NERPsFile_Free(void)
{
	int iVar1;
	uint uVar2;
	NERPsFile_Globs *pNVar3;
	
	if (globs::nerpsfileGlobs.fileSize != 0) {
		std::free(globs::nerpsfileGlobs.fileData);
	}
	if (globs::nerpsfileGlobs.messageBuffer != NULL) {
		std::free(globs::nerpsfileGlobs.messageBuffer);
		if (globs::nerpsfileGlobs.messageLineList != NULL) {
			std::free(globs::nerpsfileGlobs.messageLineList);
		}
	}
	uVar2 = 0;
	globs::nerpsfileGlobs.messageBuffer = NULL;
	globs::nerpsfileGlobs.messageLineList = NULL;
	globs::nerpsfileGlobs.messageLineCount = 0;
	globs::nerpsfileGlobs.fileSize = 0;
	if (globs::nerpsfileGlobs.soundCount != 0) {
		do {
			snd::Sound3D_Remove(globs::nerpsfileGlobs.soundList[uVar2].sampleIndex);
			uVar2 += 1;
		} while (uVar2 < globs::nerpsfileGlobs.soundCount);
		if (globs::nerpsfileGlobs.soundCount != 0) {
			if (globs::nerpsfileGlobs.soundList != NULL) {
				std::free(globs::nerpsfileGlobs.soundList);
				globs::nerpsfileGlobs.soundList = NULL;
			}
			globs::nerpsfileGlobs.soundCount = 0;
		}
	}
	pNVar3 = &globs::nerpsfileGlobs;
	for (iVar1 = 0x2d; iVar1 != 0; iVar1 += -1) {
		pNVar3->Camera_IsLockedOn = 0;
		pNVar3 = (NERPsFile_Globs *)&pNVar3->Camera_LockedOnTarget;
	}
	front::Text_Clear();
	return TRUE;
}



void __cdecl lego::nerps::NERPsRuntime_ReserveStack_Unk(uint *param_1)
{
	uint uVar1;
	
	uVar1 = *param_1;
	if (((uVar1 & 0xffff0000) == 0x20000) &&
		 (globs::constant::c_nerpsFunctions[uVar1 & 0xffff].arguments == NERPS_ARGS_0)) {
		uVar1 = (*globs::constant::c_nerpsFunctions[uVar1 & 0xffff].function)(NULL);
	}
	*param_1 = uVar1;
	return;
}



void __cdecl lego::nerps::NERPsRuntime_Execute(float elapsedAbs)
{
	NERPsFunctionArgs NVar1;
	void *pvVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint local_220;
	uint local_21c;
	uint local_210;
	uint local_20c;
	uint local_208;
	uint local_204;
	char local_200 [512];
	
	pvVar2 = globs::nerpsfileGlobs.fileData;
	uVar5 = 0;
	if (globs::nerpsfileGlobs.fileData != NULL) {
		local_204 = globs::nerpsfileGlobs.fileSize >> 2;
		local_220 = 0;
		uVar10 = 0;
		uVar8 = 0;
		uVar4 = local_21c;
		if (local_204 != 0) {
			do {
				iVar7 = 0;
				uVar3 = *(uint *)((int)pvVar2 + local_220 * 4);
				if ((uVar3 & 0x20000) == 0) {
					if ((uVar3 & 0x10000) == 0) {
						if ((uVar3 & 0x40000) == 0) {
							if ((uVar3 & 0x80000) == 0) {
								uVar4 = SEXT24(*(short *)((int)pvVar2 + local_220 * 4));
								if (uVar5 != 0) {
									uVar4 = (uint)(uVar4 == 0);
								}
								uVar5 = uVar4;
								local_21c = uVar4;
								if (uVar8 != 0) {
									if (uVar8 == 1) {
										if ((uVar10 == 0) || (uVar5 = uVar8, uVar4 == 0)) {
LAB_00453acb:
											uVar5 = 0;
										}
									}
									else {
										if (uVar8 == 2) {
											if ((uVar10 == 0) && (uVar4 == 0)) goto LAB_00453acb;
											uVar5 = 1;
										}
										else {
											if (uVar8 == 3) {
												uVar5 = (uint)(uVar4 < uVar10);
											}
											else {
												if (uVar8 == 4) {
													uVar5 = (uint)(uVar10 < uVar4);
												}
												else {
													if (uVar8 == 5) {
														uVar5 = (uint)(uVar10 == uVar4);
													}
													else {
														if (uVar8 == 6) {
															uVar5 = (uint)(uVar4 <= uVar10);
														}
														else {
															if (uVar8 != 7) goto joined_r0x00453b1b;
															uVar5 = (uint)(uVar10 <= uVar4);
														}
													}
												}
											}
										}
									}
								}
								goto LAB_00453b28;
							}
							if (uVar10 != 0) {
								local_220 = uVar3 & 0xffff;
							}
LAB_00453a74:
							uVar10 = 0;
							uVar5 = 0;
							uVar9 = 0;
						}
						else {
							uVar10 = 0;
							uVar5 = 0;
							uVar9 = 0;
						}
					}
					else {
						uVar6 = 0;
						uVar3 &= 0xffff;
						uVar5 = uVar10;
						if (uVar3 == 0) goto LAB_00453b28;
						uVar5 = uVar6;
						uVar9 = uVar3;
						if ((uVar3 != 2) && (uVar5 = uVar3, uVar9 = uVar8, uVar3 != 1)) {
							if (uVar3 == 5) {
								uVar5 = uVar6;
								uVar9 = 3;
							}
							else {
								if (uVar3 == 6) {
									uVar5 = uVar6;
									uVar9 = 4;
								}
								else {
									if (uVar3 == 7) {
										uVar5 = uVar6;
										uVar9 = 5;
									}
									else {
										if (uVar3 == 8) {
											uVar5 = uVar6;
											uVar9 = 6;
										}
										else {
											if (uVar3 == 9) {
												uVar5 = uVar6;
												uVar9 = 7;
											}
											else {
												uVar5 = uVar6;
												if (uVar3 == 10) {
													uVar9 = 8;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					uVar3 &= 0xffff;
					if ((uVar3 == 0) && ((uVar10 != 0 || (uVar8 == 0)))) break;
					NVar1 = globs::constant::c_nerpsFunctions[uVar3].arguments;
					if (NVar1 == NERPS_ARGS_0) {
LAB_0045383f:
						uVar4 = (*globs::constant::c_nerpsFunctions[uVar3].function)(NULL);
						local_21c = uVar4;
					}
					else {
						if ((NVar1 != NERPS_ARGS_1) && (NVar1 != NERPS_ARGS_2)) {
							if (NVar1 == NERPS_ARGS_0_NORETURN) {
								if (uVar10 == 0) goto LAB_00453a74;
								if (globs::nerpsruntimeGlobs.logFuncCalls != 0) {
									std::sprintf(local_200,"Func Call %s",
															 globs::constant::c_nerpsFunctions[uVar3].name);
								}
								(*globs::constant::c_nerpsFunctions[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff]
									.function)(NULL);
								uVar10 = 0;
								uVar4 = local_21c;
								uVar5 = 0;
								uVar9 = 0;
							}
							else {
								if (NVar1 == NERPS_ARGS_1_NORETURN) {
									if (uVar10 != 0) {
										if (globs::nerpsruntimeGlobs.logFuncCalls != 0) {
											std::sprintf(local_200,"Func Call %s",
																	 globs::constant::c_nerpsFunctions[uVar3].name);
										}
										local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
										NERPsRuntime_ReserveStack_Unk(&local_210);
										(*globs::constant::c_nerpsFunctions
											[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)((int *)&local_210)
										;
										uVar4 = local_21c;
									}
									local_220 += 1;
								}
								else {
									if (NVar1 == NERPS_ARGS_2_NORETURN) {
										if (uVar10 != 0) {
											local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
											local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
											NERPsRuntime_ReserveStack_Unk(&local_210);
											NERPsRuntime_ReserveStack_Unk(&local_20c);
											(*globs::constant::c_nerpsFunctions
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
											uVar4 = local_21c;
										}
										local_220 += 2;
									}
									else {
										uVar9 = uVar8;
										if (NVar1 != NERPS_ARGS_3_NORETURN) goto LAB_00453b2d;
										if (uVar10 != 0) {
											local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
											local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
											local_208 = *(uint *)((int)pvVar2 + local_220 * 4 + 0xc);
											NERPsRuntime_ReserveStack_Unk(&local_210);
											NERPsRuntime_ReserveStack_Unk(&local_20c);
											NERPsRuntime_ReserveStack_Unk(&local_208);
											(*globs::constant::c_nerpsFunctions
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
											uVar4 = local_21c;
										}
										local_220 += 3;
									}
								}
								uVar10 = 0;
								uVar5 = 0;
								uVar9 = 0;
							}
							goto LAB_00453b2d;
						}
						if (NVar1 == NERPS_ARGS_0) goto LAB_0045383f;
						if (NVar1 == NERPS_ARGS_1) {
							local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
							NERPsRuntime_ReserveStack_Unk(&local_210);
							uVar4 = (*globs::constant::c_nerpsFunctions
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
							iVar7 = 1;
							local_21c = uVar4;
						}
						else {
							if (NVar1 == NERPS_ARGS_2) {
								local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
								local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
								NERPsRuntime_ReserveStack_Unk(&local_210);
								NERPsRuntime_ReserveStack_Unk(&local_20c);
								uVar4 = (*globs::constant::c_nerpsFunctions
													[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																	((int *)&local_210);
								iVar7 = 2;
								local_21c = uVar4;
							}
						}
					}
					local_220 += iVar7;
					if (uVar5 != 0) {
						uVar4 = (uint)(uVar4 == 0);
						local_21c = uVar4;
					}
					uVar5 = uVar4;
					if (uVar8 != 0) {
						if (uVar8 == 1) {
							if ((uVar10 == 0) || (uVar5 = uVar8, uVar4 == 0)) {
LAB_00453947:
								uVar5 = 0;
							}
						}
						else {
							if (uVar8 == 2) {
								if ((uVar10 == 0) && (uVar4 == 0)) goto LAB_00453947;
								uVar5 = 1;
							}
							else {
								if (uVar8 == 3) {
									uVar5 = (uint)(uVar4 < uVar10);
								}
								else {
									if (uVar8 == 4) {
										uVar5 = (uint)(uVar10 < uVar4);
									}
									else {
										if (uVar8 == 5) {
											uVar5 = (uint)(uVar10 == uVar4);
										}
										else {
											if (uVar8 == 6) {
												uVar5 = (uint)(uVar4 <= uVar10);
											}
											else {
												if (uVar8 == 7) {
													uVar5 = (uint)(uVar10 <= uVar4);
												}
												else {
joined_r0x00453b1b:
													uVar5 = uVar10;
													if (uVar8 == 8) {
														uVar5 = (uint)(uVar10 != uVar4);
													}
												}
											}
										}
									}
								}
							}
						}
					}
LAB_00453b28:
					uVar10 = uVar5;
					uVar5 = 0;
					uVar9 = 1;
				}
LAB_00453b2d:
				local_220 += 1;
				uVar8 = uVar9;
			} while (local_220 < local_204);
		}
		NERPsRuntime_FUN_00454060(elapsedAbs);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGameSpeed(int *stack)
{
	LevelData *pLVar1;
	
	if ((*stack == 0) && (pLVar1 = lrr::Lego_GetLevel(), pLVar1->status != LEVELSTATUS_NONE)) {
		return 0;
	}
	game::Game_LockGameSpeed(stack[1]);
	game::Game_SetGameSpeed((float)(ulonglong)(uint)*stack * 0.01);
	game::Game_LockGameSpeed(stack[1]);
	return 0;
}



void __cdecl lego::nerps::NERPs_SetHasNextButton(BOOL hasNextButton)
{
	globs::nerps::nerpsHasNextButton = hasNextButton;
	return;
}



void __cdecl lego::nerps::NERPs_PlayUnkSampleIndex_IfDat_004a773c(void)
{
	if (globs::nerps::nerpsHasNextButton != 0) {
		NERPs_PlayUnkSampleIndex();
		return;
	}
	return;
}



void __cdecl lego::nerps::NERPsRuntime_AdvanceMessage(void)
{
	char *text;
	TutorialFlags TVar1;
	int gameSpeedStack [2];
	
						// gameSpeedStack[0] = 100;   // game speed at 100%
						// gameSpeedStack[1] = FALSE; // don't lock game speed
	gameSpeedStack[0] = 100;
	gameSpeedStack[1] = FALSE;
	game::Game_SetPointer_AndPlayEnumSFX(0);
	if (globs::nerpsfileGlobs.int_a4 != 0) {
		globs::nerpsfileGlobs.int_a4 += -1;
		if (3 < globs::nerpsfileGlobs.int_a4) {
			globs::nerpsfileGlobs.int_a4 = 3;
		}
		if ((int)globs::nerpsfileGlobs.uint_a0 < globs::nerpsfileGlobs.int_a4) {
			globs::nerpsfileGlobs.int_a4 = globs::nerpsfileGlobs.uint_a0;
		}
		text = NERPsFile_GetMessageLine
										 (*(uint *)((int)&globs::nerpsfileGlobs +
															 (globs::nerpsfileGlobs.uint_a0 - globs::nerpsfileGlobs.int_a4) * 4 +
															 0x7c));
		front::Text_SetNERPsMessage(text,0);
		if (globs::nerpsfileGlobs.int_a4 == 0) {
			game::Game_SetFlags2_40_And_2_unkCamera(FALSE,TRUE);
			TVar1 = funcs::NERPFunc__GetTutorialFlags(NULL);
			if (TVar1 != TUTORIAL_NONE) {
				funcs::NERPFunc__SetGameSpeed(gameSpeedStack);
			}
		}
		game::Game_SetFlags2_80(TRUE);
		return;
	}
	if (globs::nerps::nerpsBOOL_004a7740 != 0) {
		globs::nerpsfileGlobs.uint_a8 += 1;
	}
	globs::nerps::nerpsBOOL_004a7740 = FALSE;
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMessagesAreUpToDate(int *stack)
{
	return (uint)(globs::nerpsfileGlobs.messageLineCount <= globs::nerpsfileGlobs.uint_a8);
}



int __cdecl lego::nerps::funcs::NERPFunc__SupressArrow(int *stack)
{
	globs::nerpsruntimeGlobs.supressArrow = *stack;
	if (globs::nerpsfileGlobs.int_a4 == 0) {
		game::Game_SetFlags2_40_And_2_unkCamera((uint)(globs::nerpsruntimeGlobs.supressArrow == 0),1);
		return 0;
	}
	game::Game_SetFlags2_40_And_2_unkCamera(1,1);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AdvanceMessage(int *stack)
{
	if (1 < globs::nerpsfileGlobs.int_a4) {
		globs::nerpsfileGlobs.int_a4 = 1;
	}
	NERPsRuntime_AdvanceMessage();
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AllowCameraMovement(int *stack)
{
	globs::nerpsruntimeGlobs.allowCameraMovement = *stack << 0xc;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyObjects(int *stack)
{
	int local_4;
	
	local_4 = 0x1ff3 - globs::nerpsruntimeGlobs.allowCameraMovement;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyMap(int *stack)
{
	int local_4;
	
	local_4 = 0x1ffb - globs::nerpsruntimeGlobs.allowCameraMovement;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyIcon(int *stack)
{
	int local_4;
	
	local_4 = 0x1ffe - globs::nerpsruntimeGlobs.allowCameraMovement;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyCalltoarms(int *stack)
{
	int local_4;
	
	local_4 = 0x1f7f - globs::nerpsruntimeGlobs.allowCameraMovement;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__DisallowAll(int *stack)
{
	int local_4;
	
	local_4 = 0x1fff - globs::nerpsruntimeGlobs.allowCameraMovement;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashCallToArmsIcon(int *stack)
{
	if (*stack != 0) {
		front::Panel_SetCurrentAdvisorFromButton(PANEL_TOPPANEL,2,TRUE);
		return 0;
	}
	front::Advisor_ClearFlag2();
	return 0;
}



void __cdecl lego::nerps::NERPsRuntime_UpdateTimers(float elapsed)
{
	float fVar1;
	float *pfVar2;
	float *pfVar3;
	
	fVar1 = elapsed * 1000.0 * 0.04;
	pfVar2 = globs::nerpsruntimeGlobs.timers;
	do {
		pfVar3 = pfVar2 + 1;
		*pfVar2 = *pfVar2 + fVar1;
		pfVar2 = pfVar3;
	} while (pfVar3 < &globs::nerpsruntimeGlobs.supressArrow);
	if (globs::nerpsruntimeGlobs.messageTimer == 0.0) {
		return;
	}
	if (0.0 <= globs::nerpsruntimeGlobs.messageTimer) {
		if ((globs::nerps::nerpsHasNextButton == 0) || (globs::nerpsruntimeGlobs.nextArrowDisabled != 0)
			 ) {
			globs::nerpsruntimeGlobs.messageTimer = globs::nerpsruntimeGlobs.messageTimer - fVar1;
			if ((ushort)((ushort)(globs::nerpsruntimeGlobs.messageTimer < 0.0) << 8 |
									(ushort)(globs::nerpsruntimeGlobs.messageTimer == 0.0) << 0xe) == 0)
			goto LAB_00453f3e;
		}
		else {
			if ((globs::nerpsruntimeGlobs.timerbool_2c != 0) &&
				 (((0 < globs::nerpsfileGlobs.int_a4 && (globs::nerpsruntimeGlobs.supressArrow != 0)) ||
					(globs::nerpsruntimeGlobs.supressArrow == 0)))) {
				game::Game_SetFlags2_40_And_2_unkCamera(globs::nerps::nerpsBOOL_004a7740,TRUE);
			}
			globs::nerpsruntimeGlobs.timerbool_2c = globs::nerps::nerpsBOOL_004a7740;
			if (globs::nerps::nerpsBOOL_004a7740 != 0) goto LAB_00453f3e;
		}
	}
	globs::nerpsruntimeGlobs.messageTimer = 0.0;
LAB_00453f3e:
	if ((globs::nerpsfileGlobs.AdvisorTalkingMode != 0) &&
		 (globs::nerpsruntimeGlobs.messageTimer < 1000.0)) {
		front::Advisor_ClearFlag2();
		return;
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer0(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globs::nerpsruntimeGlobs.timers[0]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer1(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globs::nerpsruntimeGlobs.timers[1]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer2(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globs::nerpsruntimeGlobs.timers[2]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer3(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globs::nerpsruntimeGlobs.timers[3]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer0(int *stack)
{
	globs::nerpsruntimeGlobs.timers[0] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer1(int *stack)
{
	globs::nerpsruntimeGlobs.timers[1] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer2(int *stack)
{
	globs::nerpsruntimeGlobs.timers[2] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer3(int *stack)
{
	globs::nerpsruntimeGlobs.timers[3] = (float)(ulonglong)(uint)*stack;
	return 1;
}



void __cdecl lego::nerps::NERPsRuntime_FUN_00454060(float elapsedAbs)
{
	float fVar1;
	BOOL BVar2;
	LevelData *pLVar3;
	float10 fVar4;
	LiveObject *local_10;
	undefined4 local_c;
	int local_8;
	int local_4;
	
	if (globs::nerpsfileGlobs.Camera_IsLockedOn == 0) goto LAB_00454114;
	if (globs::nerpsfileGlobs.object_10 == NULL) {
		if ((LiveObject *)&DAT_00000009 < globs::nerpsfileGlobs.Camera_LockedOnTarget)
		goto LAB_00454114;
		BVar2 = game::Game_GetRecordObject((uint)globs::nerpsfileGlobs.Camera_LockedOnTarget,&local_10);
		if (BVar2 == 0) {
			globs::nerpsfileGlobs.Camera_IsLockedOn = 0;
			goto LAB_00454114;
		}
		game::LiveObject_GetBlockPos(local_10,&local_8,&local_4);
		game::LiveObject_GetPosition
							(local_10,(float *)&globs::nerpsfileGlobs.pointi_8,
							 (float *)&globs::nerpsfileGlobs.pointi_8.y);
	}
	else {
		game::LiveObject_GetBlockPos(globs::nerpsfileGlobs.object_10,&local_8,&local_4);
		game::LiveObject_GetPosition
							(globs::nerpsfileGlobs.object_10,(float *)&globs::nerpsfileGlobs.pointi_8,
							 (float *)&globs::nerpsfileGlobs.pointi_8.y);
		local_10 = globs::nerpsfileGlobs.object_10;
	}
	lrr::Lego_GotoInfo(local_10,NULL,1);
LAB_00454114:
	if (globs::nerpsfileGlobs.bool_14 != 0) {
		fVar1 = globs::nerpsfileGlobs.float_18 / (elapsedAbs * 25.0);
		globs::nerpsfileGlobs.float_1c = fVar1 + globs::nerpsfileGlobs.float_1c;
		if (((ushort)((ushort)(globs::nerpsfileGlobs.float_1c < globs::nerpsfileGlobs.float_18 - 5.0) <<
									8 | (ushort)(globs::nerpsfileGlobs.float_1c ==
															globs::nerpsfileGlobs.float_18 - 5.0) << 0xe) == 0) &&
			 ((ushort)((ushort)(globs::nerpsfileGlobs.float_18 - -5.0 < globs::nerpsfileGlobs.float_1c) <<
								 8 | (ushort)(globs::nerpsfileGlobs.float_18 - -5.0 ==
														 globs::nerpsfileGlobs.float_1c) << 0xe) == 0)) {
			globs::nerpsfileGlobs.bool_14 = 0;
			globs::nerpsfileGlobs.float_1c = 0.0;
		}
		lego::view::Camera_AddDist(globs::legoGlobs.cameraMain,fVar1);
	}
	if (globs::nerpsfileGlobs.bool_20 != 0) {
		if ((ushort)((ushort)(globs::nerpsfileGlobs.float_24 < 0.0) << 8 |
								(ushort)(globs::nerpsfileGlobs.float_24 == 0.0) << 0xe) == 0) {
			fVar1 = globs::nerpsfileGlobs.float_24 - globs::nerpsfileGlobs.float_28;
		}
		else {
			fVar1 = globs::nerpsfileGlobs.float_24 + globs::nerpsfileGlobs.float_28;
		}
		fVar4 = lrr::Lego_GetElapsedAbs();
		fVar4 = fVar4 * (float10)(fVar1 * 0.1666667) * (float10)0.3333333;
		globs::nerpsfileGlobs.float_28 = (float)(fVar4 + (float10)globs::nerpsfileGlobs.float_28);
		if ((((ushort)((ushort)(globs::nerpsfileGlobs.float_24 < 0.0) << 8 |
									(ushort)(globs::nerpsfileGlobs.float_24 == 0.0) << 0xe) == 0) &&
				((ushort)((ushort)(globs::nerpsfileGlobs.float_28 < globs::nerpsfileGlobs.float_24 - 1.0) <<
									8 | (ushort)(globs::nerpsfileGlobs.float_28 ==
															globs::nerpsfileGlobs.float_24 - 1.0) << 0xe) == 0)) ||
			 ((globs::nerpsfileGlobs.float_24 < 0.0 &&
				(globs::nerpsfileGlobs.float_28 < globs::nerpsfileGlobs.float_24 - -1.0)))) {
			globs::nerpsfileGlobs.bool_20 = 0;
			globs::nerpsfileGlobs.float_28 = 0.0;
		}
		lego::view::Camera_AddYaw(globs::legoGlobs.cameraMain,(float)(fVar4 * (float10)0.01745329));
	}
	pLVar3 = lrr::Lego_GetLevel();
	if (pLVar3->status != LEVELSTATUS_NONE) {
		local_10 = (LiveObject *)100;
		local_c = 0;
		funcs::NERPFunc__SetGameSpeed((int *)&local_10);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraLockOnMonster(int *stack)
{
	if (*stack != 0) {
		game::Search_LiveObjects_SkipIgnoreMes
							(NERPsRuntime_LiveObject_GetIfRockMonsterAnd_FUN_004542e0,
							 &globs::nerpsfileGlobs.object_10);
		globs::nerpsfileGlobs.Camera_IsLockedOn = TRUE;
		return 0;
	}
	globs::nerpsfileGlobs.Camera_IsLockedOn = 0;
	globs::nerpsfileGlobs.object_10 = NULL;
	return 0;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_LiveObject_GetIfRockMonsterAnd_FUN_004542e0
					(LiveObject *liveObj,LiveObject **out_liveObj)
{
	BOOL BVar1;
	
	if (liveObj != NULL) {
		BVar1 = game::LiveObject_IsRockMonsterCanGather(liveObj);
		if (BVar1 != 0) {
			*out_liveObj = liveObj;
			return TRUE;
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraLockOnObject(int *stack)
{
	if (*stack != 0) {
		globs::nerpsfileGlobs.Camera_LockedOnTarget = (LiveObject *)(*stack + -1);
		globs::nerpsfileGlobs.Camera_IsLockedOn = 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraUnlock(int *stack)
{
	globs::nerpsfileGlobs.Camera_IsLockedOn = 0;
	globs::nerpsfileGlobs.Camera_LockedOnTarget = (LiveObject *)0xffffffff;
	globs::nerpsfileGlobs.object_10 = NULL;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraZoomIn(int *stack)
{
	if (globs::nerpsfileGlobs.float_1c != 0.0) {
		lego::view::Camera_AddDist
							(globs::legoGlobs.cameraMain,
							 globs::nerpsfileGlobs.float_18 - globs::nerpsfileGlobs.float_1c);
		globs::nerpsfileGlobs.float_1c = 0.0;
	}
	if (-(float)(ulonglong)(uint)*stack != 0.0) {
		globs::nerpsfileGlobs.bool_14 = 1;
	}
	globs::nerpsfileGlobs.float_18 = -(float)(ulonglong)(uint)*stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraZoomOut(int *stack)
{
	if (globs::nerpsfileGlobs.float_1c != 0.0) {
		lego::view::Camera_AddDist
							(globs::legoGlobs.cameraMain,
							 globs::nerpsfileGlobs.float_18 - globs::nerpsfileGlobs.float_1c);
	}
	if ((float)(ulonglong)(uint)*stack != 0.0) {
		globs::nerpsfileGlobs.bool_14 = 1;
	}
	globs::nerpsfileGlobs.float_18 = (float)(ulonglong)(uint)*stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraRotate(int *stack)
{
	if (globs::nerpsfileGlobs.float_28 != 0.0) {
		lego::view::Camera_AddYaw
							(globs::legoGlobs.cameraMain,
							 (globs::nerpsfileGlobs.float_24 - globs::nerpsfileGlobs.float_28) * 0.01745329);
		globs::nerpsfileGlobs.float_28 = 0.0;
	}
	globs::nerpsfileGlobs.float_24 = (float)(ulonglong)(uint)*stack;
	if ((ushort)((ushort)(globs::nerpsfileGlobs.float_24 < 180.0) << 8 |
							(ushort)(globs::nerpsfileGlobs.float_24 == 180.0) << 0xe) == 0) {
		globs::nerpsfileGlobs.float_24 = globs::nerpsfileGlobs.float_24 - 360.0;
	}
	if (globs::nerpsfileGlobs.float_24 != 0.0) {
		globs::nerpsfileGlobs.bool_20 = 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSelectedRecordObject(int *stack)
{
	BOOL BVar1;
	uint recordObjPtr;
	LiveObject *local_4;
	
	recordObjPtr = 0;
	do {
		local_4 = NULL;
		BVar1 = game::Game_GetRecordObject(recordObjPtr,&local_4);
		if (BVar1 != 0) {
			BVar1 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(local_4,NULL);
			if (BVar1 != 0) {
				return recordObjPtr + 1;
			}
		}
		recordObjPtr += 1;
	} while (recordObjPtr < 10);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCrystalPriority(int *stack)
{
	ai::AITask_Game_SetIsPriorityDisabled(0,(uint)(*stack == 0));
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMonsterAttackPowerstation(int *stack)
{
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (*stack == 1) {
		local_c = 0x200;
		local_8 = 0xffffffff;
		local_4 = 1;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
		return 0;
	}
	local_c = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
	return 0;
}



BOOL __cdecl lego::nerps::NERPs_LiveObject_Callback_FUN_004545c0(LiveObject *liveObj,uint *param_2)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	uint local_8;
	uint local_4;
	
	if (liveObj != NULL) {
		game::LiveObject_GetBlockPos(liveObj,(int *)&local_8,(int *)&local_4);
		BVar1 = game::Level_Block_IsSolidBuilding(local_8,local_4,1);
		if (BVar1 != 0) {
			OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
			if (((*param_2 & OVar2) != STATS2_NONE) || (param_2[1] != 0xffffffff)) {
				OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
				if ((param_2[1] & OVar2) == STATS2_NONE) {
					return 0;
				}
				if (*param_2 != 0xffffffff) {
					return 0;
				}
			}
			if (param_2[2] == 0) {
				ai::AITask_DoRepair(liveObj);
			}
			else {
				if (param_2[2] == 1) {
					ai::AITask_LiveObject_FUN_00403490(liveObj);
					return 0;
				}
			}
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMonsterAttackNowt(int *stack)
{
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (*stack == 1) {
		local_c = 0;
		local_8 = 0xffffffff;
		local_4 = 1;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
		return 0;
	}
	local_c = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
	return 0;
}



void __cdecl lego::nerps::NERPs_FUN_004546d0(char *objName,undefined4 param_2)
{
	char local_8c [128];
	undefined4 local_c;
	ObjectType local_8;
	int local_4;
	
	std::sprintf(local_8c,"%s",objName);
	local_c = param_2;
	game::Object_GetObjectByName(objName,&local_8,&local_4,NULL);
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_00454740,local_8c);
	return;
}



BOOL __cdecl lego::nerps::NERPs_LiveObject_Callback_FUN_00454740(LiveObject *liveObj,int param_2)
{
	if (((liveObj != NULL) && (liveObj->objType == *(ObjectType *)(param_2 + 0x84))) &&
		 (liveObj->objIndex == *(int *)(param_2 + 0x88))) {
		stats::StatsObject_SetObjectLevel(liveObj,*(uint *)(param_2 + 0x80));
	}
	return 0;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_IsOnBlock_FUN_00454780
					(undefined4 param_1,int bx,int by,int *ref_param_4)
{
	LevelData *pLVar1;
	Point2I blockPos;
	float local_c;
	float local_8 [2];
	
	pLVar1 = lrr::Lego_GetLevel();
	game::LiveObject_GetPosition((LiveObject *)ref_param_4[1],&local_c,local_8);
	game::Map3D_WorldToBlockPos_NoZ(pLVar1->surfaceMap,local_c,local_8[0],&blockPos.x,&blockPos.y);
	if ((bx == blockPos.x) && (by == blockPos.y)) {
		*ref_param_4 = *ref_param_4 + 1;
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRecordObjectAtTutorial(int *stack)
{
	int *piVar1;
	BOOL BVar2;
	uint recordObjPtr;
	int local_8;
	LiveObject *local_4;
	
	piVar1 = stack;
	recordObjPtr = 0;
	do {
		stack = NULL;
		BVar2 = game::Game_GetRecordObject(recordObjPtr,(LiveObject **)&stack);
		if (BVar2 != 0) {
			local_4 = (LiveObject *)stack;
			local_8 = 0;
			NERPsRuntime_EnumerateBlockPointers
								(*piVar1,NERPs_LiveObject_Callback_IsOnBlock_FUN_00454780,&local_8);
			if (local_8 != 0) {
				return recordObjPtr + 1;
			}
		}
		recordObjPtr += 1;
	} while (recordObjPtr < 10);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRecordObjectAmountAtTutorial(int *stack)
{
	int *piVar1;
	BOOL BVar2;
	uint recordObjPtr;
	int local_8;
	LiveObject *local_4;
	
	piVar1 = stack;
	local_8 = 0;
	recordObjPtr = 0;
	do {
		stack = NULL;
		BVar2 = game::Game_GetRecordObject(recordObjPtr,(LiveObject **)&stack);
		if (BVar2 != 0) {
			local_4 = (LiveObject *)stack;
			NERPsRuntime_EnumerateBlockPointers
								(*piVar1,NERPs_LiveObject_Callback_IsOnBlock_FUN_00454780,&local_8);
		}
		recordObjPtr += 1;
	} while (recordObjPtr < 10);
	return local_8;
}



void __cdecl
lego::nerps::NERPsRuntime_DrawTutorialIcon
					(LevelData *level,Viewport *viewMain,float elapsedGame,float elapsedAbs)
{
	BOOL BVar1;
	float10 fVar2;
	float10 fVar3;
	Point2F local_14;
	Vector3F local_c;
	
	fVar2 = (float10)fsin((float10)globs::nerpsruntimeGlobs.tutorialIconTimer);
	globs::nerpsruntimeGlobs.tutorialIconTimer =
			 globs::nerpsruntimeGlobs.tutorialIconTimer - elapsedAbs * 25.0 * -0.01333333;
	if (globs::nerpsfileGlobs.RecordObjectPointer != 0) {
		BVar1 = game::Game_GetRecordObject
											(globs::nerpsfileGlobs.RecordObjectPointer - 1,(LiveObject **)&elapsedAbs);
		if (BVar1 != 0) {
			*(undefined4 *)((int)elapsedAbs + 0x3f8) = 1;
			game::LiveObject_GetPosition((LiveObject *)elapsedAbs,&local_c.x,&local_c.y);
			fVar3 = game::Map3D_GetWorldZ(level->surfaceMap,local_c.x,local_c.y);
			local_c.z = (float)fVar3;
			lego::view::Viewport_WorldToScreen(viewMain,&local_14,&local_c);
			local_14.x = local_14.x - (float)((int)(globs::legoGlobs.TutorialIcon)->width / 2);
			local_14.y = local_14.y -
									 ((float)fVar2 * 20.0 + (float)((globs::legoGlobs.TutorialIcon)->height << 1));
			lego::image::Image_DisplayScaled(globs::legoGlobs.TutorialIcon,NULL,&local_14,NULL);
		}
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRecordObjectPointer(int *stack)
{
	globs::nerpsfileGlobs.RecordObjectPointer = *stack;
	return *stack;
}



void __cdecl lego::nerps::NERPs_FUN_004549d0(int *param_1)
{
	front::Interface_GetIconClicked(*param_1);
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOxygenLevel(int *stack)
{
	BOOL BVar1;
	longlong lVar2;
	float local_4;
	
	local_4 = (globs::legoGlobs.level)->oxygenLevel;
	if (local_4 < 1.0) {
		local_4 = 0.0;
	}
	if (local_4 == 0.0) {
		BVar1 = unk::Teleporter_ServiceAll
											(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
											 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
		if (BVar1 == 0) {
			local_4 = 1.0;
		}
	}
	if (local_4 < 1.0) {
		local_4 = 1.0;
	}
	lVar2 = __ftol((float10)local_4);
	return (int)lVar2;
}



int __cdecl lego::nerps::funcs::NERPFunc__GenerateSlug(int *stack)
{
	int objIndex;
	Container *objCont;
	ObjectType objType;
	
	game::Object_GetObjectByName("Slug",&objType,&objIndex,&objCont);
	game::LiveObject_TryGenerateSlug(NULL,objIndex);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetAttackDefer(int *stack)
{
	lrr::LegoGame_SetAttackDefer(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCallToArms(int *stack)
{
	lrr::LegoGame_SetCallToArmsOn(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCallToArmsButtonClicked(int *stack)
{
	return globs::legoGlobs.flags2 & GAME2_CALLTOARMS;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonster(int *stack)
{
	int objIndex;
	
	objIndex = lrr::Lego_GetEmergeCreature();
	game::Game_TryGeneratedRockMonsterLiveObject
						((int **)(globs::legoGlobs.RockMonsterData_TABLE + objIndex),OBJECT_ROCKMONSTER,objIndex
						 ,*stack - 1,stack[1] - 1);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRockMonstersDestroyed(int *stack)
{
						// table[REWARDTYPE_ROCKMONSTERS]
	return globals::g_RewardCur.items[6].numDestroyed;
}



void __cdecl lego::nerps::NERPsRuntime_IncHiddenObjectsFound(ObjectType unused_objType)
{
	globs::nerpsruntimeGlobs.hiddenObjectsFound += 1;
	return;
}



void __cdecl lego::nerps::NERPsRuntime_ClearHiddenObjectsFound(void)
{
	globs::nerpsruntimeGlobs.hiddenObjectsFound = 0;
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetHiddenObjectsFound(int *stack)
{
	return globs::nerpsruntimeGlobs.hiddenObjectsFound;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetHiddenObjectsFound(int *stack)
{
	globs::nerpsruntimeGlobs.hiddenObjectsFound = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeBuildingIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_UPGRADEBUILDING,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeBuildingIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x41;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashUpgradeBuildingIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_UPGRADEBUILDING,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGoBackIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_BACKTODEFAULT,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGoBackIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGoBackIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_BACKTODEFAULT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRockMonsterRunningAway(int *stack)
{
	undefined4 local_c;
	int local_8;
	
	local_c = 0;
	local_8 = 0;
	game::Search_LiveObjects_SkipIgnoreMes
						(NERPs_LiveObject_Callback_RockMonster_FUN_00454c70,&local_c);
	return local_8;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_RockMonster_FUN_00454c70(LiveObject *liveObj,int *param_2)
{
	int iVar1;
	
	iVar1 = *param_2;
	if ((((iVar1 == 0) || (iVar1 == 1)) || (iVar1 == 2)) && (liveObj->objType == OBJECT_ROCKMONSTER))
	{
		if (iVar1 == 0) {
			if (((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe)
					 == 0) &&
				 (liveObj->health <
					liveObj->stats->PainThreshold - liveObj->stats->PainThreshold * 0.01 * 20.0)) {
				game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
				param_2[1] = param_2[1] + 1;
			}
		}
		else {
			if (iVar1 == 1) {
				liveObj->stats->PainThreshold = (float)param_2[2];
				return 0;
			}
			if (iVar1 == 2) {
				liveObj->health = (float)param_2[2];
				return 0;
			}
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterPainThreshold(int *stack)
{
	undefined4 local_c [2];
	float local_4;
	
	local_c[0] = 1;
	local_4 = (float)(ulonglong)(uint)*stack;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_RockMonster_FUN_00454c70,local_c)
	;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterHealth(int *stack)
{
	undefined4 local_c [2];
	float local_4;
	
	local_c[0] = 2;
	local_4 = (float)(ulonglong)(uint)*stack;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_RockMonster_FUN_00454c70,local_c)
	;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPauseGame(int *stack)
{
	game::Game_SetPaused(0,*stack);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetAnyKeyPressed(int *stack)
{
	uint uVar1;
	
	uVar1 = input::Input_AnyKeyPressed();
	return uVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconPos(int *stack)
{
	globs::nerps::nerpsIconPos.x = (float)(ulonglong)(uint)*stack;
	globs::nerps::nerpsIconPos.y = (float)(ulonglong)(uint)stack[1];
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconSpace(int *stack)
{
	globs::nerps::nerpsIconSpace = *stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconWidth(int *stack)
{
	globs::nerps::nerpsIconWidth = *stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLevelCompleted(int *stack)
{
	game::Objective_SetCompleteStatus(LEVELSTATUS_COMPLETE);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLevelFail(int *stack)
{
	if ((globs::legoGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE) {
		game::Objective_SetCompleteStatus(LEVELSTATUS_FAILED);
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGameFail(int *stack)
{
	game::Objective_SetCompleteStatus(LEVELSTATUS_FAILED);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialPointer(int *stack)
{
	NERPsRuntime_SetTutorialPointer(*stack,stack[1]);
	return 1;
}



int __cdecl lego::nerps::NERPsRuntime_SetSubmenuIconClicked(char *itemName,int clickedCount)
{
	int iVar1;
	ObjectType objType;
	
	game::Object_GetObjectByName(itemName,&objType,(int *)&itemName,NULL);
	iVar1 = front::Interface_SetSubmenuIconClicked(objType,(int)itemName,clickedCount);
	return iVar1;
}



int __cdecl lego::nerps::NERPsRuntime_FlashSubmenuIcon(char *objName,BOOL flash)
{
	int objIndex;
	
	game::Object_GetObjectByName(objName,(ObjectType *)&objName,&objIndex,NULL);
	front::Interface_SetSubmenuIconFlash((ObjectType)objName,objIndex,flash);
	return (int)objName;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_Enumerate_SetTutorialBlockClicks
					(BlockPointer *blockPointer,uint bx,uint by,int *pClickCount)
{
	LevelData *level;
	
	level = lrr::Lego_GetLevel();
	level->blocks[(level->dimensions).width * by + bx].clickCount = *pClickCount;
	return TRUE;
}



// NERPS: void SetTutorialBlockClicks(blockPointer, clickCount)

int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockClicks(int *stack)
{
	NERPsRuntime_EnumerateBlockPointers
						(*stack,NERPsRuntime_Enumerate_SetTutorialBlockClicks,stack + 1);
	return 1;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_Enumerate_SetTutorialCrystals
					(BlockPointer *blockPointer,uint bx,uint by,int *pCrystalCount)
{
	LevelData *level;
	int i;
	Point2I blockPos;
	
	level = lrr::Lego_GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	i = 0;
	level->blocks[(level->dimensions).width * by + bx].generateCrystals = *pCrystalCount;
	if (0 < *pCrystalCount) {
		do {
			game::Level_GenerateCrystal(&blockPos,0,NULL,TRUE);
			i += 1;
		} while (i < *pCrystalCount);
	}
	return TRUE;
}



// NERPS: void SetTutorialCrystals(blockPointer, crystalCount)

int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialCrystals(int *stack)
{
	NERPsRuntime_EnumerateBlockPointers(*stack,NERPsRuntime_Enumerate_SetTutorialCrystals,stack + 1);
	return 1;
}



BOOL __cdecl lego::nerps::NERPs_FUN_00454ff0(undefined4 unused,uint bx,int by,int *pGenerateOre)
{
	LevelData *level;
	Point2I blockPos;
	
	level = lrr::Lego_GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	level->blocks[(level->dimensions).width * by + bx].generateOre = *pGenerateOre;
	game::Level_GenerateOre(&blockPos,0,NULL,0);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetOreAtIconPositions(int *stack)
{
	NERPsRuntime_EnumerateBlockPointers(*stack,NERPs_FUN_00454ff0,stack + 1);
	return 1;
}



int __cdecl lego::nerps::NERPsRuntime_CountSelectedUnits_ByObjectName(char *objName)
{
	LiveObject **ppLVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	int local_4;
	
	iVar3 = 0;
	game::Object_GetObjectByName(objName,(ObjectType *)&objName,&local_4,NULL);
	ppLVar1 = game::Message_GetSelectedUnits();
	uVar4 = 0;
	uVar2 = game::Message_GetNumSelectedUnits();
	if (uVar2 != 0) {
		do {
			if (((char *)(*ppLVar1)->objType == objName) && ((*ppLVar1)->objIndex == local_4)) {
				iVar3 += 1;
			}
			uVar4 += 1;
			ppLVar1 = ppLVar1 + 1;
			uVar2 = game::Message_GetNumSelectedUnits();
		} while (uVar4 < uVar2);
	}
	return iVar3;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Pilot");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallTruckSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallTruck",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallDiggerSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallDigger",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRapidRiderSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallCat",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallHelicopterSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallHeli",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGraniteGrinderSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("WalkerDigger",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetChromeCrusherSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("LargeDigger",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



BOOL __cdecl lego::nerps::NERPs_Game_DoCallbacks_ByObjectName(char *objName)
{
	ObjectType local_c;
	int local_8;
	BOOL local_4;
	
	game::Object_GetObjectByName(objName,&local_c,&local_8,NULL);
	local_4 = 0;
	game::Search_LiveObjects_SkipIgnoreMes
						(NERPs_LiveObject_Callback_ByObjectTypeIndex_IsDriving,&local_c);
	return local_4;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_ByObjectTypeIndex_IsDriving
					(LiveObject *liveObj1,LiveObject *liveObj_template)
{
	if (((liveObj1->objType == liveObj_template->objType) &&
			(liveObj1->objIndex == liveObj_template->objIndex)) && (liveObj1->drivenObject != NULL)) {
		liveObj_template->customName = liveObj_template->customName + 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AddPoweredCrystals(int *stack)
{
	uint uVar1;
	
	uVar1 = 0;
	if (*stack != 0) {
		do {
			game::Level_IncCrystals();
			uVar1 += 1;
		} while (uVar1 < (uint)*stack);
	}
	game::LiveManager_InitFlagsToggle_AndClearNumDrained();
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__AddStoredOre(int *stack)
{
	uint uVar1;
	
	uVar1 = 0;
	if (*stack != 0) {
		do {
			game::Level_IncOre(ORE_NORMAL);
			uVar1 += 1;
		} while (uVar1 < (uint)*stack);
	}
	return *stack;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_Callback_GetTutorialCrystals
					(BlockPointer *blockPointer,uint bx,uint by,int *out_tutorialCrystals)
{
	LevelData *level;
	
	level = lrr::Lego_GetLevel();
	*out_tutorialCrystals =
			 *out_tutorialCrystals + level->blocks[(level->dimensions).width * by + bx].generateCrystals;
	return TRUE;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialCrystals(int *stack)
{
	int local_4;
	
	local_4 = 0;
	NERPsRuntime_EnumerateBlockPointers(*stack,NERPsRuntime_Callback_GetTutorialCrystals,&local_4);
	return local_4;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_Callback_GetTutorialBlockClicks
					(BlockPointer *blockPointer,uint bx,uint by,int *out_clicks)
{
	LevelData *level;
	
	level = lrr::Lego_GetLevel();
	*out_clicks = *out_clicks + level->blocks[(level->dimensions).width * by + bx].clickCount;
	return TRUE;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockClicks(int *stack)
{
	int clicks;
	
	clicks = 0;
	NERPsRuntime_EnumerateBlockPointers(*stack,NERPsRuntime_Callback_GetTutorialBlockClicks,&clicks);
	return clicks;
}



// Special arguments:
//   objLevel: -1 = all levels
//   objLevel: -2 = powered objects (ignoring levels?)

int __cdecl lego::nerps::NERPsRuntime_GetLevelObjectsBuilt(char *objName,int objLevel)
{
	int iVar1;
	uint levels;
	uint totalCount;
	uint i;
	ObjectType objType;
	SearchObjectTypeCount_c searchCounts;
	
	game::Object_GetObjectByName(objName,&objType,(int *)&objName,NULL);
	iVar1 = objLevel;
	if (objLevel < 0) {
		totalCount = 0;
		i = 0;
		levels = stats::Stats_GetLevels(objType,(int)objName);
		if (levels != 0) {
			do {
				if (iVar1 == -1) {
					levels = game::LiveObject_GetLevelObjectsBuilt(objType,(int)objName,i,TRUE);
					totalCount += levels;
				}
				if (iVar1 == -2) {
					searchCounts.objType = objType;
					searchCounts.objIndex = (int)objName;
					searchCounts.count = 0;
					game::Search_LiveObjects_SkipIgnoreMes
										(NERPsRuntime_LiveObjectCallback_GetPoweredObjectsBuilt,&searchCounts);
					totalCount += searchCounts.count;
				}
				i += 1;
				levels = stats::Stats_GetLevels(objType,(int)objName);
			} while (i < levels);
		}
		return totalCount;
	}
	levels = game::LiveObject_GetLevelObjectsBuilt(objType,(int)objName,objLevel,TRUE);
	return levels;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_LiveObjectCallback_GetPoweredObjectsBuilt
					(LiveObject *liveObj,SearchObjectTypeCount_c *search)
{
	if ((liveObj->objType == search->objType) && (liveObj->objIndex == search->objIndex)) {
		if ((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE) {
			search->count = search->count + 1;
			return 0;
		}
		search->count = 0;
	}
	return 0;
}



uint __cdecl lego::nerps::NERPsRuntime_GetPreviousLevelObjectsBuilt(char *objName,int objLevel)
{
	uint count;
	ObjectType objType;
	
	game::Object_GetObjectByName(objName,&objType,(int *)&objName,NULL);
	count = game::LiveObject_GetPreviousLevelObjectsBuilt(objType,(int)objName,objLevel);
	return count;
}



int __cdecl lego::nerps::NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName(char *objName)
{
	int iVar1;
	ObjectType local_4;
	
	game::Object_GetObjectByName(objName,&local_4,(int *)&objName,NULL);
	iVar1 = front::Interface_GetSubmenuIconClicked(local_4,(int)objName);
	return iVar1;
}



BOOL __cdecl lego::nerps::NERPsRuntime_FlashIcon(MenuIcon menuIcon,BOOL flash)
{
	BOOL BVar1;
	
	if (flash == TRUE) {
		BVar1 = front::Interface_SetAdvisorPointToFashingIcon(menuIcon,TRUE);
		if (BVar1 != 0) {
			front::Interface_SetIconFlash(menuIcon,TRUE);
			return TRUE;
		}
	}
	else {
		front::Advisor_ClearFlag2();
		front::Interface_SetIconFlash(menuIcon,FALSE);
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinGraniteGrinder(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("Walkerdigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinChromeCrusher(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("LargeDigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallDigger(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallDigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinRapidRider(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallCat");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallTruck(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallTruck");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallHelicopter(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallHeli");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBarracksLevel(int *stack)
{
	NERPs_FUN_004546d0("Barracks",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDocksLevel(int *stack)
{
	NERPs_FUN_004546d0("Docks",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGeoDomeLevel(int *stack)
{
	NERPs_FUN_004546d0("Geo-dome",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPowerstationLevel(int *stack)
{
	NERPs_FUN_004546d0("Powerstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetToolStoreLevel(int *stack)
{
	NERPs_FUN_004546d0("Toolstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGunstationLevel(int *stack)
{
	NERPs_FUN_004546d0("Gunstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportPadLevel(int *stack)
{
	NERPs_FUN_004546d0("TeleportPad",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetSuperTeleportLevel(int *stack)
{
	NERPs_FUN_004546d0("TeleportBIG",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeStationLevel(int *stack)
{
	NERPs_FUN_004546d0("Upgrade",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Barracks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDocksSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Docks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeoDomeSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Geo-Dome");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Powerstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoreSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Toolstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Gunstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportPadSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("TeleportPad");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSuperTeleportSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("TeleportBIG");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_CountSelectedUnits_ByObjectName("Upgrade");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredBarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Barracks",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredDocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Docks",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredGeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Geo-dome",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredPowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Powerstation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Toolstation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredGunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("GunStation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportPad",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredVehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportBIG",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredUpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Upgrade",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Barracks",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Docks",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Geo-dome",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Powerstation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Toolstation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("GunStation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportPad",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetVehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportBIG",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Upgrade",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1BarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Barracks",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1DocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Docks",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1GeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Geo-dome",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1PowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Powerstation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1ToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Toolstation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1GunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("GunStation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1TeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportPad",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1VehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportBIG",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1UpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Upgrade",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2BarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Barracks",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2DocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Docks",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2GeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Geo-dome",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2PowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Powerstation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2ToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Toolstation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2GunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("GunStation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2TeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportPad",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2VehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("TeleportBIG",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2UpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Upgrade",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Barracks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeodomeIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Geo-dome");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Powerstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoreIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Toolstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Gunstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportPadIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("TeleportPad");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetVehicleTransportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("TeleportBIG");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Upgrade");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBarracksIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("Barracks",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGeodomeIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("Geo-dome",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPowerstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("Powerstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetToolStoreIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("Toolstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGunstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("Gunstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportPadIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("TeleportPad",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetVehicleTransportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("TeleportBIG",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeStationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_SetSubmenuIconClicked("Upgrade",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashBarracksIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("Barracks",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGeodomeIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("Geo-dome",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashPowerStationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("Powerstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashToolStoreIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("Toolstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGunstationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("Gunstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTeleportPadIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("TeleportPad",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashVehicleTransportIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("TeleportBIG",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashUpgradeStationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_FlashSubmenuIcon("Upgrade",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPathsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Path",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetStudCount(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("ProcessedOre",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallHelicoptersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("SmallHeli",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGraniteGrindersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("WalkerDigger",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRapidRidersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("SmallCat",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallDiggersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("SmallDigger",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSlugsOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Slug",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFiguresOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Pilot",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOreRefineriesBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("Refinery",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalRefineriesBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("CrystalRefinery",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 1;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDynamiteClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xd;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMountIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x18;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x39;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDropSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x21;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetToolIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x30;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetPusherIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x36;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x38;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainSailorIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3e;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainPilotIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3d;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainDriverIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3a;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetLaserIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x35;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDismountIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x19;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDigIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xb;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBuildIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 2;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLayPathIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 5;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPlaceFenceIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xe;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TELEPORTMAN,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDynamiteClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_DYNAMITE,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINSKILL,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainDriverIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINDRIVER,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainSailorIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINSAILOR,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetToolIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETTOOL,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDropSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_DROPBIRDSCARER,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetLaserIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETLASER,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetPusherIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETPUSHERGUN,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETBIRDSCARER,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDismountIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETOUT,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainPilotIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINPILOT,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMountIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETIN,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDigIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_DIG,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBuildIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_BUILDBUILDING,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLayPathIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_LAYPATH,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPlaceFenceIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_PLACEFENCE,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTeleportIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_TELEPORTMAN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDynamiteIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_DYNAMITE,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashMountIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_GETIN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_TRAINSKILL,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainDriverIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_TRAINDRIVER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainPilotIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_TRAINPILOT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainSailorIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_TRAINSAILOR,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDismountIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_GETOUT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetToolIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_GETTOOL,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDropSonicBlasterIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_DROPBIRDSCARER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetLaserIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_GETLASER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetPusherIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_GETPUSHERGUN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetSonicBlasterIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_GETBIRDSCARER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDigIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_DIG,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashBuildIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_BUILDBUILDING,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashLayPathIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_LAYPATH,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashPlaceFenceIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPsRuntime_FlashIcon(INTERFACE_MENUITEM_PLACEFENCE,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom(int *stack)
{
	ushort uVar1;
	
	uVar1 = math::Maths_Rand();
	return uVar1 & 0xfff;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandomTrueFalse(int *stack)
{
	ushort uVar1;
	
	uVar1 = math::Maths_Rand();
	return uVar1 & 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom10(int *stack)
{
	short sVar1;
	
	sVar1 = math::Maths_Rand();
	return (int)sVar1 % 10;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom100(int *stack)
{
	short sVar1;
	
	sVar1 = math::Maths_Rand();
	return (int)sVar1 % 100;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalsPickedUp(int *stack)
{
	return (globs::legoGlobs.level)->field_94;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalsCurrentlyStored(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetCrystalCount(1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__False(int *stack)
{
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOrePickedUp(int *stack)
{
	return (globs::legoGlobs.level)->field_a8;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOreCurrentlyStored(int *stack)
{
	return (globs::legoGlobs.level)->numOre;
}



// NOTE: For the sake of Ghidra auto-completion, the return type
// will be `TutorialFlags`, rather than the required `int` type.

TutorialFlags __cdecl lego::nerps::funcs::NERPFunc__GetTutorialFlags(int *stack)
{
	return globs::nerpsruntimeGlobs.tutorialFlags;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR0(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR1(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR2(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR3(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR4(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR5(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR6(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR7(int *stack)
{
	return globs::nerpsruntimeGlobs.registers[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR0(int *stack)
{
	globs::nerpsruntimeGlobs.registers[0] += *stack;
	return globs::nerpsruntimeGlobs.registers[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR1(int *stack)
{
	globs::nerpsruntimeGlobs.registers[1] += *stack;
	return globs::nerpsruntimeGlobs.registers[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR2(int *stack)
{
	globs::nerpsruntimeGlobs.registers[2] += *stack;
	return globs::nerpsruntimeGlobs.registers[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR3(int *stack)
{
	globs::nerpsruntimeGlobs.registers[3] += *stack;
	return globs::nerpsruntimeGlobs.registers[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR4(int *stack)
{
	globs::nerpsruntimeGlobs.registers[4] += *stack;
	return globs::nerpsruntimeGlobs.registers[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR5(int *stack)
{
	globs::nerpsruntimeGlobs.registers[5] += *stack;
	return globs::nerpsruntimeGlobs.registers[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR6(int *stack)
{
	globs::nerpsruntimeGlobs.registers[6] += *stack;
	return globs::nerpsruntimeGlobs.registers[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR7(int *stack)
{
	globs::nerpsruntimeGlobs.registers[7] += *stack;
	return globs::nerpsruntimeGlobs.registers[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR0(int *stack)
{
	globs::nerpsruntimeGlobs.registers[0] -= *stack;
	return globs::nerpsruntimeGlobs.registers[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR1(int *stack)
{
	globs::nerpsruntimeGlobs.registers[1] -= *stack;
	return globs::nerpsruntimeGlobs.registers[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR2(int *stack)
{
	globs::nerpsruntimeGlobs.registers[2] -= *stack;
	return globs::nerpsruntimeGlobs.registers[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR3(int *stack)
{
	globs::nerpsruntimeGlobs.registers[3] -= *stack;
	return globs::nerpsruntimeGlobs.registers[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR4(int *stack)
{
	globs::nerpsruntimeGlobs.registers[4] -= *stack;
	return globs::nerpsruntimeGlobs.registers[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR5(int *stack)
{
	globs::nerpsruntimeGlobs.registers[5] -= *stack;
	return globs::nerpsruntimeGlobs.registers[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR6(int *stack)
{
	globs::nerpsruntimeGlobs.registers[6] -= *stack;
	return globs::nerpsruntimeGlobs.registers[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR7(int *stack)
{
	globs::nerpsruntimeGlobs.registers[7] -= *stack;
	return globs::nerpsruntimeGlobs.registers[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR0(int *stack)
{
	globs::nerpsruntimeGlobs.registers[0] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR1(int *stack)
{
	globs::nerpsruntimeGlobs.registers[1] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR2(int *stack)
{
	globs::nerpsruntimeGlobs.registers[2] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR3(int *stack)
{
	globs::nerpsruntimeGlobs.registers[3] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR4(int *stack)
{
	globs::nerpsruntimeGlobs.registers[4] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR5(int *stack)
{
	globs::nerpsruntimeGlobs.registers[5] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR6(int *stack)
{
	globs::nerpsruntimeGlobs.registers[6] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR7(int *stack)
{
	globs::nerpsruntimeGlobs.registers[7] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialFlags(int *stack)
{
	globs::nerpsruntimeGlobs.tutorialFlags = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainFlags(int *stack)
{
	return globs::liveGlobs.NERPs_TrainFlags;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainFlags(int *stack)
{
	globs::liveGlobs.NERPs_TrainFlags = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMonstersOnLevel(int *stack)
{
	int iVar1;
	int iVar2;
	int iVar3;
	
	iVar1 = NERPsRuntime_GetLevelObjectsBuilt("LavaMonster",0);
	iVar2 = NERPsRuntime_GetLevelObjectsBuilt("RockMonster",0);
	iVar3 = NERPsRuntime_GetLevelObjectsBuilt("IceMonster",0);
	return iVar3 + iVar1 + iVar2;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBuildingsTeleported(int *stack)
{
	return globs::liveGlobs.BuildingsTeleported;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBuildingsTeleported(int *stack)
{
	game::LiveManage_SetNumBuildingsTeleported(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessagePermit(int *stack)
{
	globs::nerpsruntimeGlobs.messagePermit = *stack;
	if (*stack == TRUE) {
		game::Game_SetFlags2_40_And_2_unkCamera(FALSE,TRUE);
		game::Game_SetFlags2_80(FALSE);
	}
	globs::textGlobs.textFlags = 0;
	globs::textGlobs.field_484 = 0;
	return *stack;
}



// May actually be related to message capabilities.

BOOL __cdecl lego::nerps::NERPsRuntime_IsMessagePermit(void)
{
	return globs::nerpsruntimeGlobs.messagePermit;
}



BOOL __cdecl lego::nerps::NERPsRuntime_GetMessageWait(void)
{
	return globs::nerpsruntimeGlobs.messageWait;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessageWait(int *stack)
{
	globs::nerpsruntimeGlobs.messageWait = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessageTimerValues(int *stack)
{
	globs::nerps::nerpsMessageTimerValues[0] = (float)(ulonglong)(uint)*stack;
	globs::nerps::nerpsMessageTimerValues[1] = (float)(ulonglong)(uint)stack[1];
	globs::nerps::nerpsMessageTimerValues[2] = (float)(ulonglong)(uint)stack[2];
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMessageTimer(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globs::nerpsruntimeGlobs.messageTimer);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessage(int *stack)
{
	BOOL BVar1;
	char *text;
	uint lineIndex;
	
	BVar1 = NERPsRuntime_IsMessagePermit();
	if (BVar1 != 0) {
		return 0;
	}
	lineIndex = *stack;
	if (lineIndex != 0) {
		lineIndex -= 1;
	}
	text = NERPsFile_GetMessageLine(lineIndex);
	if (lineIndex != globs::nerpsfileGlobs.reserved1[globs::nerpsfileGlobs.uint_a0 + 0x12]) {
		if (globs::nerpsfileGlobs.uint_a0 == 8) {
			globs::nerpsfileGlobs.field_80 = globs::nerpsfileGlobs.field_90;
			globs::nerpsfileGlobs.field_84 = globs::nerpsfileGlobs.field_94;
			globs::nerpsfileGlobs.field_8c = globs::nerpsfileGlobs.field_9c;
			globs::nerpsfileGlobs.field_88 = globs::nerpsfileGlobs.field_98;
			globs::nerpsfileGlobs.uint_a0 = 4;
		}
		globs::nerpsfileGlobs.reserved1[globs::nerpsfileGlobs.uint_a0 + 0x13] = lineIndex;
		globs::nerpsfileGlobs.uint_a0 += 1;
		if (globs::nerpsfileGlobs.uint_a0 != 0) {
			game::Game_SetFlags2_80(1);
		}
		if (globs::nerpsfileGlobs.int_a4 != 0) {
			globs::nerpsfileGlobs.int_a4 += 1;
		}
	}
	front::Text_SetNERPsMessage(text,stack[1]);
	globs::nerpsruntimeGlobs.nextArrowDisabled = stack[1];
	globs::nerps::nerpsBOOL_004a7740 = TRUE;
	BVar1 = NERPsRuntime_GetMessageWait();
	if (BVar1 != 0) {
		ddraw::DirectDraw_Flip();
		while ((globs::INPUT.Key_Map[28] == false ||
					 (globs::INPUT.prevKey_Map[28] == globs::INPUT.Key_Map[28]))) {
			input::Input_ReadKeys();
		}
	}
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetObjectiveSwitch(int *stack)
{
	globs::nerpsruntimeGlobs.objectiveSwitch = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetObjectiveSwitch(int *stack)
{
	if (globs::nerpsruntimeGlobs.objectiveSwitch != 0) {
		globs::nerpsruntimeGlobs.objectiveSwitch = 0;
		return 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetObjectiveShowing(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Objective_IsObjectiveFinished();
	return (uint)(BVar1 != 0);
}



void __cdecl lego::nerps::NERPs_PlayUnkSampleIndex(void)
{
	if (globs::nerps::nerpsUnkSampleIndex != -1) {
		snd::Sound3D_Play2(SOUND3D_PLAY_NORMAL,NULL,globs::nerps::nerpsUnkSampleIndex,FALSE,NULL);
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::nerps::NERPs_Level_NERPMessage_Parse(char *text,undefined4 *param_2,BOOL param_3)
{
	char cVar1;
	bool bVar2;
	byte bVar3;
	BOOL BVar4;
	TutorialFlags TVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	Image **ppIVar11;
	float10 fVar12;
	Point2F local_164;
	uint local_15c;
	undefined4 uStack344;
	float local_154;
	Image *local_150 [20];
	char local_100 [256];
	
	ppIVar11 = local_150;
	local_150[0] = NULL;
	local_15c &= 0xffffff00;
	for (iVar6 = 0x13; ppIVar11 = ppIVar11 + 1, iVar6 != 0; iVar6 += -1) {
		*ppIVar11 = NULL;
	}
	local_154 = globs::nerps::nerpsMessageTimerValues[2];
	if (((globs::nerpsfileGlobs.messageCount == 0) && (globs::nerpsfileGlobs.soundCount == 0)) &&
		 (param_2 != NULL)) {
		uVar7 = 0xffffffff;
		do {
			pcVar10 = text;
			if (uVar7 == 0) break;
			uVar7 -= 1;
			pcVar10 = text + 1;
			cVar1 = *text;
			text = pcVar10;
		} while (cVar1 != '\0');
		uVar7 = ~uVar7;
		puVar9 = (undefined4 *)(pcVar10 + -uVar7);
		for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
			*param_2 = *puVar9;
			puVar9 = puVar9 + 1;
			param_2 = param_2 + 1;
		}
		for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
			*(undefined *)param_2 = *(undefined *)puVar9;
			puVar9 = (undefined4 *)((int)puVar9 + 1);
			param_2 = (undefined4 *)((int)param_2 + 1);
		}
	}
	else {
		cVar1 = *text;
		local_164.x = (float)param_2;
		while (cVar1 != '\0') {
			cVar1 = *text;
			if (cVar1 == '<') {
				cVar1 = text[1];
				text = text + 1;
				bVar2 = false;
				pcVar10 = local_100;
				while ((cVar1 != '\0' && (!bVar2))) {
					if (cVar1 == '>') {
						*pcVar10 = '\0';
						bVar3 = 0;
						if (globs::nerpsfileGlobs.messageCount != 0) {
							uVar7 = 0;
							do {
								iVar6 = std::_stricmp(*(char **)((int)globs::nerpsfileGlobs.messageList + uVar7 * 8)
																			,local_100);
								if (iVar6 == 0) {
									bVar2 = true;
									local_150[local_15c & 0xff] =
											 *(Image **)((int)globs::nerpsfileGlobs.messageList + (uint)bVar3 * 8 + 4);
									local_15c = local_15c & 0xffffff00 | (uint)(byte)((char)local_15c + 1);
									break;
								}
								bVar3 += 1;
								uVar7 = (uint)bVar3;
							} while (uVar7 < globs::nerpsfileGlobs.messageCount);
						}
					}
					else {
						*pcVar10 = cVar1;
					}
					pcVar10 = pcVar10 + 1;
					text = text + 1;
					cVar1 = *text;
				}
			}
			else {
				if (cVar1 == '#') {
					cVar1 = text[1];
					text = text + 1;
					bVar2 = false;
					pcVar10 = local_100;
					while ((cVar1 != '\0' && (!bVar2))) {
						if (cVar1 == '#') {
							*pcVar10 = '\0';
							bVar3 = 0;
							if (globs::nerpsfileGlobs.soundCount != 0) {
								uVar7 = 0;
								do {
									iVar6 = std::_stricmp(globs::nerpsfileGlobs.soundList[uVar7].key,local_100);
									if (iVar6 == 0) {
										uVar7 = (uint)bVar3;
										iVar6 = globs::nerpsfileGlobs.soundList[uVar7].sampleIndex;
										if (globs::nerpsfileGlobs.soundsUNKCOUNT != uVar7) {
											globs::nerpsfileGlobs.soundsUNKCOUNT = uVar7;
											fVar12 = snd::Sound3D_GetSamplePlayTime(iVar6);
											local_154 = (float)(fVar12 * (float10)globs::nerps::nerpsMessageTimerValues[0]
																				 + (float10)globs::nerps::nerpsMessageTimerValues[1]);
											BVar4 = snd::SFX_IsSoundOn();
											if (BVar4 != 0) {
												snd::SFX_StopGlobalSample();
												fVar12 = snd::Sound3D_GetSamplePlayTime(iVar6);
												snd::SFX_SetGlobalSampleDurationIfLE0_AndNullifyHandle
																	((float)(fVar12 * (float10)25.0));
												snd::Sound3D_Play2(SOUND3D_PLAY_NORMAL,NULL,iVar6,FALSE,NULL);
												globs::nerps::nerpsUnkSampleIndex = iVar6;
												TVar5 = funcs::NERPFunc__GetTutorialFlags(NULL);
												if (TVar5 == TUTORIAL_NONE) {
													front::Advisor_SetCurrentAdvisor(ADVISOR_TALKINGAME,TRUE);
													globs::nerpsfileGlobs.AdvisorTalkingMode = TRUE;
												}
											}
										}
										break;
									}
									bVar3 += 1;
									uVar7 = (uint)bVar3;
								} while (uVar7 < globs::nerpsfileGlobs.soundCount);
							}
							bVar2 = true;
						}
						else {
							*pcVar10 = cVar1;
						}
						pcVar10 = pcVar10 + 1;
						text = text + 1;
						cVar1 = *text;
					}
				}
				else {
					if (param_2 != NULL) {
						*(char *)local_164.x = cVar1;
						local_164.x = (float)((int)local_164.x + 1);
					}
					text = text + 1;
				}
			}
			cVar1 = *text;
		}
		if (param_2 != NULL) {
			*(char *)local_164.x = '\0';
		}
		if ((char)local_15c != '\0') {
			ppIVar11 = local_150;
			uVar8 = local_15c & 0xff;
			iVar6 = 0;
			uVar7 = uVar8;
			do {
				local_15c = globs::nerps::nerpsIconWidth * uVar8;
				local_164.y = globs::nerps::nerpsIconPos.y;
				uStack344 = 0;
				local_164.x = (float)(ulonglong)(uint)(globs::nerps::nerpsIconSpace * iVar6) +
											(globs::nerps::nerpsIconPos.x - (float)(ulonglong)local_15c);
				lego::image::Image_DisplayScaled(*ppIVar11,NULL,&local_164,NULL);
				iVar6 += 1;
				ppIVar11 = ppIVar11 + 1;
				uVar7 -= 1;
			} while (uVar7 != 0);
		}
	}
	if (param_3 != 0) {
		globs::nerpsruntimeGlobs.messageTimer = local_154;
	}
	return;
}



void __cdecl lego::nerps::NERPs_InitBlockPointersTable(LevelData *level)
{
	BlockPointer *pBVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	BlockPointer **ppBVar5;
	uint uVar6;
	
	uVar4 = 0;
	ppBVar5 = level->blockPointers;
	for (iVar2 = 0x37; iVar2 != 0; iVar2 += -1) {
		*ppBVar5 = NULL;
		ppBVar5 = ppBVar5 + 1;
	}
	if ((level->dimensions).width != 0) {
		do {
			uVar6 = 0;
			if ((level->dimensions).height != 0) {
				do {
					if (level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer != 0) {
						pBVar1 = (BlockPointer *)std::malloc(0xc);
						uVar3 = (uint)level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer;
						(pBVar1->blockPos).x = uVar4;
						(pBVar1->blockPos).y = uVar6;
						pBVar1->id = (uint)level->blockPointers[uVar3];
						level->blockPointers[uVar3] = pBVar1;
						level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer = 0;
					}
					uVar6 += 1;
				} while (uVar6 < (uint)(level->dimensions).height);
			}
			uVar4 += 1;
		} while (uVar4 < (uint)(level->dimensions).width);
	}
	return;
}



BlockPointer * __cdecl lego::nerps::NERPs_GetBlockPointer(LevelData *level,int blockPointerIdx)
{
	if (((-1 < blockPointerIdx) && (blockPointerIdx < 0x37)) &&
		 (level->blockPointers[blockPointerIdx] != NULL)) {
		return level->blockPointers[blockPointerIdx];
	}
	return NULL;
}



void __cdecl lego::nerps::NERPs_BlockPointers_FUN_00456f20(void)
{
	BlockPointer *pBVar1;
	LevelData *level;
	BlockPointer *buffer;
	BlockPointer **ppBVar2;
	int blockPointerIdx;
	
	level = lrr::Lego_GetLevel();
	blockPointerIdx = 0;
	ppBVar2 = level->blockPointers;
	do {
		buffer = NERPs_GetBlockPointer(level,blockPointerIdx);
		while (buffer != NULL) {
			pBVar1 = (BlockPointer *)buffer->id;
			std::free(buffer);
			buffer = pBVar1;
		}
		*ppBVar2 = NULL;
		blockPointerIdx += 1;
		ppBVar2 = ppBVar2 + 1;
	} while (blockPointerIdx < 0x37);
	return;
}



void __cdecl
lego::nerps::NERPsRuntime_EnumerateBlockPointers
					(int blockPointerIdx,NERPsBlockPointerCallback callback,void *data)
{
	LevelData *level;
	BlockPointer *blockPointer;
	BOOL BVar1;
	
	level = lrr::Lego_GetLevel();
	blockPointer = NERPs_GetBlockPointer(level,blockPointerIdx);
	while ((blockPointer != NULL &&
				 (BVar1 = (*callback)(blockPointer,(blockPointer->blockPos).x,(blockPointer->blockPos).y,
															data), BVar1 != 0))) {
		blockPointer = (BlockPointer *)blockPointer->id;
	}
	return;
}



BOOL __cdecl
lego::nerps::NERPsRuntime_TutorialActionCallback
					(undefined4 unused,int bx,int by,SearchNERPsTutorialAction *search)
{
	LevelData *level;
	BOOL BVar1;
	LiveObject *pLVar2;
	int iVar3;
	SearchNERPsTutorialAction *pSVar4;
	Point2I blockPos;
	Point2I camBlockPos;
	Vector3F local_38;
	SearchNERPsTutorialAction search2;
	
	level = lrr::Lego_GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	switch(search->action) {
	case NERPS_TUTORIAL_GETBLOCKISGROUND:
		search->result =
				 search->result +
				 (level->blocks[(level->dimensions).width * by + bx].flags1 & BLOCK1_GROUND);
		return TRUE;
	case NERPS_TUTORIAL_SETBLOCKISGROUND:
		BVar1 = 0;
		level = lrr::Lego_GetLevel();
		game::Level_DestroyWall(level,bx,by,BVar1);
		return TRUE;
	case NERPS_TUTORIAL_GETBLOCKISPATH:
		BVar1 = game::Level_Block_IsPath(&blockPos);
		search->result = search->result + BVar1;
		return TRUE;
	case NERPS_TUTORIAL_SETBLOCKISPATH:
		iVar3 = (level->dimensions).width * by + bx;
		level->blocks[iVar3].flags1 = level->blocks[iVar3].flags1 & ~BLOCK1_RUBBLE_FULL;
		game::Level_Block_ClearRubbleLayer(&blockPos);
		game::Level_Block_SetPath(&blockPos);
		return TRUE;
	case NERPS_TUTORIAL_SETCAMERAGOTOTUTORIAL:
		lrr::Lego_GotoInfo(NULL,&blockPos,TRUE);
		return TRUE;
	case NERPS_TUTORIAL_GETCAMERAATTUTORIAL:
		res::Container_GetPosition((globs::legoGlobs.cameraMain)->cont3,NULL,&local_38);
		game::Map3D_WorldToBlockPos_NoZ
							(level->surfaceMap,local_38.x,local_38.y,&camBlockPos.x,&camBlockPos.y);
		if ((blockPos.x == camBlockPos.x) && (blockPos.y == camBlockPos.y)) {
			search->result = 1;
			return TRUE;
		}
		break;
	case NERPS_TUTORIAL_SETROCKMONSTERATTUTORIAL:
		iVar3 = lrr::Lego_GetEmergeCreature();
		pLVar2 = game::Game_TryGeneratedRockMonsterLiveObject
											 ((int **)(globs::legoGlobs.RockMonsterData_TABLE + iVar3),OBJECT_ROCKMONSTER,
												iVar3,blockPos.x,blockPos.y);
		if (pLVar2 != NULL) {
			pLVar2->stats->PainThreshold = 60.0;
			return TRUE;
		}
		break;
	case NERPS_TUTORIAL_SETCONGREGATIONATTUTORIAL_START:
		ai::AITask_DoGoto_Congregate(&blockPos);
		return TRUE;
	case NERPS_TUTORIAL_SETCONGREGATIONATTUTORIAL_STOP:
		ai::AITask_StopGoto_Congregate(&blockPos);
		return TRUE;
	case NERPS_TUTORIAL_GETUNITATBLOCK:
		pSVar4 = &search2;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			pSVar4->action = NERPS_TUTORIAL_NONE;
			pSVar4 = (SearchNERPsTutorialAction *)&pSVar4->blockPointerIdx;
		}
		search2.blockPos.x = bx;
		search2.blockPos.y = by;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,&search2);
		search->result = search->result + search2.result;
		return TRUE;
	case NERPS_TUTORIAL_SETTUTORIALPOINTER_UNK:
		pSVar4 = &search2;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			pSVar4->action = NERPS_TUTORIAL_NONE;
			pSVar4 = (SearchNERPsTutorialAction *)&pSVar4->blockPointerIdx;
		}
		search2.blockPos.x = bx;
		search2.blockPos.y = by;
		search2.fieldBool_1c = 1;
		game::Search_LiveObjects_SkipIgnoreMes
							(NERPs_LiveObject_Callback_SetField3f8_FUN_00457390,&search2);
		return TRUE;
	case NERPS_TUTORIAL_MAKESOMEONEPICKUP:
		pSVar4 = &search2;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			pSVar4->action = NERPS_TUTORIAL_NONE;
			pSVar4 = (SearchNERPsTutorialAction *)&pSVar4->blockPointerIdx;
		}
		search2.blockPos.x = bx;
		search2.blockPos.y = by;
		search2.fieldBool_20 = 1;
		search2.int_28 = 2;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,&search2);
		pLVar2 = search2.object_24;
		if (search2.result != 0) {
			search2.int_28 = 6;
			game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,&search2);
			if (search2.result != 0) {
				game::LiveObject_TryCollect_FUN_00439ce0(pLVar2,search2.object_24);
				return TRUE;
			}
		}
		break;
	case NERPS_TUTORIAL_GETMONSTERATTUTORIAL:
		pSVar4 = &search2;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			pSVar4->action = NERPS_TUTORIAL_NONE;
			pSVar4 = (SearchNERPsTutorialAction *)&pSVar4->blockPointerIdx;
		}
		search2.blockPos.x = bx;
		search2.blockPos.y = by;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,&search2);
		search->result = search->result + search2.result;
	}
	return TRUE;
}



BOOL __cdecl lego::nerps::NERPs_LiveObject_CallbackCheck_FUN_00457320(LiveObject *liveObj,int level)
{
	int local_8;
	int local_4;
	
	if (liveObj != NULL) {
		game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		if ((local_8 == *(int *)(level + 0x14)) && (local_4 == *(int *)(level + 0x18))) {
			if ((*(int *)(level + 0x20) != 0) && (liveObj->objType == *(ObjectType *)(level + 0x28))) {
				*(LiveObject **)(level + 0x24) = liveObj;
				*(undefined4 *)(level + 8) = 1;
				return 1;
			}
			*(int *)(level + 8) = *(int *)(level + 8) + 1;
		}
	}
	return 0;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_SetField3f8_FUN_00457390(LiveObject *liveObj,int param_2)
{
	int local_8;
	int local_4;
	
	if (liveObj != NULL) {
		game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		if ((local_8 == *(int *)(param_2 + 0x14)) && (local_4 == *(int *)(param_2 + 0x18))) {
			liveObj->field_3f8 = 1;
			return 0;
		}
		liveObj->field_3f8 = 0;
	}
	return 0;
}



int __cdecl
lego::nerps::funcs::NERPFunc__MakeSomeoneOnThisBlockPickUpSomethingOnThisBlock(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_24 = 0;
	local_28 = *stack;
	local_2c = 0xc;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



void __cdecl lego::nerps::NERPsRuntime_SetTutorialPointer(int blockPointerIdx,int unkMode0_1)
{
	LevelData *level;
	BlockPointer *pBVar1;
	BOOL BVar2;
	int local_34;
	int local_30;
	SearchNERPsTutorialAction search;
	
	level = lrr::Lego_GetLevel();
	for (pBVar1 = NERPs_GetBlockPointer(level,blockPointerIdx); pBVar1 != NULL;
			pBVar1 = (BlockPointer *)pBVar1->id) {
		if ((LiveObject *)unkMode0_1 == (LiveObject *)0x1) {
			level->blocks[(level->dimensions).width * (pBVar1->blockPos).y + (pBVar1->blockPos).x].
			blockpointer = (byte)blockPointerIdx;
			search.blockPointerIdx = blockPointerIdx;
			search.result = 0;
			search.action = NERPS_TUTORIAL_SETTUTORIALPOINTER_UNK;
			NERPsRuntime_EnumerateBlockPointers
								(blockPointerIdx,
								 (NERPsBlockPointerCallback)globs::constant::c_NERPsRuntime_TutorialActionCallback,
								 &search);
		}
		if ((LiveObject *)unkMode0_1 == NULL) {
			level->blocks[(level->dimensions).width * (pBVar1->blockPos).y + (pBVar1->blockPos).x].
			blockpointer = 0;
		}
	}
	if ((globs::nerpsfileGlobs.RecordObjectPointer != 0) &&
		 (BVar2 = game::Game_GetRecordObject
												(globs::nerpsfileGlobs.RecordObjectPointer - 1,(LiveObject **)&unkMode0_1),
		 BVar2 != 0)) {
		game::LiveObject_GetBlockPos((LiveObject *)unkMode0_1,&local_34,&local_30);
		search.blockPos.x = local_34;
		search.blockPos.y = local_30;
		NERPs_LiveObject_Callback_SetField3f8_FUN_00457390((LiveObject *)unkMode0_1,(int)&search);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCongregationAtTutorial(int *stack)
{
	SearchNERPsTutorialAction search;
	
	search.result = 0;
	search.blockPointerIdx = *stack;
	search.action = NERPS_TUTORIAL_SETCONGREGATIONATTUTORIAL_STOP - (stack[1] != 0);
	NERPsRuntime_EnumerateBlockPointers
						(search.blockPointerIdx,
						 (NERPsBlockPointerCallback)globs::constant::c_NERPsRuntime_TutorialActionCallback,
						 &search);
	return search.result;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 7;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCameraGotoTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 5;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCameraAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 6;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockIsGround(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 1;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockIsPath(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 3;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockIsGround(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 2;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockIsPath(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 4;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUnitAtBlock(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 10;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMonsterAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 0xd;
	local_28 = *stack;
	local_24 = 0;
	NERPsRuntime_EnumerateBlockPointers
						(local_28,(NERPsBlockPointerCallback)
											globs::constant::c_NERPsRuntime_TutorialActionCallback,&local_2c);
	return local_24;
}



void __cdecl
lego::game::Objective_Level_LoadObjectiveText
					(CFGProperty *root,undefined4 param_2,char *param_3,LevelData *level,char *filename)
{
	char cVar1;
	TextWindow *textWnd;
	uint uVar2;
	char *pcVar3;
	uint uVar4;
	char *pcVar5;
	int iVar6;
	int iVar7;
	TextWindow **ppTVar8;
	char **ppcVar9;
	undefined4 *puVar10;
	undefined4 *puVar11;
	char *pcVar12;
	bool bVar13;
	longlong lVar14;
	size_t _MaxCount;
	size_t local_cc8;
	int local_cc0;
	Area2F local_cbc;
	int local_cac;
	int local_ca8;
	Area2F local_ca4;
	char *local_c94;
	Area2F local_c90;
	char local_c80 [126];
	char acStack3074 [1026];
	undefined4 local_800 [256];
	char local_400 [1024];
	
	local_ca4.x = (level->objective).ObjectiveImagePosition.x - -60.0;
	local_c90.y = (level->objective).ObjectiveImagePosition.y - -220.0;
	local_ca4.y = (level->objective).ObjectiveImagePosition.y - -60.0;
	local_cbc.x = (level->objective).ObjectiveImagePosition.x - -40.0;
	local_cbc.y = (level->objective).ObjectiveImagePosition.y - -34.0;
	local_c90.width = 320.0;
	local_c90.height = 20.0;
	local_ca4.width = 390.0;
	local_cac = 0;
	local_ca4.height = 180.0;
	local_cbc.width = 422.0;
	local_cbc.height = 21.0;
	local_cc0 = 0;
	iVar6 = 0;
	local_ca8 = 0;
	local_c90.x = local_ca4.x;
	std::sprintf(CHAR_ARRAY_00500bc8,"%s",filename);
	if (globals::g_Objective_StatusTextWindows[0] != NULL) {
		front::TextWindow_Remove(globals::g_Objective_StatusTextWindows[0]);
	}
	if (PTRTextWindow_00500e18 != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e18);
	}
	if (PTRTextWindow_00500e1c != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e1c);
	}
	if (PTRTextWindow_00500e20 != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e20);
	}
	if (PTRTextWindow_00500e24 != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e24);
	}
	ppTVar8 = globals::g_Objective_StatusTextWindows;
	do {
		textWnd = front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT,&local_ca4,0x400);
		*ppTVar8 = textWnd;
		front::TextWindow_EnableCentering(textWnd,0);
		ppTVar8 = ppTVar8 + 1;
	} while (ppTVar8 < &PTRTextWindow_00500e18);
	PTRTextWindow_00500e24 =
			 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT2,&local_c90,0x400);
	BOOL_00500e2c = 0;
	PTRFileStream_00500bc4 = lego::file::File_Open(CHAR_ARRAY_00500bc8,"r");
	ppcVar9 = globals::g_Objective_StatusMessages;
	do {
		if (*ppcVar9 != NULL) {
			std::free(*ppcVar9);
			*ppcVar9 = NULL;
		}
		ppcVar9[0x6c] = NULL;
		ppcVar9[0x68] = NULL;
		ppcVar9[100] = NULL;
		ppcVar9 = ppcVar9 + 1;
	} while (ppcVar9 < &DAT_00500c58);
	if (PTRFileStream_00500bc4 != NULL) {
		lego::file::File_Seek(PTRFileStream_00500bc4,0,0);
		uVar4 = 0xffffffff;
		pcVar3 = param_3;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar3;
			pcVar3 = pcVar3 + 1;
		} while (cVar1 != '\0');
		uVar2 = 0;
		if (~uVar4 != 1) {
			do {
				if (iVar6 == 2) {
					local_c94 = param_3 + uVar2;
					local_ca8 = 1;
					break;
				}
				if (param_3[uVar2] == ':') {
					iVar6 += 1;
				}
				uVar2 += 1;
			} while (uVar2 < ~uVar4 - 1);
		}
		pcVar3 = lego::file::File_GetS(acStack3074 + 2,0x400,PTRFileStream_00500bc4);
		while (pcVar3 != NULL) {
			if (local_ca8 != 0) {
				uVar4 = 0xffffffff;
				pcVar3 = local_c94;
				do {
					pcVar5 = pcVar3;
					if (uVar4 == 0) break;
					uVar4 -= 1;
					pcVar5 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar5;
				} while (cVar1 != '\0');
				uVar4 = ~uVar4;
				puVar10 = (undefined4 *)(pcVar5 + -uVar4);
				puVar11 = local_800;
				for (uVar2 = uVar4 >> 2; uVar2 != 0; uVar2 -= 1) {
					*puVar11 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
					*(undefined *)puVar11 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				local_cc8 = std::sprintf(local_400,"[%s]",local_800);
				if (acStack3074[2] == '[') {
					local_cac = 0;
					local_cc0 = 0;
				}
				if (local_cac != 0) {
					uVar4 = 0xffffffff;
					uVar2 = 10;
					pcVar3 = acStack3074 + 2;
					do {
						if (uVar4 == 0) break;
						uVar4 -= 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar3 + 1;
					} while (cVar1 != '\0');
					_MaxCount = 10;
					iVar7 = 4;
					acStack3074[~uVar4] = '\0';
					iVar6 = std::_strnicmp(acStack3074 + 2,"Objective:",_MaxCount);
					if (iVar6 == 0) {
						iVar7 = 0;
					}
					else {
						uVar2 = 0xb;
						iVar6 = std::_strnicmp(acStack3074 + 2,"Completion:",0xb);
						if (iVar6 == 0) {
							iVar7 = 1;
						}
						else {
							uVar2 = 8;
							iVar6 = std::_strnicmp(acStack3074 + 2,"Failure:",8);
							if (iVar6 == 0) {
								iVar7 = 2;
							}
							else {
								uVar2 = 0xf;
								iVar6 = std::_strnicmp(acStack3074 + 2,"CrystalFailure:",0xf);
								if (iVar6 == 0) {
									iVar7 = 3;
								}
							}
						}
					}
					if (iVar7 != 4) {
						uVar4 = 0xffffffff;
						pcVar3 = acStack3074 + 2;
						do {
							if (uVar4 == 0) break;
							uVar4 -= 1;
							cVar1 = *pcVar3;
							pcVar3 = pcVar3 + 1;
						} while (cVar1 != '\0');
						if (uVar2 < ~uVar4 - 1) {
							do {
								if ((acStack3074[uVar2 + 2] != ' ') && (acStack3074[uVar2 + 2] != '\t')) break;
								uVar4 = 0xffffffff;
								uVar2 += 1;
								pcVar3 = acStack3074 + 2;
								do {
									if (uVar4 == 0) break;
									uVar4 -= 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar3 + 1;
								} while (cVar1 != '\0');
							} while (uVar2 < ~uVar4 - 1);
						}
						bVar13 = false;
						pcVar3 = acStack3074 + 2;
						cVar1 = acStack3074[2];
						while (cVar1 != '\0') {
							if ((bVar13) && ((*pcVar3 == 'a' || (*pcVar3 == 'n')))) {
								pcVar3[-1] = ' ';
								if (*pcVar3 == 'a') {
									uVar4 = globals::g_Objective_StatusBellCounts[iVar7];
									*pcVar3 = '\a';
									globals::g_Objective_StatusBellCounts[iVar7] = uVar4 + 1;
									bVar13 = false;
								}
								else {
									*pcVar3 = '\n';
									bVar13 = false;
								}
							}
							else {
								bVar13 = *pcVar3 == '\\';
							}
							pcVar5 = pcVar3 + 1;
							pcVar3 = pcVar3 + 1;
							cVar1 = *pcVar5;
						}
						front::TextWindow_PrintF
											(globals::g_Objective_StatusTextWindows[iVar7],"%s",acStack3074 + uVar2 + 2);
						pcVar3 = util::_strdup(acStack3074 + uVar2 + 2);
						globals::g_Objective_StatusMessages[iVar7] = pcVar3;
					}
				}
				if (local_cc0 != 0) {
					uVar4 = 0xffffffff;
					pcVar3 = acStack3074 + 2;
					pcVar5 = acStack3074 + 2;
					do {
						if (uVar4 == 0) break;
						uVar4 -= 1;
						cVar1 = *pcVar5;
						pcVar5 = pcVar5 + 1;
					} while (cVar1 != '\0');
					acStack3074[~uVar4] = '\0';
					front::TextWindow_PrintF(PTRTextWindow_00500e24,"%s",pcVar3);
					local_cc0 = 0;
					BOOL_00500e2c = TRUE;
				}
				iVar6 = std::_strnicmp(local_400,acStack3074 + 2,local_cc8);
				if (iVar6 == 0) {
					local_cac = 1;
				}
				iVar6 = std::_strnicmp(acStack3074 + 2,"[BEGIN]",7);
				if (iVar6 == 0) {
					local_cc0 = 1;
				}
			}
			pcVar3 = lego::file::File_GetS(acStack3074 + 2,0x400,PTRFileStream_00500bc4);
		}
		lego::file::File_Close(PTRFileStream_00500bc4);
	}
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MissionBriefingText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != NULL) {
		uVar4 = lego::image::Font_GetStringWidth(globs::legoGlobs.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e18 =
				 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e18 != NULL) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 += -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 += 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e18);
			front::TextWindow_PrintF(PTRTextWindow_00500e18,"%s",local_c80);
		}
	}
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MissionCompletedText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != NULL) {
		uVar4 = lego::image::Font_GetStringWidth(globs::legoGlobs.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e1c =
				 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e1c != NULL) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 += -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 += 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e1c);
			front::TextWindow_PrintF(PTRTextWindow_00500e1c,"%s",local_c80);
		}
	}
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,"Main","MissionFailedText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != NULL) {
		uVar4 = lego::image::Font_GetStringWidth(globs::legoGlobs.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e20 =
				 front::TextWindow_Create(globs::legoGlobs.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e20 != NULL) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 += -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 += 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e20);
			front::TextWindow_PrintF(PTRTextWindow_00500e20,"%s",local_c80);
		}
	}
	if (BOOL_00500e2c == 0) {
		local_ca4.height = local_ca4.height + local_c90.height;
		ppTVar8 = globals::g_Objective_StatusTextWindows;
		do {
			lVar14 = __ftol((float10)local_ca4.height);
			uVar4 = (uint)lVar14;
			lVar14 = __ftol((float10)local_ca4.width);
			front::TextWindow_ChangeSize(*ppTVar8,(uint)lVar14,uVar4);
			ppTVar8 = ppTVar8 + 1;
		} while (ppTVar8 < globals::g_Objective_StatusTextWindows + 3);
	}
	return;
}



void __cdecl
lego::game::Objective_Level_LoadObjectiveInfo
					(CFGProperty *root,char *rootPath,char *levelName,LevelData *level,int screenWidth,
					int screenHeight)
{
	ObjectiveData *pOVar1;
	char *pcVar2;
	BoolTri BVar3;
	Image *pIVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	char *pcVar9;
	BOOL BVar10;
	int iVar11;
	ObjectiveData *pOVar12;
	int local_500;
	ObjectType local_4fc;
	Point2I local_4f8;
	char *local_4f0;
	char *local_4ec;
	char *local_4e8;
	char *local_4e4;
	char *local_4e0;
	char *local_4dc;
	char local_400 [1024];
	
	pOVar1 = &level->objective;
	pOVar12 = pOVar1;
	for (iVar11 = 0x15; iVar11 != 0; iVar11 += -1) {
		pOVar12->ObjectiveImage = NULL;
		pOVar12 = (ObjectiveData *)&pOVar12->ObjectiveImagePosition;
	}
	globals::g_ObjectiveFlags = OBJECTIVE_NONE;
	globals::g_ObjectiveSwitch = 1;
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWADVISOR;
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveAcheiveAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWACHEIVEADVISOR;
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveFailedAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWFAILEDADVISOR;
	}
	std::sprintf(local_400,"ObjectiveImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::_strdup(pcVar2);
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		if (pOVar1->ObjectiveImage != NULL) {
			lego::image::Image_Remove(pOVar1->ObjectiveImage);
		}
		pIVar4 = lego::image::Image_LoadBMPScaled(local_4f0,0,0);
		pOVar1->ObjectiveImage = pIVar4;
		if (pIVar4 != NULL) {
			lego::image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar5 = std::atoi(local_4ec);
		(level->objective).ObjectiveImagePosition.x = (float)iVar5;
		iVar5 = std::atoi(local_4e8);
		(level->objective).ObjectiveImagePosition.y = (float)iVar5;
		if ((iVar11 == 6) && (pOVar1->ObjectiveImage != NULL)) {
			uVar6 = std::atoi(local_4e4);
			uVar7 = std::atoi(local_4e0);
			uVar8 = std::atoi(local_4dc);
			lego::image::Image_SetupTrans
								(pOVar1->ObjectiveImage,(float)(ulonglong)(uVar6 / 0xff),
								 (float)(ulonglong)(uVar7 / 0xff),(float)(ulonglong)(uVar8 / 0xff),
								 (float)(ulonglong)(uVar6 / 0xff),(float)(ulonglong)(uVar7 / 0xff),
								 (float)(ulonglong)(uVar8 / 0xff));
		}
		std::free(pcVar2);
	}
	std::sprintf(local_400,"ObjectiveAcheivedImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::_strdup(pcVar2);
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		pIVar4 = (level->objective).ObjectiveAcheivedImage;
		if (pIVar4 != NULL) {
			lego::image::Image_Remove(pIVar4);
		}
		pIVar4 = lego::image::Image_LoadBMPScaled(local_4f0,0,0);
		(level->objective).ObjectiveAcheivedImage = pIVar4;
		if (pIVar4 != NULL) {
			lego::image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar5 = std::atoi(local_4ec);
		(level->objective).ObjectiveAcheivedImagePosition.x = (float)iVar5;
		iVar5 = std::atoi(local_4e8);
		(level->objective).ObjectiveAcheivedImagePosition.y = (float)iVar5;
		if ((iVar11 == 6) && ((level->objective).ObjectiveAcheivedImage != NULL)) {
			uVar6 = std::atoi(local_4e4);
			uVar7 = std::atoi(local_4e0);
			uVar8 = std::atoi(local_4dc);
			lego::image::Image_SetupTrans
								(pOVar1->ObjectiveImage,(float)(ulonglong)(uVar6 / 0xff),
								 (float)(ulonglong)(uVar7 / 0xff),(float)(ulonglong)(uVar8 / 0xff),
								 (float)(ulonglong)(uVar6 / 0xff),(float)(ulonglong)(uVar7 / 0xff),
								 (float)(ulonglong)(uVar8 / 0xff));
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ObjectiveAcheivedAVI",0);
	pcVar2 = cfg::CFG_CopyString(root,pcVar2);
	if (pcVar2 != NULL) {
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		pcVar9 = util::_strdup(local_4f0);
		(level->objective).ObjectiveAcheivedAVIFilename = pcVar9;
		if (iVar11 == 3) {
			iVar11 = std::atoi(local_4ec);
			(level->objective).ObjectiveAcheivedAVIPosition.x = (float)iVar11;
			iVar11 = std::atoi(local_4e8);
			(level->objective).ObjectiveAcheivedAVIPosition.y = (float)iVar11;
			std::free(pcVar2);
		}
		else {
			(level->objective).field_30 = 1;
			std::free(pcVar2);
		}
	}
	std::sprintf(local_400,"ObjectiveFailedImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,",");
		pIVar4 = (level->objective).ObjectiveFailedImage;
		if (pIVar4 != NULL) {
			lego::image::Image_Remove(pIVar4);
		}
		pIVar4 = lego::image::Image_LoadBMPScaled(local_4f0,0,0);
		(level->objective).ObjectiveFailedImage = pIVar4;
		if (pIVar4 != NULL) {
			lego::image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar11 = std::atoi(local_4ec);
		(level->objective).ObjectiveFailedImagePosition.x = (float)iVar11;
		iVar11 = std::atoi(local_4e8);
		(level->objective).ObjectiveFailedImagePosition.y = (float)iVar11;
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"CrystalObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"CrystalObjective",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	iVar11 = std::atoi(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"OreObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"OreObjective",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	iVar5 = std::atoi(pcVar2);
	Objective_SetCryOreObjectives(level,iVar11,iVar5);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"TimerObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,":");
		iVar11 = std::atoi(local_4f0);
		iVar5 = std::_stricmp(local_4ec,"HitTimeFailObjective");
		Objective_SetTimerObjective(level,(float)iVar11 * 25.0,(uint)(iVar5 == 0));
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ConstructionObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if ((pcVar2 != NULL) &&
		 (BVar10 = Object_GetObjectByName(pcVar2,&local_4fc,&local_500,NULL), BVar10 != 0)) {
		Objective_SetConstructionObjective(level,local_4fc,local_500);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"BlockObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,",");
		local_4f8.x = std::atoi(local_4f0);
		local_4f8.y = std::atoi(local_4ec);
		Objective_SetBlockObjective(level,&local_4f8);
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ObjectiveText",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		Objective_Level_LoadObjectiveText(root,rootPath,levelName,level,pcVar2);
	}
	if (globals::g_ObjectiveFlags == OBJECTIVE_NONE) {
		globals::g_ObjectiveFlags = OBJECTIVE_SHOWADVISOR;
	}
	return;
}



void __cdecl
lego::game::Objective_SetCryOreObjectives(LevelData *level,int crystalObjective,int oreObjective)
{
	if (crystalObjective != 0) {
		globals::g_ObjectiveFlags |= OBJECTIVE_CRYSTAL;
		(level->objective).CrystalObjective = crystalObjective;
	}
	if (oreObjective != 0) {
		globals::g_ObjectiveFlags |= OBJECTIVE_ORE;
		(level->objective).OreObjective = oreObjective;
	}
	return;
}



void __cdecl lego::game::Objective_SetBlockObjective(LevelData *level,Point2I *blockPos)
{
	globals::g_ObjectiveFlags |= OBJECTIVE_BLOCK;
	(level->objective).BlockObjective.x = blockPos->x;
	(level->objective).BlockObjective.y = blockPos->y;
	return;
}



void __cdecl
lego::game::Objective_SetTimerObjective
					(LevelData *level,float timerObjective,BOOL hitTimeFailObjective)
{
	globals::g_ObjectiveFlags |= OBJECTIVE_TIMER;
	(level->objective).TimerObjective = timerObjective;
	if (hitTimeFailObjective != 0) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWACHEIVEADVISOR;
	}
	return;
}



void __cdecl
lego::game::Objective_SetConstructionObjective(LevelData *level,ObjectType objType,int objIndex)
{
	globals::g_ObjectiveFlags |= OBJECTIVE_CONSTRUCTION;
	(level->objective).ConstructionObjectiveObjType = objType;
	(level->objective).ConstructionObjectiveObjIndex = objIndex;
	return;
}



BOOL __cdecl lego::game::Objective_IsLevelComplete(void)
{
	return globals::g_LevelIsComplete;
}



void __cdecl lego::game::Objective_SetEndTeleportEnabled(BOOL endTeleportEnabled)
{
	globals::g_IsEndTeleportEnabled = endTeleportEnabled;
	return;
}



void __cdecl lego::game::Objective_SetCompleteStatus(LevelCompleteStatus status)
{
	bool bVar1;
	bool bVar2;
	LevelData *pLVar3;
	TutorialFlags TVar4;
	char *pcVar5;
	char *pcVar6;
	uint teleportFlags;
	char *pcVar7;
	char local_100 [256];
	
	pLVar3 = lrr::Lego_GetLevel();
	pcVar7 = NULL;
	bVar1 = true;
	bVar2 = true;
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar4 == TUTORIAL_NONE) {
		globs::legoGlobs.flags2 |= GAME2_INMENU;
	}
	globals::g_Objective_StatusUnkCounts[0] = 0;
	globals::g_Objective_StatusUnkCounts[1] = 0;
	globals::g_Objective_StatusUnkCounts[2] = 0;
	globals::g_Objective_StatusUnkCounts[3] = 0;
	if ((globals::g_ObjectiveFlags & (OBJECTIVE_UNK_1|OBJECTIVE_COMPLETE|OBJECTIVE_FAILED)) !=
			OBJECTIVE_NONE) {
		globals::g_Objective_StatusUnkCounts[0] = 0;
		globals::g_Objective_StatusUnkCounts[1] = 0;
		globals::g_Objective_StatusUnkCounts[2] = 0;
		globals::g_Objective_StatusUnkCounts[3] = 0;
		return;
	}
	if ((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
		globals::g_Objective_StatusUnkCounts[0] = 0;
		globals::g_Objective_StatusUnkCounts[1] = 0;
		globals::g_Objective_StatusUnkCounts[2] = 0;
		globals::g_Objective_StatusUnkCounts[3] = 0;
		return;
	}
	while ((((globs::INPUT.mslb != 0 || (globs::INPUT.msrb != 0)) || (globs::INPUT.mslbheld != 0)) ||
				 (globs::INPUT.lClicked != 0))) {
		globs::INPUT.lClicked = 0;
		main::Main_LoopUpdate(1);
	}
	if (status == LEVELSTATUS_NONE) {
		pcVar7 = ____EMPTYSTR__;
		globals::g_ObjectiveFlags |= OBJECTIVE_UNK_1;
		bVar1 = false;
		pLVar3->status = LEVELSTATUS_NONE;
	}
	else {
		if (status == LEVELSTATUS_COMPLETE) {
			globals::g_LevelIsComplete = 1;
			globals::g_ObjectiveFlags |= OBJECTIVE_COMPLETE;
			pLVar3->status = LEVELSTATUS_COMPLETE;
			pcVar7 = "Acheived";
			lego::image::Image_GetScreenshot
								(&globals::g_RewardCur.saveCaptureImage,globals::g_Menu_SaveImage_BigSize.width,
								 globals::g_Menu_SaveImage_BigSize.height);
			globals::g_RewardCur.saveHasCapture = 1;
		}
		else {
			if (status == LEVELSTATUS_FAILED) {
				globals::g_LevelIsComplete = 0;
				globals::g_ObjectiveFlags |= OBJECTIVE_FAILED;
				pcVar7 = "Failed";
				pLVar3->status = LEVELSTATUS_FAILED;
			}
			else {
				if (status != LEVELSTATUS_FAILED_CRYSTALS) goto LAB_00458a9a;
				globals::g_LevelIsComplete = 0;
				globals::g_ObjectiveFlags |= OBJECTIVE_FAILED|OBJECTIVE_CRYSTAL;
				pcVar7 = "FailedCrystals";
				pLVar3->status = LEVELSTATUS_FAILED;
				bVar2 = false;
			}
		}
		lrr::Lego_UnkObjective_CompleteSub_FUN_004262f0();
		reward::Reward_CountUnits();
	}
LAB_00458a9a:
	globals::g_ObjectiveFlags |= OBJECTIVE_UNK_8;
	if (bVar1) {
						// (globals::g_IsEndTeleportEnabled ? 2 : 4)
		teleportFlags = (-(uint)(globals::g_IsEndTeleportEnabled != 0) & 0xfffffffe) + 4;
		unk::Teleporter_Start(TELEPORT_SERVIVE_VEHICLE,2,teleportFlags);
		unk::Teleporter_Start(TELEPORT_SERVIVE_MINIFIGURE,2,teleportFlags);
		unk::Teleporter_Start(TELEPORT_SERVIVE_BUILDING,2,teleportFlags);
		unk::Teleporter_Start(TELEPORT_SERVIVE_ELECTRICFENCE,2,teleportFlags);
		Game_DisableCryOreDrop(TRUE);
		LiveManager_SetFlag20(TRUE);
	}
	if ((pcVar7 != NULL) && (((byte)globs::legoGlobs.flags1 & GAME1_SOUNDON) != 0)) {
		if (bVar2) {
			pcVar6 = pLVar3->levelName;
		}
		else {
			pcVar6 = ____EMPTYSTR__;
		}
		pcVar5 = "_";
		if (!bVar2) {
			pcVar5 = ____EMPTYSTR__;
		}
		std::sprintf(local_100,"Stream_Objective%s%s%s",pcVar7,pcVar5,pcVar6);
		if (globals::g_StreamObjective_Sample != NULL) {
			std::free(globals::g_StreamObjective_Sample);
		}
		globals::g_StreamObjective_Sample = util::_strdup(local_100);
		INT_00500e3c = -1;
		BOOL_00500e44 = 0;
		return;
	}
	globals::g_StreamObjective_Sample = NULL;
	return;
}



void __cdecl lego::game::Objective_ProgrammerModeGT3_FUN_00458ba0(void)
{
	TutorialFlags tutFlags;
	
	if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
				globals::g_ObjectiveFlags &= ~(OBJECTIVE_FAILED|OBJECTIVE_CRYSTAL);
			}
		}
		else {
			globals::g_ObjectiveFlags &= ~OBJECTIVE_COMPLETE;
		}
	}
	else {
		nerps::funcs::NERPFunc__SetObjectiveSwitch(&globals::g_ObjectiveSwitch);
		globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_1;
		globals::g_ObjectiveSwitch = 0;
		if ((globs::legoGlobs.flags2 & GAME2_MUSICON) != GAME2_NONE) {
			snd::Music_PlayNext(TRUE);
			globs::legoGlobs.flags2 &= ~GAME2_MUSICON;
		}
	}
	front::Advisor_ClearFlag2();
	if (INT_00500e3c != -1) {
		snd::Sound3D_Stream_Stop(FALSE);
		INT_00500e3c = -1;
	}
	Game_SetPaused(FALSE,FALSE);
	snd::SFX_PlayQueuedInstances_SetFlag8To(FALSE);
	tutFlags = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (tutFlags == TUTORIAL_NONE) {
		globs::legoGlobs.flags2 &= ~GAME2_INMENU;
	}
	return;
}



BOOL __cdecl lego::game::Objective_IsObjectiveFinished(void)
{
						// (OBJECTIVE_UNK_1|OBJECTIVE_COMPLETE|OBJECTIVE_FAILED) (0x1|0x2|0x4)
	if (((byte)globals::g_ObjectiveFlags & 7) == 0) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl
lego::game::Objective_HandleKeys
					(BOOL spaceKeyHeld,BOOL leftButtonReleasedUnk,BOOL *out_gotoNextLevel)
{
	BOOL BVar1;
	LevelCompleteStatus status;
	
	status = LEVELSTATUS_FAILED_OTHER;
	if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
				status = (LevelCompleteStatus)((byte)(globals::g_ObjectiveFlags >> 8) & 1 | 2);
			}
		}
		else {
			status = LEVELSTATUS_COMPLETE;
		}
	}
	else {
		status = LEVELSTATUS_NONE;
	}
	*out_gotoNextLevel = 0;
	if (((spaceKeyHeld != 0) || (leftButtonReleasedUnk != 0)) &&
		 (globals::g_Objective_StatusUnkCounts[status] == globals::g_Objective_StatusBellCounts[status])
		 ) {
		if (((globs::INPUT.msx < 130) ||
				((int)((globs::legoGlobs.BackButtonImage)->width + 130) <= globs::INPUT.msx)) ||
			 ((globs::INPUT.msy < 315 ||
				((int)((globs::legoGlobs.BackButtonImage)->height + 315) <= globs::INPUT.msy)))) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
				if ((globals::g_ObjectiveFlags & (OBJECTIVE_COMPLETE|OBJECTIVE_FAILED)) != OBJECTIVE_NONE) {
					BVar1 = unk::Teleporter_ServiceAll
														(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
														 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
					if (BVar1 != 0) {
						Objective_ProgrammerModeGT3_FUN_00458ba0();
						BVar1 = lrr::Lego_EndLevel();
						*out_gotoNextLevel = (uint)(BVar1 == 0);
					}
				}
			}
			else {
				Objective_ProgrammerModeGT3_FUN_00458ba0();
				Game_SetMenuNextPosition(NULL);
				Game_SetMenuPreviousPosition(NULL);
				Game_SetPaused(FALSE,FALSE);
				input::Input_SetCursorPos
									((int)globs::mainGlobs.appWidth / 2,(int)globs::mainGlobs.appHeight / 2);
				BVar1 = front::Bubble_GetObjectUIsAlwaysVisible();
				if (BVar1 != 0) {
					front::Bubble_ToggleObjectUIsAlwaysVisible();
				}
			}
		}
	}
	if (status == LEVELSTATUS_FAILED_OTHER) goto LAB_00458e8c;
	if (globals::g_Objective_StatusUnkCounts[status] < globals::g_Objective_StatusBellCounts[status])
	{
		if (((globs::INPUT.msx < 470) ||
				((int)((globs::legoGlobs.NextButtonImage)->width + 470) <= globs::INPUT.msx)) ||
			 ((globs::INPUT.msy < 315 ||
				((int)((globs::legoGlobs.NextButtonImage)->height + 315) <= globs::INPUT.msy)))) {
LAB_00458e07:
			if (spaceKeyHeld == 0) goto LAB_00458e20;
			if (leftButtonReleasedUnk != 0) goto LAB_00458e0f;
		}
		else {
			front::ToolTip_AddFlag4(TOOLTIP_MORE);
			if (leftButtonReleasedUnk == 0) goto LAB_00458e07;
LAB_00458e0f:
			Game_SetPointer_AndPlayEnumSFX(0);
		}
		globals::g_Objective_StatusUnkCounts[status] = globals::g_Objective_StatusUnkCounts[status] + 1;
	}
LAB_00458e20:
	if ((((globals::g_Objective_StatusUnkCounts[status] != 0) && (0x81 < globs::INPUT.msx)) &&
			(globs::INPUT.msx < (int)((globs::legoGlobs.BackButtonImage)->width + 0x82))) &&
		 ((0x13a < globs::INPUT.msy &&
			(globs::INPUT.msy < (int)((globs::legoGlobs.BackButtonImage)->height + 0x13b))))) {
		front::ToolTip_AddFlag4(TOOLTIP_BACK);
		if (leftButtonReleasedUnk != 0) {
			Game_SetPointer_AndPlayEnumSFX(0);
			globals::g_Objective_StatusUnkCounts[status] =
					 globals::g_Objective_StatusUnkCounts[status] - 1;
		}
	}
LAB_00458e8c:
	BVar1 = Objective_IsObjectiveFinished();
	return BVar1;
}



void __cdecl
lego::game::Objective_Update
					(TextWindow *textWnd,LevelData *level,float elapsedGame,float elapsedAbs)
{
	Image *image;
	bool bVar1;
	bool bVar2;
	BOOL BVar3;
	BOOL BVar4;
	float10 fVar5;
	Point2F *pPVar6;
	int local_10;
	Point2F local_c;
	int local_4;
	TextWindow *textWnd_00;
	
	bVar1 = false;
	bVar2 = false;
	BVar4 = 0;
	local_c.x = 0.0;
	if (PROGRAMMER_MODE_3 < globs::mainGlobs.programmerLevel) {
		Objective_ProgrammerModeGT3_FUN_00458ba0();
	}
	if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_FAILED) == OBJECTIVE_NONE) {
				BVar3 = Objective_Level_FUN_00459310(level,&local_4,elapsedGame);
				if (BVar3 == 0) {
					reward::Rewards_UpdateTimers(elapsedGame);
				}
				else {
					if (local_4 == 0) {
						Objective_SetCompleteStatus(LEVELSTATUS_FAILED);
					}
					else {
						Objective_SetCompleteStatus(LEVELSTATUS_COMPLETE);
					}
				}
			}
			else {
				BVar3 = unk::Teleporter_ServiceAll
													(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
													 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
				if (BVar3 != 0) {
					local_10 = 2;
					save::ObjectRecall_Save_CreateNewObjectRecall();
					if ((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
						local_10 = 3;
					}
					Game_SetPaused(FALSE,TRUE);
					bVar2 = true;
					if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
						if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWFAILEDADVISOR) != OBJECTIVE_NONE) {
							front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,TRUE);
						}
						globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_8;
					}
					front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,FALSE,FALSE);
					BVar4 = 1;
					bVar1 = true;
				}
			}
		}
		else {
			BVar3 = unk::Teleporter_ServiceAll
												(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
												 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
			if (BVar3 != 0) {
				bVar1 = true;
				Game_SetPaused(FALSE,TRUE);
				save::ObjectRecall_Save_CopyToNewObjectRecallData();
				if ((level->objective).field_34 == 0) {
					if ((level->objective).field_30 == 0) {
						pPVar6 = &(level->objective).ObjectiveAcheivedAVIPosition;
					}
					else {
						pPVar6 = NULL;
					}
					lrr::Lego_PlayMovie_old((level->objective).ObjectiveAcheivedAVIFilename,pPVar6);
					(level->objective).field_34 = TRUE;
				}
				local_10 = TRUE;
				bVar2 = true;
				front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,FALSE,FALSE);
				if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
					if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
						front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,TRUE);
					}
					globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_8;
				}
				BVar4 = TRUE;
			}
		}
	}
	else {
		BVar4 = TRUE;
		Game_SetPaused(FALSE,TRUE);
		local_10 = 0;
		bVar2 = true;
		if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
				front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,TRUE);
			}
			globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_8;
		}
		local_c.x = 1.401298e-45;
		front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,FALSE,FALSE);
	}
	if ((INT_00500e3c != -1) &&
		 (FLOAT_00500e40 = FLOAT_00500e40 - elapsedAbs,
		 (ushort)((ushort)(FLOAT_00500e40 < 0.0) << 8 | (ushort)(FLOAT_00500e40 == 0.0) << 0xe) != 0)) {
		front::Advisor_ClearFlag2();
		INT_00500e3c = -1;
	}
	if (((bVar1) && ((globs::legoGlobs.flags2 & GAME2_MUSICON) == GAME2_NONE)) &&
		 (((byte)globs::legoGlobs.flags1 & GAME1_MUSICON) != 0)) {
		globs::legoGlobs.flags2 |= GAME2_MUSICON;
		snd::Music_PlayNext(FALSE);
	}
	if ((BOOL_00500e44 != 0) && (globals::g_StreamObjective_Sample != NULL)) {
		BVar3 = snd::SFX_GetType(globals::g_StreamObjective_Sample,(SFXType *)&elapsedAbs);
		if (BVar3 != 0) {
			snd::SFX_GetFlag8();
			snd::SFX_SetFlag8To_AndOptPlayQueuedInstances(0,0);
			INT_00500e3c = snd::SFX_Sample_Random_Play_OrAddToQueue((SFXType)elapsedAbs,FALSE);
			fVar5 = snd::SFX_Sample_Random_GetSamplePlayTime((SFXType)elapsedAbs);
			FLOAT_00500e40 = (float)((fVar5 - (float10)1.5) * (float10)25.0);
			snd::SFX_PlayQueuedInstances_SetFlag8To(TRUE);
		}
		std::free(globals::g_StreamObjective_Sample);
		globals::g_StreamObjective_Sample = NULL;
	}
	BOOL_00500e44 = BVar4;
	if (local_c.x != 0.0) {
		snd::SFX_PlayQueuedInstances_SetFlag8To(1);
	}
	if (bVar2) {
		if (globals::g_Objective_StatusUnkCounts[local_10] <
				globals::g_Objective_StatusBellCounts[local_10]) {
			pPVar6 = &local_c;
			local_c.x = 470.0;
			local_c.y = 315.0;
		}
		else {
			pPVar6 = NULL;
		}
		Game_SetMenuNextPosition(pPVar6);
		if (globals::g_Objective_StatusUnkCounts[local_10] == 0) {
			pPVar6 = NULL;
		}
		else {
			pPVar6 = &local_c;
			local_c.x = 130.0;
			local_c.y = 315.0;
		}
		Game_SetMenuPreviousPosition(pPVar6);
		if (globals::g_Objective_StatusUnkCounts[local_10] !=
				globals::g_Objective_StatusUnkCounts2[local_10]) {
			front::TextWindow_Clear(globals::g_Objective_StatusTextWindows[local_10]);
			front::TextWindow_PagePrintF
								(globals::g_Objective_StatusTextWindows[local_10],
								 globals::g_Objective_StatusUnkCounts[local_10],"%s",
								 globals::g_Objective_StatusMessages[local_10]);
			globals::g_Objective_StatusUnkCounts2[local_10] =
					 globals::g_Objective_StatusUnkCounts[local_10];
		}
		image = (level->objective).ObjectiveImage;
		if (image != NULL) {
			lego::image::Image_DisplayScaled(image,NULL,&(level->objective).ObjectiveImagePosition,NULL);
		}
		textWnd_00 = PTRTextWindow_00500e1c;
		if ((level->status != LEVELSTATUS_COMPLETE) &&
			 (textWnd_00 = PTRTextWindow_00500e20, level->status != LEVELSTATUS_FAILED)) {
			textWnd_00 = PTRTextWindow_00500e18;
		}
		if (textWnd_00 != NULL) {
			front::TextWindow_Update(textWnd_00,0,elapsedGame,NULL);
		}
		if (globals::g_Objective_StatusTextWindows[local_10] != NULL) {
			front::TextWindow_Update(globals::g_Objective_StatusTextWindows[local_10],0,elapsedGame,NULL);
		}
		if (PTRTextWindow_00500e24 != NULL) {
			front::TextWindow_Update(PTRTextWindow_00500e24,0,elapsedGame,NULL);
		}
	}
	return;
}



BOOL __cdecl lego::game::Objective_Level_FUN_00459310(LevelData *level,BOOL *out_bool,float elapsed)
{
	float fVar1;
	BOOL BVar2;
	
	if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
		return 0;
	}
	*out_bool = 1;
	if ((globals::g_ObjectiveFlags & OBJECTIVE_TIMER) != OBJECTIVE_NONE) {
		fVar1 = (level->objective).TimerObjective - elapsed;
		(level->objective).TimerObjective = fVar1;
		if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
				*out_bool = 0;
			}
			return TRUE;
		}
	}
	if (((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) &&
		 ((uint)level->numCrystals < (level->objective).CrystalObjective)) {
		return 0;
	}
	if (((globals::g_ObjectiveFlags & OBJECTIVE_ORE) != OBJECTIVE_NONE) &&
		 ((uint)level->numOre < (level->objective).OreObjective)) {
		return 0;
	}
	BVar2 = Search_LiveObjects_SkipIgnoreMes
										(Objective_LiveObjectCallback_FUN_004593c0,&level->objective);
	return (uint)(BVar2 != 0);
}



BOOL __cdecl
lego::game::Objective_LiveObjectCallback_FUN_004593c0(LiveObject *liveObj,ObjectiveData *objective)
{
	int local_8;
	int local_4;
	
	if (((globals::g_ObjectiveFlags & OBJECTIVE_BLOCK) != OBJECTIVE_NONE) &&
		 ((liveObj->objType == OBJECT_MINIFIGURE || (liveObj->objType == OBJECT_VEHICLE)))) {
		LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		if ((local_8 == (objective->BlockObjective).x) && (local_4 == (objective->BlockObjective).y)) {
			return TRUE;
		}
	}
	if ((((globals::g_ObjectiveFlags & OBJECTIVE_CONSTRUCTION) != OBJECTIVE_NONE) &&
			(objective->ConstructionObjectiveObjType == liveObj->objType)) &&
		 (objective->ConstructionObjectiveObjIndex == liveObj->objIndex)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::ObjectRecall_StoreMiniFigure(LiveObject *liveObj)
{
	SaveObjectRecall *recall;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 (((liveObj->flags5 != LIVEOBJ5_NONE || (liveObj->objLevel != 0)) ||
			(liveObj->customName != NULL)))) {
		if (globs::objectrecallGlobs.recallUsed == globs::objectrecallGlobs.recallCapacity) {
						// More space is needed, allocate 10 extra slots
			globs::objectrecallGlobs.recallCapacity += 10;
			globs::objectrecallGlobs.recallList =
					 (SaveObjectRecall *)
					 std::realloc(globs::objectrecallGlobs.recallList,
												globs::objectrecallGlobs.recallCapacity * 0x14);
		}
		recall = globs::objectrecallGlobs.recallList + globs::objectrecallGlobs.recallUsed;
		globs::objectrecallGlobs.recallUsed = globs::objectrecallGlobs.recallUsed + 1;
		recall->flags5 = liveObj->flags5;
		recall->level = liveObj->objLevel;
						// std::memset(recall->customName, 0, 0xc);
		*(undefined4 *)recall->customName = 0;
		*(undefined4 *)(recall->customName + 4) = 0;
		*(undefined4 *)(recall->customName + 8) = 0;
		if (liveObj->customName != NULL) {
			std::strncpy(recall->customName,liveObj->customName,0xb);
		}
	}
	return;
}



BOOL __cdecl lego::game::ObjectRecall_RecallMiniFigure(LiveObject *liveObj)
{
	SaveObjectRecall *recall;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (globs::objectrecallGlobs.recallUsed != 0)) {
		globs::objectrecallGlobs.recallUsed -= 1;
		recall = globs::objectrecallGlobs.recallList + globs::objectrecallGlobs.recallUsed;
						// Trained ability flags
		liveObj->flags5 =
				 globs::objectrecallGlobs.recallList[globs::objectrecallGlobs.recallUsed].flags5;
		stats::StatsObject_SetObjectLevel(liveObj,recall->level);
		LiveObject_SetCustomName(liveObj,recall->customName);
		return TRUE;
	}
	return 0;
}



void __cdecl lego::save::ObjectRecall_Save_FreeObjectRecall(void)
{
	globs::objectrecallGlobs.recallUsed = 0;
	globs::objectrecallGlobs.recallCapacity = 0;
	if (globs::objectrecallGlobs.recallList != NULL) {
		std::free(globs::objectrecallGlobs.recallList);
	}
	globs::objectrecallGlobs.recallList = NULL;
	return;
}



void __cdecl lego::save::ObjectRecall_Save_CopyToNewObjectRecallData(void)
{
	uint uVar1;
	int iVar2;
	SaveObjectRecall *pSVar3;
	SaveObjectRecall *pSVar4;
	
	if ((globs::objectrecallGlobs.recallUsed != 0) && (globs::objectrecallGlobs.recallList != NULL)) {
		if (globs::objectrecallGlobs.recallNewList != NULL) {
			std::free(globs::objectrecallGlobs.recallNewList);
		}
		globs::objectrecallGlobs.recallNewList =
				 (SaveObjectRecall *)std::malloc(globs::objectrecallGlobs.recallUsed * 0x14);
						// std::memcpy(recallNewList, recallList, recallUsed * 0x14);
		pSVar3 = globs::objectrecallGlobs.recallList;
		pSVar4 = globs::objectrecallGlobs.recallNewList;
		for (uVar1 = globs::objectrecallGlobs.recallUsed * 5 & 0x3fffffff; uVar1 != 0; uVar1 -= 1) {
			pSVar4->flags5 = pSVar3->flags5;
			pSVar3 = (SaveObjectRecall *)&pSVar3->level;
			pSVar4 = (SaveObjectRecall *)&pSVar4->level;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pSVar4->flags5 = *(undefined *)&pSVar3->flags5;
			pSVar3 = (SaveObjectRecall *)((int)&pSVar3->flags5 + 1);
			pSVar4 = (SaveObjectRecall *)((int)&pSVar4->flags5 + 1);
		}
		globs::objectrecallGlobs.recallNewCount = globs::objectrecallGlobs.recallUsed;
		globs::objectrecallGlobs.loaded = TRUE;
	}
	return;
}



BOOL __cdecl lego::save::ObjectRecall_Save_CreateNewObjectRecall(void)
{
	uint uVar1;
	int iVar2;
	SaveObjectRecall *pSVar3;
	SaveObjectRecall *pSVar4;
	
	ObjectRecall_Save_FreeObjectRecall();
	if ((globs::objectrecallGlobs.recallNewList != NULL) &&
		 (globs::objectrecallGlobs.recallNewCount != 0)) {
		globs::objectrecallGlobs.recallList =
				 (SaveObjectRecall *)std::malloc(globs::objectrecallGlobs.recallNewCount * 0x14);
						// std::memcpy(recallList, recallNewList, recallNewCount * 0x14);
		pSVar3 = globs::objectrecallGlobs.recallNewList;
		pSVar4 = globs::objectrecallGlobs.recallList;
		for (uVar1 = globs::objectrecallGlobs.recallNewCount * 5 & 0x3fffffff; uVar1 != 0; uVar1 -= 1) {
			pSVar4->flags5 = pSVar3->flags5;
			pSVar3 = (SaveObjectRecall *)&pSVar3->level;
			pSVar4 = (SaveObjectRecall *)&pSVar4->level;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pSVar4->flags5 = *(undefined *)&pSVar3->flags5;
			pSVar3 = (SaveObjectRecall *)((int)&pSVar3->flags5 + 1);
			pSVar4 = (SaveObjectRecall *)((int)&pSVar4->flags5 + 1);
		}
		globs::objectrecallGlobs.recallUsed = globs::objectrecallGlobs.recallNewCount;
		globs::objectrecallGlobs.recallCapacity = globs::objectrecallGlobs.recallNewCount;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::save::ObjectRecall_IsLoaded(void)
{
	return globs::objectrecallGlobs.loaded;
}



BOOL __cdecl lego::save::ObjectRecall_SaveRROSFile(char *filename)
{
	File *f;
	RROSFileHeader hdr;
	
	f = lego::file::File_Open(filename,"wb");
	if (f != NULL) {
						// std::strncpy(hdr.signature, "RROS", 4);
		hdr.signature = L'\x534f5252';
		hdr.count = globs::objectrecallGlobs.recallUsed;
						// Write Header:
						// char[4] "RROS"
						// uint    count
		lego::file::File_Write(&hdr,4,2,f);
						// Write Payload:
						// RROSStruct14[count] data
		lego::file::File_Write
							(globs::objectrecallGlobs.recallList,0x14,globs::objectrecallGlobs.recallUsed,f);
		lego::file::File_Close(f);
		ObjectRecall_Save_CopyToNewObjectRecallData();
		globs::objectrecallGlobs.loaded = FALSE;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::save::ObjectRecall_LoadRROSFile(char *filename)
{
	File *f;
	int fileSize;
	BOOL result;
	RROSFileHeader hdr;
	
	result = 0;
	ObjectRecall_Save_FreeObjectRecall();
	f = lego::file::File_Open(filename,"rb");
	if (f != NULL) {
		fileSize = lego::file::File_Length(f);
		lego::file::File_Read(&hdr,4,2,f);
						// if (std::strncmp(hdr.signature, "RROS", 4) == 0)
		if (hdr.signature == L'\x534f5252') {
			if (fileSize - 8U == hdr.count * 0x14) {
				globs::objectrecallGlobs.recallUsed = hdr.count;
				globs::objectrecallGlobs.recallCapacity = hdr.count;
				globs::objectrecallGlobs.recallList = (SaveObjectRecall *)std::malloc(hdr.count * 0x14);
				lego::file::File_Read
									(globs::objectrecallGlobs.recallList,0x14,globs::objectrecallGlobs.recallUsed,f);
				ObjectRecall_Save_CopyToNewObjectRecallData();
				globs::objectrecallGlobs.loaded = FALSE;
			}
		}
		lego::file::File_Close(f);
		result = TRUE;
	}
	return result;
}



void __cdecl lego::front::ObjInfo_Initialise(CFGProperty *root,char *rootPath)
{
	ObjInfo_LoadHealthBar(root,rootPath);
	ObjInfo_LoadHunger(root,rootPath);
	ObjInfo_LoadBubble(root,rootPath);
	return;
}



BOOL __cdecl lego::front::ObjInfo_LoadHealthBar(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	int x;
	int y;
	int width;
	int height;
	BOOL BVar3;
	BoolTri BVar4;
	float *pfVar5;
	ColourRGBF *pCVar6;
	float *pfVar7;
	float *out_b;
	char *stringParts [10];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		return 0;
	}
	iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
	if (iVar2 == 2) {
		x = std::atoi(stringParts[0]);
		globs::objinfoGlobs.HealthBarPosition.x = (float)x;
		y = std::atoi(stringParts[1]);
		globs::objinfoGlobs.HealthBarPosition.y = (float)y;
		std::free(pcVar1);
		pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarWidthHeight",0);
		pcVar1 = cfg::CFG_CopyString(root,pcVar1);
		if (pcVar1 == NULL) {
			return 0;
		}
		iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
		if (iVar2 == 2) {
			width = std::atoi(stringParts[0]);
			globs::objinfoGlobs.HealthBarWidthHeight.width = (float)width;
			height = std::atoi(stringParts[1]);
			globs::objinfoGlobs.HealthBarWidthHeight.height = (float)height;
			std::free(pcVar1);
			pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarBorderSize",0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == NULL) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarBorderSize",0);
				pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			}
			globs::objinfoGlobs.HealthBarBorderSize = std::atoi(pcVar1);
			out_b = globs::objinfoGlobs.HealthBarBorderRGB_b;
			pfVar7 = globs::objinfoGlobs.HealthBarBorderRGB_g;
			pfVar5 = globs::objinfoGlobs.HealthBarBorderRGB_r;
			pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarBorderRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar5,pfVar7,out_b);
			if (BVar3 == 0) {
				return 0;
			}
			globs::objinfoGlobs.HealthBarBorderRGB_r[1] =
					 globs::objinfoGlobs.HealthBarBorderRGB_r[0] +
					 globs::objinfoGlobs.HealthBarBorderRGB_r[0] * 0.4;
			globs::objinfoGlobs.HealthBarBorderRGB_r[2] =
					 globs::objinfoGlobs.HealthBarBorderRGB_r[0] -
					 globs::objinfoGlobs.HealthBarBorderRGB_r[0] * 0.4;
			globs::objinfoGlobs.HealthBarBorderRGB_g[1] =
					 globs::objinfoGlobs.HealthBarBorderRGB_g[0] +
					 globs::objinfoGlobs.HealthBarBorderRGB_g[0] * 0.4;
			globs::objinfoGlobs.HealthBarBorderRGB_g[2] =
					 globs::objinfoGlobs.HealthBarBorderRGB_g[0] -
					 globs::objinfoGlobs.HealthBarBorderRGB_g[0] * 0.4;
			globs::objinfoGlobs.HealthBarBorderRGB_b[1] =
					 globs::objinfoGlobs.HealthBarBorderRGB_b[0] +
					 globs::objinfoGlobs.HealthBarBorderRGB_b[0] * 0.4;
			globs::objinfoGlobs.HealthBarBorderRGB_b[2] =
					 globs::objinfoGlobs.HealthBarBorderRGB_b[0] -
					 globs::objinfoGlobs.HealthBarBorderRGB_b[0] * 0.4;
			pfVar5 = globs::objinfoGlobs.HealthBarBorderRGB_g;
			do {
				if ((ushort)((ushort)(pfVar5[-3] < 1.0) << 8 | (ushort)(pfVar5[-3] == 1.0) << 0xe) == 0) {
					pfVar5[-3] = 1.0;
				}
				if ((ushort)((ushort)(*pfVar5 < 1.0) << 8 | (ushort)(*pfVar5 == 1.0) << 0xe) == 0) {
					*pfVar5 = 1.0;
				}
				if ((ushort)((ushort)(pfVar5[3] < 1.0) << 8 | (ushort)(pfVar5[3] == 1.0) << 0xe) == 0) {
					pfVar5[3] = 1.0;
				}
				if (pfVar5[-3] < 0.0) {
					pfVar5[-3] = 0.0;
				}
				if (*pfVar5 < 0.0) {
					*pfVar5 = 0.0;
				}
				if (pfVar5[3] < 0.0) {
					pfVar5[3] = 0.0;
				}
				pfVar5 = pfVar5 + 1;
			} while (pfVar5 < globs::objinfoGlobs.HealthBarBorderRGB_b);
			pfVar7 = &globs::objinfoGlobs.HealthBarBackgroundRGB.blue;
			pfVar5 = &globs::objinfoGlobs.HealthBarBackgroundRGB.green;
			pCVar6 = &globs::objinfoGlobs.HealthBarBackgroundRGB;
			pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarBackgroundRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,&pCVar6->red,pfVar5,pfVar7);
			if (BVar3 == 0) {
				return 0;
			}
			pfVar7 = &globs::objinfoGlobs.HealthBarRGB.blue;
			pfVar5 = &globs::objinfoGlobs.HealthBarRGB.green;
			pCVar6 = &globs::objinfoGlobs.HealthBarRGB;
			pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,&pCVar6->red,pfVar5,pfVar7);
			if (BVar3 == 0) {
				return 0;
			}
			pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HealthBarVertical",0);
			BVar4 = cfg::CFG_ReadBool(root,pcVar1);
			if (BVar4 == BOOL3_TRUE) {
				globs::objinfoGlobs.flags |= OBJINFO_HEALTHBAR_VERTICAL;
			}
			globs::objinfoGlobs.flags = globs::objinfoGlobs.flags | OBJINFO_HEALTHBAR;
			return TRUE;
		}
	}
	std::free(pcVar1);
	return 0;
}



BOOL __cdecl lego::front::ObjInfo_LoadHunger(CFGProperty *root,char *rootPath)
{
	char *str;
	int numParts;
	int x;
	int y;
	char *stringParts [10];
	
	ObjInfo_LoadHungerImages(root,rootPath);
	str = cfg::CFG_JoinPath(rootPath,"ObjInfo","HungerImagesPosition",0);
	str = cfg::CFG_CopyString(root,str);
	if (str != NULL) {
		numParts = util::Util_Tokenise(str,stringParts,":");
		if (numParts == 2) {
			x = std::atoi(stringParts[0]);
			globs::objinfoGlobs.HungerPosition.x = (float)x;
			y = std::atoi(stringParts[1]);
			globs::objinfoGlobs.HungerPosition.y = (float)y;
			std::free(str);
			globs::objinfoGlobs.flags = globs::objinfoGlobs.flags | OBJINFO_HUNGERIMAGES;
			return TRUE;
		}
		std::free(str);
	}
	return 0;
}



void __cdecl lego::front::ObjInfo_LoadHungerImages(CFGProperty *root,char *rootPath)
{
	char *str;
	Image *image;
	Image **pHungerImage;
	int i;
	uint width;
	uint height;
	char buff [64];
	
	i = 0;
	pHungerImage = globs::objinfoGlobs.HungerImages;
	do {
		std::sprintf(buff,"HungerImage%i",i);
		height = 0;
		width = 0;
		str = cfg::CFG_JoinPath(rootPath,"ObjInfo","HungerImages",buff,0);
		str = cfg::CFG_ReadString(root,str);
		image = lego::image::Image_LoadBMPScaled(str,width,height);
		*pHungerImage = image;
		if (image != NULL) {
			lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		pHungerImage = (Image **)((int)pHungerImage + 4);
		i += 1;
						// while (i < 5);
	} while (pHungerImage < &globs::objinfoGlobs.BubblePosition);
	return;
}



BOOL __cdecl lego::front::ObjInfo_LoadBubble(CFGProperty *root,char *rootPath)
{
	char *str;
	int iVar1;
	char *stringParts [10];
	
	str = cfg::CFG_JoinPath(rootPath,"ObjInfo","BubbleImagesPosition",0);
	str = cfg::CFG_CopyString(root,str);
	if (str != NULL) {
		iVar1 = util::Util_Tokenise(str,stringParts,":");
		if (iVar1 == 2) {
			iVar1 = std::atoi(stringParts[0]);
			globs::objinfoGlobs.BubblePosition.x = (float)iVar1;
			iVar1 = std::atoi(stringParts[1]);
			globs::objinfoGlobs.BubblePosition.y = (float)iVar1;
			std::free(str);
			globs::objinfoGlobs.flags = globs::objinfoGlobs.flags | OBJINFO_BUBBLEIMAGES;
			return TRUE;
		}
		std::free(str);
	}
	return 0;
}



void __cdecl lego::front::ObjInfo_DrawHealthBar(LiveObject *liveObj,int screenX,int screenY)
{
	undefined *puVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	BOOL BVar6;
	Point2F *pPVar7;
	float fVar8;
	Point2F *pPVar9;
	float *pfVar10;
	uint uVar11;
	float *pfVar12;
	uint count;
	Point2F *pPVar13;
	float *pfVar14;
	float fVar15;
	float fVar16;
	Area2F local_17c;
	float *local_16c;
	uint local_168;
	Point2F *local_164;
	uint local_160;
	float local_15c;
	undefined4 uStack344;
	float local_154;
	float local_150;
	float local_14c;
	uint local_148;
	undefined4 uStack324;
	Point2F local_140;
	float local_138 [18];
	Point2F local_f0;
	float afStack232 [18];
	Point2F local_a0;
	float local_98 [18];
	Point2F local_50;
	float local_48 [18];
	
	count = 0;
	local_168 = 0;
	if ((((byte)globs::objinfoGlobs.flags & OBJINFO_HEALTHBAR) != 0) &&
		 (BVar6 = DamageFont_LiveObject_CheckCanShowDamage_Unk(liveObj), BVar6 != 0)) {
		uStack344 = 0;
		local_15c = (float)(globs::objinfoGlobs.HealthBarBorderSize * 2);
		fVar8 = globs::objinfoGlobs.HealthBarWidthHeight.width + (float)(ulonglong)(uint)local_15c;
		fVar15 = globs::objinfoGlobs.HealthBarWidthHeight.height + (float)(ulonglong)(uint)local_15c;
		local_17c.x = (float)screenX + globs::objinfoGlobs.HealthBarPosition.x;
		local_17c.y = (float)screenY + globs::objinfoGlobs.HealthBarPosition.y;
		local_160 = 0;
		uVar11 = local_160;
		if (globs::objinfoGlobs.HealthBarBorderSize != 0) {
			local_164 = &local_f0;
			local_16c = &local_f0.y;
			local_150 = (local_17c.y + fVar15) - 2.0;
			local_15c = (local_17c.x + fVar8) - 2.0;
			local_14c = (local_17c.x + fVar8) - 1.0;
			local_154 = (local_17c.y + fVar15) - 1.0;
			pPVar9 = &local_50;
			pfVar14 = &local_50.y;
			pfVar12 = &local_140.y;
			pPVar13 = &local_140;
			pfVar10 = &local_a0.y;
			pPVar7 = &local_a0;
			do {
				local_160 = uVar11;
				uStack324 = 0;
				fVar4 = (float)(ulonglong)local_160;
				fVar2 = local_17c.x + fVar4;
				fVar3 = local_17c.y + fVar4;
				fVar5 = local_154 - fVar4;
				pPVar7->x = fVar2;
				*pfVar10 = fVar3;
				fVar16 = pPVar7->x;
				pPVar9->x = fVar2;
				*pfVar12 = local_150 - fVar4;
				*pfVar14 = fVar5;
				pPVar7[1].x = local_14c - fVar4;
				pPVar13->x = fVar16;
				local_164->x = local_15c - fVar4;
				pfVar10[2] = fVar3;
				*local_16c = fVar5;
				pPVar9[1].x = local_14c - fVar4;
				pPVar13[1].x = fVar2 - -1.0;
				pfVar14[2] = fVar5;
				fVar16 = pPVar9[1].x;
				pfVar12[2] = fVar3;
				pPVar7 = pPVar7 + 2;
				pfVar10 = pfVar10 + 4;
				pPVar13 = pPVar13 + 2;
				pfVar14 = pfVar14 + 4;
				local_16c[2] = fVar3 - -1.0;
				pPVar9 = pPVar9 + 2;
				local_164[1].x = fVar16;
				count = local_168 + 2;
				local_164 = local_164 + 2;
				pfVar12 = pfVar12 + 4;
				local_16c = local_16c + 4;
				uVar11 = local_160 + 1;
				local_168 = count;
				local_148 = local_160;
			} while (uVar11 < globs::objinfoGlobs.HealthBarBorderSize);
		}
		local_160 = uVar11;
		puVar1 = (undefined *)liveObj->health;
		if (0.0 <= (float)puVar1) {
			if ((ushort)((ushort)((float)puVar1 < 100.0) << 8 | (ushort)((float)puVar1 == 100.0) << 0xe)
					== 0) {
				puVar1 = &DAT_42c80000;
			}
		}
		else {
			puVar1 = NULL;
		}
		if (((byte)globs::objinfoGlobs.flags & OBJINFO_HEALTHBAR_VERTICAL) == 0) {
			local_17c.width = (float)puVar1 * fVar8 * 0.01;
			local_17c.height = fVar15;
			draw::Draw_RectListEx
								(&local_17c,1,globs::objinfoGlobs.HealthBarRGB.red,
								 globs::objinfoGlobs.HealthBarRGB.green,globs::objinfoGlobs.HealthBarRGB.blue,
								 DRAWEFFECT_NONE);
			local_17c.x = local_17c.x + local_17c.width;
			local_17c.width = fVar8 - local_17c.width;
			fVar8 = globs::objinfoGlobs.HealthBarBackgroundRGB.red;
			fVar15 = globs::objinfoGlobs.HealthBarBackgroundRGB.green;
			fVar16 = globs::objinfoGlobs.HealthBarBackgroundRGB.blue;
		}
		else {
			local_17c.height = (1.0 - (float)puVar1 * 0.01) * fVar15;
			local_17c.width = fVar8;
			draw::Draw_RectListEx
								(&local_17c,1,globs::objinfoGlobs.HealthBarBackgroundRGB.red,
								 globs::objinfoGlobs.HealthBarBackgroundRGB.green,
								 globs::objinfoGlobs.HealthBarBackgroundRGB.blue,DRAWEFFECT_NONE);
			local_17c.y = local_17c.y + local_17c.height;
			local_17c.height = fVar15 - local_17c.height;
			fVar8 = globs::objinfoGlobs.HealthBarRGB.red;
			fVar15 = globs::objinfoGlobs.HealthBarRGB.green;
			fVar16 = globs::objinfoGlobs.HealthBarRGB.blue;
		}
		draw::Draw_RectListEx(&local_17c,1,fVar8,fVar15,fVar16,DRAWEFFECT_NONE);
		draw::Draw_LineListEx
							(&local_a0,&local_140,count,globs::objinfoGlobs.HealthBarBorderRGB_r[1],
							 globs::objinfoGlobs.HealthBarBorderRGB_g[1],
							 globs::objinfoGlobs.HealthBarBorderRGB_b[1],DRAWEFFECT_NONE);
		draw::Draw_LineListEx
							(&local_50,&local_f0,count,globs::objinfoGlobs.HealthBarBorderRGB_r[2],
							 globs::objinfoGlobs.HealthBarBorderRGB_g[2],
							 globs::objinfoGlobs.HealthBarBorderRGB_b[2],DRAWEFFECT_NONE);
	}
	return;
}



void __cdecl lego::front::ObjInfo_DrawHungerImage(LiveObject *liveObj,int screenX,int screenY)
{
	uint index0_4;
	longlong lVar1;
	Point2F destPos;
	
	if (((byte)globs::objinfoGlobs.flags & OBJINFO_HUNGERIMAGES) != 0) {
		lVar1 = __ftol((float10)liveObj->energy * (float10)0.01 * (float10)5.0);
		index0_4 = (uint)lVar1;
		if (4 < index0_4) {
			index0_4 = 4;
		}
		if (globs::objinfoGlobs.HungerImages[index0_4] != NULL) {
			destPos.x = (float)screenX + globs::objinfoGlobs.HungerPosition.x;
			destPos.y = (float)screenY + globs::objinfoGlobs.HungerPosition.y;
			lego::image::Image_DisplayScaled
								(globs::objinfoGlobs.HungerImages[index0_4],NULL,&destPos,NULL);
		}
	}
	return;
}



void __cdecl lego::front::ObjInfo_DrawBubbleImage(Image *image,int screenX,int screenY)
{
	Point2F destPos;
	
	if (((byte)globs::objinfoGlobs.flags & OBJINFO_BUBBLEIMAGES) != 0) {
		destPos.x = (float)screenX + globs::objinfoGlobs.BubblePosition.x;
		destPos.y = (float)screenY + globs::objinfoGlobs.BubblePosition.y;
		lego::image::Image_DisplayScaled(image,NULL,&destPos,NULL);
	}
	return;
}



void __cdecl lego::front::Panel_Initialise(void)
{
	globs::panelGlobs.panelName[0] = "Panel_Radar";
	globs::panelGlobs.panelName[1] = "Panel_RadarFill";
	globs::panelGlobs.panelName[2] = "Panel_RadarOverlay";
	globs::panelGlobs.panelName[3] = "Panel_Messages";
	globs::panelGlobs.panelName[4] = "Panel_MessagesSide";
	globs::panelGlobs.panelName[5] = "Panel_CrystalSideBar";
	globs::panelGlobs.panelName[6] = "Panel_TopPanel";
	globs::panelGlobs.panelName[7] = "Panel_Information";
	globs::panelGlobs.panelName[8] = "Panel_PriorityList";
	globs::panelGlobs.panelName[9] = "Panel_CameraControl";
	globs::panelGlobs.panelName[10] = "Panel_InfoDock";
	globs::panelGlobs.panelName[11] = "Panel_Encyclopedia";
	globs::panelGlobs.panelButtonName[0][0] = "PanelButton_Radar_Toggle";
	globs::panelGlobs.panelButtonName[0][1] = "PanelButton_Radar_TaggedObjectView";
	globs::panelGlobs.panelButtonName[0][2] = "PanelButton_Radar_ZoomIn";
	globs::panelGlobs.panelButtonName[0][3] = "PanelButton_Radar_ZoomOut";
	globs::panelGlobs.panelButtonName[0][4] = "PanelButton_Radar_MapView";
	globs::panelGlobs.panelButtonName[5][0] = "PanelButton_CrystalSideBar_Ore";
	globs::panelGlobs.panelButtonName[5][1] = "PanelButton_CrystalSideBar_Crystals";
	globs::panelGlobs.panelButtonName[6][0] = "PanelButton_TopPanel_Options";
	globs::panelGlobs.panelButtonName[6][1] = "PanelButton_TopPanel_Priorities";
	globs::panelGlobs.panelButtonName[6][2] = "PanelButton_TopPanel_CallToArms";
	globs::panelGlobs.panelButtonName[7][0] = "PanelButton_Information_Toggle";
	globs::panelGlobs.panelButtonName[7][1] = "PanelButton_Information_Function";
	globs::panelGlobs.panelButtonName[8][0] = "PanelButton_PriorityList_Disable1";
	globs::panelGlobs.panelButtonName[8][1] = "PanelButton_PriorityList_Disable2";
	globs::panelGlobs.panelButtonName[8][2] = "PanelButton_PriorityList_Disable3";
	globs::panelGlobs.panelButtonName[8][3] = "PanelButton_PriorityList_Disable4";
	globs::panelGlobs.panelButtonName[8][4] = "PanelButton_PriorityList_Disable5";
	globs::panelGlobs.panelButtonName[8][5] = "PanelButton_PriorityList_Disable6";
	globs::panelGlobs.panelButtonName[8][6] = "PanelButton_PriorityList_Disable7";
	globs::panelGlobs.panelButtonName[8][7] = "PanelButton_PriorityList_Disable8";
	globs::panelGlobs.panelButtonName[8][8] = "PanelButton_PriorityList_Disable9";
	globs::panelGlobs.panelButtonName[8][9] = "PanelButton_PriorityList_UpOne1";
	globs::panelGlobs.panelButtonName[8][10] = "PanelButton_PriorityList_UpOne2";
	globs::panelGlobs.panelButtonName[8][11] = "PanelButton_PriorityList_UpOne3";
	globs::panelGlobs.panelButtonName[8][12] = "PanelButton_PriorityList_UpOne4";
	globs::panelGlobs.panelButtonName[8][13] = "PanelButton_PriorityList_UpOne5";
	globs::panelGlobs.panelButtonName[8][14] = "PanelButton_PriorityList_UpOne6";
	globs::panelGlobs.panelButtonName[8][15] = "PanelButton_PriorityList_UpOne7";
	globs::panelGlobs.panelButtonName[8][16] = "PanelButton_PriorityList_UpOne8";
	globs::panelGlobs.panelButtonName[8][17] = "PanelButton_PriorityList_Close";
	globs::panelGlobs.panelButtonName[8][18] = "PanelButton_PriorityList_Reset";
	globs::panelGlobs.panelButtonName[9][0] = "PanelButton_CameraControl_ZoomIn";
	globs::panelGlobs.panelButtonName[9][1] = "PanelButton_CameraControl_ZoomOut";
	globs::panelGlobs.panelButtonName[9][2] = "PanelButton_CameraControl_CycleBuildings";
	globs::panelGlobs.panelButtonName[9][3] = "PanelButton_CameraControl_Rotate";
	globs::panelGlobs.panelButtonName[10][0] = "PanelButton_InfoDock_Goto";
	globs::panelGlobs.panelButtonName[10][1] = "PanelButton_InfoDock_Close";
	globs::panelGlobs.panelButtonName[11][0] = "PanelButton_Encyclopedia_Close";
	globs::panelGlobs.currentPanel = PANEL__COUNT;
	globs::panelGlobs.currentButton = PANELBUTTON__COUNT;
	return;
}



void __cdecl lego::front::Panel_LoadInterfaceButtons_ScrollInfo(void)
{
	Panel_ScrollInfo_Initialise();
	Panel_Encyclopedia_Initialise();
	Panel_Button_SetFlag_20(PANEL_TOPPANEL,PANELBUTTON_TOPPANEL_PRIORITIES,TRUE);
	Panel_Button_SetFlag_20(PANEL_TOPPANEL,PANELBUTTON_TOPPANEL_CALLTOARMS,TRUE);
	return;
}



void __cdecl lego::front::Panel_ResetAll(void)
{
	char *pcVar1;
	char **ppcVar2;
	char *pcVar3;
	int iVar4;
	
	ppcVar2 = (char **)&globs::panelGlobs.panelTable[0].flags;
	do {
		ppcVar2[-5] = ppcVar2[-7];
		pcVar3 = NULL;
		*ppcVar2 = (char *)((uint)*ppcVar2 & 0xfffffff5 | 4);
		ppcVar2[-4] = ppcVar2[-6];
		if (ppcVar2[-1] != NULL) {
			iVar4 = 0;
			do {
				pcVar1 = ppcVar2[-2];
				*(undefined4 *)(pcVar1 + iVar4 + 0x24) = 0;
				pcVar1 = pcVar1 + iVar4;
				iVar4 += 0x2c;
				pcVar3 = pcVar3 + 1;
				*(uint *)(pcVar1 + 0x28) = *(uint *)(pcVar1 + 0x28) & 0xffffffb7;
			} while (pcVar3 < ppcVar2[-1]);
		}
		ppcVar2 = ppcVar2 + 0xc;
	} while (ppcVar2 < globs::panelGlobs.panelButtonName + 0xb);
	globs::panelGlobs.cryOreMeterValue = 0.0;
	return;
}



void __cdecl lego::front::Panel_LoadImage(char *filename,PanelType panelType,uint flags)
{
	uint uVar1;
	Image *image;
	BOOL BVar2;
	
	globs::panelGlobs.panelTable[panelType].buttonCount = 0;
	globs::panelGlobs.panelTable[panelType].flags = flags;
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globs::panelGlobs.panelTable[panelType].imageOrFlic = image;
	if (image != NULL) {
		globs::panelGlobs.panelTable[panelType].isFlic = 0;
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		globs::panelGlobs.panelTable[panelType].flags =
				 globs::panelGlobs.panelTable[panelType].flags | 1;
		return;
	}
	BVar2 = lego::image::Flic_Setup
										(filename,(Flic **)(globs::panelGlobs.panelTable + panelType),
										 FLICMEMORY|FLICLOOPINGON);
	if (BVar2 != 0) {
		uVar1 = globs::panelGlobs.panelTable[panelType].flags;
		globs::panelGlobs.panelTable[panelType].isFlic = 1;
		globs::panelGlobs.panelTable[panelType].flags = uVar1 | 1;
	}
	return;
}



BOOL __cdecl lego::front::Panel_GetPanelType(char *panelName,PanelType *out_panelType)
{
	int cmp;
	Panel_Globs *pName;
	int i;
	
	i = 0;
	pName = &globs::panelGlobs;
	do {
		cmp = std::_stricmp(panelName,(char *)pName->panelName[0]);
		if (cmp == 0) {
			*out_panelType = i;
			return TRUE;
		}
		pName = (Panel_Globs *)(pName->panelName + 1);
						// index++
		i += PANEL_RADARFILL;
						// index < PANEL__COUNT (12)
	} while (pName < (Panel_Globs *)globs::panelGlobs.panelTable);
	return 0;
}



BOOL __cdecl
lego::front::Panel_TestScreenImageCollision(PanelType panelType,int screenX,int screenY)
{
	PanelType PVar1;
	BOOL BVar2;
	uint y;
	PanelData *pPVar3;
	longlong lVar4;
	PanelType *out_colour;
	
	PVar1 = panelType;
	pPVar3 = globs::panelGlobs.panelTable + panelType;
	if (globs::panelGlobs.panelTable[panelType].isFlic == 0) {
		out_colour = &panelType;
		lVar4 = __ftol((float10)globs::panelGlobs.panelTable[panelType].xyOutIn.y);
		y = screenY - (int)lVar4;
		lVar4 = __ftol((float10)globs::panelGlobs.panelTable[PVar1].xyOutIn.x);
		BVar2 = lego::image::Image_GetPixel(pPVar3->imageOrFlic,screenX - (int)lVar4,y,out_colour);
		if (BVar2 != 0) {
						// return (pixelColour == 0x0); // black, so probably transparent
			return (uint)(panelType == PANEL_RADAR);
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::front::Panel_GetButtonType
					(PanelType panelType,char *buttonName,PanelButtonType *out_buttonType)
{
	int cmp;
	char *(*pName) [24];
	PanelButtonType buttonType;
	
	pName = globs::panelGlobs.panelButtonName[panelType];
	buttonType = 0;
	do {
		if ((*pName)[0] != NULL) {
			cmp = std::_stricmp(buttonName,(*pName)[0]);
			if (cmp == 0) {
				*out_buttonType = buttonType;
				return TRUE;
			}
		}
		buttonType += 1;
		pName = (char *(*) [24])(*pName + 1);
	} while (buttonType < PANELBUTTON__COUNT);
	return 0;
}



uint __cdecl
lego::front::Panel_PrintF(PanelType panelType,Font *font,int x,int y,BOOL center,char *msg,...)
{
	Font *font_00;
	int y_00;
	uint uVar1;
	float10 fVar2;
	longlong lVar3;
	char *msg_00;
	va_list argptr;
	PanelType panelType_00;
	
	font_00 = font;
	panelType_00 = panelType;
	if (center != 0) {
		lego::image::Font_VGetStringInfo(font,&panelType,NULL,msg,&stack0x0000001c);
		x -= panelType >> 1;
	}
	argptr = &stack0x0000001c;
	msg_00 = msg;
	fVar2 = std::floor((double)((float)y + globs::panelGlobs.panelTable[panelType_00].xyOutIn.y));
	lVar3 = __ftol(fVar2);
	y_00 = (int)lVar3;
	fVar2 = std::floor((double)((float)x + globs::panelGlobs.panelTable[panelType_00].xyOutIn.x));
	lVar3 = __ftol(fVar2);
	uVar1 = lego::image::Font_VPrintF(font_00,(int)lVar3,y_00,msg_00,argptr);
	return uVar1;
}



PanelTextWindow * __cdecl
lego::front::Panel_TextWindow_Create(PanelType panelType,Font *font,Area2F *rect,uint size)
{
	PanelTextWindow *panelWnd;
	TextWindow *textWnd;
	longlong lVar1;
	Area2F area;
	
	area.x = 0.0;
	area.y = 0.0;
	area.width = rect->width;
	area.height = rect->height;
	panelWnd = (PanelTextWindow *)std::malloc(0x10);
	if (panelWnd != NULL) {
		panelWnd->textWindow = NULL;
		(panelWnd->position).x = 0.0;
		(panelWnd->position).y = 0.0;
		panelWnd->panel = NULL;
		textWnd = TextWindow_Create(font,&area,size);
		panelWnd->textWindow = textWnd;
		lVar1 = __ftol((float10)rect->x);
		(panelWnd->position).x = (float)lVar1;
		lVar1 = __ftol((float10)rect->y);
		(panelWnd->position).y = (float)lVar1;
		panelWnd->panel = globs::panelGlobs.panelTable + panelType;
	}
	return panelWnd;
}



void __cdecl lego::front::Panel_TextWindow_PrintF(PanelTextWindow *panelWnd,char *msg,...)
{
	TextWindow_VPrintF(panelWnd->textWindow,0,msg,&stack0x0000000c);
	return;
}



void __cdecl
lego::front::Panel_TextWindow_Update(PanelTextWindow *textWnd,uint posFromEnd,float elapsed)
{
	int ypos;
	float10 fVar1;
	longlong lVar2;
	
	fVar1 = std::floor((double)((float)(int)(textWnd->position).y + (textWnd->panel->xyOutIn).y));
	lVar2 = __ftol(fVar1);
	ypos = (int)lVar2;
	fVar1 = std::floor((double)((float)(int)(textWnd->position).x + (textWnd->panel->xyOutIn).x));
	lVar2 = __ftol(fVar1);
	TextWindow_ChangePosition(textWnd->textWindow,(int)lVar2,ypos);
	TextWindow_Update(textWnd->textWindow,posFromEnd,elapsed,NULL);
	return;
}



void __cdecl lego::front::Panel_TextWindow_Clear(PanelTextWindow *panelWnd)
{
	TextWindow_Clear(panelWnd->textWindow);
	return;
}



void __cdecl
lego::front::Panel_TextWindow_GetInfo
					(PanelTextWindow *panelWnd,uint *out_linesCount,uint *out_linesCapacity)
{
	TextWindow_GetInfo(panelWnd->textWindow,out_linesCount,out_linesCapacity);
	return;
}



void __cdecl lego::front::Panel_SetArea(PanelType panelType,int xOut,int yOut,int xIn,int yIn)
{
	byte bVar1;
	
	globs::panelGlobs.panelTable[panelType].xyOut.x = (float)xOut;
	globs::panelGlobs.panelTable[panelType].xyIn.x = (float)xIn;
	bVar1 = *(byte *)&globs::panelGlobs.panelTable[panelType].flags;
	globs::panelGlobs.panelTable[panelType].xyOut.y = (float)yOut;
	globs::panelGlobs.panelTable[panelType].xyIn.y = (float)yIn;
	globs::panelGlobs.panelTable[panelType].field_20 = 0;
	if ((bVar1 & 2) != 0) {
		globs::panelGlobs.panelTable[panelType].xyOutIn.x = (float)xOut;
		globs::panelGlobs.panelTable[panelType].xyOutIn.y = (float)yOut;
		return;
	}
	globs::panelGlobs.panelTable[panelType].xyOutIn.x = (float)xIn;
	globs::panelGlobs.panelTable[panelType].xyOutIn.y = (float)yIn;
	return;
}



void __cdecl lego::front::Panel_SetXYField3(PanelType panelType,float x,float y)
{
	globs::panelGlobs.panelTable[panelType].xyOutIn.x = x;
	globs::panelGlobs.panelTable[panelType].xyOutIn.y = y;
	return;
}



void __cdecl lego::front::Panel_GetXYField3(PanelType panelType,float *out_x,float *out_y)
{
	*out_x = globs::panelGlobs.panelTable[panelType].xyOutIn.x;
	*out_y = globs::panelGlobs.panelTable[panelType].xyOutIn.y;
	return;
}



void __cdecl lego::front::Panel_FUN_0045a9f0(PanelType panelType,float elapsedAbs)
{
	int iVar1;
	float fVar2;
	uint uVar3;
	PanelData *pPVar4;
	float10 fVar5;
	longlong lVar6;
	ulonglong uVar7;
	float local_28;
	float local_24;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Area2F local_10;
	
	pPVar4 = globs::panelGlobs.panelTable + panelType;
	if ((*(byte *)&globs::panelGlobs.panelTable[panelType].flags & 4) == 0) {
		local_28 = globs::panelGlobs.panelTable[panelType].xyOut.x;
		local_24 = globs::panelGlobs.panelTable[panelType].xyOut.y;
	}
	else {
		local_28 = globs::panelGlobs.panelTable[panelType].xyIn.x;
		local_24 = globs::panelGlobs.panelTable[panelType].xyIn.y;
	}
	if (elapsedAbs != 0.0) {
		fVar2 = ABS(globs::panelGlobs.panelTable[panelType].xyOutIn.x - local_28);
		if ((ushort)((ushort)(fVar2 < 1.0) << 8 | (ushort)(fVar2 == 1.0) << 0xe) == 0) {
			globs::panelGlobs.panelTable[panelType].xyOutIn.x =
					 ((4.0 / elapsedAbs) * globs::panelGlobs.panelTable[panelType].xyOutIn.x + local_28) /
					 (4.0 / elapsedAbs - -1.0);
		}
		else {
			globs::panelGlobs.panelTable[panelType].xyOutIn.x = local_28;
		}
		fVar2 = ABS(globs::panelGlobs.panelTable[panelType].xyOutIn.y - local_24);
		if ((ushort)((ushort)(fVar2 < 1.0) << 8 | (ushort)(fVar2 == 1.0) << 0xe) == 0) {
			globs::panelGlobs.panelTable[panelType].xyOutIn.y =
					 ((4.0 / elapsedAbs) * globs::panelGlobs.panelTable[panelType].xyOutIn.y + local_24) /
					 (4.0 / elapsedAbs - -1.0);
		}
		else {
			globs::panelGlobs.panelTable[panelType].xyOutIn.y = local_24;
		}
	}
	fVar5 = std::floor((double)globs::panelGlobs.panelTable[panelType].xyOutIn.x);
	local_20.x = (float)fVar5;
	local_10.x = (float)fVar5;
	fVar5 = std::floor((double)globs::panelGlobs.panelTable[panelType].xyOutIn.y);
	iVar1 = globs::panelGlobs.panelTable[panelType].isFlic;
	local_20.y = (float)fVar5;
	local_10.y = (float)fVar5;
	if (iVar1 == 0) {
		lego::image::Image_DisplayScaled(pPVar4->imageOrFlic,NULL,&local_20,NULL);
	}
	else {
		if (iVar1 == 1) {
			local_18 = res::AnimClone_IsLws__Flic_GetWidth((AnimClone *)pPVar4->imageOrFlic);
			uStack20 = 0;
			local_10.width = (float)(ulonglong)local_18;
			local_18 = lego::image::Flic_GetHeight((Flic *)pPVar4->imageOrFlic);
			uStack20 = 0;
			local_10.height = (float)(ulonglong)local_18;
			uVar7 = CONCAT44(1,~globs::legoGlobs.flags1 >> 0x14) & 0xffffffff00000001;
			lego::image::Flic_Animate
								((Flic *)pPVar4->imageOrFlic,&local_10,(BOOL)uVar7,(BOOL)(uVar7 >> 0x20));
		}
	}
	if (panelType == PANEL_CAMERACONTROL) {
		if ((globs::panelGlobs.flags & 0x10) != 0) {
			lego::image::Image_DisplayScaled
								(globs::panelGlobs.rotateUpImage,NULL,&globs::panelGlobs.rotateUpOffset,NULL);
			globs::panelGlobs.flags &= 0xffffffef;
		}
		if ((globs::panelGlobs.flags & 0x20) != 0) {
			lego::image::Image_DisplayScaled
								(globs::panelGlobs.rotateDownImage,NULL,&globs::panelGlobs.rotateDownOffset,NULL);
			globs::panelGlobs.flags &= 0xffffffdf;
		}
		if ((globs::panelGlobs.flags & 0x40) != 0) {
			lego::image::Image_DisplayScaled
								(globs::panelGlobs.rotateLeftImage,NULL,&globs::panelGlobs.rotateLeftOffset,NULL);
			globs::panelGlobs.flags &= 0xffffffbf;
		}
		if ((globs::panelGlobs.flags & 0x80) != 0) {
			lego::image::Image_DisplayScaled
								(globs::panelGlobs.rotateRightImage,NULL,&globs::panelGlobs.rotateRightOffset,NULL);
			globs::panelGlobs.flags &= 0xffffff7f;
		}
	}
	lVar6 = __ftol((float10)globs::panelGlobs.panelTable[panelType].xyOutIn.x - (float10)local_28);
	uVar3 = (int)(uint)lVar6 >> 0x1f;
	if (((int)(((uint)lVar6 ^ uVar3) - uVar3) < 2) &&
		 (lVar6 = __ftol((float10)globs::panelGlobs.panelTable[panelType].xyOutIn.y - (float10)local_24)
		 , uVar3 = (int)(uint)lVar6 >> 0x1f, (int)(((uint)lVar6 ^ uVar3) - uVar3) < 2)) {
		globs::panelGlobs.panelTable[panelType].flags =
				 globs::panelGlobs.panelTable[panelType].flags & 0xfffffff7;
	}
	Panel_Display_FUN_0045ac80(panelType);
	return;
}



void __cdecl lego::front::Panel_Display_FUN_0045ac80(PanelType panelType)
{
	float fVar1;
	Image *image;
	BOOL BVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	float *pfVar6;
	Point2F local_8;
	
	uVar5 = 0;
	if (globs::panelGlobs.panelTable[panelType].buttonCount != 0) {
		iVar4 = 0;
		do {
			pfVar6 = (float *)((int)globs::panelGlobs.panelTable[panelType].buttonList + iVar4);
			local_8.x = *pfVar6 + globs::panelGlobs.panelTable[panelType].xyOutIn.x;
			local_8.y = pfVar6[1] + globs::panelGlobs.panelTable[panelType].xyOutIn.y;
			fVar1 = pfVar6[10];
			if (((uint)fVar1 & 0x10) == 0) {
				uVar3 = (uint)fVar1 & 0x40;
				if ((((uint)fVar1 & 8) == 0) && (((uint)fVar1 & 2) != 0)) {
					if (uVar3 == 0) {
LAB_0045ad31:
						image = (Image *)pfVar6[4];
					}
					else {
						BVar2 = Interface_GetBool_004ded1c();
						if (BVar2 == 0) goto LAB_0045ad5a;
						image = (Image *)pfVar6[4];
					}
				}
				else {
					if ((((uint)fVar1 & 4) == 0) && (((uint)fVar1 & 8) == 0)) {
						if ((uVar3 == 0) || (BVar2 = Interface_GetBool_004ded1c(), BVar2 == 0)) {
							image = (Image *)pfVar6[6];
						}
						else {
							image = (Image *)pfVar6[4];
						}
					}
					else {
						if ((uVar3 != 0) && (BVar2 = Interface_GetBool_004ded1c(), BVar2 != 0))
						goto LAB_0045ad31;
						image = (Image *)pfVar6[5];
					}
				}
				if (image != NULL) {
					lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
				}
			}
LAB_0045ad5a:
			uVar5 += 1;
			iVar4 += 0x2c;
		} while (uVar5 < globs::panelGlobs.panelTable[panelType].buttonCount);
	}
	return;
}



void __cdecl
lego::front::Panel_Button_SetFlags_10(PanelType panelType,PanelButtonType buttonType,BOOL state)
{
	uint *puVar1;
	void *pvVar2;
	uint uVar3;
	
	pvVar2 = globs::panelGlobs.panelTable[panelType].buttonList;
	puVar1 = (uint *)((int)pvVar2 + buttonType * 0x2c + 0x28);
	uVar3 = *(uint *)((int)pvVar2 + buttonType * 0x2c + 0x28);
	if (state != 0) {
		*puVar1 = uVar3 | 0x10;
		return;
	}
	*puVar1 = uVar3 & 0xffffffef;
	return;
}



void __cdecl lego::front::Panel_ChangeFlags_BasedOnState(PanelType panelType)
{
	uint panelFlags;
	
	panelFlags = globs::panelGlobs.panelTable[panelType].flags;
	if ((panelFlags & 2) != 0) {
		globs::panelGlobs.panelTable[panelType].flags = panelFlags & 0xfffffffd | 0xc;
		return;
	}
	globs::panelGlobs.panelTable[panelType].flags = panelFlags & 0xfffffffb | 10;
	return;
}



BOOL __cdecl lego::front::Panel_IsFlags_4_Not8(PanelType panelType)
{
	uint uVar1;
	
	uVar1 = globs::panelGlobs.panelTable[panelType].flags;
	if (((uVar1 & 4) != 0) && ((uVar1 & 8) == 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::front::Panel_IsFlags_2_Not8(PanelType panelType)
{
	uint flags;
	
	flags = globs::panelGlobs.panelTable[panelType].flags;
	if (((flags & 2) != 0) && ((flags & 8) == 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::front::Panel_IsFlags_8(PanelType panelType)
{
	return globs::panelGlobs.panelTable[panelType].flags & 8;
}



void __cdecl
lego::front::Panel_Button_SetFlag_20(PanelType panelType,PanelButtonType buttonType,BOOL setFlag20)
{
	void *pvVar1;
	
	pvVar1 = (void *)((int)globs::panelGlobs.panelTable[panelType].buttonList + buttonType * 0x2c);
	if (setFlag20 != 0) {
		*(uint *)((int)pvVar1 + 0x28) = *(uint *)((int)pvVar1 + 0x28) | 0x20;
		return;
	}
	*(uint *)((int)pvVar1 + 0x28) = *(uint *)((int)pvVar1 + 0x28) & 0xffffffdf;
	return;
}



void __cdecl
lego::front::Panel_Button_SetFlag_8_OrUnset_c
					(PanelType panelType,PanelButtonType buttonType,BOOL setFlag8)
{
	void *pvVar1;
	uint uVar2;
	
	pvVar1 = (void *)((int)globs::panelGlobs.panelTable[panelType].buttonList + buttonType * 0x2c);
	uVar2 = *(uint *)((int)pvVar1 + 0x28);
	if ((uVar2 & 0x20) != 0) {
		if (setFlag8 != 0) {
			*(uint *)((int)pvVar1 + 0x28) = uVar2 | 8;
			return;
		}
		*(uint *)((int)pvVar1 + 0x28) = uVar2 & 0xfffffff3;
	}
	return;
}



void __cdecl
lego::front::Panel_CreateButtons
					(PanelType panelType,uint count,int param_3,int param_4,int *param_5,int param_6,
					int param_7,int param_8)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	char *pcVar4;
	void *buttons;
	Image *pIVar5;
	float *pfVar6;
	char **ppcVar7;
	float *pfVar8;
	
	if (count != 0) {
		buttons = std::malloc(count * 0x2c);
		globs::panelGlobs.panelTable[panelType].buttonList = buttons;
		globs::panelGlobs.panelTable[panelType].buttonCount = count;
		if (count != 0) {
			pfVar8 = (float *)(param_4 + 4);
			ppcVar7 = (char **)param_5;
			do {
				pfVar6 = (float *)((param_8 - (int)param_5) + (int)ppcVar7);
				pfVar1 = (float *)((int)globs::panelGlobs.panelTable[panelType].buttonList +
													*(int *)((int)pfVar6 + (param_3 - param_8)) * 0x2c);
				*pfVar1 = pfVar8[-1];
				pfVar1[1] = *pfVar8;
				pfVar1[2] = pfVar8[1] + pfVar8[-1];
				fVar2 = pfVar8[2];
				fVar3 = *pfVar8;
				pfVar1[6] = 0.0;
				pfVar1[4] = 0.0;
				pfVar1[5] = 0.0;
				pfVar1[3] = fVar2 + fVar3;
				pfVar1[8] = *pfVar6;
				if ((param_5 != NULL) && (*ppcVar7 != NULL)) {
					pIVar5 = lego::image::Image_LoadBMPScaled(*ppcVar7,0,0);
					pfVar1[6] = (float)pIVar5;
					if (pIVar5 != NULL) {
						lego::image::Image_SetupTrans(pIVar5,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				if ((param_6 != 0) &&
					 (pcVar4 = *(char **)((param_6 - (int)param_5) + (int)ppcVar7), pcVar4 != NULL)) {
					pIVar5 = lego::image::Image_LoadBMPScaled(pcVar4,0,0);
					pfVar1[4] = (float)pIVar5;
					if (pIVar5 != NULL) {
						lego::image::Image_SetupTrans(pIVar5,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				if ((param_7 != 0) &&
					 (pcVar4 = *(char **)((param_7 - (int)param_5) + (int)ppcVar7), pcVar4 != NULL)) {
					pIVar5 = lego::image::Image_LoadBMPScaled(pcVar4,0,0);
					pfVar1[5] = (float)pIVar5;
					if (pIVar5 != NULL) {
						lego::image::Image_SetupTrans(pIVar5,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				pfVar8 = pfVar8 + 4;
				ppcVar7 = ppcVar7 + 1;
				count -= 1;
				pfVar1[10] = 0.0;
			} while (count != 0);
		}
	}
	return;
}



BOOL __cdecl
lego::front::Panel_UnkUpdate_FUN_0045b070
					(float elapsedAbs,uint mouseX,uint mouseY,BOOL leftButton,BOOL leftButtonLast,
					BOOL *out_panelCollision)
{
	int *piVar1;
	uint mouseY_00;
	BOOL BVar2;
	BOOL BVar3;
	TutorialFlags TVar4;
	LevelData *pLVar5;
	BOOL BVar6;
	
	BVar2 = leftButtonLast;
	BVar6 = leftButton;
	mouseY_00 = mouseY;
	if (leftButton == 0) {
		globs::panelGlobs.flags &= 0xfffffffe;
	}
	BVar3 = Panel_InputProc_FUN_0045b5d0
										((PanelType *)&out_panelCollision,(PanelButtonType *)&leftButton,mouseX,mouseY,
										 leftButton,leftButtonLast,&leftButtonLast,out_panelCollision);
	if (BVar3 == 0) {
		BVar6 = ScrollInfo_Mouse_FUN_00463b60((int *)&mouseY,mouseX,mouseY_00,BVar6,BVar2);
		if (BVar6 == 0) {
			return (BOOL)NULL;
		}
		if (mouseY == 0) {
			Info_UpdateInt6EC_FromScrollInfo();
		}
		if (leftButtonLast == 0) {
			return (BOOL)(BOOL *)0x1;
		}
	}
	else {
		globs::legoGlobs.flags1 |= GAME1_UNK_200;
		if ((out_panelCollision == (BOOL *)&DAT_0000000c) || (leftButton == PANELBUTTON__COUNT)) {
			return (BOOL)out_panelCollision;
		}
		TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if (leftButtonLast != 0) {
			piVar1 = (int *)((int)globs::panelGlobs.panelTable[(int)out_panelCollision].buttonList +
											leftButton * 0x2c + 0x24);
			*piVar1 = *piVar1 + 1;
			if (((TVar4 & TUTORIAL_UNK_10) != TUTORIAL_NONE) && (out_panelCollision == NULL)) {
				game::Game_SetPointer_AndPlayEnumSFX(1);
				return (BOOL)(BOOL *)TRUE;
			}
			if ((((TVar4 & TUTORIAL_UNK_20) != TUTORIAL_NONE) && (out_panelCollision == (BOOL *)0x6)) &&
				 (leftButton == 0)) {
				Panel_Button_SetFlag_8_OrUnset_c(PANEL_TOPPANEL,0,0);
				game::Game_SetPointer_AndPlayEnumSFX(1);
				return (BOOL)(BOOL *)TRUE;
			}
			if ((((TVar4 & TUTORIAL_UNK_40) != TUTORIAL_NONE) && (out_panelCollision == (BOOL *)0x6)) &&
				 (leftButton == 1)) {
				Panel_Button_SetFlag_8_OrUnset_c(PANEL_TOPPANEL,1,FALSE);
				game::Game_SetPointer_AndPlayEnumSFX(1);
				return (BOOL)(BOOL *)TRUE;
			}
			if ((((TVar4 & TUTORIAL_UNK_80) != TUTORIAL_NONE) && (out_panelCollision == (BOOL *)0x6)) &&
				 (leftButton == 2)) {
				Panel_Button_SetFlag_8_OrUnset_c(PANEL_TOPPANEL,2,FALSE);
				game::Game_SetPointer_AndPlayEnumSFX(1);
				return (BOOL)(BOOL *)TRUE;
			}
			if ((((TVar4 & TUTORIAL_UNK_400) != TUTORIAL_NONE) &&
					(out_panelCollision == (BOOL *)&DAT_00000009)) && (leftButton == 2)) {
				game::Game_SetPointer_AndPlayEnumSFX(1);
				return (BOOL)(BOOL *)TRUE;
			}
			if (((TVar4 & TUTORIAL_UNK_1000) != TUTORIAL_NONE) &&
				 (out_panelCollision == (BOOL *)&DAT_00000009)) {
				if ((leftButton == 0) || (leftButton == 1)) goto LAB_0045b57a;
				if (leftButton == 3) {
					game::Game_SetPointer_AndPlayEnumSFX(1);
					return (BOOL)(BOOL *)TRUE;
				}
			}
		}
		if (BVar6 != 0) {
			if (out_panelCollision == NULL) {
				if ((globs::legoGlobs.flags1 & GAME1_RADAR_MAPVIEW) != GAME1_NONE) {
					if (leftButton == 2) {
						if (globs::legoGlobs.tvTiltOrZoom_334 < 20.0) {
							globs::legoGlobs.tvTiltOrZoom_334 = elapsedAbs + globs::legoGlobs.tvTiltOrZoom_334;
						}
						if ((ushort)((ushort)(globs::legoGlobs.tvTiltOrZoom_334 < 20.0) << 8 |
												(ushort)(globs::legoGlobs.tvTiltOrZoom_334 == 20.0) << 0xe) == 0) {
							globs::legoGlobs.tvTiltOrZoom_334 = 20.0;
						}
					}
					else {
						if (leftButton == 3) {
							if ((ushort)((ushort)(globs::legoGlobs.tvTiltOrZoom_334 < 10.0) << 8 |
													(ushort)(globs::legoGlobs.tvTiltOrZoom_334 == 10.0) << 0xe) == 0) {
								globs::legoGlobs.tvTiltOrZoom_334 = globs::legoGlobs.tvTiltOrZoom_334 - elapsedAbs;
							}
							if (globs::legoGlobs.tvTiltOrZoom_334 < 10.0) {
								globs::legoGlobs.tvTiltOrZoom_334 = 10.0;
							}
						}
					}
				}
			}
			else {
				if (((out_panelCollision == (BOOL *)&DAT_00000009) &&
						(TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
						(TVar4 & TUTORIAL_UNK_1000) == TUTORIAL_NONE)) &&
					 (Panel_RotationControl_MoveDist(leftButton,elapsedAbs), leftButton == 3)) {
					Panel_RotationControl_FUN_0045bf90(mouseX,mouseY_00,elapsedAbs);
				}
			}
		}
		if (leftButtonLast == 0) {
			return (BOOL)(BOOL *)0x1;
		}
		pLVar5 = lrr::Lego_GetLevel();
		if (pLVar5->status == LEVELSTATUS_NONE) {
			game::Game_SetPointer_AndPlayEnumSFX(0);
			if (false) {
				return (BOOL)(BOOL *)0x1;
			}
			switch(out_panelCollision) {
			case NULL:
				if (leftButton == 0) {
					Panel_ChangeFlags_BasedOnState(PANEL_RADAR);
					Panel_ChangeFlags_BasedOnState(PANEL_RADARFILL);
					return (BOOL)(BOOL *)TRUE;
				}
				if (leftButton != 1) {
					if (leftButton != 4) {
						return (BOOL)(BOOL *)0x1;
					}
					globs::legoGlobs.flags1 =
							 globs::legoGlobs.flags1 & ~GAME1_RADAR_TRACKOBJECTVIEW | GAME1_RADAR_MAPVIEW;
					Panel_Button_SetFlags_10(PANEL_RADAR,2,FALSE);
					Panel_Button_SetFlags_10(PANEL_RADAR,3,FALSE);
					return (BOOL)(BOOL *)TRUE;
				}
				globs::legoGlobs.flags1 =
						 globs::legoGlobs.flags1 &
						 (GAME1_HIGHFOGCOLOURRGB|GAME1_UNK_20000|GAME1_UNK_40000|GAME1_DYNAMICPM|
							GAME1_CAMERADISABLED|GAME1_UNK_200000|GAME1_ONLYBUILDONPATHS|GAME1_ALWAYSROCKFALL|
							GAME1_DEBUG_NONERPS|GAME1_PAUSED|GAME1_STREAMNERPSSPEACH|GAME1_UNK_8000000|
							GAME1_LASERTRACKER|GAME1_UNK_20000000|GAME1_DEBUG_NOCLIP_FPS|GAME1_UNK_80000000) |
						 (ushort)((ushort)globs::legoGlobs.flags1 | 0x2000) & ~GAME1_RADAR_MAPVIEW;
				Panel_Button_SetFlags_10(PANEL_RADAR,2,TRUE);
				Panel_Button_SetFlags_10(PANEL_RADAR,3,TRUE);
				return (BOOL)(BOOL *)TRUE;
			default:
				return (BOOL)(BOOL *)0x1;
			case (BOOL *)0x6:
				goto switchD_0045b34e_caseD_6;
			case (BOOL *)0x8:
				if (leftButton == PANELBUTTON_PRIORITYLIST_RESET) {
					ai::Priorities_Reset();
					return (BOOL)(BOOL *)TRUE;
				}
				if (leftButton == 0x11) {
					if (((byte)globs::panelGlobs.panelTable[8].flags & 4) != 0) {
						return (BOOL)(BOOL *)0x1;
					}
					Interface_BackToMain();
					return (BOOL)(BOOL *)TRUE;
				}
				Panel_PriorityList_FUN_0045b8e0(leftButton);
				return (BOOL)(BOOL *)TRUE;
			case (BOOL *)0x9:
				if (leftButton != 2) {
					return (BOOL)(BOOL *)0x1;
				}
				game::LiveManager_CheckMouseIntersections_FUN_0044c810();
				return (BOOL)(BOOL *)TRUE;
			case (BOOL *)0xa:
				if (leftButton == 1) {
					Info_PopFirstMessage();
					return (BOOL)(BOOL *)TRUE;
				}
				if (leftButton != 0) {
					return (BOOL)(BOOL *)0x1;
				}
				Info_UpdateMessage(0);
				Info_GotoFirst();
				return (BOOL)(BOOL *)TRUE;
			case (BOOL *)0xb:
				if (leftButton != 0) {
					return (BOOL)(BOOL *)0x1;
				}
				if (((byte)globs::panelGlobs.panelTable[11].flags & 4) != 0) {
					return (BOOL)(BOOL *)0x1;
				}
				Interface_BackToMain();
				return (BOOL)(BOOL *)TRUE;
			}
		}
	}
LAB_0045b57a:
	game::Game_SetPointer_AndPlayEnumSFX(1);
	return (BOOL)(BOOL *)TRUE;
switchD_0045b34e_caseD_6:
	if ((globs::legoGlobs.viewMode != VIEW_FIRSTPERSON) && (leftButton == 1)) {
		if (((byte)globs::panelGlobs.panelTable[8].flags & 4) == 0) {
			Interface_BackToMain();
		}
		else {
			game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
			Interface_OpenMenu_FUN_0041b200(0x16,NULL);
		}
	}
	if (leftButton == 0) {
		game::Game_SetPaused(TRUE,0);
		globs::legoGlobs.flags2 = globs::legoGlobs.flags2 ^ GAME2_INOPTIONSMENU;
		return (BOOL)(BOOL *)TRUE;
	}
	if (leftButton != 2) {
		return (BOOL)(BOOL *)0x1;
	}
	if ((globs::legoGlobs.flags2 & GAME2_CALLTOARMS) != GAME2_NONE) {
		lrr::LegoGame_SetCallToArmsOn(FALSE);
		return (BOOL)(BOOL *)TRUE;
	}
	lrr::LegoGame_SetCallToArmsOn(TRUE);
	return (BOOL)(BOOL *)TRUE;
}



BOOL __cdecl
lego::front::Panel_InputProc_FUN_0045b5d0
					(PanelType *out_panelType,PanelButtonType *out_panelButton,int mouseX,int mouseY,
					BOOL leftButton,BOOL leftButtonLast,BOOL *optout_param_7,BOOL *optout_panelCollision)
{
	Area2F *area;
	BOOL BVar1;
	int iVar2;
	BOOL BVar3;
	PanelButtonType panelButton;
	float fVar4;
	PanelType panelType;
	
	BVar3 = 0;
	if (optout_param_7 != NULL) {
		*optout_param_7 = 0;
	}
						// PANEL_BUTTON__COUNT ?
	*out_panelButton = PANELBUTTON__COUNT;
	*out_panelType = PANEL__COUNT;
						// Flag must force some behavior for camera control (held down on button?)
	if (((byte)globs::panelGlobs.flags & 1) != 0) {
		*out_panelType = PANEL_CAMERACONTROL;
		*out_panelButton = PANELBUTTON_CAMERACONTROL_ROTATE;
		return TRUE;
	}
	panelType = PANEL_RADAR;
	do {
		if ((*(byte *)&globs::panelGlobs.panelTable[panelType].flags & 1) != 0) {
			if ((((optout_panelCollision != NULL) && (panelType != PANEL_RADARFILL)) &&
					(panelType != PANEL_RADAROVERLAY)) &&
				 (BVar1 = Panel_TestScreenImageCollision(panelType,mouseX,mouseY), BVar1 == 0)) {
				*optout_panelCollision = TRUE;
			}
			panelButton = 0;
			if (globs::panelGlobs.panelTable[panelType].buttonCount != 0) {
				do {
					area = (Area2F *)
								 ((int)globs::panelGlobs.panelTable[panelType].buttonList + panelButton * 0x2c);
					if (BVar3 == 0) {
						if ((panelType == PANEL_CAMERACONTROL) && (panelButton == 3)) {
							iVar2 = math::Panel_MathX_TestInsideCircle
																(mouseX,mouseY,globs::panelGlobs.rotateCenter.x,
																 globs::panelGlobs.rotateCenter.y,globs::panelGlobs.rotateRadius);
						}
						else {
							iVar2 = Panel_TestMouseInsideOutInArea_FUN_0045b850
																(globs::panelGlobs.panelTable + panelType,area,mouseX,mouseY);
						}
						if ((false) || (iVar2 == 0)) goto LAB_0045b7eb;
						*out_panelType = panelType;
						if (leftButton == 0) {
							fVar4 = area[2].x;
							if (((fVar4 == 3.643376e-44) && (globs::liveGlobs.countBuildingsOnly_c438 == 0)) &&
								 (((byte)globs::liveGlobs.flags & 0x40) != 0)) {
								fVar4 = 4.904545e-44;
							}
							ToolTip_AddFlag4((ToolTipType)fVar4);
							if (globs::panelGlobs.currentButton != PANELBUTTON__COUNT) {
								if ((panelType == globs::panelGlobs.currentPanel) &&
									 (panelButton == globs::panelGlobs.currentButton)) {
									*out_panelButton = panelButton;
									fVar4 = area[2].width;
									if (((uint)fVar4 & 0x20) != 0) {
										if (((uint)fVar4 & 8) == 0) {
											fVar4 = (float)((uint)fVar4 | 8);
										}
										else {
											fVar4 = (float)((uint)fVar4 & 0xfffffff7);
										}
										area[2].width = fVar4;
									}
									if (optout_param_7 != NULL) {
										*optout_param_7 = TRUE;
									}
									area[2].width = (float)((uint)area[2].width & 0xfffffffb | 2);
								}
								goto LAB_0045b7e4;
							}
							BVar3 = TRUE;
							*out_panelButton = panelButton;
							area[2].width = (float)((uint)area[2].width & 0xfffffffb | 2);
						}
						else {
							if (globs::panelGlobs.currentButton == PANELBUTTON__COUNT) {
								if (leftButtonLast == 0) {
									globs::panelGlobs.currentPanel = panelType;
									BVar3 = TRUE;
									globs::panelGlobs.currentButton = panelButton;
									*out_panelButton = panelButton;
									area[2].width = (float)((uint)area[2].width & 0xfffffffd | 4);
								}
								else {
LAB_0045b7e4:
									BVar3 = TRUE;
								}
							}
							else {
								if ((panelType != globs::panelGlobs.currentPanel) ||
									 (panelButton != globs::panelGlobs.currentButton)) goto LAB_0045b7e4;
								BVar3 = TRUE;
								*out_panelButton = panelButton;
								area[2].width = (float)((uint)area[2].width & 0xfffffffd | 4);
							}
						}
					}
					else {
LAB_0045b7eb:
						fVar4 = area[2].width;
						area[2].width = (float)((uint)fVar4 & 0xfffffffd);
						if (((uint)fVar4 & 8) == 0) {
							fVar4 = (float)((uint)fVar4 & 0xfffffff9);
						}
						else {
							fVar4 = (float)((uint)fVar4 & 0xfffffffd | 4);
						}
						area[2].width = fVar4;
					}
					panelButton += 1;
				} while (panelButton < globs::panelGlobs.panelTable[panelType].buttonCount);
			}
		}
		panelType += PANEL_RADARFILL;
		if (PANEL_ENCYCLOPEDIA < panelType) {
			if (leftButton == 0) {
				globs::panelGlobs.currentPanel = PANEL__COUNT;
				globs::panelGlobs.currentButton = PANELBUTTON__COUNT;
			}
			return BVar3;
		}
	} while( true );
}



BOOL __cdecl
lego::front::Panel_TestMouseInsideOutInArea_FUN_0045b850
					(PanelData *panel,Area2F *area,int mouseX,int mouseY)
{
	float fVar1;
	float fVar2;
	longlong lVar3;
	longlong lVar4;
	
	lVar3 = __ftol((float10)(panel->xyOutIn).x);
	lVar4 = __ftol((float10)(panel->xyOutIn).y);
	fVar1 = (float)(mouseX - (int)lVar3);
	if ((((area->x <= fVar1) && (fVar2 = (float)(mouseY - (int)lVar4), fVar2 < area->height)) &&
			(area->y <= fVar2)) && (fVar1 < area->width)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::unk::lego::front::Panel_UnsetFlag_6(void)
{
	globs::panelGlobs.flags = globs::panelGlobs.flags & 0xfffffff9;
	return;
}



void __cdecl lego::front::Panel_PriorityList_FUN_0045b8e0(PanelButtonPriorityList buttonType)
{
	switch(buttonType) {
	case PANELBUTTON_PRIORITYLIST_DISABLE1:
		ai::Priorities_DisablePriority(0);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE2:
		ai::Priorities_DisablePriority(1);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE3:
		ai::Priorities_DisablePriority(2);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE4:
		ai::Priorities_DisablePriority(3);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE5:
		ai::Priorities_DisablePriority(4);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE6:
		ai::Priorities_DisablePriority(5);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE7:
		ai::Priorities_DisablePriority(6);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE8:
		ai::Priorities_DisablePriority(7);
		return;
	case PANELBUTTON_PRIORITYLIST_DISABLE9:
		ai::Priorities_DisablePriority(8);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE1:
		ai::Priorities_MovePriorityUp(1);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE2:
		ai::Priorities_MovePriorityUp(2);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE3:
		ai::Priorities_MovePriorityUp(3);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE4:
		ai::Priorities_MovePriorityUp(4);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE5:
		ai::Priorities_MovePriorityUp(5);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE6:
		ai::Priorities_MovePriorityUp(6);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE7:
		ai::Priorities_MovePriorityUp(7);
		return;
	case PANELBUTTON_PRIORITYLIST_UPONE8:
		ai::Priorities_MovePriorityUp(8);
	}
	return;
}



void __cdecl lego::front::Panel_ScrollInfo_Initialise(void)
{
	Area2F rect;
	
	ScrollInfo_Initialise("Interface\\InfoPanel\\scrollInfo.bmp",0,0,7,0);
	ScrollInfo_SetXYOrSize_Unk(0,8,33);
	rect.x = 0.0;
	rect.y = 0.0;
	rect.width = 18.0;
	rect.height = 11.0;
	ScrollInfo_AddStruct1C(0,TRUE,&rect,NULL,NULL);
	rect.x = 0.0;
	rect.y = 11.0;
	rect.width = 18.0;
	rect.height = 11.0;
	ScrollInfo_AddStruct1C(0,FALSE,&rect,NULL,NULL);
	rect.x = 0.0;
	rect.y = 0.0;
	rect.width = 0.0;
	rect.height = 0.0;
	ScrollInfo_AddCreateStruct28(0,&rect,1,0,"Interface\\Buttons\\scrollInfoSld.bmp");
	rect.x = 40.0;
	rect.y = 12.0;
	rect.width = 180.0;
	rect.height = 43.0;
	globs::panelGlobs.infoTextWnd =
			 Panel_TextWindow_Create(PANEL_INFORMATION,globs::legoGlobs.bmpFONT5_HI,&rect,0x100);
	return;
}



void __cdecl lego::front::Panel_Encyclopedia_Initialise(void)
{
	Area2F rect;
	
	rect.x = 21.0;
	rect.y = 11.0;
	rect.width = 221.0;
	rect.height = 227.0;
	globs::panelGlobs.encyclopediaTextWnd =
			 Panel_TextWindow_Create(PANEL_ENCYCLOPEDIA,globs::legoGlobs.bmpFONT5_HI,&rect,0x400);
	return;
}



BOOL __cdecl
lego::math::Panel_MathX_TestInsideCircle(int x,int y,int centerX,int centerY,int radius)
{
	float dist;
	
	dist = SQRT((float)(centerY - y) * (float)(centerY - y) +
							(float)(centerX - x) * (float)(centerX - x));
	if ((ushort)((ushort)((float)radius < dist) << 8 | (ushort)((float)radius == dist) << 0xe) == 0) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::math::Panel_Maths_XY_Div_Radius(int x,int y,int radius,float *out_x,float *out_y)
{
	*out_x = (float)x / (float)radius;
	*out_y = (float)y / (float)radius;
	return;
}



void __cdecl
lego::front::Panel_RotationControl_GetMouseXY_FUN_0045bbf0
					(int *out_mouseX,int *out_mouseY,int param_3,int param_4,int param_5)
{
	float fVar1;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar2;
	
	fVar1 = (float)((float10)*out_mouseX - (float10)param_3);
	lVar2 = __ftol(((float10)1.0 /
								 SQRT(((float10)*out_mouseY - (float10)param_4) *
											(float10)(float)((float10)*out_mouseY - (float10)param_4) +
											((float10)*out_mouseX - (float10)param_3) * (float10)fVar1)) * (float10)fVar1
								 * (float10)((float)param_5 - 1.0) + (float10)param_3);
	*out_mouseX = (int)lVar2;
	lVar2 = __ftol(extraout_ST0 + extraout_ST1);
	*out_mouseY = (int)lVar2;
	return;
}



void __cdecl lego::front::Panel_RotationControl_Initialise(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	float10 fVar2;
	char *local_28;
	char *local_24;
	char *local_20;
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","CenterPositionX",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		globs::panelGlobs.rotateCenter.x = 1;
	}
	else {
		globs::panelGlobs.rotateCenter.x = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","CenterPositionY",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		globs::panelGlobs.rotateCenter.y = 1;
	}
	else {
		globs::panelGlobs.rotateCenter.y = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","Radius",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		globs::panelGlobs.rotateRadius = 1;
	}
	else {
		globs::panelGlobs.rotateRadius = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","LeftImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		globs::panelGlobs.rotateLeftImage = NULL;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globs::panelGlobs.rotateLeftImage = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globs::panelGlobs.rotateLeftImage);
		fVar2 = std::atof(local_24);
		globs::panelGlobs.rotateLeftOffset.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		globs::panelGlobs.rotateLeftOffset.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","RightImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		globs::panelGlobs.rotateRightImage = NULL;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globs::panelGlobs.rotateRightImage = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globs::panelGlobs.rotateRightImage);
		fVar2 = std::atof(local_24);
		globs::panelGlobs.rotateRightOffset.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		globs::panelGlobs.rotateRightOffset.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","UpImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		globs::panelGlobs.rotateUpImage = NULL;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globs::panelGlobs.rotateUpImage = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globs::panelGlobs.rotateUpImage);
		fVar2 = std::atof(local_24);
		globs::panelGlobs.rotateUpOffset.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		globs::panelGlobs.rotateUpOffset.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"PanelRotationControl","DownImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globs::panelGlobs.rotateDownImage = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globs::panelGlobs.rotateDownImage);
		fVar2 = std::atof(local_24);
		globs::panelGlobs.rotateDownOffset.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		globs::panelGlobs.rotateDownOffset.y = (float)fVar2;
		std::free(pcVar1);
		return;
	}
	globs::panelGlobs.rotateDownImage = NULL;
	return;
}



BOOL __cdecl lego::front::Panel_RotationControl_FUN_0045bf90(int mouseX,int mouseY,float elapsedAbs)
{
	float yawAmount;
	BOOL BVar1;
	float local_8;
	float local_4;
	
	BVar1 = math::Panel_MathX_TestInsideCircle
										(mouseX,mouseY,globs::panelGlobs.rotateCenter.x,globs::panelGlobs.rotateCenter.y
										 ,globs::panelGlobs.rotateRadius);
	if (BVar1 == 0) {
		if ((globs::panelGlobs.flags & 1) == 0) {
			return 0;
		}
		if (true) {
			Panel_RotationControl_GetMouseXY_FUN_0045bbf0
								(&mouseX,&mouseY,globs::panelGlobs.rotateCenter.x,globs::panelGlobs.rotateCenter.y,
								 globs::panelGlobs.rotateRadius);
			input::Input_SetCursorPos(mouseX,mouseY);
			goto LAB_0045c031;
		}
	}
	BVar1 = math::Panel_MathX_TestInsideCircle
										(mouseX,mouseY,globs::panelGlobs.rotateCenter.x,globs::panelGlobs.rotateCenter.y
										 ,4);
	if (BVar1 != 0) {
		return 1;
	}
LAB_0045c031:
	globs::panelGlobs.flags |= 1;
	math::Panel_Maths_XY_Div_Radius
						(globs::panelGlobs.rotateCenter.x - mouseX,mouseY - globs::panelGlobs.rotateCenter.y,
						 globs::panelGlobs.rotateRadius,&local_4,&local_8);
	BVar1 = math::Panel_MathX_TestInsideCircle
										(mouseX,globs::panelGlobs.rotateCenter.y,globs::panelGlobs.rotateCenter.x,
										 globs::panelGlobs.rotateCenter.y,3);
	if (BVar1 != 0) {
		lego::view::Camera_AddTilt(globs::legoGlobs.cameraMain,local_8 * elapsedAbs * 0.04);
		if (0.0 <= local_8) {
			globs::panelGlobs.flags = globs::panelGlobs.flags | 0x20;
			return 1;
		}
		globs::panelGlobs.flags = globs::panelGlobs.flags | 0x10;
		return 1;
	}
	BVar1 = math::Panel_MathX_TestInsideCircle
										(globs::panelGlobs.rotateCenter.x,mouseY,globs::panelGlobs.rotateCenter.x,
										 globs::panelGlobs.rotateCenter.y,3);
	yawAmount = local_4 * elapsedAbs * 0.04;
	if (BVar1 == 0) {
		lego::view::Camera_AddYaw(globs::legoGlobs.cameraMain,yawAmount);
		lego::view::Camera_AddTilt(globs::legoGlobs.cameraMain,local_8 * elapsedAbs * 0.04);
		if (0.0 <= local_8) {
			globs::panelGlobs.flags |= 0x20;
		}
		else {
			globs::panelGlobs.flags |= 0x10;
		}
		if (local_4 < 0.0) {
			globs::panelGlobs.flags = globs::panelGlobs.flags | 0x80;
			return 1;
		}
	}
	else {
		lego::view::Camera_AddYaw(globs::legoGlobs.cameraMain,yawAmount);
		if (local_4 < 0.0) {
			globs::panelGlobs.flags = globs::panelGlobs.flags | 0x80;
			return 1;
		}
	}
	globs::panelGlobs.flags = globs::panelGlobs.flags | 0x40;
	return 1;
}



void __cdecl lego::front::Panel_RotationControl_MoveDist(BOOL doAdd,float amount)
{
	if (doAdd == 0) {
		lego::view::Camera_AddDist(globs::legoGlobs.cameraMain,amount * -3.0);
		return;
	}
	if (doAdd == 1) {
		lego::view::Camera_AddDist(globs::legoGlobs.cameraMain,amount * 3.0);
	}
	return;
}



void __cdecl
lego::front::Panel_GetButtonRect(PanelType panelType,PanelButtonType buttonType,Area2F *out_rect)
{
	float *pfVar1;
	void *pvVar2;
	
	pvVar2 = globs::panelGlobs.panelTable[panelType].buttonList;
	pfVar1 = (float *)((int)pvVar2 + buttonType * 0x2c);
	out_rect->x = *(float *)((int)pvVar2 + buttonType * 0x2c);
	out_rect->y = pfVar1[1];
	out_rect->width = pfVar1[2] - *pfVar1;
	out_rect->height = pfVar1[3] - pfVar1[1];
	return;
}



void __cdecl
lego::front::Panel_Crystals_Initialise(char *smallCrystal,char *usedCrystal,char *noSmallCrystal)
{
	globs::panelGlobs.crystalSmallImage = lego::image::Image_LoadBMPScaled(smallCrystal,0,0);
	if (globs::panelGlobs.crystalSmallImage != NULL) {
		lego::image::Image_SetupTrans(globs::panelGlobs.crystalSmallImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globs::panelGlobs.crystalUsedImage = lego::image::Image_LoadBMPScaled(usedCrystal,0,0);
	if (globs::panelGlobs.crystalUsedImage != NULL) {
		lego::image::Image_SetupTrans(globs::panelGlobs.crystalUsedImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globs::panelGlobs.crystalNoSmallImage = lego::image::Image_LoadBMPScaled(noSmallCrystal,0,0);
	if (globs::panelGlobs.crystalNoSmallImage != NULL) {
		lego::image::Image_SetupTrans(globs::panelGlobs.crystalNoSmallImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl
lego::front::Panel_Crystals_LoadRewardQuota(CFGProperty *root,char *rootPath,char *levelName)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,levelName,"Reward","Quota","Crystals",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,levelName,"Reward","Quota","Crystals",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	globs::panelGlobs.crystalQuota = std::atoi(pcVar1);
	if ((26 < globs::panelGlobs.crystalQuota) || (globs::panelGlobs.crystalQuota == 0)) {
		globs::panelGlobs.crystalQuota = 26;
	}
	return;
}



void __cdecl
lego::front::Panel_Crystals_Draw(uint crystals,uint usedCrystals,float elapsedGame_unused)
{
	uint (*pauVar1) [6];
	uint uVar2;
	int iVar3;
	uint *puVar4;
	uint (*pauVar5) [6];
	uint uVar6;
	CryTuple_8 *pCVar7;
	uint uVar8;
	uint uVar9;
	Image *image;
	CryTuple_8 *local_70;
	float local_6c;
	uint baseCounts [2];
	CryTuple_8 tableCounts [12];
	
						// [26] is the hardcoded max displayable crystals in the sidebar
	tableCounts[0].cryCount = 0;
	baseCounts[0] = 0;
	puVar4 = &tableCounts[0].unkCount;
	for (iVar3 = 0x17; iVar3 != 0; iVar3 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	baseCounts[1] = 0;
						// shift both all/used crystals tables down by one
						//  [0] <- [1] ... [5] <- count
	pauVar5 = globs::panelGlobs.s_crystalShifts;
	do {
		iVar3 = 2;
		pauVar1 = pauVar5;
		do {
			(*pauVar1)[0] = (*pauVar1)[1];
			pauVar1 = pauVar1[1];
			iVar3 += -1;
		} while (iVar3 != 0);
		pauVar5 = (uint (*) [6])(*pauVar5 + 1);
	} while (pauVar5 < (uint (*) [6])(globs::panelGlobs.s_crystalShifts + 5));
	globs::panelGlobs.s_crystalShifts[0][5] = crystals;
	local_70 = tableCounts;
	globs::panelGlobs.s_crystalShifts[1][5] = usedCrystals;
	uVar6 = 0;
	puVar4 = baseCounts;
	do {
		uVar8 = 0;
		do {
			uVar9 = *puVar4;
			uVar2 = 0;
			if (uVar9 != 0) {
				pCVar7 = local_70;
				do {
					if (pCVar7->cryCount == globs::panelGlobs.s_crystalShifts[uVar8 + uVar6]) {
						tableCounts[uVar2 + uVar6].unkCount = tableCounts[uVar2 + uVar6].unkCount + 1;
						break;
					}
					uVar2 += 1;
					pCVar7 = pCVar7 + 1;
				} while (uVar2 < uVar9);
			}
			if (uVar2 == uVar9) {
				tableCounts[uVar2 + uVar6].cryCount = globs::panelGlobs.s_crystalShifts[uVar8 + uVar6];
				tableCounts[uVar2 + uVar6].unkCount = 1;
				*puVar4 = uVar9 + 1;
			}
			uVar8 += 1;
		} while (uVar8 < 6);
		uVar6 += 6;
		local_70 = local_70 + 6;
		puVar4 = puVar4 + 1;
						// end of last loop
						// if (i >= 12) (aka, i >= 2, where i is a multiple of 6)
		if (0xb < uVar6) {
			uVar6 = 0;
			do {
				uVar8 = baseCounts[uVar6];
				uVar9 = 0;
				if (uVar8 != 0) {
					pCVar7 = tableCounts;
					puVar4 = &tableCounts[uVar6 * 6].unkCount;
					do {
						uVar2 = *puVar4;
						if (uVar9 < uVar2) {
							uVar9 = uVar2;
							if (uVar6 == 0) {
								crystals = pCVar7->cryCount;
							}
							else {
								usedCrystals = puVar4[-1];
							}
						}
						pCVar7 = pCVar7 + 1;
						puVar4 = puVar4 + 2;
						uVar8 -= 1;
					} while (uVar8 != 0);
				}
				uVar6 += 1;
			} while (uVar6 < 2);
			Panel_PrintF(PANEL_CRYSTALSIDEBAR,globs::legoGlobs.bmpToolTipFont,0x29,0x1d5,1,"%i",crystals);
			if (globs::panelGlobs.crystalNoSmallImage != NULL) {
						// More hardcoded screen resolution positions
				local_70 = (CryTuple_8 *)0x441c0000;
				local_6c = 429.0;
				for (uVar6 = globs::panelGlobs.crystalQuota; uVar6 != 0; uVar6 -= 1) {
					lego::image::Image_DisplayScaled
										(globs::panelGlobs.crystalNoSmallImage,NULL,(Point2F *)&local_70,NULL);
					local_6c = local_6c - 17.0;
				}
			}
			if (globs::panelGlobs.crystalSmallImage != NULL) {
				uVar6 = 0;
				if (globs::panelGlobs.crystalQuota < crystals) {
					crystals = globs::panelGlobs.crystalQuota;
				}
				if (globs::panelGlobs.crystalQuota < usedCrystals) {
					usedCrystals = globs::panelGlobs.crystalQuota;
				}
						// More hardcoded screen resolution positions
				local_70 = (CryTuple_8 *)0x441c0000;
				local_6c = 429.0;
				image = globs::panelGlobs.crystalSmallImage;
				uVar8 = usedCrystals;
				if (globs::panelGlobs.crystalUsedImage != NULL) {
					for (; image = globs::panelGlobs.crystalUsedImage,
							globs::panelGlobs.crystalUsedImage = image, uVar8 != 0; uVar8 = uVar8 - 1) {
						lego::image::Image_DisplayScaled
											(globs::panelGlobs.crystalSmallImage,NULL,(Point2F *)&local_70,NULL);
						local_6c = local_6c - 17.0;
						uVar6 = usedCrystals;
					}
				}
				if (uVar6 < crystals) {
					iVar3 = crystals - uVar6;
					do {
						lego::image::Image_DisplayScaled(image,NULL,(Point2F *)&local_70,NULL);
						local_6c = local_6c - 17.0;
						iVar3 += -1;
					} while (iVar3 != 0);
				}
			}
			return;
		}
	} while( true );
}



void __cdecl
lego::front::Panel_AirMeter_Initialise
					(char *airJuiceName,uint juiceX,uint juiceY,uint juiceLength,char *noAirName,uint noAirX,
					uint noAirY)
{
	globs::panelGlobs.airMeterJuiceImage = lego::image::Image_LoadBMPScaled(airJuiceName,0,0);
	globs::panelGlobs.airMeterJuiceOffset.x = (float)(ulonglong)juiceX;
	globs::panelGlobs.airMeterJuiceOffset.y = (float)(ulonglong)juiceY;
	globs::panelGlobs.airMeterJuiceLength = juiceLength;
	globs::panelGlobs.airMeterNoAirImage = lego::image::Image_LoadBMPScaled(noAirName,0,0);
	if (globs::panelGlobs.airMeterNoAirImage != NULL) {
		lego::image::Image_SetupTrans(globs::panelGlobs.airMeterNoAirImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globs::panelGlobs.airMeterNoAirOffset.x = (float)(ulonglong)noAirX;
	globs::panelGlobs.airMeterNoAirOffset.y = (float)(ulonglong)noAirY;
	return;
}



void __cdecl lego::front::Panel_AirMeter_SetOxygen(PanelType panelType,float oxygen)
{
	Point2F local_10;
	Size2F local_8;
	
	if ((globs::panelGlobs.airMeterJuiceImage != NULL) &&
		 ((ushort)((ushort)(oxygen < 0.0) << 8 | (ushort)(oxygen == 0.0) << 0xe) == 0)) {
		local_8.height = (float)(globs::panelGlobs.airMeterJuiceImage)->height;
		if ((ushort)((ushort)(oxygen < 100.0) << 8 | (ushort)(oxygen == 100.0) << 0xe) == 0) {
			oxygen = (float)&DAT_42c80000;
		}
		local_8.width = (float)(ulonglong)globs::panelGlobs.airMeterJuiceLength * 0.01 * oxygen;
		local_10.x = globs::panelGlobs.panelTable[panelType].xyOutIn.x +
								 globs::panelGlobs.airMeterJuiceOffset.x;
		local_10.y = globs::panelGlobs.panelTable[panelType].xyOutIn.y +
								 globs::panelGlobs.airMeterJuiceOffset.y;
		lego::image::Image_DisplayScaled(globs::panelGlobs.airMeterJuiceImage,NULL,&local_10,&local_8);
	}
	return;
}



void __cdecl lego::front::Panel_AirMeter_SetAirBeat_UnkBool(BOOL state)
{
	globs::panelGlobs.airMeterUnkBeatBool = state;
	return;
}



void __cdecl lego::front::Panel_AirMeter_FUN_0045c770(PanelType panelType)
{
	Image *image;
	BOOL BVar1;
	Point2F local_8;
	
	image = globs::panelGlobs.airMeterNoAirImage;
	if (globs::panelGlobs.airMeterNoAirImage != NULL) {
		local_8.x = globs::panelGlobs.panelTable[panelType].xyOutIn.x +
								globs::panelGlobs.airMeterNoAirOffset.x;
		local_8.y = globs::panelGlobs.panelTable[panelType].xyOutIn.y +
								globs::panelGlobs.airMeterNoAirOffset.y;
		if (globs::panelGlobs.airMeterUnkBeatBool != 0) {
			BVar1 = Interface_GetBool_004ded1c();
			if (BVar1 != 0) {
				lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
			}
		}
	}
	return;
}



void __cdecl
lego::front::Panel_CryOreSideBar_Initialise(char *sidebarName,uint xPos,uint yPos,uint meterOffset)
{
	globs::panelGlobs.cryOreSideBarImage = lego::image::Image_LoadBMPScaled(sidebarName,0,0);
	globs::panelGlobs.cryOreSideBarOffset.x = (float)(ulonglong)xPos;
	globs::panelGlobs.cryOreSideBarOffset.y = (float)(ulonglong)yPos;
	globs::panelGlobs.cryOreMeterOffset = meterOffset;
	return;
}



void __cdecl lego::front::Panel_CryOreSideBar_ChangeOreMeter(BOOL increment,uint amount)
{
	if (increment == 0) {
		if (amount != 0) {
			do {
				amount -= 1;
				globs::panelGlobs.cryOreMeterValue =
						 (globs::panelGlobs.cryOreMeterValue - 0.05) * 20.0 * 0.05263158;
			} while (amount != 0);
		}
	}
	else {
		if (amount != 0) {
			do {
				amount -= 1;
				globs::panelGlobs.cryOreMeterValue =
						 globs::panelGlobs.cryOreMeterValue - (1.0 - globs::panelGlobs.cryOreMeterValue) * -0.05
				;
			} while (amount != 0);
		}
	}
	if (globs::panelGlobs.cryOreMeterValue < 0.0) {
		globs::panelGlobs.cryOreMeterValue = 0.0;
	}
	return;
}



void __cdecl lego::front::Panel_CryOreSideBar_Draw(void)
{
	Size2F local_10;
	Point2F local_8;
	
	if ((globs::panelGlobs.cryOreSideBarImage != NULL) &&
		 ((ushort)((ushort)(globs::panelGlobs.cryOreMeterValue < 0.0) << 8 |
							(ushort)(globs::panelGlobs.cryOreMeterValue == 0.0) << 0xe) == 0)) {
		local_10.width = (float)(globs::panelGlobs.cryOreSideBarImage)->width;
		local_8.x = globs::panelGlobs.cryOreSideBarOffset.x;
		local_10.height =
				 (float)(ulonglong)globs::panelGlobs.cryOreMeterOffset * globs::panelGlobs.cryOreMeterValue;
		local_8.y = globs::panelGlobs.cryOreSideBarOffset.y - local_10.height;
		lego::image::Image_DisplayScaled(globs::panelGlobs.cryOreSideBarImage,NULL,&local_8,&local_10);
	}
	return;
}



BOOL __cdecl
lego::front::Panel_SetCurrentAdvisorFromButton
					(PanelType panelType,PanelButtonType buttonType,BOOL setFlag2)
{
	BOOL BVar1;
	
	BVar1 = Panel_GetAdvisorTypeFromButton(panelType,buttonType,&buttonType);
	if (BVar1 != 0) {
		Advisor_SetCurrentAdvisor(buttonType,setFlag2);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::front::Panel_GetAdvisorTypeFromButton
					(PanelType panelType,PanelButtonType buttonType,AdvisorType *out_advisorType)
{
						// max value is used as "invalid"
	*out_advisorType = ADVISOR__COUNT;
	if (true) {
		switch(panelType) {
		case PANEL_RADAR:
						// PANELBUTTON_RADAR_TOGGLE (0x0)
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARTOGGLE;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
						// PANELBUTTON_RADAR_TAGGEDOBJECTVIEW (0x1)
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARTOGGLEOBJECTVIEW;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
						// PANELBUTTON_RADAR_ZOOMIN (0x2)
			if (buttonType == 2) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARZOOMIN;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
						// PANELBUTTON_RADAR_ZOOMOUT (0x3)
			if (buttonType == 3) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARZOOMOUT;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
						// PANELBUTTON_RADAR_MAPVIEW (0x4)
			if (buttonType == 4) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARMAPVIEW;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			break;
		case PANEL_TOPPANEL:
						// PANELBUTTON_TOPPANEL_OPTIONS (0x0)
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_TOPPANELOPTIONS;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
						// PANELBUTTON_TOPPANEL_PRIORITIES (0x1)
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_TOPPANELPRIORITIES;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
						// PANELBUTTON_TOPPANEL_CALLTOARMS (0x2)
			if (buttonType == 2) {
				*out_advisorType = ADVISOR_PANELPOINT_TOPPANELCALLTOARMS;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			break;
		case PANEL_CAMERACONTROL:
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_CONTROLZOOMIN;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_CONTROLZOOMOUT;
			}
			break;
		case PANEL_INFODOCK:
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_INFODOCKGOTO;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_INFODOCKCLOSE;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
		}
	}
	return (uint)(*out_advisorType != ADVISOR__COUNT);
}



void __cdecl lego::front::Pointer_Initialise(void)
{
	globs::pointerGlobs.pointerName[0] = "Pointer_Standard";
	globs::pointerGlobs.pointerName[1] = "Pointer_Blank";
	globs::pointerGlobs.pointerName[2] = "Pointer_Selected";
	globs::pointerGlobs.pointerName[3] = "Pointer_Drill";
	globs::pointerGlobs.pointerName[4] = "Pointer_CantDrill";
	globs::pointerGlobs.pointerName[5] = "Pointer_Clear";
	globs::pointerGlobs.pointerName[6] = "Pointer_Go";
	globs::pointerGlobs.pointerName[7] = "Pointer_CantGo";
	globs::pointerGlobs.pointerName[8] = "Pointer_Teleport";
	globs::pointerGlobs.pointerName[9] = "Pointer_CantTeleport";
	globs::pointerGlobs.pointerName[10] = "Pointer_Reinforce";
	globs::pointerGlobs.pointerName[11] = "Pointer_CantReinforce";
	globs::pointerGlobs.pointerName[12] = "Pointer_RadarPan";
	globs::pointerGlobs.pointerName[13] = "Pointer_TrackObject";
	globs::pointerGlobs.pointerName[14] = "Pointer_Help";
	globs::pointerGlobs.pointerName[15] = "Pointer_CantHelp";
	globs::pointerGlobs.pointerName[16] = "Pointer_PutDown";
	globs::pointerGlobs.pointerName[17] = "Pointer_GetIn";
	globs::pointerGlobs.pointerName[18] = "Pointer_GetOut";
	globs::pointerGlobs.pointerName[19] = "Pointer_TutorialBlockInfo";
	globs::pointerGlobs.pointerName[20] = "Pointer_Okay";
	globs::pointerGlobs.pointerName[21] = "Pointer_NotOkay";
	globs::pointerGlobs.pointerName[22] = "Pointer_CanBuild";
	globs::pointerGlobs.pointerName[23] = "Pointer_CannotBuild";
	globs::pointerGlobs.pointerName[24] = "Pointer_Dynamite";
	globs::pointerGlobs.pointerName[25] = "Pointer_CantDynamite";
	globs::pointerGlobs.pointerName[26] = "Pointer_PickUp";
	globs::pointerGlobs.pointerName[27] = "Pointer_CantPickUp";
	globs::pointerGlobs.pointerName[28] = "Pointer_PickUpOre";
	globs::pointerGlobs.pointerName[29] = "Pointer_LegoManCantDig";
	globs::pointerGlobs.pointerName[30] = "Pointer_VehicleCantDig";
	globs::pointerGlobs.pointerName[31] = "Pointer_LegoManDig";
	globs::pointerGlobs.pointerName[32] = "Pointer_VehicleDig";
	globs::pointerGlobs.pointerName[33] = "Pointer_LegoManCantPickUp";
	globs::pointerGlobs.pointerName[34] = "Pointer_VehicleCantPickUp";
	globs::pointerGlobs.pointerName[35] = "Pointer_LegoManPickUp";
	globs::pointerGlobs.pointerName[36] = "Pointer_VehiclePickUp";
	globs::pointerGlobs.pointerName[37] = "Pointer_LegoManCantGo";
	globs::pointerGlobs.pointerName[38] = "Pointer_VehicleCantGo";
	globs::pointerGlobs.pointerName[39] = "Pointer_LegoManGo";
	globs::pointerGlobs.pointerName[40] = "Pointer_VehicleGo";
	globs::pointerGlobs.pointerName[41] = "Pointer_LegoManClear";
	globs::pointerGlobs.pointerName[42] = "Pointer_VehicleClear";
	globs::pointerGlobs.pointerName[43] = "Pointer_SurfaceType_Immovable";
	globs::pointerGlobs.pointerName[44] = "Pointer_SurfaceType_Hard";
	globs::pointerGlobs.pointerName[45] = "Pointer_SurfaceType_Medium";
	globs::pointerGlobs.pointerName[46] = "Pointer_SurfaceType_Loose";
	globs::pointerGlobs.pointerName[47] = "Pointer_SurfaceType_Soil";
	globs::pointerGlobs.pointerName[48] = "Pointer_SurfaceType_Lava";
	globs::pointerGlobs.pointerName[49] = "Pointer_SurfaceType_Water";
	globs::pointerGlobs.pointerName[50] = "Pointer_SurfaceType_OreSeam";
	globs::pointerGlobs.pointerName[51] = "Pointer_SurfaceType_Lake";
	globs::pointerGlobs.pointerName[52] = "Pointer_SurfaceType_CrystalSeam";
	globs::pointerGlobs.pointerName[53] = "Pointer_SurfaceType_RechargeSeam";
	globs::pointerGlobs.pointerName[54] = "Pointer_CantZoom";
	globs::pointerGlobs.pointerName[55] = "Pointer_Zoom";
	return;
}



// Load all Pointers in the CFG block (prop is the first child in the block)
// 
// USAGE: <PointerType><bmpPath>
// USAGE: <PointerType><flicPath>,<num1>,<num2>

void __cdecl lego::front::Pointer_LoadPointers(CFGProperty *root)
{
	char cVar1;
	bool bVar2;
	PointerType PVar3;
	BOOL BVar4;
	int iVar;
	Image *pIVar5;
	char *name;
	char *pcVar6;
	PointerType pointerType;
	char *stringParts [10];
	char local_400 [1024];
	
	if (root != NULL) {
		do {
			name = root->key;
			bVar2 = true;
			if (name != NULL) {
				iVar = -1;
				pcVar6 = name;
				do {
					if (iVar == 0) break;
					iVar += -1;
					cVar1 = *pcVar6;
					pcVar6 = pcVar6 + 1;
				} while (cVar1 != '\0');
				if ((iVar != -2) && (*name == '!')) {
					if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
						name = name + 1;
					}
					else {
						bVar2 = false;
					}
				}
			}
			if ((bVar2) && (BVar4 = Pointer_GetType(name,&pointerType), BVar4 != 0)) {
				std::sprintf(local_400,"%s",root->value);
				iVar = util::Util_Tokenise(local_400,stringParts,",");
				PVar3 = pointerType;
				if (iVar == 1) {
					pIVar5 = lego::image::Image_LoadBMPScaled(stringParts[0],0,0);
					globs::pointerGlobs.pointerImages[PVar3] = pIVar5;
					globs::pointerGlobs.pointerIsFlic[PVar3] = 0;
				}
				else {
					lego::image::Flic_Setup
										(stringParts[0],(Flic **)(globs::pointerGlobs.pointerImages + pointerType),
										 FLICMEMORY|FLICLOOPINGON);
					globs::pointerGlobs.pointerIsFlic[pointerType] = 1;
					iVar = std::atoi(stringParts[1]);
					globs::pointerGlobs.pointerFlicPositions[pointerType].x = iVar;
					iVar = std::atoi(stringParts[2]);
					globs::pointerGlobs.pointerFlicPositions[pointerType].y = iVar;
				}
				if (globs::pointerGlobs.pointerIsFlic[pointerType] == 0) {
					lego::image::Image_SetupTrans
										(globs::pointerGlobs.pointerImages[pointerType],0.0,0.0,0.0,0.0,0.0,0.0);
				}
			}
			root = cfg::CFG_NextFlat(root);
		} while (root != NULL);
	}
	return;
}



BOOL __cdecl lego::front::Pointer_GetType(char *name,PointerType *out_pointerType)
{
	int cmp;
	char **pName;
	int i;
	
	i = 0;
	pName = globs::pointerGlobs.pointerName;
	do {
		cmp = std::_stricmp(*pName,name);
		if (cmp == 0) {
			*out_pointerType = i;
			return TRUE;
		}
		pName = pName + 1;
		i += POINTER_BLANK;
	} while (pName < &globs::pointerGlobs.timer);
	return 0;
}



Image * __cdecl lego::front::Pointers_GetImage(PointerType pointerType)
{
	return globs::pointerGlobs.pointerImages[pointerType];
}



void __cdecl lego::front::Pointer_SetCurrent_IfTimerFinished(PointerType pointerType)
{
	if ((ushort)((ushort)(globs::pointerGlobs.timer < 0.0) << 8 |
							(ushort)(globs::pointerGlobs.timer == 0.0) << 0xe) != 0) {
		globs::pointerGlobs.currentType = pointerType;
	}
	return;
}



void __cdecl lego::front::Pointer_SetCurrent(PointerType pointerType,float timer)
{
	globs::pointerGlobs.currentType = pointerType;
	globs::pointerGlobs.timer = timer;
	return;
}



PointerType __cdecl lego::front::Pointer_GetCurrentType(void)
{
	return globs::pointerGlobs.currentType;
}



void __cdecl lego::front::Pointer_DrawPointer(uint mouseX,uint mouseY)
{
	Image *image;
	uint uVar1;
	Point2F destPos;
	Area2F destArea;
	
	destPos.x = (float)(ulonglong)mouseX;
	destPos.y = (float)(ulonglong)mouseY;
	if (globs::pointerGlobs.pointerIsFlic[globs::pointerGlobs.currentType] != TRUE) {
						// Draw a BMP image pointer
		image = globs::pointerGlobs.pointerImages[globs::pointerGlobs.currentType];
		if (globs::pointerGlobs.pointerImages[globs::pointerGlobs.currentType] == NULL) {
			image = globs::pointerGlobs.pointerImages[0];
		}
		lego::image::Image_DisplayScaled(image,NULL,&destPos,NULL);
		return;
	}
						// Draw a FLIC image pointer
	destArea.x = (float)globs::pointerGlobs.pointerFlicPositions[globs::pointerGlobs.currentType].x +
							 destPos.x;
	destArea.y = (float)globs::pointerGlobs.pointerFlicPositions[globs::pointerGlobs.currentType].y +
							 destPos.y;
	uVar1 = res::AnimClone_IsLws__Flic_GetWidth
										((AnimClone *)globs::pointerGlobs.pointerImages[globs::pointerGlobs.currentType]
										);
	destArea.width = (float)(ulonglong)uVar1;
	uVar1 = lego::image::Flic_GetHeight
										((Flic *)globs::pointerGlobs.pointerImages[globs::pointerGlobs.currentType]);
	destArea.height = (float)(ulonglong)uVar1;
	lego::image::Image_DisplayScaled(globs::pointerGlobs.pointerImages[1],NULL,&destPos,NULL);
						// GAME1_CAMERADISABLED (0x100000)
	lego::image::Flic_Animate
						((Flic *)globs::pointerGlobs.pointerImages[globs::pointerGlobs.currentType],&destArea,
						 ~globs::legoGlobs.flags1 >> 0x14 & 1,TRUE);
	return;
}



void __cdecl lego::front::Pointer_Update(float elapsedAbs)
{
	if ((ushort)((ushort)(globs::pointerGlobs.timer < 0.0) << 8 |
							(ushort)(globs::pointerGlobs.timer == 0.0) << 0xe) == 0) {
		globs::pointerGlobs.timer = globs::pointerGlobs.timer - elapsedAbs;
	}
	return;
}



void __cdecl lego::ai::Priorities_InitialiseImages(CFGProperty *root,char *keyBasePath)
{
	AIPriorityType AVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	Image *pIVar5;
	AIPriorityType local_254;
	char *stringParts [10];
	char *stringPartsSub [10];
	char buff [512];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"PriorityImages",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar2); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		BVar3 = AIPriority_GetType(prop->key,&local_254);
		if (BVar3 != 0) {
			std::sprintf(buff,"%s",prop->value);
			util::Util_Tokenise(buff,stringParts,":");
			iVar4 = util::Util_Tokenise(stringParts[0],stringPartsSub,"|");
			AVar1 = local_254;
			pcVar2 = util::_strdup(stringPartsSub[0]);
			globs::prioritiesGlobs.priorityText[AVar1] = pcVar2;
			if (iVar4 == 2) {
				snd::SFX_GetType(stringPartsSub[1],globs::prioritiesGlobs.prioritySFX + AVar1);
			}
			pIVar5 = lego::image::Image_LoadBMPScaled(stringParts[1],0,0);
			globs::prioritiesGlobs.priorityImage[local_254] = pIVar5;
			pIVar5 = lego::image::Image_LoadBMPScaled(stringParts[2],0,0);
			globs::prioritiesGlobs.priorityPressImage[local_254] = pIVar5;
			pIVar5 = lego::image::Image_LoadBMPScaled(stringParts[3],0,0);
			globs::prioritiesGlobs.priorityOffImage[local_254] = pIVar5;
		}
	}
	return;
}



void __cdecl lego::ai::Priorities_Reset(void)
{
	undefined4 *puVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::prioritiesGlobs.count != 0) {
		puVar1 = globs::prioritiesGlobs.priorityUnk;
		do {
			puVar1[-0x6c] = puVar1[-0x1b];
			AITask_Game_SetAITaskValue2(puVar1[-0x1b],*puVar1);
			AITask_Game_SetIsPriorityDisabled(puVar1[-0x6c],puVar1[0x1b]);
			uVar2 += 1;
			puVar1 = puVar1 + 1;
		} while (uVar2 < globs::prioritiesGlobs.count);
	}
	return;
}



BOOL __cdecl lego::ai::Priorities_LoadLevel(CFGProperty *root,char *rootPath,char *levelName)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	BoolTri BVar2;
	
	globs::prioritiesGlobs.count = 0;
	keyPath = cfg::CFG_JoinPath(rootPath,levelName,"Priorities",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		BVar1 = AIPriority_GetType(prop->key,(AIPriorityType *)&levelName);
		if (BVar1 != 0) {
			globs::prioritiesGlobs.priorityTypeTable_1[globs::prioritiesGlobs.count] =
					 (AIPriorityType)levelName;
			globs::prioritiesGlobs.priorityTypeTable_2[globs::prioritiesGlobs.count] =
					 (AIPriorityType)levelName;
			globs::prioritiesGlobs.priorityUnk[globs::prioritiesGlobs.count] =
					 globs::prioritiesGlobs.count * -5 + 0x50;
			AITask_Game_SetAITaskValue2
								((int)levelName,globs::prioritiesGlobs.priorityUnk[globs::prioritiesGlobs.count]);
			BVar2 = util::Util_GetBoolFromString(prop->value);
			if (BVar2 == BOOL3_TRUE) {
				AITask_Game_SetIsPriorityDisabled((int)levelName,0);
				globs::prioritiesGlobs.priorityActive[globs::prioritiesGlobs.count] = 0;
			}
			else {
				AITask_Game_SetIsPriorityDisabled((int)levelName,1);
				globs::prioritiesGlobs.priorityActive[globs::prioritiesGlobs.count] = 1;
			}
			globs::prioritiesGlobs.count += 1;
		}
	}
	return 1;
}



void __cdecl lego::ai::Priorities_InitialisePositions(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	int number;
	float *pPointY;
	char *stringParts [16];
	char *rootPath_00;
	
	rootPath_00 = rootPath;
	number = 0;
	pPointY = &globs::prioritiesGlobs.priorityPoints[0].y;
	do {
		number += 1;
		std::itoa(number,(char *)&rootPath,10);
		pcVar1 = cfg::CFG_JoinPath(rootPath_00,"PrioritiesImagePositions",&rootPath,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 != NULL) {
			util::Util_Tokenise(pcVar1,stringParts,",");
			iVar2 = std::atoi(stringParts[0]);
			pPointY[-1] = (float)iVar2;
			iVar2 = std::atoi(stringParts[1]);
			*pPointY = (float)iVar2;
		}
		pPointY = pPointY + 2;
	} while (pPointY < globs::prioritiesGlobs.priorityTypeTable_2 + 1);
	return;
}



BOOL __cdecl
lego::ai::Priorities_UnkUpdate_FUN_0045d3d0
					(uint mouseX,uint mouseY,BOOL leftButton,BOOL param_4,BOOL param_5)
{
	char *pcVar1;
	Image *pIVar2;
	uint uVar3;
	uint uVar4;
	float fVar5;
	BOOL BVar6;
	float *pfVar7;
	char **ppcVar8;
	AIPriorityType AVar9;
	Point2F local_30;
	float local_28;
	float local_24;
	uint local_20;
	undefined4 uStack28;
	uint local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	BVar6 = front::Panel_IsFlags_4_Not8(PANEL_PRIORITYLIST);
	if ((BVar6 == 0) && (BVar6 = front::Panel_IsFlags_8(PANEL_PRIORITYLIST), BVar6 == 0)) {
		front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_28,&local_24);
		AVar9 = AI_PRIORITY_CRYSTAL;
		if (globs::prioritiesGlobs.count != 0) {
			pfVar7 = &globs::prioritiesGlobs.priorityPoints[0].y;
			ppcVar8 = (char **)globs::prioritiesGlobs.priorityTypeTable_1;
			do {
				pcVar1 = *ppcVar8;
				pIVar2 = globs::prioritiesGlobs.priorityImage[(int)pcVar1];
				if (pIVar2 != NULL) {
					uStack28 = 0;
					local_30.x = pfVar7[-1] + local_28;
					local_20 = mouseX;
					uVar3 = pIVar2->height;
					fVar5 = (float)(ulonglong)mouseX;
					uVar4 = pIVar2->width;
					local_30.y = local_24 + *pfVar7;
					if ((local_30.x <= fVar5) &&
						 (uStack20 = 0, local_18 = uVar4,
						 (ushort)((ushort)(fVar5 < (float)(ulonglong)uVar4 + local_30.x) << 8 |
										 (ushort)(fVar5 == (float)(ulonglong)uVar4 + local_30.x) << 0xe) != 0)) {
						uStack12 = 0;
						local_10 = mouseY;
						fVar5 = (float)(ulonglong)mouseY;
						if ((local_30.y <= fVar5) &&
							 (uStack4 = 0, local_8 = uVar3,
							 (ushort)((ushort)(fVar5 < (float)(ulonglong)uVar3 + local_30.y) << 8 |
											 (ushort)(fVar5 == (float)(ulonglong)uVar3 + local_30.y) << 0xe) != 0)) {
							globs::prioritiesGlobs.flags |= 1;
							Priorities_FUN_0045d630(&local_30,uVar4 - 1,uVar3 - 1);
							if (leftButton == 0) {
								if ((globs::s_PriorityList_Type == AVar9) && (globs::s_PriorityList_Name == pcVar1))
								{
									front::ToolTip_SetText
														(TOOLTIP_PRIORITY,globs::prioritiesGlobs.priorityText[(int)pcVar1]);
									front::ToolTip_AddFlag4(TOOLTIP_PRIORITY);
									front::Interface_SetDat_004df1f4(globs::prioritiesGlobs.prioritySFX[(int)pcVar1]);
								}
								else {
									front::ToolTip_AddFlag4(TOOLTIP_NULL);
									globs::s_PriorityList_Type = AVar9;
									globs::s_PriorityList_Name = pcVar1;
								}
							}
							BVar6 = Priorities_FUN_0045d5c0(AVar9,leftButton,param_4);
							if ((BVar6 != 0) && (param_5 != 0)) {
								Priorities_FUN_0045d680(AVar9);
							}
							return TRUE;
						}
					}
				}
				AVar9 += AI_PRIORITY_ORE;
				ppcVar8 = ppcVar8 + 1;
				pfVar7 = pfVar7 + 2;
			} while (AVar9 < globs::prioritiesGlobs.count);
		}
		Priorities_FUN_0045d5c0(0x1b,leftButton,param_4);
	}
	return 0;
}



BOOL __cdecl lego::ai::Priorities_FUN_0045d5c0(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = globs::prioritiesGlobs.field_4b8;
	if (param_2 == 0) {
		globs::prioritiesGlobs.field_4b8 = 0x1b;
	}
	else {
		if (globs::prioritiesGlobs.field_4b8 == 0x1b) {
			if (param_3 == 0) {
				globs::prioritiesGlobs.field_4b8 = param_1;
				globs::prioritiesGlobs.flags = globs::prioritiesGlobs.flags | 2;
				return (uint)(param_1 == 0x1b);
			}
		}
		else {
			if (globs::prioritiesGlobs.field_4b8 == param_1) {
				globs::prioritiesGlobs.flags = globs::prioritiesGlobs.flags | 2;
				return (uint)(globs::prioritiesGlobs.field_4b8 == param_1);
			}
		}
	}
	return (uint)(iVar1 == param_1);
}



void __cdecl lego::ai::Priorities_FUN_0045d630(Point2F *param_1,uint param_2,uint param_3)
{
	globs::prioritiesGlobs.float_4a8 = param_1->x;
	globs::prioritiesGlobs.float_4ac = param_1->y;
	globs::prioritiesGlobs.float_4b0 = (float)(ulonglong)param_2;
	globs::prioritiesGlobs.float_4b4 = (float)(ulonglong)param_3;
	return;
}



void __cdecl lego::ai::Priorities_FUN_0045d680(uint param_1)
{
	if (((byte)globs::panelGlobs.flags & 2) != 0) {
		Priorities_FUN_0045d6b0(param_1);
		return;
	}
	if (((byte)globs::panelGlobs.flags & 4) != 0) {
		Priorities_MovePriorityUp(param_1);
	}
	return;
}



void __cdecl lego::ai::Priorities_FUN_0045d6b0(uint param_1)
{
	AIPriorityType index;
	AIPriorityType index_00;
	uint uVar1;
	int iVar2;
	int iVar3;
	
	if ((param_1 != 0) && (param_1 < globs::prioritiesGlobs.count)) {
		index = globs::prioritiesGlobs.priorityTypeTable_1[param_1];
		iVar3 = 0;
		if (param_1 != 0) {
			iVar2 = 0x50;
			uVar1 = param_1;
			do {
				index_00 = globs::prioritiesGlobs.prioritySFX[uVar1 + 0x1a];
				globs::prioritiesGlobs.priorityTypeTable_1[uVar1] = index_00;
				AITask_Game_SetAITaskValue2(index_00,iVar2 + param_1 * -5);
				iVar3 += 1;
				iVar2 += 5;
				uVar1 = param_1 - iVar3;
			} while (uVar1 != 0);
		}
		globs::prioritiesGlobs.priorityTypeTable_1[0] = index;
		AITask_Game_SetAITaskValue2(index,0x50);
	}
	game::Game_SetPointer_AndPlayEnumSFX(3);
	return;
}



void __cdecl lego::ai::Priorities_MovePriorityUp(uint index)
{
	AIPriorityType AVar1;
	
	if ((index != 0) && (index < globs::prioritiesGlobs.count)) {
		AVar1 = globs::prioritiesGlobs.priorityTypeTable_1[index];
		globs::prioritiesGlobs.priorityTypeTable_1[index] =
				 globs::prioritiesGlobs.prioritySFX[index + 0x1a];
		globs::prioritiesGlobs.prioritySFX[index + 0x1a] = AVar1;
		AITask_Game_SetAITaskValue2(globs::prioritiesGlobs.priorityTypeTable_1[index],index * -5 + 0x50)
		;
		AITask_Game_SetAITaskValue2(globs::prioritiesGlobs.prioritySFX[index + 0x1a],index * -5 + 0x55);
		Priorities_FUN_0045d810(index - 1);
	}
	game::Game_SetPointer_AndPlayEnumSFX(0);
	return;
}



void __cdecl lego::ai::Priorities_DisablePriority(uint index)
{
	BOOL BVar1;
	
	if (index < globs::prioritiesGlobs.count) {
		BVar1 = AITask_Game_IsPriorityDisabled(globs::prioritiesGlobs.priorityTypeTable_1[index]);
		AITask_Game_SetIsPriorityDisabled
							(globs::prioritiesGlobs.priorityTypeTable_1[index],(uint)(BVar1 == 0));
		if (((BVar1 == 0) != 0) &&
			 ((globs::prioritiesGlobs.priorityTypeTable_1[index] == AI_PRIORITY_CRYSTAL ||
				(globs::prioritiesGlobs.priorityTypeTable_1[index] == AI_PRIORITY_ORE)))) {
			front::Text_DisplayMessage(TEXT_CRYSTALOREDISABLED,TRUE,FALSE);
		}
	}
	return;
}



void __cdecl lego::ai::Priorities_FUN_0045d810(undefined4 param_1)
{
	int y;
	PanelButtonType buttonType;
	longlong lVar1;
	float local_18;
	float local_14;
	Area2F local_10;
	
	switch(param_1) {
	case 0:
		Priorities_FUN_0045d900(0);
		return;
	case 1:
		buttonType = 9;
		break;
	case 2:
		buttonType = 10;
		break;
	case 3:
		buttonType = 0xb;
		break;
	case 4:
		buttonType = 0xc;
		break;
	case 5:
		buttonType = 0xd;
		break;
	case 6:
		buttonType = 0xe;
		break;
	case 7:
		buttonType = 0xf;
		break;
	case 8:
		buttonType = 0x10;
		break;
	default:
		goto switchD_0045d821_caseD_9;
	}
	front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_18,&local_14);
	front::Panel_GetButtonRect(PANEL_PRIORITYLIST,buttonType,&local_10);
	lVar1 = __ftol((float10)local_10.height * (float10)0.5 + (float10)local_10.y + (float10)local_14);
	y = (int)lVar1;
	lVar1 = __ftol((float10)local_10.width * (float10)0.5 + (float10)local_10.x + (float10)local_18);
	input::Input_SetCursorPos((int)lVar1,y);
switchD_0045d821_caseD_9:
	return;
}



void __cdecl lego::ai::Priorities_FUN_0045d900(int priorityIndex)
{
	AIPriorityType AVar1;
	Image *pIVar2;
	int y;
	longlong lVar3;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 local_4;
	
	AVar1 = globs::prioritiesGlobs.priorityTypeTable_1[priorityIndex];
	if (globs::prioritiesGlobs.priorityImage[AVar1] != NULL) {
		front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_10,&local_c);
		pIVar2 = globs::prioritiesGlobs.priorityImage[AVar1];
		local_4 = 0;
		local_8 = pIVar2->height >> 1;
		lVar3 = __ftol((float10)globs::prioritiesGlobs.priorityPoints[priorityIndex].y +
									 (float10)local_c + (float10)local_8);
		y = (int)lVar3;
		local_8 = pIVar2->width >> 1;
		local_4 = 0;
		lVar3 = __ftol((float10)globs::prioritiesGlobs.priorityPoints[priorityIndex].x +
									 (float10)local_10 + (float10)local_8);
		input::Input_SetCursorPos((int)lVar3,y);
	}
	return;
}



void __cdecl lego::ai::Priorities_Update(void)
{
	AIPriorityType priorityIndex;
	Image *image;
	BOOL BVar1;
	uint uVar2;
	AIPriorityType *pAVar3;
	float *pfVar4;
	Point2F local_10;
	float local_8;
	float local_4;
	
	BVar1 = front::Panel_IsFlags_4_Not8(PANEL_PRIORITYLIST);
	if (BVar1 == 0) {
		front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_8,&local_4);
		uVar2 = 0;
		if (globs::prioritiesGlobs.count != 0) {
			pfVar4 = &globs::prioritiesGlobs.priorityPoints[0].y;
			pAVar3 = globs::prioritiesGlobs.priorityTypeTable_1;
			do {
				local_10.x = pfVar4[-1] + local_8;
				local_10.y = local_4 + *pfVar4;
				priorityIndex = *pAVar3;
				BVar1 = AITask_Game_IsPriorityDisabled(priorityIndex);
				if (BVar1 == 0) {
					if (((globs::prioritiesGlobs.flags & 2) == 0) ||
						 (globs::prioritiesGlobs.field_4b8 != uVar2)) {
						image = globs::prioritiesGlobs.priorityImage[priorityIndex];
					}
					else {
						image = globs::prioritiesGlobs.priorityPressImage[priorityIndex];
					}
				}
				else {
					image = globs::prioritiesGlobs.priorityOffImage[priorityIndex];
				}
				if (image != NULL) {
					lego::image::Image_DisplayScaled(image,NULL,&local_10,NULL);
				}
				uVar2 += 1;
				pAVar3 = pAVar3 + 1;
				pfVar4 = pfVar4 + 2;
			} while (uVar2 < globs::prioritiesGlobs.count);
		}
		if ((globs::prioritiesGlobs.flags & 1) != 0) {
			front::Interface_Front_DrawLineListUnk_FUN_0041cc60
								((Area2F *)&globs::prioritiesGlobs.float_4a8);
			globs::prioritiesGlobs.flags &= 0xfffffffe;
		}
		globs::prioritiesGlobs.flags &= 0xfffffffd;
	}
	return;
}



BOOL __cdecl lego::game::PTL_Initialise(char *filename,char *rootPath)
{
	uint uVar1;
	CFGProperty *prop;
	CFGProperty *prop_00;
	MessageType MVar2;
	
	globs::ptlGlobs.count = 0;
	prop = cfg::CFG_Open(filename);
	if (prop != NULL) {
		prop_00 = cfg::CFG_GetChildren(prop,rootPath);
		uVar1 = globs::ptlGlobs.count;
		while (prop_00 != NULL) {
			globs::ptlGlobs.count = uVar1 + 1;
			MVar2 = Message_LookupPTLEventIndex(prop_00->key);
			globs::ptlGlobs.table[uVar1].eventIndex = MVar2;
			MVar2 = Message_LookupPTLEventIndex(prop_00->value);
			globs::ptlGlobs.table[uVar1].actionIndex = MVar2;
			prop_00 = cfg::CFG_NextFlat(prop_00);
			uVar1 = globs::ptlGlobs.count;
		}
		globs::ptlGlobs.count = uVar1;
		cfg::CFG_Close(prop);
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::PTL_EventToAction(MessageAction *ref_message)
{
	uint i;
	PTL_Globs *pPTLProp;
	
	i = 0;
	if (globs::ptlGlobs.count != 0) {
		pPTLProp = &globs::ptlGlobs;
		while (ref_message->event != pPTLProp->table[0].eventIndex) {
			i += 1;
			pPTLProp = (PTL_Globs *)(pPTLProp->table + 1);
			if (globs::ptlGlobs.count <= i) {
				return;
			}
		}
		ref_message->event = pPTLProp->table[0].actionIndex;
	}
	return;
}



void __cdecl lego::game::RadarMap_SetTVTiltOrZoom(RadarMap *radarMap,float tvTiltOrZoom)
{
	radarMap->arrowTiltOrZoom = tvTiltOrZoom;
	return;
}



void __cdecl lego::game::RadarMap_Initialise(void)
{
	RadarMap_Globs *pRVar1;
	RadarMap_Globs *pRVar2;
	float *pfVar3;
	int iVar4;
	int iVar5;
	uint i;
	float *pfVar6;
	
	pRVar1 = &globs::radarmapGlobs;
	do {
		iVar5 = 3;
		pRVar2 = pRVar1;
		do {
			pRVar1 = (RadarMap_Globs *)&pRVar2->colourTable[0].green;
			iVar5 += -1;
			pRVar2->colourTable[0].red = pRVar2->colourTable[0].red * 0.003921569;
			pRVar2 = pRVar1;
		} while (iVar5 != 0);
	} while (pRVar1 < (RadarMap_Globs *)&globs::radarmapGlobs.strucfUnkInt_1);
						// Set all float_c fields to 1.0f (for table_1 and table_2)
	pfVar3 = &globs::radarmapGlobs.structfTable_1[0].float_c;
	do {
		pfVar3[0x50] = 1.0;
		*pfVar3 = 1.0;
		pfVar3 = pfVar3 + 4;
	} while (pfVar3 < &globs::radarmapGlobs.structfTable_2[0].float_c);
	globs::radarmapGlobs.structfTable_1[0].width = 320.0;
	globs::radarmapGlobs.structfTable_1[0].height = 40.0;
	globs::radarmapGlobs.structfTable_2[0].width = 420.0;
	globs::radarmapGlobs.structfTable_2[0].height = 180.0;
	globs::radarmapGlobs.structfTable_1[1].width = 420.0;
	globs::radarmapGlobs.structfTable_1[1].height = 180.0;
	globs::radarmapGlobs.structfTable_2[1].width = 360.0;
	globs::radarmapGlobs.structfTable_2[1].height = 180.0;
	globs::radarmapGlobs.structfTable_1[2].width = 360.0;
	globs::radarmapGlobs.structfTable_1[2].height = 180.0;
	globs::radarmapGlobs.structfTable_2[2].width = 360.0;
	globs::radarmapGlobs.structfTable_2[2].height = 400.0;
	globs::radarmapGlobs.structfTable_1[3].width = 360.0;
	globs::radarmapGlobs.structfTable_1[3].height = 400.0;
	globs::radarmapGlobs.structfTable_2[3].width = 280.0;
	globs::radarmapGlobs.structfTable_2[3].height = 400.0;
	globs::radarmapGlobs.structfTable_1[4].width = 280.0;
	globs::radarmapGlobs.structfTable_1[4].height = 400.0;
	globs::radarmapGlobs.structfTable_2[4].width = 280.0;
	globs::radarmapGlobs.structfTable_2[4].height = 180.0;
	globs::radarmapGlobs.structfTable_1[5].width = 280.0;
	globs::radarmapGlobs.structfTable_1[5].height = 180.0;
	globs::radarmapGlobs.structfTable_2[5].width = 220.0;
	globs::radarmapGlobs.structfTable_2[5].height = 180.0;
	globs::radarmapGlobs.structfTable_1[6].width = 220.0;
	globs::radarmapGlobs.structfTable_1[6].height = 180.0;
	globs::radarmapGlobs.structfTable_2[6].width = 320.0;
	globs::radarmapGlobs.structfTable_2[6].height = 40.0;
	globs::radarmapGlobs.structfCount = 7;
	i = 0;
	pfVar3 = &globs::radarmapGlobs.structfTable_1[0].height;
	do {
		iVar5 = 2;
		pfVar6 = pfVar3;
		do {
						// More hardcoded resolution behaviors. This divides as:
						//  appWidth()  / 640.0
						//  appHeight() / 480.0
			iVar4 = main::appWidth();
			pfVar6[-1] = (float)iVar4 * 0.0015625 * pfVar6[-1];
			iVar4 = main::appHeight();
			iVar5 += -1;
			*pfVar6 = (float)iVar4 * 0.002083333 * *pfVar6;
			pfVar6 = pfVar6 + 0x50;
		} while (iVar5 != 0);
		i += 1;
		pfVar3 = pfVar3 + 4;
	} while (i < globs::radarmapGlobs.structfCount);
	globs::radarmapGlobs.strucfUnkInt_1 = -1;
	globs::radarmapGlobs.strucfUnkInt_2 = -1;
	return;
}



RadarMap * __cdecl
lego::game::RadarMap_Create(SurfaceMap *surfMap,Area2F *radarViewRect,float tvTiltOrZoom)
{
	float fVar1;
	RadarMap *radarMap;
	float10 fVar2;
	
	radarMap = (RadarMap *)std::malloc(0x3c);
	if (radarMap != NULL) {
		(radarMap->screenRect).x = radarViewRect->x;
		(radarMap->screenRect).y = radarViewRect->y;
		(radarMap->screenRect).width = radarViewRect->width;
		fVar1 = radarViewRect->height;
		radarMap->arrowTiltOrZoom = tvTiltOrZoom;
		(radarMap->screenRect).height = fVar1;
		fVar2 = Map3D_GetBlockSize(surfMap);
		radarMap->BlockSize = (float)fVar2;
		radarMap->surfMap = surfMap;
		return radarMap;
	}
	return NULL;
}



// Multiple-use function to free data

void __cdecl lego::game::RadarMap_Free_UnwindMultiUse(RadarMap *radarMap)
{
	std::free(radarMap);
	return;
}



void __cdecl
lego::game::RadarMap_DrawDotCircle_FUN_0045ddc0
					(RadarMap *radarMap,Point2F *param_2,float param_3,float param_4)
{
	float b;
	longlong lVar1;
	Area2F local_20;
	Area2F local_10;
	
	local_20.height = 0.0;
	local_20.x = param_2->x;
	local_20.y = param_2->y;
	local_20.width = param_3;
	draw::Draw_GetClipWindow(&local_10);
	draw::Draw_SetClipWindow(&radarMap->screenRect);
	RadarMap_FUN_0045ec00(radarMap,&local_20);
	b = param_4 * 0.7 - -0.3;
	lVar1 = __ftol((float10)local_20.width);
	draw::Draw_DotCircle
						((Point2F *)&local_20,(uint)lVar1,(uint)lVar1 * 2,b * 0.7,b * 0.9,b,DRAWEFFECT_NONE);
	draw::Draw_SetClipWindow(&local_10);
	return;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl lego::game::RadarMap_Draw_FUN_0045de80(RadarMap *radarMap,Point2F *position)
{
	float fVar1;
	float fVar2;
	BOOL BVar3;
	uint uVar4;
	int iVar5;
	SurfaceMap *pSVar6;
	uint uVar7;
	float *pfVar8;
	Point2F *pPVar9;
	uint uVar10;
	Vector4F *transform4d;
	undefined4 *puVar11;
	float *pfVar12;
	float *pfVar13;
	Point2F *pPVar14;
	Vector3F *pVVar15;
	float *pfVar16;
	uint uStack46860;
	uint uStack46856;
	uint uStack46852;
	uint uStack46848;
	float *pfStack46844;
	Vector3F VStack46840;
	uint uStack46828;
	uint uStack46824;
	int iStack46820;
	int iStack46816;
	Area2F AStack46812;
	Vector3F VStack46796;
	Vector3F VStack46784;
	Vector3F VStack46772;
	Vector4F VStack46760;
	float fStack46744;
	undefined4 uStack46740;
	undefined4 uStack46736;
	undefined4 uStack46732;
	float fStack46728;
	float fStack46724;
	undefined4 uStack46720;
	undefined4 uStack46716;
	undefined4 uStack46712;
	float fStack46708;
	undefined4 uStack46704;
	undefined4 uStack46700;
	undefined4 uStack46696;
	undefined4 uStack46692;
	undefined4 uStack46688;
	undefined4 uStack46684;
	float fStack46680;
	undefined4 uStack46676;
	undefined4 uStack46672;
	undefined4 uStack46668;
	float fStack46664;
	float fStack46660;
	undefined4 uStack46656;
	undefined4 uStack46652;
	undefined4 uStack46648;
	float fStack46644;
	undefined4 uStack46640;
	undefined4 uStack46636;
	Point2F PStack46632;
	Point2F aPStack46624 [3];
	float fStack46600;
	float fStack46596;
	Area2F AStack46592;
	Vector3F aVStack46576 [8];
	Point2F aPStack46480 [20];
	Point2F aPStack46320 [20];
	float afStack46156 [59];
	Vector3F aVStack45920 [60];
	Point2F aPStack45200 [200];
	Point2F aPStack43600 [200];
	Draw_Rect aDStack42000 [1499];
	undefined4 uStack4;
	
	uStack4 = 0x45de8a;
	fVar1 = (radarMap->screenRect).width;
	(radarMap->arrowPos).x = position->x;
	fVar2 = radarMap->arrowTiltOrZoom;
	(radarMap->arrowPos).y = position->y;
	uVar10 = 0;
	uVar7 = 0;
	uStack46856 = 0;
	uStack46860 = 0;
	uStack46824 = 0;
	uStack46828 = 0;
	VStack46840.x = ((fVar1 * 0.5) / fVar2) * radarMap->BlockSize;
	VStack46840.y =
			 (((radarMap->screenRect).height * 0.5) / radarMap->arrowTiltOrZoom) * radarMap->BlockSize;
	Map3D_FUN_0044fad0(radarMap->surfMap,position->x - VStack46840.x,VStack46840.y + position->y,
										 (int *)&uStack46828,(int *)&uStack46824);
	Map3D_FUN_0044fad0(radarMap->surfMap,position->x + VStack46840.x,position->y - VStack46840.y,
										 &iStack46820,&iStack46816);
	draw::Draw_GetClipWindow(&AStack46592);
	draw::Draw_SetClipWindow(&radarMap->screenRect);
	uStack46852 = uStack46824;
	uStack46848 = uStack46828;
	iVar5 = iStack46820;
	if ((int)uStack46824 <= iStack46816) {
		do {
			uVar4 = uStack46848;
			if ((int)uStack46848 <= iVar5) {
				pfStack46844 = &aPStack45200[uVar7].y;
				pPVar9 = aPStack45200 + uVar7;
				pfVar8 = &aPStack43600[uVar7].y;
				pPVar14 = aPStack43600 + uVar7;
				pfVar13 = &aDStack42000[uVar10].rect.width;
				do {
					BVar3 = RadarMap_DrawBlock((Draw_Rect *)(pfVar13 + -2),uStack46848,uStack46852);
					if (BVar3 != 0) {
						BVar3 = front::Interface_GetBool_004ded1c();
						if (((BVar3 != 0) && (uStack46848 == globs::radarmapGlobs.strucfUnkInt_1)) &&
							 (uStack46852 == globs::radarmapGlobs.strucfUnkInt_2)) {
							pfVar13[2] = 1.0;
							pfVar13[3] = 0.0;
							pfVar13[4] = 0.0;
						}
						pSVar6 = radarMap->surfMap;
						fVar1 = radarMap->BlockSize;
						fVar2 = radarMap->BlockSize;
						((Area2F *)(pfVar13 + -2))->x =
								 (float)uStack46848 * radarMap->BlockSize + (pSVar6->worldDimensions_fnegx).width;
						pfVar13[-1] = -((float)uStack46852 * fVar2) + (pSVar6->worldDimensions_fnegx).height;
						pfVar13[1] = fVar1;
						*pfVar13 = fVar1;
						RadarMap_FUN_0045ec00(radarMap,(Area2F *)(pfVar13 + -2));
						*pfVar13 = *pfVar13 - 1.0;
						pfVar13[1] = pfVar13[1] - 1.0;
						BVar3 = Level_Block_IsReinforced(uStack46848,uStack46852);
						if ((BVar3 != 0) && (uStack46860 < 200)) {
							fVar1 = *pfVar13;
							fVar2 = pfVar13[-1];
							pPVar14->x = pfVar13[-2];
							*pfVar8 = fVar2;
							fVar1 = (fVar1 - 1.0) + pfVar13[-2];
							pPVar9->x = fVar1;
							pPVar14[1].x = fVar1;
							*pfStack46844 = fVar2;
							pfVar8[2] = fVar2;
							pPVar9[1].x = fVar1;
							fVar2 = (pfVar13[1] - 1.0) + pfVar13[-1];
							pfStack46844[2] = fVar2;
							pPVar14[2].x = fVar1;
							pfVar8[4] = fVar2;
							pPVar9[2].x = pfVar13[-2];
							pfStack46844[4] = fVar2;
							pPVar14[3].x = pfVar13[-2];
							pfVar8[6] = fVar2;
							pPVar9[3].x = pfVar13[-2];
							pfStack46844[6] = pfVar13[-1];
							uStack46860 += 4;
							pPVar14 = pPVar14 + 4;
							pfVar8 = pfVar8 + 8;
							pPVar9 = pPVar9 + 4;
							pfStack46844 = pfStack46844 + 8;
						}
						uStack46856 += 1;
						pfVar13 = pfVar13 + 7;
					}
					uStack46848 += 1;
					uVar4 = uStack46828;
					iVar5 = iStack46820;
					uVar7 = uStack46860;
					uVar10 = uStack46856;
				} while ((int)uStack46848 <= iStack46820);
			}
			uStack46852 += 1;
			uStack46848 = uVar4;
		} while ((int)uStack46852 <= iStack46816);
	}
	ddraw::DirectDraw_Clear(&radarMap->screenRect,0);
	draw::Draw_RectList2Ex(aDStack42000,uVar10,DRAWEFFECT_NONE);
						// Draw reinforcement yellow borders around blocks
	draw::Draw_LineListEx
						(aPStack43600,aPStack45200,uVar7,globs::radarmapGlobs.colourTable[0].red,
						 globs::radarmapGlobs.colourTable[0].green,globs::radarmapGlobs.colourTable[0].blue,
						 DRAWEFFECT_NONE);
	(radarMap->worldRect).x = position->x - VStack46840.x;
	(radarMap->worldRect).y = position->y - VStack46840.y;
	(radarMap->worldRect).width = position->x + VStack46840.x;
	fVar1 = position->y;
	radarMap->drawRectList = aDStack42000;
	radarMap->drawRectCount = 0;
	(radarMap->worldRect).height = VStack46840.y + fVar1;
	Search_LiveObjects_SkipIgnoreMes(RadarMap_LiveObject_Callback_FUN_0045e720,radarMap);
	draw::Draw_RectList2Ex(radarMap->drawRectList,radarMap->drawRectCount,DRAWEFFECT_NONE);
	if (globs::legoGlobs.viewMode == VIEW_TOPDOWN) {
		VStack46760.x = 0.0;
		VStack46760.y = 0.0;
		VStack46760.z = 0.0;
		VStack46760.w = 1.0;
		iVar5 = main::appWidth();
		uStack46740 = 0;
		fStack46744 = (float)iVar5;
		uStack46736 = 0;
		uStack46732 = 0x3f800000;
		iVar5 = main::appWidth();
		fStack46728 = (float)iVar5;
		iVar5 = main::appHeight();
		uStack46720 = 0;
		fStack46724 = (float)iVar5;
		uStack46716 = 0x3f800000;
		uStack46712 = 0;
		iVar5 = main::appHeight();
		uStack46704 = 0;
		fStack46708 = (float)iVar5;
		uStack46700 = 0x3f800000;
		uStack46696 = 0;
		uStack46692 = 0;
		uStack46688 = 0x3f800000;
		uStack46684 = 0x3f800000;
		iVar5 = main::appWidth();
		uStack46676 = 0;
		fStack46680 = (float)iVar5;
		uStack46672 = 0x3f800000;
		uStack46668 = 0x3f800000;
		iVar5 = main::appWidth();
		fStack46664 = (float)iVar5;
		iVar5 = main::appHeight();
		uStack46656 = 0x3f800000;
		fStack46660 = (float)iVar5;
		uStack46652 = 0x3f800000;
		uStack46648 = 0;
		iVar5 = main::appHeight();
		uStack46640 = 0x3f800000;
		fStack46644 = (float)iVar5;
		uStack46636 = 0x3f800000;
		VStack46784.x = 0.0;
		VStack46784.y = 0.0;
		pSVar6 = lrr::Lego_GetMap();
		VStack46772.x = 0.0;
		pVVar15 = aVStack46576;
		VStack46784.z = pSVar6->float_20 * 0.5;
		VStack46772.y = 0.0;
		VStack46772.z = -1.0;
		transform4d = &VStack46760;
		iVar5 = 8;
		do {
			lego::view::Viewport_InverseTransform(globs::legoGlobs.viewMain,pVVar15,transform4d);
			transform4d = transform4d + 1;
			pVVar15 = pVVar15 + 1;
			iVar5 += -1;
		} while (iVar5 != 0);
		uStack46856 = 0;
		uVar7 = globs::radarmapGlobs.structfCount;
		do {
			uVar10 = 0;
			if (uVar7 != 0) {
				puVar11 = &globs::radarmapGlobs.structfTable_1[0].field_8;
				pVVar15 = aVStack45920 + uStack46856 * 0x28;
				do {
					if (uStack46856 == 0) {
						puVar11[0x50] = 0;
						*puVar11 = 0;
					}
					else {
						puVar11[0x50] = 0x3f800000;
						*puVar11 = 0x3f800000;
					}
					lego::view::Viewport_InverseTransform
										(globs::legoGlobs.viewMain,pVVar15 + -0x14,(Vector4F *)(puVar11 + -2));
					lego::view::Viewport_InverseTransform
										(globs::legoGlobs.viewMain,pVVar15,(Vector4F *)(puVar11 + 0x4e));
					uVar10 += 1;
					pVVar15 = pVVar15 + 1;
					puVar11 = puVar11 + 4;
					uVar7 = globs::radarmapGlobs.structfCount;
				} while (uVar10 < globs::radarmapGlobs.structfCount);
			}
			uStack46856 += 1;
		} while (uStack46856 < 2);
		pfVar8 = afStack46156;
		pfVar13 = &aPStack46480[0].y;
		uStack46860 = 2;
		do {
			uVar10 = 0;
			pfVar12 = pfVar8;
			pfVar16 = pfVar13;
			if (uVar7 != 0) {
				do {
					VStack46840.x = pfVar12[0x77] - pfVar12[-1];
					VStack46840.y = pfVar12[0x78] - *pfVar12;
					VStack46840.z = pfVar12[0x79] - pfVar12[1];
					math::Maths_RayPlaneIntersection
										(&VStack46796,(Vector3F *)(pfVar12 + -1),&VStack46840,&VStack46784,&VStack46772)
					;
					AStack46812.x = VStack46796.x;
					AStack46812.y = VStack46796.y;
					RadarMap_FUN_0045ec00(radarMap,&AStack46812);
					pfVar16[-1] = AStack46812.x;
					*pfVar16 = AStack46812.y;
					uVar10 += 1;
					pfVar12 = pfVar12 + 3;
					pfVar16 = pfVar16 + 2;
					uVar7 = globs::radarmapGlobs.structfCount;
				} while (uVar10 < globs::radarmapGlobs.structfCount);
			}
			pfVar13 = pfVar13 + 0x28;
			pfVar8 = pfVar8 + 0x3c;
			uStack46860 += -1;
		} while (uStack46860 != 0);
		draw::Draw_LineListEx(aPStack46480,aPStack46320,uVar7,1.0,1.0,1.0,DRAWEFFECT_HALFTRANS);
		pfVar8 = &PStack46632.y;
		pfVar13 = &aVStack46576[0].y;
		iVar5 = 4;
		do {
			VStack46840.x = pfVar13[0xb] - pfVar13[-1];
			VStack46840.y = pfVar13[0xc] - *pfVar13;
			VStack46840.z = pfVar13[0xd] - pfVar13[1];
			math::Maths_RayPlaneIntersection
								(&VStack46796,(Vector3F *)(pfVar13 + -1),&VStack46840,&VStack46784,&VStack46772);
			AStack46812.x = VStack46796.x;
			AStack46812.y = VStack46796.y;
			RadarMap_FUN_0045ec00(radarMap,&AStack46812);
			pfVar8[-1] = AStack46812.x;
			*pfVar8 = AStack46812.y;
			pfVar13 = pfVar13 + 3;
			pfVar8 = pfVar8 + 2;
			iVar5 += -1;
		} while (iVar5 != 0);
		fStack46600 = PStack46632.x;
		fStack46596 = PStack46632.y;
		draw::Draw_LineListEx(&PStack46632,aPStack46624,4,0.7,0.7,0.7,DRAWEFFECT_HALFTRANS);
	}
	draw::Draw_SetClipWindow(&AStack46592);
	return;
}



BOOL __cdecl lego::game::RadarMap_CanLiveObjectShowOnRadar(LiveObject *liveObj)
{
	ObjectStatsFlags2 statsFlags2;
	ObjectType objType;
	
	objType = liveObj->objType;
						// objType is [VEHICLE, MINIFIGURE, ROCKMONSTER, CRYSTAL,
						//             ORE, UPGRADEPART, ELECTRICFENCE, PATH]
	if ((((((objType != OBJECT_ELECTRICFENCESTUD) && (objType != OBJECT_BOULDER)) &&
				(objType != OBJECT_DYNAMITE)) &&
			 ((objType != OBJECT_OOHSCARY && (objType != OBJECT_PUSHER)))) &&
			((objType != OBJECT_FREEZER && ((objType != OBJECT_LASERSHOT && (objType != OBJECT_BARRIER))))
			)) && ((objType != OBJECT_ICECUBE &&
						 ((objType != OBJECT_BUILDING && (objType != OBJECT_SPIDERWEB)))))) {
		statsFlags2 = stats::StatsObject_GetStatsFlags2(liveObj);
						// not (statsFlags2 & STATS2_DONTSHOWONRADAR)
		return ~statsFlags2 >> 0x1d & 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::RadarMap_LiveObject_Callback_FUN_0045e720(LiveObject *liveObj,RadarMap *radarMap)
{
	float fVar1;
	ObjectType OVar2;
	BOOL BVar3;
	Point2F position;
	
	BVar3 = RadarMap_CanLiveObjectShowOnRadar(liveObj);
	if (BVar3 == 0) {
		return 0;
	}
	LiveObject_GetPosition(liveObj,&position.x,&position.y);
	if (((((radarMap->worldRect).x <= position.x) &&
			 (fVar1 = (radarMap->worldRect).width,
			 (ushort)((ushort)(position.x < fVar1) << 8 | (ushort)(position.x == fVar1) << 0xe) != 0)) &&
			((radarMap->worldRect).y <= position.y)) &&
		 (fVar1 = (radarMap->worldRect).height,
		 (ushort)((ushort)(position.y < fVar1) << 8 | (ushort)(position.y == fVar1) << 0xe) != 0)) {
		OVar2 = liveObj->objType;
		if (OVar2 == OBJECT_ROCKMONSTER) {
			radarMap->drawRectList[radarMap->drawRectCount].r = globs::radarmapGlobs.colourTable[15].red;
			radarMap->drawRectList[radarMap->drawRectCount].g = globs::radarmapGlobs.colourTable[15].green
			;
			radarMap->drawRectList[radarMap->drawRectCount].b = globs::radarmapGlobs.colourTable[15].blue;
			fVar1 = 0.3333333;
		}
		else {
			if ((OVar2 == OBJECT_POWERCRYSTAL) || (OVar2 == OBJECT_ORE)) {
				radarMap->drawRectList[radarMap->drawRectCount].r = globs::radarmapGlobs.colourTable[16].red
				;
				radarMap->drawRectList[radarMap->drawRectCount].g =
						 globs::radarmapGlobs.colourTable[16].green;
				radarMap->drawRectList[radarMap->drawRectCount].b =
						 globs::radarmapGlobs.colourTable[16].blue;
				fVar1 = 0.25;
			}
			else {
				radarMap->drawRectList[radarMap->drawRectCount].r = globs::radarmapGlobs.colourTable[14].red
				;
				radarMap->drawRectList[radarMap->drawRectCount].g =
						 globs::radarmapGlobs.colourTable[14].green;
				radarMap->drawRectList[radarMap->drawRectCount].b =
						 globs::radarmapGlobs.colourTable[14].blue;
				fVar1 = 0.3333333;
			}
		}
		radarMap->drawRectList[radarMap->drawRectCount].rect.x =
				 position.x - fVar1 * 0.5 * radarMap->BlockSize;
		radarMap->drawRectList[radarMap->drawRectCount].rect.y =
				 fVar1 * 0.5 * radarMap->BlockSize + position.y;
		radarMap->drawRectList[radarMap->drawRectCount].rect.width = fVar1 * radarMap->BlockSize;
		radarMap->drawRectList[radarMap->drawRectCount].rect.height = fVar1 * radarMap->BlockSize;
		RadarMap_FUN_0045ec00(radarMap,&radarMap->drawRectList[radarMap->drawRectCount].rect);
		radarMap->drawRectCount = radarMap->drawRectCount + 1;
	}
	return 0;
}



BOOL __cdecl lego::game::RadarMap_InsideRadarScreen(RadarMap *radarMap,uint mouseX,uint mouseY)
{
	if (((((radarMap->screenRect).x <= (float)(ulonglong)mouseX) &&
			 ((float)(ulonglong)mouseX < (radarMap->screenRect).width + (radarMap->screenRect).x)) &&
			((radarMap->screenRect).y <= (float)(ulonglong)mouseY)) &&
		 ((float)(ulonglong)mouseY < (radarMap->screenRect).height + (radarMap->screenRect).y)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::RadarMap_ScreenToWorldBlockPos
					(RadarMap *radarMap,uint mouseX,uint mouseY,Point2F *optout_worldPos,int *out_bx,
					int *out_by)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	
	fVar1 = (float)(ulonglong)mouseX;
	if (((radarMap->screenRect).x <= fVar1) &&
		 (fVar2 = (radarMap->screenRect).width + (radarMap->screenRect).x,
		 (ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) == 0)) {
		fVar2 = (float)(ulonglong)mouseY;
		if (((radarMap->screenRect).y <= fVar2) &&
			 (fVar3 = (radarMap->screenRect).height + (radarMap->screenRect).y,
			 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) == 0)) {
			fVar3 = 1.0 / radarMap->arrowTiltOrZoom;
			fVar4 = (radarMap->screenRect).width * 0.5;
			fVar2 = radarMap->BlockSize * (((radarMap->screenRect).y + fVar4) - fVar2) * fVar3 +
							(radarMap->arrowPos).y;
			fVar1 = (radarMap->arrowPos).x +
							-(radarMap->BlockSize * (((radarMap->screenRect).x + fVar4) - fVar1) * fVar3);
			BVar5 = Map3D_WorldToBlockPos_NoZ(radarMap->surfMap,fVar1,fVar2,out_bx,out_by);
			if (BVar5 != 0) {
				if (optout_worldPos != NULL) {
					optout_worldPos->x = fVar1;
					optout_worldPos->y = fVar2;
				}
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::RadarMap_TrySelectObject
					(RadarMap *radarMap,uint mouseX,uint mouseY,LiveObject **out_liveObj,
					Point2F *optout_objPosition)
{
	BOOL BVar1;
	Point2I blockPos;
	SearchRadarObjectRadius_10 search;
	
	search.worldPos.x = 0.0;
	search.worldPos.y = 0.0;
	search.radius = 0.0;
	search.object = NULL;
	BVar1 = RadarMap_ScreenToWorldBlockPos
										(radarMap,mouseX,mouseY,&search.worldPos,&blockPos.x,&blockPos.y);
	if (BVar1 != 0) {
		BVar1 = Level_Block_IsSolidBuilding(blockPos.x,blockPos.y,TRUE);
		if (BVar1 == 0) {
			search.radius = radarMap->BlockSize * 0.1666667;
		}
		else {
			search.radius = radarMap->BlockSize;
		}
		BVar1 = Search_LiveObjects_SkipIgnoreMes(RadarMap_LiveObjectCallback_InsideSquareRadius,&search)
		;
		if (BVar1 != 0) {
			*out_liveObj = search.object;
			if (optout_objPosition != NULL) {
				LiveObject_GetPosition(search.object,&optout_objPosition->x,&optout_objPosition->y);
			}
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::RadarMap_LiveObjectCallback_InsideSquareRadius
					(LiveObject *liveObj,SearchRadarObjectRadius_10 *search)
{
	Point2F position;
	
	LiveObject_GetPosition(liveObj,&position.x,&position.y);
	if ((ABS(position.x - (search->worldPos).x) <= search->radius) &&
		 (ABS(position.y - (search->worldPos).y) <= search->radius)) {
		search->object = liveObj;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::RadarMap_FUN_0045ec00(RadarMap *radarMap,Area2F *ref_param_2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	
	fVar1 = (radarMap->screenRect).width;
	fVar2 = (radarMap->screenRect).height;
	fVar3 = (radarMap->screenRect).x;
	fVar4 = (radarMap->screenRect).y;
	ref_param_2->x = ref_param_2->x - (radarMap->arrowPos).x;
	ref_param_2->y = ref_param_2->y - (radarMap->arrowPos).y;
	ref_param_2->x = (radarMap->arrowTiltOrZoom / radarMap->BlockSize) * ref_param_2->x;
	ref_param_2->y = (radarMap->arrowTiltOrZoom / radarMap->BlockSize) * ref_param_2->y;
	ref_param_2->width = (radarMap->arrowTiltOrZoom / radarMap->BlockSize) * ref_param_2->width;
	fVar5 = radarMap->arrowTiltOrZoom;
	fVar6 = radarMap->BlockSize;
	ref_param_2->x = ref_param_2->x + fVar1 * 0.5 + fVar3;
	ref_param_2->y = (fVar2 * 0.5 + fVar4) - ref_param_2->y;
	ref_param_2->height = (fVar5 / fVar6) * ref_param_2->height;
	return;
}



BOOL __cdecl lego::game::RadarMap_DrawBlock(Draw_Rect *drawRect,uint bx,uint by)
{
	uint by_00;
	BOOL BVar1;
	Point2I blockPos;
	uint bx_00;
	
	by_00 = by;
	bx_00 = bx;
	blockPos.x = bx;
	blockPos.y = by;
	Level_Block_GetSurfaceType(bx,by,&bx);
	BVar1 = Level_Block_IsWall(bx_00,by_00);
	if (BVar1 == 0) {
		BVar1 = Level_Block_IsNotWallOrGround(bx_00,by_00);
		if ((BVar1 != 0) && (BVar1 = Level_Block_IsSurveyed(bx_00,by_00), BVar1 != 0)) {
			if (((globs::legoGlobs.level)->blocks
					 [((globs::legoGlobs.level)->dimensions).width * by_00 + bx_00].flags1 & BLOCK1_HIDDEN) !=
					BLOCK1_NONE) {
						// SURFACE_UNDISCOVERED
				drawRect->r = globs::radarmapGlobs.colourTable[29].red;
				drawRect->g = globs::radarmapGlobs.colourTable[29].green;
				drawRect->b = globs::radarmapGlobs.colourTable[29].blue;
				return TRUE;
			}
			switch(bx) {
			case 1:
						// SURFACE_IMMOVABLE
				drawRect->r = globs::radarmapGlobs.colourTable[8].red;
				drawRect->g = globs::radarmapGlobs.colourTable[8].green;
				drawRect->b = globs::radarmapGlobs.colourTable[8].blue;
				return TRUE;
			case 2:
						// SURFACE_HARD
				drawRect->r = globs::radarmapGlobs.colourTable[7].red;
				drawRect->g = globs::radarmapGlobs.colourTable[7].green;
				drawRect->b = globs::radarmapGlobs.colourTable[7].blue;
				return TRUE;
			case 3:
						// SURFACE_MEDIUM
				drawRect->r = globs::radarmapGlobs.colourTable[6].red;
				drawRect->g = globs::radarmapGlobs.colourTable[6].green;
				drawRect->b = globs::radarmapGlobs.colourTable[6].blue;
				return TRUE;
			case 4:
						// SURFACE_LOOSE
				drawRect->r = globs::radarmapGlobs.colourTable[5].red;
				drawRect->g = globs::radarmapGlobs.colourTable[5].green;
				drawRect->b = globs::radarmapGlobs.colourTable[5].blue;
				return TRUE;
			case 5:
						// SURFACE_SOIL
				drawRect->r = globs::radarmapGlobs.colourTable[4].red;
				drawRect->g = globs::radarmapGlobs.colourTable[4].green;
				drawRect->b = globs::radarmapGlobs.colourTable[4].blue;
				return TRUE;
			case 6:
				goto switchD_0045ef37_caseD_6;
			case 7:
						// SURFACE_WATER_unused
				drawRect->r = globs::radarmapGlobs.colourTable[2].red;
				drawRect->g = globs::radarmapGlobs.colourTable[2].green;
				drawRect->b = globs::radarmapGlobs.colourTable[2].blue;
				return TRUE;
			case 8:
switchD_0045ef37_caseD_8:
						// SURFACE_ORESEAM
				drawRect->r = globs::radarmapGlobs.colourTable[24].red;
				drawRect->g = globs::radarmapGlobs.colourTable[24].green;
				drawRect->b = globs::radarmapGlobs.colourTable[24].blue;
				return TRUE;
			case 9:
						// SURFACE_LAKE
				drawRect->r = globs::radarmapGlobs.colourTable[27].red;
				drawRect->g = globs::radarmapGlobs.colourTable[27].green;
				drawRect->b = globs::radarmapGlobs.colourTable[27].blue;
				return TRUE;
			case 10:
switchD_0045ef37_caseD_a:
						// SURFACE_CRYSTALSEAM
				drawRect->r = globs::radarmapGlobs.colourTable[25].red;
				drawRect->g = globs::radarmapGlobs.colourTable[25].green;
				drawRect->b = globs::radarmapGlobs.colourTable[25].blue;
				return TRUE;
			case 0xb:
switchD_0045ef37_caseD_b:
						// SURFACE_RECHARGESEAM
				drawRect->r = globs::radarmapGlobs.colourTable[26].red;
				drawRect->g = globs::radarmapGlobs.colourTable[26].green;
				drawRect->b = globs::radarmapGlobs.colourTable[26].blue;
				return TRUE;
			default:
				goto switchD_0045ef37_caseD_b;
			}
		}
		BVar1 = Level_Block_IsGround(bx_00,by_00);
		if (BVar1 == 0) {
			return 0;
		}
		if (bx != SURFACE_LAVA) {
			if (bx == SURFACE_WATER_unused) {
						// SURFACE_WATER_unused
				drawRect->r = globs::radarmapGlobs.colourTable[2].red;
				drawRect->g = globs::radarmapGlobs.colourTable[2].green;
				drawRect->b = globs::radarmapGlobs.colourTable[2].blue;
				return TRUE;
			}
			if (bx == SURFACE_LAKE) {
						// SURFACE_LAKE
				drawRect->r = globs::radarmapGlobs.colourTable[27].red;
				drawRect->g = globs::radarmapGlobs.colourTable[27].green;
				drawRect->b = globs::radarmapGlobs.colourTable[27].blue;
				return TRUE;
			}
			if (((globs::legoGlobs.level)->blocks
					 [((globs::legoGlobs.level)->dimensions).width * by_00 + bx_00].flags1 & BLOCK1_FOUNDATION
					) != BLOCK1_NONE) {
				drawRect->r = globs::radarmapGlobs.colourTable[28].red;
				drawRect->g = globs::radarmapGlobs.colourTable[28].green;
				drawRect->b = globs::radarmapGlobs.colourTable[28].blue;
				return TRUE;
			}
			BVar1 = Level_Block_IsPath(&blockPos);
			if (BVar1 != 0) {
				BVar1 = Level_Block_IsPowered(&blockPos);
				if (BVar1 != 0) {
						// SURFACE_PATH (powered)
					drawRect->r = globs::radarmapGlobs.colourTable[22].red;
					drawRect->g = globs::radarmapGlobs.colourTable[22].green;
					drawRect->b = globs::radarmapGlobs.colourTable[22].blue;
					return TRUE;
				}
						// SURFACE_PATH (unpowered)
				drawRect->r = globs::radarmapGlobs.colourTable[23].red;
				drawRect->g = globs::radarmapGlobs.colourTable[23].green;
				drawRect->b = globs::radarmapGlobs.colourTable[23].blue;
				return TRUE;
			}
			drawRect->r = globs::radarmapGlobs.colourTable[1].red;
			drawRect->g = globs::radarmapGlobs.colourTable[1].green;
			drawRect->b = globs::radarmapGlobs.colourTable[1].blue;
			return TRUE;
		}
switchD_0045ef37_caseD_6:
						// SURFACE_LAVA
		drawRect->r = globs::radarmapGlobs.colourTable[3].red;
		drawRect->g = globs::radarmapGlobs.colourTable[3].green;
		drawRect->b = globs::radarmapGlobs.colourTable[3].blue;
	}
	else {
		BVar1 = Level_Block_IsDestroyedConnection(bx_00,by_00);
		if (BVar1 == 0) {
			if (true) {
				switch(bx) {
				case 1:
						// SURFACE_IMMOVABLE
					drawRect->r = globs::radarmapGlobs.colourTable[13].red;
					drawRect->g = globs::radarmapGlobs.colourTable[13].green;
					drawRect->b = globs::radarmapGlobs.colourTable[13].blue;
					return TRUE;
				case 2:
						// SURFACE_HARD
					drawRect->r = globs::radarmapGlobs.colourTable[12].red;
					drawRect->g = globs::radarmapGlobs.colourTable[12].green;
					drawRect->b = globs::radarmapGlobs.colourTable[12].blue;
					return TRUE;
				case 3:
						// SURFACE_MEDIUM
					drawRect->r = globs::radarmapGlobs.colourTable[11].red;
					drawRect->g = globs::radarmapGlobs.colourTable[11].green;
					drawRect->b = globs::radarmapGlobs.colourTable[11].blue;
					return TRUE;
				case 4:
						// SURFACE_LOOSE
					drawRect->r = globs::radarmapGlobs.colourTable[10].red;
					drawRect->g = globs::radarmapGlobs.colourTable[10].green;
					drawRect->b = globs::radarmapGlobs.colourTable[10].blue;
					return TRUE;
				case 5:
						// SURFACE_SOIL
					drawRect->r = globs::radarmapGlobs.colourTable[9].red;
					drawRect->g = globs::radarmapGlobs.colourTable[9].green;
					drawRect->b = globs::radarmapGlobs.colourTable[9].blue;
					return TRUE;
				case 8:
					goto switchD_0045ef37_caseD_8;
				case 10:
					goto switchD_0045ef37_caseD_a;
				case 0xb:
					goto switchD_0045ef37_caseD_b;
				}
			}
		}
		else {
			switch(bx) {
			case 1:
						// SURFACE_IMMOVABLE
				drawRect->r = globs::radarmapGlobs.colourTable[21].red;
				drawRect->g = globs::radarmapGlobs.colourTable[21].green;
				drawRect->b = globs::radarmapGlobs.colourTable[21].blue;
				return 1;
			case 2:
						// SURFACE_HARD
				drawRect->r = globs::radarmapGlobs.colourTable[20].red;
				drawRect->g = globs::radarmapGlobs.colourTable[20].green;
				drawRect->b = globs::radarmapGlobs.colourTable[20].blue;
				return 1;
			case 3:
						// SURFACE_MEDIUM
				drawRect->r = globs::radarmapGlobs.colourTable[19].red;
				drawRect->g = globs::radarmapGlobs.colourTable[19].green;
				drawRect->b = globs::radarmapGlobs.colourTable[19].blue;
				return TRUE;
			case 4:
						// SURFACE_LOOSE
				drawRect->r = globs::radarmapGlobs.colourTable[18].red;
				drawRect->g = globs::radarmapGlobs.colourTable[18].green;
				drawRect->b = globs::radarmapGlobs.colourTable[18].blue;
				return TRUE;
			case 5:
						// SURFACE_SOIL
				drawRect->r = globs::radarmapGlobs.colourTable[17].red;
				drawRect->g = globs::radarmapGlobs.colourTable[17].green;
				drawRect->b = globs::radarmapGlobs.colourTable[17].blue;
				return TRUE;
			}
		}
	}
switchD_0045ef37_caseD_b:
	return TRUE;
}



BOOL __cdecl lego::reward::Reward_Initialise(void)
{
	int iVar1;
	uint uVar2;
	RewardLevel *pRVar3;
	char **ppcVar4;
	char *ITEM_NAMES [10];
	
	ITEM_NAMES[0] = "Crystals";
	ITEM_NAMES[1] = "Ore";
	ITEM_NAMES[2] = "Diggable";
	ITEM_NAMES[3] = "Constructions";
	ITEM_NAMES[4] = "Caverns";
	ITEM_NAMES[5] = "Figures";
	ITEM_NAMES[6] = "RockMonsters";
	ITEM_NAMES[7] = "Oxygen";
	ITEM_NAMES[8] = "Timer";
	ITEM_NAMES[9] = "Score";
	globals::g_RewardBase = (RewardLevel *)std::malloc(0x318c);
	pRVar3 = globals::g_RewardBase;
						// std::memset(_, 0, 0x318c);
	for (iVar1 = 0xc63; iVar1 != 0; iVar1 += -1) {
		pRVar3->Enabled = 0;
		pRVar3 = (RewardLevel *)&pRVar3->saveHasCapture;
	}
	uVar2 = 0;
	ppcVar4 = ITEM_NAMES;
	globals::g_RewardBase->itemPtr = globals::g_RewardBase->items;
	globals::g_RewardBase->itemCount = 10;
	do {
		std::sprintf(globals::g_RewardBase->itemPtr->name + uVar2,"%s",*ppcVar4);
		uVar2 += 0x210;
		ppcVar4 = ppcVar4 + 1;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		Reward_LoadItemImages((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		Reward_LoadItemText((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		Reward_LoadItemFlics((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		Reward_LoadItemFonts((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		Reward_LoadItemSounds((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		Reward_LoadItemBoxImages
							((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	return TRUE;
}



void __cdecl lego::reward::Reward_LoadItemSounds(RewardLevelItem *rewardItem)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Sounds",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	rewardItem->SoundName = pcVar1;
	return;
}



void __cdecl lego::reward::Reward_LoadItemFonts(RewardLevelItem *rewardItem)
{
	char *pcVar1;
	Font *pFVar2;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Fonts",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		pFVar2 = lego::image::Font_Load(pcVar1);
		rewardItem->Font = pFVar2;
		if (pFVar2 != NULL) {
			return;
		}
	}
	rewardItem->Font = globals::g_Reward_Font;
	return;
}



void __cdecl lego::reward::Reward_LoadItemBoxImages(RewardLevelItem *rewardItem)
{
	char *pcVar1;
	int iVar2;
	Image *image;
	char reduceName [64];
	char valueBuffer [128];
	char *stringParts [100];
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","BoxImages",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
			std::sprintf(reduceName,"!%s",rewardItem->name);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",reduceName,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
		}
		if (pcVar1 == NULL) {
			return;
		}
	}
	util::Util_Tokenise(pcVar1,stringParts,"|");
	std::sprintf(valueBuffer,"%s",stringParts[0]);
	iVar2 = std::atoi(stringParts[1]);
	(rewardItem->BoxImagePosition).x = iVar2;
	iVar2 = std::atoi(stringParts[2]);
	(rewardItem->BoxImagePosition).y = iVar2;
	image = lego::image::Image_LoadBMPScaled(valueBuffer,0,0);
	rewardItem->BoxImage = image;
	if (image != NULL) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		rewardItem->flags = rewardItem->flags | REWARDITEM_BOXIMAGES;
		std::free(pcVar1);
	}
	return;
}



void __cdecl lego::reward::Reward_LoadItemImages(RewardLevelItem *rewardItem)
{
	char *pcVar1;
	int iVar2;
	Image *image;
	char local_250 [64];
	char local_210 [128];
	char *local_190;
	char *local_18c;
	char *local_188;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
			std::sprintf(local_250,"!%s",rewardItem->name);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",local_250,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
		}
		if (pcVar1 == NULL) {
			return;
		}
	}
	util::Util_Tokenise(pcVar1,&local_190,"|");
	std::sprintf(local_210,"%s",local_190);
	iVar2 = std::atoi(local_18c);
	(rewardItem->ImagePosition).x = iVar2;
	iVar2 = std::atoi(local_188);
	(rewardItem->ImagePosition).y = iVar2;
	image = lego::image::Image_LoadBMPScaled(local_210,0,0);
	rewardItem->Image = image;
	if (image != NULL) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		rewardItem->flags = rewardItem->flags | REWARDITEM_IMAGES;
		std::free(pcVar1);
	}
	return;
}



void __cdecl lego::reward::Reward_LoadItemText(RewardLevelItem *rewardItem)
{
	RewardItemFlags RVar1;
	char *pcVar2;
	int iVar3;
	char *stringParts [100];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Text",rewardItem->name,0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		util::Util_Tokenise(pcVar2,stringParts,"|");
		std::sprintf(rewardItem->Text,"%s",stringParts[0]);
		util::stringReplaceChar(rewardItem->Text,'_',' ');
		iVar3 = std::atoi(stringParts[1]);
		(rewardItem->TextPosition).x = iVar3;
		iVar3 = std::atoi(stringParts[2]);
		RVar1 = rewardItem->flags;
		(rewardItem->TextPosition).y = iVar3;
		rewardItem->flags =
				 RVar1 | (REWARDITEM_VALUETEXT|REWARDITEM_NAMETEXT|REWARDITEM_NAMETEXT_HALFTRANS);
		std::free(pcVar2);
	}
	return;
}



void __cdecl lego::reward::Reward_LoadItemFlics(RewardLevelItem *rewardItem)
{
	RewardItemFlags RVar1;
	char *pcVar2;
	int iVar3;
	char reduceName [64];
	char valueBuffer [128];
	char *stringParts [100];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Flics",rewardItem->name,0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		if ((globs::mainGlobs.flags & CMD_REDUCEFLICS) == CMD_NONE) {
			std::sprintf(reduceName,"!%s",rewardItem->name);
			pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Flics",reduceName,0);
			pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
		}
		if (pcVar2 == NULL) {
			return;
		}
	}
	util::Util_Tokenise(pcVar2,stringParts,"|");
	std::sprintf(valueBuffer,"%s",stringParts[0]);
	std::sprintf(rewardItem->FlicName,"%s",valueBuffer);
	iVar3 = std::atoi(stringParts[1]);
	(rewardItem->FlicPosition).x = iVar3;
	iVar3 = std::atoi(stringParts[2]);
	(rewardItem->FlicPosition).y = iVar3;
	iVar3 = std::atoi(stringParts[3]);
	(rewardItem->FlicSize).width = iVar3;
	iVar3 = std::atoi(stringParts[4]);
	RVar1 = rewardItem->flags;
	(rewardItem->FlicSize).height = iVar3;
	rewardItem->flags = RVar1 | REWARDITEM_FLIC;
	std::free(pcVar2);
	return;
}



void __cdecl lego::reward::Reward_Shutdown(void)
{
	RewardLevelItem *rewardItem;
	uint uVar1;
	
	uVar1 = 0;
	do {
		if ((globals::g_RewardBase->itemPtr->name[uVar1 - 4] & REWARDITEM_IMAGES) != 0) {
			Reward_FreeItemImage((RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar1 - 4)));
		}
		rewardItem = (RewardLevelItem *)(globals::g_RewardBase->itemPtr->name + (uVar1 - 4));
		if ((*(byte *)&rewardItem->flags & REWARDITEM_VALUETEXT) != 0) {
			Reward_FreeItemFont(rewardItem);
		}
		uVar1 += 0x210;
	} while (uVar1 < 0x14a0);
	std::free(globals::g_RewardBase);
	return;
}



void __cdecl lego::reward::Reward_FreeItemImage(RewardLevelItem *rewardItem)
{
	lego::image::Image_Remove(rewardItem->Image);
	return;
}



void __cdecl lego::reward::Reward_FreeItemFont(RewardLevelItem *rewardItem)
{
	lego::image::Font_Remove(rewardItem->Font);
	return;
}



BOOL __cdecl lego::reward::Reward_LoadGraphics(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	float10 fVar2;
	uint width;
	uint height;
	char *stringParts [100];
	
	lrr::Lego_GetLevel();
	height = 0;
	width = 0;
	globals::g_Reward_LegoCfgRoot = root;
	globals::g_Reward_CfgRootName = rootPath;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Wallpaper",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Reward_Wallpaper = lego::image::Image_LoadBMPScaled(pcVar1,width,height);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Display",0);
	globals::g_Reward_Display = cfg::CFG_ReadBool(root,pcVar1);
	if (globals::g_Reward_Display == BOOL3_ERROR) {
		globals::g_Reward_Display = 0;
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","CentreText",0);
	globals::g_Reward_CentreText = cfg::CFG_ReadBool(root,pcVar1);
	if (globals::g_Reward_CentreText == BOOL3_ERROR) {
		globals::g_Reward_CentreText = 0;
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","ScrollSpeed",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","ScrollSpeed",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globals::g_Reward_ScrollSpeed = (float)fVar2;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","VertSpacing",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","VertSpacing",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globals::g_Reward_VertSpacing = (float)fVar2;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Font",0);
	globals::g_Reward_Font_filename = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","TitleFont",0);
	globals::g_Reward_TitleFont_filename = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","BackFont",0);
	globals::g_Reward_BackFont_filename = cfg::CFG_CopyString(root,pcVar1);
	globals::g_Reward_Font = lego::image::Font_Load(globals::g_Reward_Font_filename);
	globals::g_Reward_TitleFont = lego::image::Font_Load(globals::g_Reward_TitleFont_filename);
	globals::g_Reward_BackFont = lego::image::Font_Load(globals::g_Reward_BackFont_filename);
	Reward_LoadButtons(root,rootPath);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","CompleteText",0);
	globals::g_Reward_CompleteText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","FailedText",0);
	globals::g_Reward_FailedText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","QuitText",0);
	globals::g_Reward_QuitText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","TextPos",0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,stringParts,"|");
		globals::g_Reward_TextPos.x = std::atoi(stringParts[0]);
		globals::g_Reward_TextPos.y = std::atoi(stringParts[1]);
	}
	return 1;
}



BOOL __cdecl lego::reward::Reward_LoadButtons(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	char *parts [100];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","SaveButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,parts,"|");
		globals::g_Reward_SaveButton = lego::image::Image_LoadBMPScaled(parts[0],0,0);
		if (globals::g_Reward_SaveButton != NULL) {
			globals::g_Reward_SaveButton_hi = lego::image::Image_LoadBMPScaled(parts[1],0,0);
			globals::g_Reward_SaveButton_in = lego::image::Image_LoadBMPScaled(parts[2],0,0);
			globals::g_Reward_SaveButton_dim = lego::image::Image_LoadBMPScaled(parts[3],0,0);
			iVar2 = std::atoi(parts[4]);
			globals::g_Reward_SaveButtonPosition.x = (float)iVar2;
			iVar2 = std::atoi(parts[5]);
			globals::g_Reward_SaveButtonPosition.y = (float)iVar2;
			lego::image::Image_SetupTrans(globals::g_Reward_SaveButton,0.0,0.0,0.0,0.0,0.0,0.0);
			if (globals::g_Reward_SaveButton_hi != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_SaveButton_hi,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			if (globals::g_Reward_SaveButton_in != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_SaveButton_in,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","AdvanceButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,parts,"|");
		globals::g_Reward_AdvanceButton = lego::image::Image_LoadBMPScaled(parts[0],0,0);
		if (globals::g_Reward_AdvanceButton != NULL) {
			globals::g_Reward_AdvanceButton_hi = lego::image::Image_LoadBMPScaled(parts[1],0,0);
			globals::g_Reward_AdvanceButton_in = lego::image::Image_LoadBMPScaled(parts[2],0,0);
			globals::g_Reward_AdvanceButton_dim = lego::image::Image_LoadBMPScaled(parts[3],0,0);
			iVar2 = std::atoi(parts[4]);
			globals::g_Reward_AdvanceButtonPosition.x = (float)iVar2;
			iVar2 = std::atoi(parts[5]);
			globals::g_Reward_AdvanceButtonPosition.y = (float)iVar2;
			lego::image::Image_SetupTrans(globals::g_Reward_AdvanceButton,0.0,0.0,0.0,0.0,0.0,0.0);
			if (globals::g_Reward_AdvanceButton_hi != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_AdvanceButton_hi,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			if (globals::g_Reward_AdvanceButton_in != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_AdvanceButton_in,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		std::free(pcVar1);
	}
	if ((globals::g_Reward_SaveButton != NULL) && (globals::g_Reward_AdvanceButton != NULL)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_CreateLevel(void)
{
	int iVar1;
	LevelData *level;
	char *pcVar2;
	BoolTri BVar3;
	uint uVar4;
	int iVar5;
	int iVar6;
	undefined4 *puVar7;
	RewardLevel *reward;
	undefined4 *puVar8;
	float10 fVar9;
	
	level = lrr::Lego_GetLevel();
	globals::g_RewardLevel = (RewardLevel *)std::malloc(0x318c);
	reward = globals::g_RewardLevel;
						// std:::memset(_, 0, 0x318c);
	for (iVar5 = 0xc63; iVar5 != 0; iVar5 += -1) {
		reward->Enabled = 0;
		reward = (RewardLevel *)&reward->saveHasCapture;
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Enable",0);
	BVar3 = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar2);
	globals::g_RewardLevel->Enabled = BVar3;
	if (globals::g_RewardLevel->Enabled == BOOL3_ERROR) {
		globals::g_RewardLevel->Enabled = 0;
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Modifier",0);
	pcVar2 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Modifier",0)
		;
		pcVar2 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar2);
	}
	iVar5 = std::atoi(pcVar2);
	globals::g_RewardLevel->Modifier = iVar5;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Timer",0);
	pcVar2 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Timer",0);
		pcVar2 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar2);
	}
	fVar9 = std::atof(pcVar2);
	globals::g_Reward_Timer = (float)fVar9;
	if ((float10)0.0 == fVar9) {
		globals::g_Reward_Timer = 76.9375;
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayText",0);
	globals::g_Reward_DisplayText = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (globals::g_Reward_DisplayText == BOOL3_ERROR) {
		globals::g_Reward_DisplayText = 1;
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayImages",0);
	globals::g_Reward_DisplayImages = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (globals::g_Reward_DisplayImages == BOOL3_ERROR) {
		globals::g_Reward_DisplayImages = 1;
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayFlics",0);
	globals::g_Reward_DisplayFlics = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (globals::g_Reward_DisplayFlics == BOOL3_ERROR) {
		globals::g_Reward_DisplayFlics = 1;
	}
	globals::g_RewardLevel->itemPtr = globals::g_RewardLevel->items;
	uVar4 = 0;
	globals::g_RewardLevel->itemCount = 10;
	do {
		iVar5 = uVar4 - 4;
		iVar1 = uVar4 - 4;
		uVar4 += 0x210;
		puVar7 = (undefined4 *)(globals::g_RewardBase->itemPtr->name + iVar5);
		puVar8 = (undefined4 *)(globals::g_RewardLevel->itemPtr->name + iVar1);
		for (iVar6 = 0x84; iVar6 != 0; iVar6 += -1) {
			*puVar8 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar8 = puVar8 + 1;
		}
	} while (uVar4 < 0x14a0);
	uVar4 = 0;
	do {
		Reward_LoadLevelItemImportance
							((RewardLevelItem *)(globals::g_RewardLevel->itemPtr->name + (uVar4 - 4)));
		uVar4 += 0x210;
	} while (uVar4 < 0x14a0);
	uVar4 = 0;
	do {
		Reward_LoadLevelItemQuota
							((RewardLevelItem *)(globals::g_RewardLevel->itemPtr->name + (uVar4 - 4)));
		uVar4 += 0x210;
	} while (uVar4 < 0x14a0);
						// HARDCODED: Set Caverns::Quota = 1, for Level03 ("Rubble Trouble!")
	iVar5 = std::_stricmp(level->levelName,"Levels::Level03");
	if (iVar5 == 0) {
		globals::g_RewardLevel->itemPtr[4].Quota = 1;
	}
	return 1;
}



void __cdecl lego::reward::Reward_LoadLevelItemImportance(RewardLevelItem *rewardItem)
{
	LevelData *level;
	char *pcVar1;
	float10 fVar2;
	
	level = lrr::Lego_GetLevel();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Importance",
														 rewardItem->name,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Importance",
															 rewardItem->name,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
		fVar2 = std::atof(pcVar1);
		rewardItem->Importance = (float)fVar2;
		return;
	}
	fVar2 = std::atof(____EMPTYSTR__);
	rewardItem->Importance = (float)fVar2;
	return;
}



void __cdecl lego::reward::Reward_LoadLevelItemQuota(RewardLevelItem *rewardItem)
{
	LevelData *level;
	char *pcVar1;
	int iVar2;
	
	level = lrr::Lego_GetLevel();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Quota",
														 rewardItem->name,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Quota",
															 rewardItem->name,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
		iVar2 = std::atoi(pcVar1);
		rewardItem->Quota = iVar2;
		return;
	}
	iVar2 = std::atoi(____EMPTYSTR__);
	rewardItem->Quota = iVar2;
	return;
}



void __cdecl lego::reward::Reward_FreeLevel(void)
{
	std::free(globals::g_RewardLevel);
	return;
}



RewardLevel * __cdecl lego::reward::GetRewardLevel2(undefined4 unused_levelField10)
{
	return globals::g_RewardLevel;
}



// No different from above (GetRewardLevel2(undefined4))

RewardLevel * __cdecl lego::reward::GetRewardLevel(void)
{
	LevelData *level;
	RewardLevel *reward;
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return NULL;
	}
	reward = GetRewardLevel2(level->field_10);
	return reward;
}



void __cdecl lego::reward::Reward_CountUnits(void)
{
	LevelData *level;
	RewardLevel *pRVar1;
	RewardBuildingCounts *pRVar2;
	int iVar3;
	RewardBuildingCounts *pRVar4;
	RewardBuildingCounts buildingCounts;
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return;
	}
	pRVar1 = GetRewardLevel2(level->field_10);
	if (pRVar1 == NULL) {
		return;
	}
	pRVar2 = Reward_CountBuildings(&buildingCounts);
	pRVar4 = &globals::g_RewardCur.buildingCounts;
	for (iVar3 = 0x66; iVar3 != 0; iVar3 += -1) {
		pRVar4->nameTable[0] = pRVar2->nameTable[0];
		pRVar2 = (RewardBuildingCounts *)(pRVar2->nameTable + 1);
		pRVar4 = (RewardBuildingCounts *)(pRVar4->nameTable + 1);
	}
						// table[REWARDTYPE_FIGURES]
	globals::g_RewardCur.items[5].numDestroyed =
			 nerps::NERPsRuntime_GetPreviousLevelObjectsBuilt("Pilot",0);
	return;
}



RewardBuildingCounts * __cdecl
lego::reward::Reward_CountBuildings(RewardBuildingCounts *out_buildingCounts)
{
	uint uVar1;
	int iVar2;
	uint objLevel;
	RewardBuildingCounts *pRVar3;
	uint objIndex;
	RewardBuildingCounts *pRVar4;
	RewardBuildingCounts buildingCounts;
	
	buildingCounts.count = 0;
	game::Search_LiveObjects_SkipIgnoreMes(Reward_LiveObjectCallback_CountBuildings,&buildingCounts);
	buildingCounts.numPrevLevels_unk = 0;
	objIndex = 0;
	do {
		objLevel = 0;
		do {
			uVar1 = game::LiveObject_GetPreviousLevelObjectsBuilt(OBJECT_BUILDING,objIndex,objLevel);
			objLevel += 1;
			buildingCounts.numPrevLevels_unk = buildingCounts.numPrevLevels_unk + uVar1;
		} while (objLevel < 0x10);
		objIndex += 1;
	} while (objIndex < 0xf);
	pRVar3 = &buildingCounts;
	pRVar4 = out_buildingCounts;
	for (iVar2 = 0x66; iVar2 != 0; iVar2 += -1) {
		pRVar4->nameTable[0] = pRVar3->nameTable[0];
		pRVar3 = (RewardBuildingCounts *)(pRVar3->nameTable + 1);
		pRVar4 = (RewardBuildingCounts *)(pRVar4->nameTable + 1);
	}
	return out_buildingCounts;
}



BOOL __cdecl
lego::reward::Reward_LiveObjectCallback_CountBuildings
					(LiveObject *liveObj,RewardBuildingCounts *search)
{
	RewardBuildingCounts *pRVar1;
	char *pcVar2;
	int objIndex;
	
	game::LiveObject_GetTypeIndex(liveObj,(int *)&liveObj,&objIndex);
	pRVar1 = search;
						// if (objType == OBJECT_BUILDING)
	if (liveObj == (LiveObject *)&DAT_00000004) {
		pcVar2 = game::Object_GetTypeName(OBJECT_BUILDING,objIndex);
		pRVar1->nameTable[pRVar1->count] = pcVar2;
		pRVar1->count = pRVar1->count + 1;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_Prepare(void)
{
	undefined *puVar1;
	float fVar2;
	uint uVar3;
	uint uVar4;
	LevelData *level;
	RewardLevel *reward;
	uint uVar5;
	SurfaceMap *surfMap;
	int iVar6;
	char *pcVar7;
	Image *pIVar8;
	uint uVar9;
	RewardBuildingCounts *pRVar10;
	Image *pIVar11;
	RewardBuildingCounts *pRVar12;
	char (*out_buffer) [64];
	float10 fVar13;
	ulonglong uVar14;
	uint local_30;
	uint local_28;
	uint local_24;
	int local_20;
	int local_1c;
	Point2I local_18;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	TerrainType terrain;
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return 0;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward != NULL) {
		if (globals::g_RewardCur.saveHasCapture != 0) {
			pIVar8 = &globals::g_RewardCur.saveCaptureImage;
			pIVar11 = &reward->saveCaptureImage;
			for (iVar6 = 8; iVar6 != 0; iVar6 += -1) {
				pIVar11->surface = pIVar8->surface;
				pIVar8 = (Image *)&pIVar8->width;
				pIVar11 = (Image *)&pIVar11->width;
			}
			reward->saveHasCapture = TRUE;
		}
		reward->items[0].countdownRatio = 0.0;
		reward->items[1].countdownRatio = 0.0;
		reward->items[2].countdown = globals::g_RewardCur.items[2].countdown;
		reward->items[4].countdown = globals::g_RewardCur.items[4].countdown;
		reward->items[2].countdownRatio = 0.0;
		reward->float_1b04 = 0.0;
		reward->float_1b08 = 0.0;
		uVar5 = Reward_GetLevelObjectsBuilt("Pilot",0,0);
		reward->items[5].numGenerated = uVar5;
		reward->items[5].numDestroyed = globals::g_RewardCur.items[5].numDestroyed;
		reward->items[5].damageTaken = globals::g_RewardCur.items[5].damageTaken;
		uVar5 = globals::g_RewardCur.items[6].numGenerated;
		reward->items[6].numGenerated = globals::g_RewardCur.items[6].numGenerated;
		reward->items[6].numDestroyed = globals::g_RewardCur.items[6].numDestroyed;
		fVar2 = (float)(ulonglong)(uVar5 * 100);
		if ((ushort)((ushort)(globals::g_RewardCur.items[6].damageTaken < fVar2) << 8 |
								(ushort)(globals::g_RewardCur.items[6].damageTaken == fVar2) << 0xe) != 0) {
			fVar2 = globals::g_RewardCur.items[6].damageTaken;
		}
		reward->items[6].damageTaken = fVar2;
		reward->items[6].numAttacked = globals::g_RewardCur.items[6].numAttacked;
		pRVar10 = &globals::g_RewardCur.buildingCounts;
		pRVar12 = &reward->buildingCounts;
		for (iVar6 = 0x66; iVar6 != 0; iVar6 += -1) {
			pRVar12->nameTable[0] = pRVar10->nameTable[0];
			pRVar10 = (RewardBuildingCounts *)(pRVar10->nameTable + 1);
			pRVar12 = (RewardBuildingCounts *)(pRVar12->nameTable + 1);
		}
		uVar5 = 0;
		reward->field_1c8 = 0;
		fVar2 = (globs::legoGlobs.level)->oxygenLevel;
		reward->items[7].countdownRatio = (float)&DAT_42c80000;
		reward->items[7].countdown = fVar2;
		reward->items[8].countdown = globals::g_RewardCur.items[8].countdown;
		reward->items[8].countdownRatio =
				 globals::g_RewardCur.items[8].countdownRatio / reward->items[8].countdown;
		surfMap = level->surfaceMap;
		if ((surfMap->smallDimensions).width != 0) {
			do {
				uVar9 = 0;
				if ((surfMap->smallDimensions).height != 0) {
					do {
						terrain = level->blocks[uVar9 * (level->dimensions).width + uVar5].terrain;
						reward->field_1c8 = reward->field_1c8 + 1;
						local_18.x = uVar5;
						local_18.y = uVar9;
						lrr::Lego_GetBlockCryOre
											(&local_18,(int *)&local_28,&local_1c,(int *)&local_24,&local_20);
						local_10 = local_28;
						uStack12 = 0;
						uStack4 = 0;
						reward->items[0].countdownRatio =
								 (float)(ulonglong)local_28 + reward->items[0].countdownRatio;
						local_8 = local_24;
						reward->items[1].countdownRatio =
								 (float)(ulonglong)local_24 + reward->items[1].countdownRatio;
						if ((*(byte *)&level->blocks[uVar9 * (level->dimensions).width + uVar5].flags1 & 8) == 0
							 ) {
							if (terrain != TERRAIN_IMMOVABLE) {
								reward->items[2].countdownRatio = reward->items[2].countdownRatio - -1.0;
								reward->float_1b04 = reward->float_1b04 - -1.0;
							}
							if (terrain == TERRAIN_CRYSTALSEAM) {
								reward->items[0].countdownRatio = reward->items[0].countdownRatio - -4.0;
							}
						}
						else {
							if ((terrain != TERRAIN_WATER_unused) && (terrain != TERRAIN_LAVA)) {
								reward->float_1b04 = reward->float_1b04 - -1.0;
							}
						}
						if ((level->blocks[uVar9 * (level->dimensions).width + uVar5].flags1 &
								(BLOCK1_FOUNDATION|BLOCK1_UNK_1000000|BLOCK1_PATH|BLOCK1_UNK_40000000)) !=
								BLOCK1_NONE) {
							reward->float_1b08 = reward->float_1b08 - -1.0;
							reward->items[2].countdownRatio = reward->items[2].countdownRatio - -1.0;
						}
						uVar9 += 1;
					} while (uVar9 < (uint)(level->surfaceMap->smallDimensions).height);
				}
				surfMap = level->surfaceMap;
				uVar5 += 1;
			} while (uVar5 < (uint)(surfMap->smallDimensions).width);
		}
		fVar2 = reward->items[2].countdownRatio;
		uVar5 = (reward->buildingCounts).count;
		uVar9 = (reward->buildingCounts).numPrevLevels_unk;
		reward->uintConstructCount_1cc = uVar5;
		reward->uintConstruct_1d0 = uVar9;
		local_30 = 0;
		reward->items[1].countdownRatio = reward->items[1].countdownRatio - fVar2 * -4.0;
		if (uVar5 != 0) {
			out_buffer = reward->buildingNameBuffers;
			pRVar10 = &reward->buildingCounts;
			do {
				std::sprintf((char *)out_buffer,"%s",pRVar10->nameTable[0]);
				local_30 += 1;
				pRVar10 = (RewardBuildingCounts *)(pRVar10->nameTable + 1);
				out_buffer = out_buffer[1];
			} while (local_30 < reward->uintConstructCount_1cc);
		}
		uVar5 = reward->items[5].numGenerated;
		uVar9 = reward->uintConstruct_1d0;
		reward->items[0].countdown = (float)(ulonglong)(uint)level->numCrystals;
		uVar3 = reward->items[5].numDestroyed;
		reward->items[1].countdown = (float)(ulonglong)(uint)level->numOre;
		uVar4 = reward->items[6].numGenerated;
		reward->items[5].countdownRatio = (float)(ulonglong)uVar5;
		reward->items[5].countdown = (float)(ulonglong)(uVar5 - uVar3);
		reward->items[6].countdown = reward->items[6].damageTaken;
		uVar5 = reward->uintConstructCount_1cc;
		reward->items[6].countdownRatio = (float)(ulonglong)(uVar4 * 100);
		uVar9 = (uVar5 - uVar9) + 1;
		local_8 = reward->items[8].Quota;
		reward->items[3].countdownRatio = (float)(ulonglong)uVar5;
		reward->items[3].countdown = (float)(ulonglong)uVar9;
		if (local_8 == 0) {
			reward->items[8].percentFloat = 0.0;
			local_8 = uVar9;
		}
		else {
			fVar13 = (float10)reward->items[8].countdown * (float10)0.04;
			uStack4 = 0;
			if ((float10)(ulonglong)local_8 <= fVar13) {
				reward->items[8].percentFloat = (float)&DAT_42c80000;
			}
			else {
				uVar14 = __ftol(((float10)100.0 / (float10)(ulonglong)local_8) * fVar13);
				reward->items[8].percentFloat = (float)(uVar14 & 0xffffffff);
				fVar2 = reward->items[8].percentFloat;
				if ((ushort)((ushort)(fVar2 < 100.0) << 8 | (ushort)(fVar2 == 100.0) << 0xe) == 0) {
					puVar1 = &DAT_42c80000;
				}
				else {
					puVar1 = (undefined *)reward->items[8].percentFloat;
				}
				reward->items[8].percentFloat = (float)puVar1;
				if ((float)puVar1 < 0.0) {
					puVar1 = NULL;
				}
				reward->items[8].percentFloat = (float)puVar1;
				local_8 = (uint)uVar14;
			}
		}
		uVar5 = reward->items[3].Quota;
		if (uVar5 != 0) {
			uVar14 = 100 / (ulonglong)uVar5;
			local_8 = (uint)uVar14;
			reward->items[3].percentFloat = (float)uVar14 * reward->items[3].countdown;
		}
		uVar5 = reward->items[4].Quota;
		if (uVar5 != 0) {
			uVar14 = 100 / (ulonglong)uVar5;
			local_8 = (uint)uVar14;
			reward->items[4].percentFloat = (float)uVar14 * reward->items[4].countdown;
		}
		uVar5 = reward->items[0].Quota;
		if (uVar5 != 0) {
			reward->items[0].countdownRatio = (float)(ulonglong)uVar5;
			local_8 = uVar5;
		}
		uStack4 = 0;
		uVar5 = 0;
		do {
			if (uVar5 != 0x1080) {
				pcVar7 = reward->itemPtr->name + (uVar5 - 4);
				if ((ushort)((ushort)(*(float *)(pcVar7 + 0x38) < 100.0) << 8 |
										(ushort)(*(float *)(pcVar7 + 0x38) == 100.0) << 0xe) == 0) {
					puVar1 = &DAT_42c80000;
				}
				else {
					puVar1 = *(undefined **)(pcVar7 + 0x38);
				}
				*(undefined **)(pcVar7 + 0x38) = puVar1;
				if ((float)puVar1 < 0.0) {
					puVar1 = NULL;
				}
				*(undefined **)(pcVar7 + 0x38) = puVar1;
			}
			uVar5 += 0x210;
		} while (uVar5 < 0x14a0);
		Reward_PrepareCalculate();
		Reward_PrepareScroll();
		reward = &globals::g_RewardCur;
		for (iVar6 = 0xc63; iVar6 != 0; iVar6 += -1) {
			reward->Enabled = 0;
			reward = (RewardLevel *)&reward->saveHasCapture;
		}
		return TRUE;
	}
	return 0;
}



uint __cdecl lego::reward::Reward_GetLevelObjectsBuilt(char *objName,int objLevel,BOOL currentLevel)
{
	BOOL BVar1;
	uint count;
	ObjectType objType;
	
	BVar1 = game::Object_GetObjectByName(objName,&objType,(int *)&objName,NULL);
	if (BVar1 != 0) {
		count = game::LiveObject_GetLevelObjectsBuilt(objType,(int)objName,objLevel,currentLevel);
		return count;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_PrepareCalculate(void)
{
	float fVar1;
	float fVar2;
	float fVar3;
	undefined *puVar4;
	LevelData *pLVar5;
	RewardLevel *pRVar6;
	uint uVar7;
	
	pLVar5 = lrr::Lego_GetLevel();
	if (pLVar5 == NULL) {
		return 0;
	}
	pRVar6 = GetRewardLevel2(pLVar5->field_10);
	if (pRVar6 == NULL) {
		return 0;
	}
	pRVar6->items[9].countdown = 0.0;
	pRVar6->items[9].countdownRatio = 0.0;
	pRVar6->items[9].percentFloat = 0.0;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[0].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[0].countdownRatio) * pRVar6->items[0].countdown);
	}
	pRVar6->items[0].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[0].percentFloat = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[1].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[1].countdownRatio) * pRVar6->items[1].countdown);
	}
	pRVar6->items[1].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[1].percentFloat = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[2].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[2].countdownRatio) * pRVar6->items[2].countdown);
	}
	pRVar6->items[2].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[2].percentFloat = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->float_1b04 != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->float_1b04) * pRVar6->float_1b08);
	}
	pRVar6->float_1b0c = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->float_1b0c = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[7].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[7].countdownRatio) * pRVar6->items[7].countdown);
	}
	pRVar6->items[7].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[7].percentFloat = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[3].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[3].countdownRatio) * pRVar6->items[3].countdown);
	}
	pRVar6->items[3].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[3].percentFloat = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[5].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[5].countdownRatio) * pRVar6->items[5].countdown);
	}
	pRVar6->items[5].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[5].percentFloat = (float)puVar4;
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[6].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[6].countdownRatio) * pRVar6->items[6].countdown);
	}
	pRVar6->items[6].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[6].percentFloat = (float)puVar4;
	uVar7 = 0;
	if (0.0 < pRVar6->items[5].Importance) {
		do {
			uVar7 += 1;
			fVar1 = pRVar6->items[5].percentFloat;
			fVar2 = pRVar6->items[5].Importance;
			fVar3 = pRVar6->items[9].countdown;
			pRVar6->items[9].countdownRatio = pRVar6->items[9].countdownRatio - -100.0;
			pRVar6->items[9].countdown = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items[0].Importance) {
		do {
			uVar7 += 1;
			fVar1 = pRVar6->items[0].percentFloat;
			fVar2 = pRVar6->items[0].Importance;
			fVar3 = pRVar6->items[9].countdown;
			pRVar6->items[9].countdownRatio = pRVar6->items[9].countdownRatio - -100.0;
			pRVar6->items[9].countdown = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items[7].Importance) {
		do {
			uVar7 += 1;
			fVar1 = pRVar6->items[7].percentFloat;
			fVar2 = pRVar6->items[7].Importance;
			fVar3 = pRVar6->items[9].countdown;
			pRVar6->items[9].countdownRatio = pRVar6->items[9].countdownRatio - -100.0;
			pRVar6->items[9].countdown = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items[3].Importance) {
		do {
			uVar7 += 1;
			fVar1 = pRVar6->items[3].percentFloat;
			fVar2 = pRVar6->items[3].Importance;
			fVar3 = pRVar6->items[9].countdown;
			pRVar6->items[9].countdownRatio = pRVar6->items[9].countdownRatio - -100.0;
			pRVar6->items[9].countdown = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items[4].Importance) {
		do {
			uVar7 += 1;
			fVar1 = pRVar6->items[4].percentFloat;
			fVar2 = pRVar6->items[4].Importance;
			fVar3 = pRVar6->items[9].countdown;
			pRVar6->items[9].countdownRatio = pRVar6->items[9].countdownRatio - -100.0;
			pRVar6->items[9].countdown = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items[8].Importance) {
		fVar1 = pRVar6->items[9].countdownRatio;
		fVar2 = pRVar6->items[9].countdown;
		do {
			uVar7 += 1;
			fVar1 = fVar1 - -100.0;
			fVar2 = (100.0 - pRVar6->items[8].percentFloat) + fVar2;
		} while ((float)(ulonglong)uVar7 < pRVar6->items[8].Importance);
		pRVar6->items[9].countdown = fVar2;
		pRVar6->items[9].countdownRatio = fVar1;
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items[6].Importance) {
		do {
			uVar7 += 1;
			fVar1 = pRVar6->items[6].percentFloat;
			fVar2 = pRVar6->items[6].Importance;
			fVar3 = pRVar6->items[9].countdown;
			pRVar6->items[9].countdownRatio = pRVar6->items[9].countdownRatio - -100.0;
			pRVar6->items[9].countdown = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	fVar1 = pRVar6->items[9].countdown;
	fVar2 = pRVar6->items[9].countdownRatio;
	if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
		pRVar6->items[9].countdown = pRVar6->items[9].countdownRatio;
	}
	if (pRVar6->items[9].countdown < 0.0) {
		pRVar6->items[9].countdown = 0.0;
	}
	puVar4 = &DAT_42c80000;
	if (pRVar6->items[9].countdownRatio != 0.0) {
		puVar4 = (undefined *)((100.0 / pRVar6->items[9].countdownRatio) * pRVar6->items[9].countdown);
	}
	pRVar6->items[9].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[9].percentFloat = (float)puVar4;
	puVar4 = (undefined *)((float)(ulonglong)(uint)pRVar6->Modifier + pRVar6->items[9].percentFloat);
	pRVar6->items[9].percentFloat = (float)puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	pRVar6->items[9].percentFloat = (float)puVar4;
	return TRUE;
}



BOOL __cdecl lego::reward::Reward_PrepareScroll(void)
{
	LevelData *level;
	RewardLevel *rewardFront;
	float heightf;
	LevelCompleteStatus status;
	char *text;
	float widthf;
	
	heightf = (float)globs::mainGlobs.appHeight;
	widthf = (float)globs::mainGlobs.appWidth;
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return 0;
	}
	rewardFront = GetRewardLevel2(level->field_10);
	if (rewardFront != NULL) {
		Reward_PrepareValueText();
		RewardScroll_Create(&globals::g_RewardScroll,0,heightf * 0.05,widthf,
												heightf - heightf * 0.2857143,globals::g_Reward_ScrollSpeed);
		RewardScroll_SetDelay_Unk(globals::g_RewardScroll,400.0);
						// This has no effect. (flags |= 0;)
		RewardScroll_AddFlags(globals::g_RewardScroll,REWARDSCROLL_NONE);
						// Add label to display level name at top of screen.
		RewardScroll_AddLabel
							(globals::g_RewardScroll,level->FullName,globals::g_Reward_TitleFont,0.0,
							 (float)globs::mainGlobs.appHeight * 0.04,
							 REWARDSCROLL_LABEL_CENTERED|REWARDSCROLL_LABEL_NOSCROLL);
		status = level->status;
		text = globals::g_Reward_CompleteText;
		if (((status == LEVELSTATUS_COMPLETE) ||
				(text = globals::g_Reward_FailedText, status == LEVELSTATUS_FAILED)) ||
			 (text = globals::g_Reward_QuitText, status == LEVELSTATUS_FAILED_CRYSTALS)) {
			text = util::Util_RemoveUnderscores(text);
			std::sprintf(globals::g_LevelStatusMessage_text,"%s",text);
		}
						// Add label to display completion message just below level name.
		RewardScroll_AddLabel
							(globals::g_RewardScroll,globals::g_LevelStatusMessage_text,globals::g_Reward_Font,0.0
							 ,globals::g_Reward_VertSpacing,REWARDSCROLL_LABEL_CENTERED);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_PrepareValueText(void)
{
	char cVar1;
	LevelData *level;
	RewardLevel *reward;
	int iVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	undefined4 *puVar9;
	float10 fVar10;
	longlong lVar11;
	ulonglong uVar12;
	char *pcVar13;
	char buff2 [128];
	char buff1 [128];
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return 0;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward == NULL) {
		return 0;
	}
	lVar11 = __ftol((float10)reward->items[0].percentFloat);
	reward->items[0].percentInt = (int)lVar11;
	std::sprintf(reward->items[0].valueText,"%d%%%%",(int)lVar11);
	lVar11 = __ftol((float10)reward->items[1].percentFloat);
	reward->items[1].percentInt = (int)lVar11;
	std::sprintf(reward->items[1].valueText,"%d%%%%",(int)lVar11);
	lVar11 = __ftol((float10)reward->items[2].percentFloat);
	reward->items[2].percentInt = (int)lVar11;
	std::sprintf(reward->items[2].valueText,"%d%%%%",(int)lVar11);
	lVar11 = __ftol((float10)reward->float_1b0c);
	*(int *)&reward->field_0x1b24 = (int)lVar11;
	std::sprintf((char *)&reward->field_0x1ba8,"%d",(int)lVar11);
	uVar3 = reward->uintConstructCount_1cc;
	reward->items[3].percentInt = uVar3;
	std::sprintf(reward->items[3].valueText,"%d",uVar3);
	lVar11 = __ftol((float10)reward->items[4].percentFloat);
	reward->items[4].percentInt = (int)lVar11;
	std::sprintf(reward->items[4].valueText,"%d%%%%",(int)lVar11);
	lVar11 = __ftol((float10)reward->items[5].percentFloat);
	reward->items[5].percentInt = (int)lVar11;
	std::sprintf(reward->items[5].valueText,"%d%%%%",(int)lVar11);
	if (100.0 <= reward->items[6].damageTaken) {
		fVar10 = (float10)100.0;
	}
	else {
		fVar10 = (float10)reward->items[6].damageTaken;
	}
	lVar11 = __ftol(fVar10);
	reward->items[6].percentInt = (int)lVar11;
	std::sprintf(reward->items[6].valueText,"%d%%%%",(int)lVar11);
	lVar11 = __ftol((float10)reward->items[7].percentFloat);
	reward->items[7].percentInt = (int)lVar11;
	std::sprintf(reward->items[7].valueText,"%d%%%%",(int)lVar11);
	uVar12 = __ftol((float10)reward->items[8].countdown * (float10)reward->items[8].countdownRatio *
									(float10)0.04);
	reward->items[8].percentInt = (int)uVar12;
	uVar3 = (uint)((uVar12 & 0xffffffff) % 359999);
	std::sprintf(buff1,____EMPTYSTR__);
	if (uVar3 < 0xe11) {
		pcVar13 = "00:";
	}
	else {
		uVar4 = (uVar3 - 1) / 0xe10;
		uVar5 = uVar4;
		do {
			uVar3 -= 0xe10;
			uVar5 -= 1;
		} while (uVar5 != 0);
		if (uVar4 < 10) {
			pcVar13 = "0%d:";
		}
		else {
			pcVar13 = "%d:";
		}
		std::sprintf(buff2,pcVar13,uVar4);
		pcVar13 = buff2;
	}
	uVar5 = 0xffffffff;
	do {
		pcVar7 = pcVar13;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar7 = pcVar13 + 1;
		cVar1 = *pcVar13;
		pcVar13 = pcVar7;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	iVar2 = -1;
	pcVar13 = buff1;
	do {
		pcVar8 = pcVar13;
		if (iVar2 == 0) break;
		iVar2 += -1;
		pcVar8 = pcVar13 + 1;
		cVar1 = *pcVar13;
		pcVar13 = pcVar8;
	} while (cVar1 != '\0');
	puVar6 = (undefined4 *)(pcVar7 + -uVar5);
	puVar9 = (undefined4 *)(pcVar8 + -1);
	for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	if (uVar3 < 0x3d) {
		pcVar13 = "00.";
	}
	else {
		uVar4 = (uVar3 - 1) / 0x3c;
		uVar5 = uVar4;
		do {
			uVar3 -= 0x3c;
			uVar5 -= 1;
		} while (uVar5 != 0);
		if (uVar4 < 10) {
			pcVar13 = "0%d.";
		}
		else {
			pcVar13 = "%d.";
		}
		std::sprintf(buff2,pcVar13,uVar4);
		pcVar13 = buff2;
	}
	uVar5 = 0xffffffff;
	do {
		pcVar7 = pcVar13;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar7 = pcVar13 + 1;
		cVar1 = *pcVar13;
		pcVar13 = pcVar7;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	iVar2 = -1;
	pcVar13 = buff1;
	do {
		pcVar8 = pcVar13;
		if (iVar2 == 0) break;
		iVar2 += -1;
		pcVar8 = pcVar13 + 1;
		cVar1 = *pcVar13;
		pcVar13 = pcVar8;
	} while (cVar1 != '\0');
	puVar6 = (undefined4 *)(pcVar7 + -uVar5);
	puVar9 = (undefined4 *)(pcVar8 + -1);
	for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	if (uVar3 < 2) {
		pcVar13 = "00";
	}
	else {
		if (uVar3 - 1 < 10) {
			pcVar13 = "0%d";
		}
		else {
			pcVar13 = "%d";
		}
		std::sprintf(buff2,pcVar13,uVar3 - 1);
		pcVar13 = buff2;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar7 = pcVar13;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar7 = pcVar13 + 1;
		cVar1 = *pcVar13;
		pcVar13 = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar2 = -1;
	pcVar13 = buff1;
	do {
		pcVar8 = pcVar13;
		if (iVar2 == 0) break;
		iVar2 += -1;
		pcVar8 = pcVar13 + 1;
		cVar1 = *pcVar13;
		pcVar13 = pcVar8;
	} while (cVar1 != '\0');
	puVar6 = (undefined4 *)(pcVar7 + -uVar3);
	puVar9 = (undefined4 *)(pcVar8 + -1);
	for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	std::sprintf(reward->items[8].valueText,"%s",buff1);
	lVar11 = __ftol((float10)reward->items[9].percentFloat);
	reward->items[9].percentInt = (int)lVar11;
	std::sprintf(reward->items[9].valueText,"%d%%%%",(int)lVar11);
	return TRUE;
}



BOOL __cdecl lego::reward::Reward_Show(void)
{
	LevelData *level_reg;
	RewardLevel *reward;
	BOOL BVar1;
	Movie_t *mov;
	RewardItemType rewardTypeCapped;
	int i1;
	int off2;
	int i3;
	int off4;
	char *fName;
	int off1;
	int i2;
	int off3;
	RewardItemType rewardType;
	RewardUIState curState;
	float timer;
	BOOL finished;
	float lastTime;
	float delta;
	BOOL saved;
	LevelData *level;
	undefined4 uStack20;
	uint tmp_time1;
	undefined4 uStack12;
	uint tmp_time2;
	undefined4 uStack4;
	
	curState = REWARDSTATE_0;
	finished = 0;
	saved = 0;
	rewardType = REWARDTYPE_CRYSTALS;
	level = (LevelData *)main::Main_GetTime();
	uStack20 = 0;
	timer = globals::g_Reward_Timer;
	lastTime = (float)ZEXT48(level);
	level_reg = lrr::Lego_GetLevel();
	if (level_reg == NULL) {
		return 0;
	}
	level = level_reg;
	reward = GetRewardLevel2(level_reg->field_10);
	if (reward != NULL) {
		BVar1 = Reward_LoopBegin();
		if (BVar1 != 0) {
			while ((((int)curState < 4 || (globs::INPUT.mslb != 0)) || (globs::INPUT.lClicked != 0))) {
				tmp_time1 = main::Main_GetTime();
				uStack12 = 0;
				delta = ((float)(ulonglong)tmp_time1 - lastTime) * 0.001;
				tmp_time2 = main::Main_GetTime();
				uStack4 = 0;
				lastTime = (float)(ulonglong)tmp_time2;
				timer = delta + timer;
				Reward_UpdateState(&rewardType,&curState,&timer);
						// IsKeyReleased(KEY_SPACE) (57)  (or is mouse pressed)
						//  "Jump to next state(?)."
				if ((((globs::INPUT.Key_Map[57] == false) && (globs::INPUT.prevKey_Map[57] != false)) ||
						(globs::INPUT.lClicked != 0)) && ((int)curState < REWARDSTATE_3)) {
					curState += REWARDSTATE_1;
					if (curState == REWARDSTATE_3) {
						curState = REWARDSTATE_2;
					}
					if (((int)curState < REWARDSTATE_2) || (level_reg->status != LEVELSTATUS_COMPLETE)) {
						rewardType = REWARDTYPE_SCORE;
					}
					else {
						rewardType = REWARDTYPE__COUNT;
					}
				}
				if (globals::g_Reward_Wallpaper != NULL) {
					lego::image::Image_DisplayScaled(globals::g_Reward_Wallpaper,NULL,NULL,NULL);
				}
				i1 = 0;
						// for (int i1 = 0; i1 < rewardType; i1++)
				if (0 < (int)rewardType) {
					off1 = 0;
					do {
						Reward_DrawItem((RewardLevelItem *)(reward->itemPtr->name + off1 + -4),REWARDITEM_IMAGES
														,rewardType);
						i1 += 1;
						off1 += 0x210;
					} while (i1 < (int)rewardType);
				}
				i2 = 0;
						// for (int i2 = 0; i2 < min(rewardType, 9); i2++)
				off2 = 0;
				while( true ) {
					rewardTypeCapped = rewardType;
					if (9 < (int)rewardType) {
						rewardTypeCapped = REWARDTYPE_SCORE;
					}
					if ((int)rewardTypeCapped <= i2) break;
					Reward_DrawItem((RewardLevelItem *)(reward->itemPtr->name + off2 + -4),
													REWARDITEM_BOXIMAGES,rewardType);
					i2 += 1;
					off2 += 0x210;
				}
				i3 = 0;
						// for (int i3 = 0; i3 < rewardType; i3++)
				if (0 < (int)rewardType) {
					off3 = 0;
					do {
						Reward_DrawItem((RewardLevelItem *)(reward->itemPtr->name + off3 + -4),REWARDITEM_FLIC,
														rewardType);
						i3 += 1;
						off3 += 0x210;
					} while (i3 < (int)rewardType);
				}
				Reward_DrawAllValues(&rewardType,&finished);
				if ((finished != 0) && (Reward_DrawScore(rewardType), (int)curState < REWARDSTATE_3)) {
					Reward_HandleButtons(&curState,&saved);
				}
				RewardScroll_DrawLabels(globals::g_RewardScroll);
				if (curState == REWARDSTATE_3) {
					curState = REWARDSTATE__COUNT;
				}
				Reward_HandleDebugKeys(&rewardType,&curState,&finished,&timer);
				Reward_LoopUpdate(delta);
				level_reg = level;
			}
			RewardScroll_Free(&globals::g_RewardScroll);
						// for (int i = 0; i < 10; i++)
			off4 = 0;
			do {
				if ((reward->itemPtr->name[off4 + -4] & 4U) != 0) {
					lego::image::Flic_Close(*(Flic **)((int)&reward->itemPtr->Flic + off4));
					*(undefined4 *)((int)&reward->itemPtr->Flic + off4) = 0;
				}
				off4 += 0x210;
			} while (off4 < 0x14a0);
			snd::Sound3D_Stream_Stop(TRUE);
			if ((level_reg->status == LEVELSTATUS_COMPLETE) && (globs::legoGlobs.EndGameAVI1 != NULL)) {
				BVar1 = front::Front_SaveData_FUN_00418050();
				if ((BVar1 == 0) ||
					 (fName = globs::legoGlobs.EndGameAVI2, globs::legoGlobs.EndGameAVI2 == NULL)) {
					fName = globs::legoGlobs.EndGameAVI1;
				}
				BVar1 = lego::file::File_Exists(fName);
				if (BVar1 != 0) {
					mov = video::Movie_Load(fName);
						// not skippable
					front::Front_PlayMovie(mov,FALSE);
					video::Movie_Free(mov);
				}
				snd::SFX_Sample_AddToQueue(SFX_AMBIENTMUSICLOOP,SOUND_LOOP);
				front::MainMenuFull_TriggerShowCredits();
				snd::Sound3D_Stream_Stop(TRUE);
			}
			return TRUE;
		}
		return 0;
	}
	return 0;
}



void __cdecl
lego::reward::Reward_DrawItem
					(RewardLevelItem *rewardItem,RewardItemFlags flags,RewardItemType rewardType)
{
	char *pcVar1;
	RewardLevelItem *pRVar2;
	Flic *fsp;
	int iVar3;
	uint uVar4;
	Point2F local_3c;
	float local_34;
	Point2F local_30;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	Area2F destArea;
	
	if (rewardType == REWARDTYPE_CRYSTALS) {
		iVar3 = 0;
	}
	else {
		iVar3 = rewardType + REWARDTYPE__INVALID;
	}
	pRVar2 = globals::g_RewardLevel->itemPtr;
	if (((globals::g_Reward_DisplayImages != 0) &&
			((*(byte *)&rewardItem->flags & REWARDITEM_IMAGES) != 0)) &&
		 ((flags & REWARDITEM_IMAGES) != REWARDITEM_NONE)) {
		local_3c.x = (float)(rewardItem->ImagePosition).y;
		local_30.x = (float)(ulonglong)(uint)(rewardItem->ImagePosition).x;
		local_3c.y = 0.0;
		local_30.y = (float)(ulonglong)(uint)local_3c.x;
		lego::image::Image_DisplayScaled(rewardItem->Image,NULL,&local_30,NULL);
	}
	if (((globals::g_Reward_DisplayImages != 0) &&
			((*(byte *)&rewardItem->flags & REWARDITEM_BOXIMAGES) != 0)) &&
		 ((flags & REWARDITEM_BOXIMAGES) != REWARDITEM_NONE)) {
		local_30.x = (float)(rewardItem->BoxImagePosition).y;
		local_3c.x = (float)(ulonglong)(uint)(rewardItem->BoxImagePosition).x;
		local_30.y = 0.0;
		local_3c.y = (float)(ulonglong)(uint)local_30.x;
		lego::image::Image_DisplayScaled(rewardItem->BoxImage,NULL,&local_3c,NULL);
	}
	if (((globals::g_Reward_DisplayFlics != 0) &&
			((*(byte *)&rewardItem->flags & REWARDITEM_FLIC) != 0)) &&
		 ((flags & REWARDITEM_FLIC) != REWARDITEM_NONE)) {
		if (rewardItem->Flic == NULL) {
			lego::image::Flic_Setup(rewardItem->FlicName,&rewardItem->Flic,FLICDISK);
		}
		destArea.x = (float)(ulonglong)(uint)(rewardItem->FlicPosition).x;
		local_30.x = (float)(rewardItem->FlicSize).height;
		destArea.y = (float)(ulonglong)(uint)(rewardItem->FlicPosition).y;
		destArea.width = (float)(ulonglong)(uint)(rewardItem->FlicSize).width;
		fsp = rewardItem->Flic;
		local_30.y = 0.0;
		destArea.height = (float)(ulonglong)(uint)local_30.x;
		lego::image::Flic_Animate(fsp,&destArea,(uint)(fsp->currentframe < 0x23),0);
	}
	if (globals::g_Reward_DisplayText != 0) {
		if (((*(byte *)&rewardItem->flags & REWARDITEM_VALUETEXT) != 0) &&
			 ((flags & REWARDITEM_VALUETEXT) != REWARDITEM_NONE)) {
			uVar4 = lego::image::Font_GetStringWidth(rewardItem->Font,rewardItem->valueText);
			lego::image::Font_PrintF
								(rewardItem->Font,(rewardItem->TextPosition).x - (uVar4 >> 1),
								 (rewardItem->TextPosition).y,rewardItem->valueText);
			if (rewardType < REWARDTYPE__COUNT) {
				pcVar1 = pRVar2[iVar3].Text;
				uVar4 = lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,pcVar1);
				lego::image::Font_PrintF
									(globals::g_Reward_TitleFont,globals::g_Reward_TextPos.x - (uVar4 >> 1),
									 globals::g_Reward_TextPos.y,pcVar1);
			}
		}
		if ((globals::g_Reward_DisplayText != 0) &&
			 ((((rewardItem->flags & REWARDITEM_NAMETEXT) != REWARDITEM_NONE &&
				 ((flags & REWARDITEM_NAMETEXT) != REWARDITEM_NONE)) ||
				(((rewardItem->flags & REWARDITEM_NAMETEXT_HALFTRANS) != REWARDITEM_NONE &&
				 ((flags & REWARDITEM_NAMETEXT_HALFTRANS) != REWARDITEM_NONE)))))) {
			local_1c = 0.1176471;
			local_18 = 0.1176471;
			local_14 = 0.1176471;
			local_28 = 0.2352941;
			local_24 = 0.2352941;
			local_20 = 0.2352941;
			local_3c.x = 0.0;
			local_3c.y = 0.0;
			local_34 = 0.0;
			uVar4 = lego::image::Font_GetStringWidth(rewardItem->Font,rewardItem->valueText);
			local_30.x = (float)(uVar4 + 0x14);
			destArea.x = (float)(ulonglong)(((rewardItem->TextPosition).x - (uVar4 >> 1)) - 10);
			destArea.y = (float)(ulonglong)(uint)(rewardItem->TextPosition).y;
			local_30.y = 0.0;
			destArea.width = (float)(ulonglong)(uint)local_30.x;
			local_30.x = (float)lego::image::Font_GetHeight(rewardItem->Font);
			local_30.y = 0.0;
			destArea.height = (float)(ulonglong)(uint)local_30.x;
			front::ToolTip_DrawBox
								((Area2F)CONCAT412(destArea.height,
																	 CONCAT48(destArea.width,CONCAT44(destArea.y,destArea.x))),
								 local_1c,local_18,local_14,local_28,local_24,local_20,local_3c.x,local_3c.y,
								 local_34,flags & REWARDITEM_NAMETEXT_HALFTRANS);
			lego::image::Font_PrintF
								(rewardItem->Font,(rewardItem->TextPosition).x - (uVar4 >> 1),
								 (rewardItem->TextPosition).y,rewardItem->valueText);
			if (rewardType < REWARDTYPE__COUNT) {
				pcVar1 = pRVar2[iVar3].Text;
				uVar4 = lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,pcVar1);
				local_30.x = (float)(uVar4 + 0x14);
				destArea.x = (float)(ulonglong)((globals::g_Reward_TextPos.x - (uVar4 >> 1)) - 10);
				destArea.y = (float)(ulonglong)(uint)globals::g_Reward_TextPos.y;
				local_30.y = 0.0;
				destArea.width = (float)(ulonglong)(uint)local_30.x;
				local_30.x = (float)lego::image::Font_GetHeight(globals::g_Reward_TitleFont);
				local_30.y = 0.0;
				destArea.height = (float)(ulonglong)(uint)local_30.x;
				front::ToolTip_DrawBox
									((Area2F)CONCAT412(destArea.height,
																		 CONCAT48(destArea.width,CONCAT44(destArea.y,destArea.x))),
									 local_1c,local_18,local_14,local_28,local_24,local_20,local_3c.x,local_3c.y,
									 local_34,0);
				lego::image::Font_PrintF
									(globals::g_Reward_TitleFont,globals::g_Reward_TextPos.x - (uVar4 >> 1),
									 globals::g_Reward_TextPos.y,pcVar1);
			}
		}
	}
	return;
}



void __cdecl lego::reward::Reward_DrawScore(RewardItemType rewardType)
{
	char cVar1;
	LevelData *level;
	RewardLevel *reward;
	uint uVar2;
	RewardLevelItem *pRVar3;
	int iVar4;
	char *pcVar5;
	char buff2 [32];
	char buff1 [32];
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward == NULL) {
		return;
	}
	if (level->status == LEVELSTATUS_COMPLETE) {
		Reward_DrawItem(reward->itemPtr + 9,REWARDITEM_VALUETEXT,rewardType);
		std::sprintf(buff2,"%s",reward->itemPtr[9].Text);
		pRVar3 = reward->itemPtr;
		uVar2 = 0xffffffff;
		iVar4 = 0;
		pcVar5 = pRVar3[9].Text;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar5;
			pcVar5 = pcVar5 + 1;
		} while (cVar1 != '\0');
		if (0 < (int)(~uVar2 - 1)) {
			do {
				if (pRVar3[9].Text[iVar4] == ' ') {
					buff2[iVar4] = '\0';
					std::sprintf(buff1,"%s",buff2 + iVar4 + 1);
				}
				pRVar3 = reward->itemPtr;
				uVar2 = 0xffffffff;
				iVar4 += 1;
				pcVar5 = pRVar3[9].Text;
				do {
					if (uVar2 == 0) break;
					uVar2 -= 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar5 + 1;
				} while (cVar1 != '\0');
			} while (iVar4 < (int)(~uVar2 - 1));
		}
		pcVar5 = buff2;
		iVar4 = reward->itemPtr[9].TextPosition.y + -0x28;
		uVar2 = lego::image::Font_GetStringWidth(globals::g_Reward_BackFont,buff2);
		lego::image::Font_PrintF
							(globals::g_Reward_BackFont,reward->itemPtr[9].TextPosition.x - (uVar2 >> 1),iVar4,
							 pcVar5);
	}
	return;
}



void __cdecl lego::reward::Reward_HandleButtons(RewardUIState *out_state,BOOL *out_saved)
{
	float fVar1;
	bool bVar2;
	LevelData *level;
	RewardLevel *reward;
	BOOL BVar3;
	Image *image;
	
	bVar2 = false;
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward == NULL) {
		return;
	}
	if (level->status == LEVELSTATUS_COMPLETE) {
		fVar1 = (float)globs::INPUT.msx;
		image = globals::g_Reward_SaveButton;
		if (((((ushort)((ushort)(fVar1 < globals::g_Reward_SaveButtonPosition.x) << 8 |
									 (ushort)(fVar1 == globals::g_Reward_SaveButtonPosition.x) << 0xe) == 0) &&
				 (fVar1 < (float)(ulonglong)globals::g_Reward_SaveButton->width +
									globals::g_Reward_SaveButtonPosition.x)) &&
				(fVar1 = (float)globs::INPUT.msy,
				(ushort)((ushort)(fVar1 < globals::g_Reward_SaveButtonPosition.y) << 8 |
								(ushort)(fVar1 == globals::g_Reward_SaveButtonPosition.y) << 0xe) == 0)) &&
			 (fVar1 < (float)(ulonglong)globals::g_Reward_SaveButton->height +
								globals::g_Reward_SaveButtonPosition.y)) {
			front::ToolTip_AddFlag4(TOOLTIP_REWARD_SAVE);
			if (((globs::INPUT.mslb != 0) &&
					(image = globals::g_Reward_SaveButton_in, globals::g_Reward_SaveButton_in != NULL)) ||
				 (image = globals::g_Reward_SaveButton_hi, globals::g_Reward_SaveButton_hi != NULL)) {
				lego::image::Image_DisplayScaled(image,NULL,&globals::g_Reward_SaveButtonPosition,NULL);
			}
			BVar3 = front::Front_LeftButtonInputUnk_FUN_00435480();
			if (BVar3 != 0) {
				bVar2 = true;
				snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_OKAY,0);
				Reward_GotoSaveMenu();
				*out_saved = TRUE;
				snd::SFX_Sample_Sound3D_StopSound(SFX_MUSICLOOP);
				snd::SFX_Sample_AddToQueue(SFX_MUSICLOOP,SOUND_LOOP);
			}
			goto LAB_004621e1;
		}
	}
	else {
		image = globals::g_Reward_SaveButton_dim;
		if (globals::g_Reward_SaveButton_dim == NULL) goto LAB_004621e1;
	}
	lego::image::Image_DisplayScaled(image,NULL,&globals::g_Reward_SaveButtonPosition,NULL);
LAB_004621e1:
	fVar1 = (float)globs::INPUT.msx;
	if ((((ushort)((ushort)(fVar1 < globals::g_Reward_AdvanceButtonPosition.x) << 8 |
								(ushort)(fVar1 == globals::g_Reward_AdvanceButtonPosition.x) << 0xe) != 0) ||
			((float)(ulonglong)globals::g_Reward_AdvanceButton->width +
			 globals::g_Reward_AdvanceButtonPosition.x <= fVar1)) ||
		 ((fVar1 = (float)globs::INPUT.msy,
			(ushort)((ushort)(fVar1 < globals::g_Reward_AdvanceButtonPosition.y) << 8 |
							(ushort)(fVar1 == globals::g_Reward_AdvanceButtonPosition.y) << 0xe) != 0 ||
			((float)(ulonglong)globals::g_Reward_AdvanceButton->height +
			 globals::g_Reward_AdvanceButtonPosition.y <= fVar1)))) {
		lego::image::Image_DisplayScaled
							(globals::g_Reward_AdvanceButton,NULL,&globals::g_Reward_AdvanceButtonPosition,NULL);
	}
	else {
		front::ToolTip_AddFlag4(TOOLTIP_REWARD_ADVANCE);
		if (((globs::INPUT.mslb != 0) &&
				(image = globals::g_Reward_AdvanceButton_in, globals::g_Reward_AdvanceButton_in != NULL)) ||
			 (image = globals::g_Reward_AdvanceButton_hi, globals::g_Reward_AdvanceButton_hi != NULL)) {
			lego::image::Image_DisplayScaled(image,NULL,&globals::g_Reward_AdvanceButtonPosition,NULL);
		}
		BVar3 = front::Front_LeftButtonInputUnk_FUN_00435480();
		if (BVar3 != 0) {
			bVar2 = true;
			*out_state = REWARDSTATE_3;
			snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_OKAY,0);
			Reward_GotoAdvance();
		}
	}
	if ((!bVar2) && (BVar3 = front::Front_LeftButtonInputUnk_FUN_00435480(), BVar3 != 0)) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_NOTOKAY,0);
	}
	return;
}



void __cdecl lego::reward::Reward_GotoSaveMenu(void)
{
	LevelData *level2;
	BOOL BVar1;
	BOOL BVar2;
	LevelCollection *levelCol;
	int iVar3;
	SaveData *pSVar4;
	RewardLevel *reward;
	SaveData *pSVar5;
	LevelData *level;
	uint uVar6;
	SaveStruct_18 saveStruct18;
	SaveData saveData;
	char *levelName;
	
	level2 = lrr::Lego_GetLevel();
	front::Front_IsMenuLabelUnkValue1_NotM1();
	BVar1 = front::Front_GetUnkTutoOrMissions();
	front::PausedMenu_UpdateUnkStruct_FromSliderValues();
	BVar2 = front::Front_IsFrontEndEnabled();
	if (BVar2 != 0) {
		levelName = level2->levelName;
		levelCol = front::LevelCollections_GetTutorialOrMissions();
		iVar3 = front::LevelCollection_IndexOf(levelCol,levelName);
		front::LevelIndex_FUN_00417ec0(iVar3);
		iVar3 = save::Save_GetSaveNumber();
		pSVar4 = save::Save_GetCurrentSaveData();
		save::Save_CopyData(&saveData);
		reward = GetRewardLevel();
		if (BVar1 == 0) {
			BVar1 = game::Objective_IsLevelComplete();
			if (BVar1 != 0) {
				do {
					front::Front_RunScreenMenuType(MENU_SCREEN_SAVE);
				} while (BOOL_00558508 != 0);
				if (globals::g_SaveMenu_IsLoadMode == 1) {
					BVar1 = front::Front_GetBool_00558500();
					if (BVar1 != 0) {
						front::Front_FUN_00417f30();
						front::Front_SetBool_00558500(FALSE);
					}
					pSVar5 = save::Save_GetCurrentSaveData();
					if (pSVar5 != NULL) {
						pSVar5 = save::Save_GetCurrentSaveData();
						if ((pSVar5 != pSVar4) && (pSVar4 != NULL)) {
							front::Save_OverwriteData(&saveData);
							level = lrr::Lego_GetLevel();
							levelName = level->levelName;
							levelCol = front::LevelCollections_GetTutorialOrMissions();
							uVar6 = front::LevelCollection_IndexOf(levelCol,levelName);
							front::Front_LevelSave_Unk_FUN_00417de0(uVar6);
							levelName = level2->levelName;
							levelCol = front::LevelCollections_GetTutorialOrMissions();
							iVar3 = front::LevelCollection_IndexOf(levelCol,levelName);
							front::Front_CopyRewardToSave(iVar3,reward);
							save::Save_CopyStruct18(&saveStruct18);
							save::SaveStruct18_FUN_00417e50(&saveStruct18);
							front::Front_FUN_00417ef0();
							return;
						}
						level = lrr::Lego_GetLevel();
						levelName = level->levelName;
						levelCol = front::LevelCollections_GetTutorialOrMissions();
						uVar6 = front::LevelCollection_IndexOf(levelCol,levelName);
						front::Front_LevelSave_Unk_FUN_00417de0(uVar6);
						levelName = level2->levelName;
						levelCol = front::LevelCollections_GetTutorialOrMissions();
						iVar3 = front::LevelCollection_IndexOf(levelCol,levelName);
						front::Front_CopyRewardToSave(iVar3,reward);
						save::Save_CopyStruct18(&saveStruct18);
						save::SaveStruct18_FUN_00417e50(&saveStruct18);
						front::Front_FUN_00417ef0();
						return;
					}
					level2 = lrr::Lego_GetLevel();
					levelName = level2->levelName;
					levelCol = front::LevelCollections_GetTutorialOrMissions();
					front::LevelCollection_IndexOf(levelCol,levelName);
					return;
				}
				save::Save_SetSaveNumber(iVar3);
				pSVar4 = save::Save_GetCurrentSaveData();
				if (pSVar4 != NULL) {
					level = lrr::Lego_GetLevel();
					levelName = level->levelName;
					levelCol = front::LevelCollections_GetTutorialOrMissions();
					uVar6 = front::LevelCollection_IndexOf(levelCol,levelName);
					front::Front_LevelSave_Unk_FUN_00417de0(uVar6);
					levelName = level2->levelName;
					levelCol = front::LevelCollections_GetTutorialOrMissions();
					iVar3 = front::LevelCollection_IndexOf(levelCol,levelName);
					front::Front_CopyRewardToSave(iVar3,reward);
					save::Save_CopyStruct18(&saveStruct18);
					save::SaveStruct18_FUN_00417e50(&saveStruct18);
				}
			}
		}
	}
	return;
}



void __cdecl lego::reward::Reward_GotoAdvance(void)
{
	LevelData *level;
	LevelCollection *levelSet;
	uint levelIndex;
	int iVar1;
	RewardLevel *reward;
	SaveData *save;
	uint uVar2;
	SaveReward *pSVar3;
	MenuItemTrigger *pMVar4;
	char *levelName;
	undefined4 uVar5;
	
	level = lrr::Lego_GetLevel();
	levelName = level->levelName;
	levelSet = front::LevelCollections_GetTutorialOrMissions();
	levelIndex = front::LevelCollection_IndexOf(levelSet,levelName);
	iVar1 = lego::save::Save_GetSaveNumber();
	if (iVar1 == -1) {
		lego::save::Save_SetSaveNumber(5);
	}
	level = lrr::Lego_GetLevel();
	if (level->status == LEVELSTATUS_COMPLETE) {
		front::Front_LevelSave_Unk_FUN_00417de0(levelIndex);
	}
	reward = GetRewardLevel();
	front::Front_CopyRewardToSave(levelIndex,reward);
	if (iVar1 == -1) {
		save = lego::save::Save_GetSaveData_OfNumber(5);
		if (save != NULL) {
			pSVar3 = save->missionsTable + 1;
			for (uVar2 = save->missionsCount * 0x3190 - 0x3190 >> 2; uVar2 != 0; uVar2 -= 1) {
				pSVar3->flags = SAVEREWARD_NONE;
				pSVar3 = (SaveReward *)&pSVar3->reward;
			}
			for (iVar1 = 0; iVar1 != 0; iVar1 += -1) {
				*(undefined *)&pSVar3->flags = 0;
				pSVar3 = (SaveReward *)((int)&pSVar3->flags + 1);
			}
			level = lrr::Lego_GetLevel();
			if (level->status == LEVELSTATUS_COMPLETE) {
				front::Front_LevelSave_Unk_FUN_00417de0(levelIndex);
			}
			reward = GetRewardLevel();
			front::Front_CopyRewardToSave(levelIndex,reward);
		}
		front::Front_FUN_00417ef0();
		lego::save::Save_ReadSaveFile(5,globals::g_SaveData_TABLE + 5,FALSE);
	}
	uVar5 = 0;
	pMVar4 = *(MenuItemTrigger **)(globals::g_MainMenuFull->menus[1]->Items->length + 0x10);
	levelSet = &globals::g_MissionLevels;
	save = lego::save::Save_GetCurrentSaveData();
	front::LevelIdentifier_FUN_00417310
						(globals::g_StartMissionLevel,(int)save->missionsTable,levelSet,pMVar4,uVar5);
	front::Front_SetBool_0055881c(FALSE);
	return;
}



void __cdecl
lego::reward::Reward_HandleDebugKeys
					(RewardItemType *ref_rewardType,RewardUIState *ref_state,BOOL *ref_finished,
					float *ref_timer)
{
	LevelData *level;
	RewardLevel *reward;
	int off;
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward == NULL) {
		return;
	}
	if (((byte)globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != 0) {
						// IsKeyDown(KEY_SPACE) (57) && IsKeyPressed(KEY_ESCAPE) (1)
						//  "Terminate the program."
		if (((globs::INPUT.Key_Map[57] != false) && (globs::INPUT.Key_Map[1] != false)) &&
			 (globs::INPUT.prevKey_Map[1] != globs::INPUT.Key_Map[1])) {
			lrr::Lego_Exit();
		}
						// IsKeyPressed(KEY_R) (19)
						//  "Restart the rewards showcase from the beginning."
		if ((globs::INPUT.Key_Map[19] != false) &&
			 (globs::INPUT.prevKey_Map[19] != globs::INPUT.Key_Map[19])) {
			*ref_rewardType = REWARDTYPE_CRYSTALS;
			*ref_state = REWARDSTATE_0;
			*ref_timer = globals::g_Reward_Timer;
			*ref_finished = 0;
			snd::SFX_Sample_Sound3D_StopSound(SFX_MUSICLOOP);
			snd::SFX_Sample_AddToQueue(SFX_MUSICLOOP,SOUND_LOOP);
			off = 0;
			do {
				Reward_PlayFlic((RewardLevelItem *)(reward->itemPtr->name + off + -4));
				off += 0x210;
			} while (off < 0x14a0);
		}
	}
	return;
}



void __cdecl lego::reward::Reward_PlayFlic(RewardLevelItem *rewardItem)
{
	if ((*(byte *)&rewardItem->flags & REWARDITEM_FLIC) != 0) {
		lego::image::Flic_Close(rewardItem->Flic);
		lego::image::Flic_Setup(rewardItem->FlicName,&rewardItem->Flic,FLICDISK);
	}
	return;
}



void __cdecl
lego::reward::Reward_UpdateState
					(RewardItemType *ref_rewardType,RewardUIState *ref_state,float *ref_timer)
{
	char *sfxName;
	bool bVar1;
	LevelData *level;
	RewardLevel *reward;
	RewardItemType RVar2;
	BOOL BVar3;
	int off;
	bool bVar4;
	SFXType sfxType;
	
	bVar1 = false;
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward == NULL) {
		return;
	}
	if (globals::g_Reward_Timer <= *ref_timer) {
		bVar4 = *ref_state == REWARDSTATE_0;
		if (!bVar4) goto LAB_004627c2;
		bVar1 = true;
	}
	bVar4 = *ref_state == REWARDSTATE_0;
LAB_004627c2:
	if ((!bVar4) && (globals::g_Reward_Timer + globals::g_Reward_Timer <= *ref_timer)) {
		level = lrr::Lego_GetLevel();
		if ((level->status == LEVELSTATUS_COMPLETE) && ((int)*ref_rewardType < 10)) {
			bVar1 = true;
		}
	}
	if (bVar1) {
		*ref_timer = *ref_timer - globals::g_Reward_Timer;
		RVar2 = *ref_rewardType;
		if ((int)RVar2 < 10) {
			RVar2 += REWARDTYPE_ORE;
		}
		*ref_rewardType = RVar2;
		sfxName = reward->itemPtr[RVar2 + REWARDTYPE__INVALID].SoundName;
		if (sfxName != NULL) {
			BVar3 = snd::SFX_GetType(sfxName,&sfxType);
			if (BVar3 != 0) {
				snd::SFX_Sample_AddToQueue(sfxType,SOUND_ONCE);
			}
		}
		RVar2 = *ref_rewardType;
		if (9 < (int)RVar2) {
			if (*ref_state == REWARDSTATE_0) {
				*ref_rewardType = REWARDTYPE_SCORE;
				*ref_state = *ref_state + REWARDSTATE_1;
				return;
			}
			if ((9 < (int)RVar2) && (1 < (int)*ref_state)) {
				if (10 < (int)RVar2) {
					*ref_rewardType = REWARDTYPE__COUNT;
					*ref_state = *ref_state + REWARDSTATE_1;
					return;
				}
				off = 0;
				do {
					Reward_PlayFlic((RewardLevelItem *)(reward->itemPtr->name + off + -4));
					off += 0x210;
				} while (off < 0x14a0);
			}
		}
	}
	return;
}



void __cdecl lego::reward::Reward_DrawAllValues(RewardItemType *in_rewardType,BOOL *out_finished)
{
	RewardItemType rewardType;
	LevelData *level;
	RewardLevel *reward;
	RewardItemType rewardTypeCapped;
	int off;
	int i;
	
	level = lrr::Lego_GetLevel();
	if (level == NULL) {
		return;
	}
	reward = GetRewardLevel2(level->field_10);
	if (reward == NULL) {
		return;
	}
	if (((*in_rewardType == REWARDTYPE__COUNT) ||
			((level->status != LEVELSTATUS_COMPLETE && (*in_rewardType == REWARDTYPE_SCORE)))) &&
		 ((reward->items[9].Flic == NULL ||
			(((globals::g_Reward_DisplayFlics == 0 || (0x21 < (reward->itemPtr[9].Flic)->currentframe)) ||
			 (level->status != LEVELSTATUS_COMPLETE)))))) {
		*out_finished = TRUE;
	}
	i = 0;
	off = 0;
	while( true ) {
		rewardType = *in_rewardType;
		rewardTypeCapped = rewardType;
		if (9 < (int)rewardType) {
			rewardTypeCapped = REWARDTYPE_SCORE;
		}
		if ((int)rewardTypeCapped <= i) break;
		Reward_DrawItem((RewardLevelItem *)(reward->itemPtr->name + off + -4),REWARDITEM_VALUETEXT,
										rewardType);
		i += 1;
		off += 0x210;
	}
						// These calls serve no purpose
	lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,level->FullName);
	lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,globals::g_LevelStatusMessage_text);
	return;
}



void __cdecl lego::reward::Reward_LoopUpdate(float elapsed)
{
	front::Pointer_Update(1.0);
	front::Pointer_SetCurrent_IfTimerFinished(POINTER_STANDARD);
	front::Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
	front::Front_LeftButtonInputUnk_FUN_00435480();
	globs::INPUT.lClicked = FALSE;
	snd::SFX_Update(elapsed);
						// param_1 / 25.0 * 1000.0 (related to milliseconds)
	front::ToolTip_Update(globs::INPUT.msx,globs::INPUT.msy,elapsed * 0.04 * 1000.0);
	main::Main_LoopUpdate(TRUE);
	return;
}



BOOL __cdecl lego::reward::Reward_LoopBegin(void)
{
	LevelData *level;
	RewardLevel *reward;
	
	level = lrr::Lego_GetLevel();
	if (level != NULL) {
		reward = GetRewardLevel2(level->field_10);
		if (reward != NULL) {
			if ((globals::g_Reward_Display != 0) && (reward->Enabled != 0)) {
				while( true ) {
						// IsKeyUp(KEY_SPACE) && !IsKeyReleased(KEY_SPACE)  (57)
					if ((((globs::INPUT.Key_Map[57] == false) ||
							 (globs::INPUT.prevKey_Map[57] == globs::INPUT.Key_Map[57])) &&
							(globs::INPUT.Key_Map[57] == false)) &&
						 ((globs::INPUT.prevKey_Map[57] == false && (true)))) break;
					main::Main_LoopUpdate(TRUE);
				}
				globs::INPUT.lClicked = 0;
				snd::SFX_Sample_AddToQueue(SFX_MUSICLOOP,SOUND_LOOP);
				return TRUE;
			}
			Reward_GotoAdvance();
		}
	}
	return 0;
}



void __cdecl lego::reward::Rewards_UpdateTimers(float elapsedGame)
{
	globals::g_RewardCur.items[8].countdownRatio =
			 elapsedGame + globals::g_RewardCur.items[8].countdownRatio;
	globals::g_RewardCur.items[8].countdown = globals::g_RewardCur.items[8].countdown - -1.0;
	return;
}



void __cdecl lego::reward::Rewards_WallDestroyed(void)
{
						// table[REWARDTYPE_DIGGABLE]
	globals::g_RewardCur.items[2].countdown = globals::g_RewardCur.items[2].countdown - -1.0;
	return;
}



void __cdecl lego::reward::Rewards_CavernDiscovered(void)
{
						// table[REWARDTYPE_CAVERNS]
	globals::g_RewardCur.items[4].countdown = globals::g_RewardCur.items[4].countdown - -1.0;
	return;
}



void __cdecl lego::reward::Rewards_RockMonsterGenerated(void)
{
						// table[REWARDTYPE_ROCKMONSTERS]
	globals::g_RewardCur.items[6].numGenerated += 1;
	return;
}



void __cdecl lego::reward::Rewards_RockMonsterDestroyed(void)
{
						// table[REWARDTYPE_ROCKMONSTERS]
	globals::g_RewardCur.items[6].numDestroyed += 1;
	return;
}



// Seems to be when a rock monster is attacked with a weapon.

void __cdecl lego::reward::Rewards_RockMonsterAttacked(void)
{
						// table[REWARDTYPE_ROCKMONSTERS]
	globals::g_RewardCur.items[6].numAttacked += 1;
	return;
}



void __cdecl lego::reward::Rewards_RockMonsterDamageDealt(float damage)
{
	globals::g_RewardCur.items[6].damageTaken = damage + globals::g_RewardCur.items[6].damageTaken;
	return;
}



void __cdecl lego::reward::Rewards_MiniFigureDamageTaken(float damage)
{
	globals::g_RewardCur.items[5].damageTaken = damage + globals::g_RewardCur.items[5].damageTaken;
	return;
}



RewardScroll * __cdecl
lego::reward::RewardScroll_Create
					(RewardScroll **out_scroll,float zero,float heightDiv20,float width,float bottomSubDiv3pt5
					,float scrollSpeed)
{
	RewardScroll *front;
	RewardScrollLabel **itemsTable;
	RewardScrollLabel *pRVar1;
	int iVar2;
	RewardScroll *pRVar3;
	
	front = (RewardScroll *)std::malloc(0x28);
	if (front != NULL) {
		pRVar3 = front;
						// std::memset(front, 0, 0x28);
		for (iVar2 = 10; iVar2 != 0; iVar2 += -1) {
			pRVar3->yInitial = 0.0;
			pRVar3 = (RewardScroll *)&pRVar3->xPos;
		}
		itemsTable = (RewardScrollLabel **)std::malloc(4);
		front->labels = itemsTable;
		pRVar1 = (RewardScrollLabel *)std::malloc(0x20);
		*itemsTable = pRVar1;
						// std::memset(itemsTable[0], 0, 0x20);
		for (iVar2 = 8; iVar2 != 0; iVar2 += -1) {
			pRVar1->mode = REWARDSCROLL_MODE_NONE;
			pRVar1 = (RewardScrollLabel *)&pRVar1->xPos;
		}
		front->scrollSpeed = scrollSpeed;
		front->xPos = zero;
		front->yPos = heightDiv20;
		front->width = width;
		front->height = bottomSubDiv3pt5;
		front->yInitial = heightDiv20;
	}
	*out_scroll = front;
	return front;
}



BOOL __cdecl lego::reward::RewardScroll_Free(RewardScroll **ref_scroll)
{
	RewardScroll *scroll;
	uint i;
	char *text;
	
	i = 0;
	scroll = *ref_scroll;
	if (scroll->labelCount != 0) {
		do {
			text = scroll->labels[i]->text;
			if (text != NULL) {
				std::free(text);
			}
			std::free((*ref_scroll)->labels[i]);
			scroll = *ref_scroll;
			i += 1;
		} while (i < scroll->labelCount);
	}
	if ((*ref_scroll)->labels != NULL) {
		std::free((*ref_scroll)->labels);
	}
	std::free(*ref_scroll);
	return TRUE;
}



RewardScrollLabel * __cdecl
lego::reward::RewardScroll_AddLabel
					(RewardScroll *scroll,char *text,Font *font,float xPos,float yPos,
					RewardScrollLabelFlags labelFlags)
{
	char cVar1;
	RewardScrollLabel **itemsTable;
	RewardScrollLabel *item;
	char *textCpy;
	int iVar2;
	uint uVar3;
	uint idx;
	
	if (font == NULL) {
		return NULL;
	}
	idx = scroll->labelCount;
	scroll->labelCount = idx + 1;
	itemsTable = (RewardScrollLabel **)std::realloc(scroll->labels,(idx + 1) * 4);
	scroll->labels = itemsTable;
	item = (RewardScrollLabel *)std::malloc(0x20);
	scroll->labels[idx] = item;
	item = scroll->labels[idx];
	for (iVar2 = 8; iVar2 != 0; iVar2 += -1) {
		item->mode = REWARDSCROLL_MODE_NONE;
		item = (RewardScrollLabel *)&item->xPos;
	}
	scroll->labels[idx]->xPos = xPos;
	scroll->labels[idx]->yPos = yPos;
	uVar3 = 0xffffffff;
	textCpy = text;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *textCpy;
		textCpy = textCpy + 1;
	} while (cVar1 != '\0');
	textCpy = (char *)std::malloc(~uVar3);
	scroll->labels[idx]->text = textCpy;
	std::sprintf(scroll->labels[idx]->text,"%s",text);
	scroll->labels[idx]->mode = REWARDSCROLL_MODE_TEXT;
	scroll->labels[idx]->font = font;
	scroll->labels[idx]->flags = scroll->labels[idx]->flags | labelFlags;
	return scroll->labels[idx];
}



// This name is purely speculation. The passed value is 400.0

void __cdecl lego::reward::RewardScroll_SetDelay_Unk(RewardScroll *scroll,float curScrollY)
{
	scroll->curScrollY = curScrollY;
	return;
}



void __cdecl lego::reward::RewardScroll_AddFlags(RewardScroll *scroll,RewardScrollFlags flags)
{
	scroll->flags = scroll->flags | flags;
	return;
}



BOOL __cdecl lego::reward::RewardScroll_DrawLabels(RewardScroll *scroll)
{
	float fVar1;
	RewardScrollLabel **pLabel;
	uint strWidth;
	RewardScrollLabelFlags RVar2;
	RewardScroll *pRVar3;
	longlong lVar4;
	ulonglong textYPos;
	int textXPos;
	uint i;
	int dec;
	Size2F destSize;
	Point2F destPos;
	RewardScrollLabel *label;
	RewardScrollLabelMode labelMode;
	RewardScroll *scroll_00;
	
	scroll_00 = scroll;
	i = 0;
	if (scroll->labelCount != 0) {
		do {
			label = scroll_00->labels[i];
			lVar4 = __ftol((float10)label->xPos + (float10)scroll_00->xPos);
			textXPos = (int)lVar4;
			textYPos = __ftol((float10)label->yPos + (float10)scroll_00->yPos);
			scroll = (RewardScroll *)textYPos;
			if ((*(byte *)&scroll_00->flags & 1) != 0) {
				if ((float)(int)scroll < scroll_00->yInitial) {
					lVar4 = __ftol((float10)scroll_00->curScrollY + (float10)scroll_00->height);
					do {
						scroll = (RewardScroll *)((int)&scroll->yInitial + (int)lVar4);
						textYPos = ZEXT48(scroll);
					} while ((float)(int)scroll < scroll_00->yInitial);
				}
				pRVar3 = (RewardScroll *)textYPos;
				fVar1 = scroll_00->curScrollY + scroll_00->yInitial + scroll_00->height;
				if ((ushort)((ushort)((float)(int)scroll < fVar1) << 8 |
										(ushort)((float)(int)scroll == fVar1) << 0xe) == 0) {
					lVar4 = __ftol((float10)scroll_00->height);
					do {
						pRVar3 = (RewardScroll *)((int)pRVar3 - (int)lVar4);
						textYPos = ZEXT48(pRVar3);
						scroll = pRVar3;
					} while ((ushort)((ushort)((float)(int)pRVar3 < fVar1) << 8 |
													 (ushort)((float)(int)pRVar3 == fVar1) << 0xe) == 0);
				}
			}
			labelMode = label->mode;
			if (labelMode == REWARDSCROLL_MODE_WINDOW) {
				front::TextWindow_ChangePosition(label->textWnd,textXPos,(int)textYPos);
				front::TextWindow_Update
									(scroll_00->labels[i]->textWnd,0,globs::mainGlobs.fixedFrameTiming,NULL);
LAB_00462e93:
				destPos.x = (float)textXPos;
				pLabel = scroll_00->labels + i;
				destPos.y = (float)(int)scroll;
				destSize.width = (float)(ulonglong)(*pLabel)->image->width;
				destSize.height = (float)(ulonglong)(*pLabel)->image->height;
				lego::image::Image_DisplayScaled((*pLabel)->image,NULL,&destPos,&destSize);
LAB_00462ef7:
				label = scroll_00->labels[i];
						// Centered flag maybe(?)
				if ((*(byte *)&label->flags & REWARDSCROLL_LABEL_CENTERED) != 0) {
					strWidth = lego::image::Font_GetStringWidth(label->font,label->text);
					lVar4 = __ftol(((float10)scroll_00->width - (float10)scroll_00->xPos) * (float10)-0.5);
					textXPos += -(int)lVar4 - (strWidth >> 1);
				}
				textYPos &= 0xffffffff;
				label = scroll_00->labels[i];
				RVar2 = label->flags & REWARDSCROLL_LABEL_NOSCROLL;
				if (RVar2 != REWARDSCROLL_LABEL_NONE) {
					textYPos = __ftol((float10)label->yPos);
					scroll = (RewardScroll *)textYPos;
				}
				if ((RVar2 != REWARDSCROLL_LABEL_NONE) ||
					 ((fVar1 = (float)(int)scroll, fVar1 < scroll_00->height + scroll_00->yInitial &&
						((ushort)((ushort)(fVar1 < scroll_00->yInitial) << 8 |
										 (ushort)(fVar1 == scroll_00->yInitial) << 0xe) == 0)))) {
					lego::image::Font_PrintF(label->font,textXPos,(int)textYPos,label->text);
				}
			}
			else {
				if (labelMode == REWARDSCROLL_MODE_IMAGE) goto LAB_00462e93;
				if (labelMode == REWARDSCROLL_MODE_TEXT) goto LAB_00462ef7;
			}
			i += 1;
		} while (i < scroll_00->labelCount);
	}
	scroll_00->yPos = scroll_00->yPos - scroll_00->scrollSpeed;
	if (((byte)globs::legoGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != 0) {
						// IsKeyDown(KEY_S) (31)
						//  "Stop scroll speed (set to zero)."
		if (globs::INPUT.Key_Map[31] != false) {
			scroll_00->scrollSpeed = 0.0;
		}
						// IsKeyDown(KEY_R) (19)
						//  "Reset scroll position. (Also restarts rewards UI, defined somewhere else)."
		if (globs::INPUT.Key_Map[19] != false) {
			scroll_00->yPos = scroll_00->yInitial;
		}
						// IsKeyDown(KEY_EQUALS) (13)
						//  "Decrease (increase upwards) scrollSpeed."
		if (globs::INPUT.Key_Map[13] != false) {
			scroll_00->scrollSpeed = scroll_00->scrollSpeed - -0.01;
		}
						// IsKeyDown(KEY_MINUS) (12)
						//  "Increase (increase downwards) scrollSpeed."
		if (globs::INPUT.Key_Map[12] != false) {
			scroll_00->scrollSpeed = scroll_00->scrollSpeed - 0.01;
		}
		scroll = NULL;
		dec = 0;
		do {
						// Ghidra really messed this one up...
						//  "Assign leveled scrollSpeed. [0 = 100%, 9 = 90%..., 1 = 10%]"
						// 
						// for (int k = 0; k < 10; k++)
						//   IsKeyDown(KEY_ONE + k)  (2)
			if (*(char *)((int)&scroll[0x2f7e3].yPos + 2) != '\0') {
				pRVar3 = scroll;
				if (scroll_00->scrollSpeed < 0.0) {
					pRVar3 = (RewardScroll *)dec;
				}
				scroll_00->scrollSpeed = (float)(int)pRVar3 * 0.1;
			}
			scroll = (RewardScroll *)((int)&scroll->yInitial + 1);
			dec += -1;
		} while (-10 < dec);
	}
	return TRUE;
}



BOOL __cdecl lego::game::Roof_Initialise(Container *contRoot,int width,int height)
{
	uint i;
	uint count;
	
	globs::roofGlobs.contMesh = res::Container_MakeMesh2(contRoot,CONTAINER_MESHTYPE_IMMEDIATE);
	if (globs::roofGlobs.contMesh != NULL) {
		globs::roofGlobs.texture = NULL;
		count = height * width;
		globs::roofGlobs.hidden = 0;
		globs::roofGlobs.grid = (RoofBlock *)std::malloc(count * 8);
		if (globs::roofGlobs.grid != NULL) {
			i = 0;
			if (count != 0) {
				do {
					globs::roofGlobs.grid[i].groupID = D3DRMGROUP_0;
						// = ROOF_HIDDEN; // TRUE equate only present because of Ghidra register propagation
					*(undefined *)&globs::roofGlobs.grid[i].flags = TRUE;
					i += 1;
				} while (i < count);
			}
			globs::roofGlobs.dimensions.width = width;
			globs::roofGlobs.dimensions.height = height;
			globs::roofGlobs.needsUpdate = TRUE;
			globs::roofGlobs.visibleCount = 0;
			return TRUE;
		}
		res::Container_Remove(globs::roofGlobs.contMesh);
	}
	return 0;
}



BOOL __cdecl lego::game::Roof_SetTexture(char *filename)
{
	D3DRMGroupIndex count;
	D3DRMGroupIndex groupID;
	
	if (globs::roofGlobs.texture != NULL) {
		res::Container_FreeTexture(globs::roofGlobs.texture);
	}
	globs::roofGlobs.texture = res::Container_LoadTexture2(filename,TRUE,NULL,NULL);
	if (globs::roofGlobs.texture != NULL) {
		count = res::Container_Mesh_GetGroupCount(globs::roofGlobs.contMesh);
		groupID = D3DRMGROUP_0;
		if (count != D3DRMGROUP_0) {
			do {
				res::Container_Mesh_SetTexture(globs::roofGlobs.contMesh,groupID,globs::roofGlobs.texture);
				groupID += 1;
			} while (groupID < count);
		}
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Roof_Shutdown(void)
{
	if (globs::roofGlobs.grid != NULL) {
		std::free(globs::roofGlobs.grid);
	}
	globs::roofGlobs.grid = NULL;
	if (globs::roofGlobs.contMesh != NULL) {
		res::Container_Remove(globs::roofGlobs.contMesh);
	}
	globs::roofGlobs.contMesh = NULL;
	res::Container_FreeTexture(globs::roofGlobs.texture);
	return;
}



// FLAGS:
//  0x1 - get/set : unset if true (adds mesh group, texture, then hides?)
//  0x2 - set : implicit set to true (this block has lowered vertices that need updating?)
//  0x4 - set : specifies how assigned vertices are ordered/shifted.

void __cdecl
lego::game::Roof_LowerBlockRoofVertices
					(uint bx,uint by,Vector3F *vertPos0,Vector3F *vertPos1,Vector3F *vertPos2,
					Vector3F *vertPos3)
{
	ushort uVar1;
	byte flagsByte;
	D3DRMGroupIndex groupID;
	D3DRMVertex vertices [4];
	uint faceData [6];
	bool bShiftVertices;
	RoofBlock *roof;
	
	roof = globs::roofGlobs.grid + by * globs::roofGlobs.dimensions.width + bx;
						// I'm not sure how this is supposed to function for already-visible roof tiles (maybe
						// it's handled separately?)
						// 
						// if (roof->flags & ROOF_HIDDEN) // (0x1) has roof never been visible?
	bShiftVertices = false;
	if ((*(byte *)&roof->flags & 1) != 0) {
		faceData[0] = 0;
		faceData[2] = 3;
		faceData[5] = 3;
		faceData[1] = 1;
		faceData[3] = 1;
		faceData[4] = 2;
		groupID = res::Container_Mesh_AddGroup(globs::roofGlobs.contMesh,4,2,3,faceData);
		roof->groupID = groupID;
		if (groupID != D3DRMGROUP_ALLGROUPS) {
			res::Container_Mesh_SetTexture(globs::roofGlobs.contMesh,groupID,globs::roofGlobs.texture);
			res::Container_Mesh_SetPerspectiveCorrection(globs::roofGlobs.contMesh,roof->groupID,1);
			res::Container_Mesh_HideGroup(globs::roofGlobs.contMesh,roof->groupID,1);
						// &= ~ROOF_HIDDEN; // (~0x1) roof mesh has been created, unset flag
			*(byte *)&roof->flags = *(byte *)&roof->flags & 0xfe;
		}
	}
						// At least one block has been added that needs processing by RoofMesh_Update
	globs::roofGlobs.needsUpdate = 1;
	*(byte *)&roof->flags = *(byte *)&roof->flags | ROOF_NEEDUPDATE;
	if (vertPos2->z <= vertPos0->z) {
		if ((ushort)((ushort)(vertPos2->z < vertPos1->z) << 8 |
								(ushort)(vertPos2->z == vertPos1->z) << 0xe) != 0) {
			uVar1 = (ushort)(vertPos2->z < vertPos3->z) << 8 | (ushort)(vertPos2->z == vertPos3->z) << 0xe
			;
			goto joined_r0x0046334a;
		}
	}
	else {
		if ((ushort)((ushort)(vertPos0->z < vertPos1->z) << 8 |
								(ushort)(vertPos0->z == vertPos1->z) << 0xe) != 0) {
			uVar1 = (ushort)(vertPos0->z < vertPos3->z) << 8 | (ushort)(vertPos0->z == vertPos3->z) << 0xe
			;
joined_r0x0046334a:
			if (uVar1 != 0) goto LAB_00463350;
		}
	}
	bShiftVertices = true;
LAB_00463350:
	if (bShiftVertices) {
						// Assign vertex positions in order: [1->3], [2->2], [3->1], [0->0]
		vertices[3].position.x = vertPos1->x;
		vertices[3].position.y = vertPos1->y;
		vertices[3].position.z = vertPos1->z;
		vertices[2].position.x = vertPos2->x;
		vertices[2].position.y = vertPos2->y;
		vertices[2].position.z = vertPos2->z;
		vertices[1].position.x = vertPos3->x;
		vertices[1].position.y = vertPos3->y;
		vertices[1].position.z = vertPos3->z;
		vertices[0].position.x = vertPos0->x;
		vertices[0].position.y = vertPos0->y;
		vertices[0].position.z = vertPos0->z;
						// |= ROOF_SHIFTVERTICES; // (0x4)
		flagsByte = *(byte *)&roof->flags | ROOF_SHIFTVERTICES;
	}
	else {
						// Assign vertex positions in order: [0->3], [1->2], [2->1], [3->0]
		vertices[3].position.x = vertPos0->x;
		vertices[3].position.y = vertPos0->y;
		vertices[3].position.z = vertPos0->z;
		vertices[2].position.x = vertPos1->x;
		vertices[2].position.y = vertPos1->y;
		vertices[2].position.z = vertPos1->z;
		vertices[1].position.x = vertPos2->x;
		vertices[1].position.y = vertPos2->y;
		vertices[1].position.z = vertPos2->z;
		vertices[0].position.x = vertPos3->x;
		vertices[0].position.y = vertPos3->y;
		vertices[0].position.z = vertPos3->z;
						// &= ~ROOF_SHIFTVERTICES; // (~0x4)
		flagsByte = *(byte *)&roof->flags & 0xfb;
	}
	*(byte *)&roof->flags = flagsByte;
	vertices[3].normal.x = 0.0;
	vertices[3].normal.z = 0.0;
	vertices[2].normal.x = 0.0;
	vertices[2].normal.z = 0.0;
	vertices[1].normal.x = 0.0;
	vertices[1].normal.z = 0.0;
	vertices[0].normal.x = 0.0;
	vertices[0].normal.z = 0.0;
	vertices[3].normal.y = 0.0;
	vertices[2].normal.y = 0.0;
	vertices[1].normal.y = 0.0;
	vertices[0].normal.y = 0.0;
						// white (no coloration)
	vertices[3].colour = 0xffffffff;
	vertices[2].colour = 0xffffffff;
	vertices[1].colour = 0xffffffff;
	vertices[0].colour = 0xffffffff;
	vertices[3].tu = 0.0;
	vertices[3].tv = 1.0;
	vertices[2].tu = 1.0;
	vertices[2].tv = 1.0;
	vertices[1].tu = 1.0;
	vertices[1].tv = 0.0;
	vertices[0].tu = 0.0;
	vertices[0].tv = 0.0;
	res::Container_Mesh_SetVertices(globs::roofGlobs.contMesh,roof->groupID,0,4,vertices);
	return;
}



// FLAGS:
//  0x2 - get/set : unset if true
//  0x4 - get : shift down vertex index

void __cdecl lego::game::Roof_Update(void)
{
	float fVar1;
	uint dirIndex;
	BOOL BVar2;
	uint width;
	uint i;
	int idx;
	float *pNormalZ;
	Point2I *pDir;
	uint x;
	uint y;
	int j;
	Vector3F worldPos;
	Point2I DIRECTIONS_4X4 [16];
	D3DRMVertex vertices [4];
	RoofBlock *roof;
	
	if (globs::roofGlobs.needsUpdate != 0) {
		globs::roofGlobs.needsUpdate = 0;
		y = 0;
		width = globs::roofGlobs.dimensions.width;
		if (globs::roofGlobs.dimensions.height != 0) {
			do {
				x = 0;
				if (width != 0) {
					do {
						idx = y * width + x;
						// Roof vertex has been updated by RoofMesh_LowerRoofVertices.
						//  Update it here, and unset the flag.
						roof = globs::roofGlobs.grid + idx;
						if ((*(byte *)&globs::roofGlobs.grid[idx].flags & ROOF_NEEDUPDATE) != 0) {
							DIRECTIONS_4X4[2].y = 1;
							DIRECTIONS_4X4[3].y = 1;
							DIRECTIONS_4X4[5].x = 1;
							DIRECTIONS_4X4[6].x = 1;
							DIRECTIONS_4X4[6].y = 1;
							DIRECTIONS_4X4[7].y = 1;
							DIRECTIONS_4X4[10].x = 1;
							DIRECTIONS_4X4[11].x = 1;
							DIRECTIONS_4X4[1].x = -1;
							DIRECTIONS_4X4[3].x = -1;
							DIRECTIONS_4X4[9].y = -1;
							DIRECTIONS_4X4[10].y = -1;
							DIRECTIONS_4X4[13].x = -1;
							DIRECTIONS_4X4[13].y = -1;
							DIRECTIONS_4X4[14].y = -1;
							DIRECTIONS_4X4[15].x = -1;
							DIRECTIONS_4X4[0].x = 0;
							DIRECTIONS_4X4[0].y = 0;
							DIRECTIONS_4X4[1].y = 0;
							DIRECTIONS_4X4[2].x = 0;
							DIRECTIONS_4X4[4].x = 0;
							DIRECTIONS_4X4[4].y = 0;
							DIRECTIONS_4X4[5].y = 0;
							DIRECTIONS_4X4[7].x = 0;
							DIRECTIONS_4X4[8].x = 0;
							DIRECTIONS_4X4[8].y = 0;
							DIRECTIONS_4X4[9].x = 0;
							DIRECTIONS_4X4[11].y = 0;
							DIRECTIONS_4X4[12].x = 0;
							DIRECTIONS_4X4[12].y = 0;
							DIRECTIONS_4X4[14].x = 0;
							DIRECTIONS_4X4[15].y = 0;
							res::Container_Mesh_GetVertices(globs::roofGlobs.contMesh,roof->groupID,0,4,vertices);
							i = 0;
						// loop for DIRECTIONS_4X4[i...][]
							pNormalZ = &vertices[0].normal.z;
							do {
						// Some counter-clockwise flag maybe?
								dirIndex = i;
						// GHIDRA FAIL: setting 0x4 flag equate causes Ghidra to hang
						// 
						// if (roof->flags & ROOF_SHIFTVERTICES) // (0x4)
								if ((*(byte *)&roof->flags & 4) != 0) {
									dirIndex = i - 1 & 3;
								}
								j = 4;
						// loop for DIRECTIONS_4X4[dirIndex][j...]
								pDir = DIRECTIONS_4X4 + dirIndex * 4;
								do {
									BVar2 = Roof_GetBlockPlaneNormal(x + pDir->x,pDir->y + y,&worldPos);
									if (BVar2 != 0) {
										pNormalZ[-2] = worldPos.x + pNormalZ[-2];
										pNormalZ[-1] = worldPos.y + pNormalZ[-1];
										*pNormalZ = worldPos.z + *pNormalZ;
									}
									pDir = pDir + 1;
									j += -1;
								} while (j != 0);
								i += 1;
								fVar1 = 1.0 / SQRT(pNormalZ[-2] * pNormalZ[-2] +
																	 *pNormalZ * *pNormalZ + pNormalZ[-1] * pNormalZ[-1]);
								*pNormalZ = fVar1 * *pNormalZ;
								pNormalZ[-2] = fVar1 * pNormalZ[-2];
								pNormalZ[-1] = fVar1 * pNormalZ[-1];
								pNormalZ = pNormalZ + 9;
							} while (i < 4);
							res::Container_Mesh_SetVertices(globs::roofGlobs.contMesh,roof->groupID,0,4,vertices);
						// &= ~ROOF_NEEDUPDATE; // (~0x2) updated, so clear flag
							*(byte *)&roof->flags = *(byte *)&roof->flags & 0xfd;
							width = globs::roofGlobs.dimensions.width;
						}
						x += 1;
					} while (x < width);
				}
				y += 1;
			} while (y < (uint)globs::roofGlobs.dimensions.height);
		}
	}
	return;
}



void __cdecl lego::game::Roof_Hide(BOOL hide)
{
	if (globs::roofGlobs.hidden != hide) {
		globs::roofGlobs.hidden = hide;
		if (hide != 0) {
			res::Container_Hide(globs::roofGlobs.contMesh,TRUE);
			return;
		}
		res::Container_Hide(globs::roofGlobs.contMesh,FALSE);
	}
	return;
}



// I'm not actually sure if this is supposed to be "visible" blocks. But it's a
//  list of blocks that are assigned and cleared, all in a single FP update loop.

void __cdecl lego::game::Roof_AddVisibleBlock(uint bx,uint by)
{
	int idx;
	RoofBlock *roof;
	
	idx = by * globs::roofGlobs.dimensions.width + bx;
	roof = globs::roofGlobs.grid + idx;
	res::Container_Mesh_HideGroup(globs::roofGlobs.contMesh,globs::roofGlobs.grid[idx].groupID,FALSE);
	globs::roofGlobs.visibleTable[globs::roofGlobs.visibleCount] = roof;
	globs::roofGlobs.visibleCount = globs::roofGlobs.visibleCount + 1;
	return;
}



void __cdecl lego::game::Roof_HideAllVisibleBlocks(void)
{
	uint i;
	RoofBlock **pRoof;
	
	i = 0;
	if (globs::roofGlobs.visibleCount != 0) {
		pRoof = globs::roofGlobs.visibleTable;
		do {
			res::Container_Mesh_HideGroup(globs::roofGlobs.contMesh,(*pRoof)->groupID,TRUE);
			i += 1;
			pRoof = pRoof + 1;
		} while (i < globs::roofGlobs.visibleCount);
	}
	globs::roofGlobs.visibleCount = 0;
	return;
}



// FLAGS:
//  0x1 - get : if false, this function succeeds (assuming correct block bounds)
// 
// I'm really not sure about the math for this one, or what kind of vector is
//  really being returned. But it's used for setting vertex normals.

BOOL __cdecl lego::game::Roof_GetBlockPlaneNormal(uint bx,uint by,Vector3F *out_normal)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F normal1;
	Vector3F normal2;
	D3DRMVertex vertices [4];
	
	if (((bx < (uint)globs::roofGlobs.dimensions.width) &&
			(by < (uint)globs::roofGlobs.dimensions.height)) &&
		 ((*(byte *)&globs::roofGlobs.grid[by * globs::roofGlobs.dimensions.width + bx].flags &
			ROOF_HIDDEN) == 0)) {
		res::Container_Mesh_GetVertices
							(globs::roofGlobs.contMesh,
							 globs::roofGlobs.grid[by * globs::roofGlobs.dimensions.width + bx].groupID,0,4,
							 vertices);
		math::Maths_PlaneNormal
							(&normal1,&vertices[0].position,&vertices[1].position,&vertices[2].position);
		math::Maths_PlaneNormal
							(&normal2,&vertices[2].position,&vertices[3].position,&vertices[0].position);
		fVar3 = normal2.y + normal1.y;
		fVar1 = normal2.z + normal1.z;
		fVar2 = normal2.x + normal1.x;
		fVar4 = 1.0 / SQRT(fVar2 * fVar2 + fVar1 * fVar1 + fVar3 * fVar3);
		out_normal->x = fVar4 * fVar2;
		out_normal->y = fVar4 * fVar3;
		out_normal->z = fVar4 * fVar1;
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::front::ScrollInfo_Initialise(char *filename,BOOL index,uint unkFlags,int param_4,int param_5)
{
	Image *pIVar1;
	char **ppcVar2;
	
	ppcVar2 = (char **)&param_5;
	if (filename != NULL) {
		do {
			globals::g_ScrollInfos[index].flags = 1;
			globals::g_ScrollInfos[index].flags = (-(uint)((char *)unkFlags != NULL) & 8) + 9;
			pIVar1 = lego::image::Image_LoadBMPScaled(filename,0,0);
			globals::g_ScrollInfos[index].image = pIVar1;
			if (pIVar1 != NULL) {
				globals::g_ScrollInfos[index].flags = globals::g_ScrollInfos[index].flags | 4;
			}
			filename = *ppcVar2;
			globals::g_ScrollInfos[index].panelType = param_4;
			index = (BOOL)ppcVar2[1];
			unkFlags = (uint)ppcVar2[2];
			param_4 = (int)ppcVar2[3];
			ppcVar2 = ppcVar2 + 4;
		} while (filename != NULL);
	}
	return;
}



void __cdecl lego::front::ScrollInfo_SetXYOrSize_Unk(BOOL index,uint x_or_width,uint y_or_height)
{
	globals::g_ScrollInfos[index].pointOrSize.x = (float)(ulonglong)x_or_width;
	globals::g_ScrollInfos[index].pointOrSize.y = (float)(ulonglong)y_or_height;
	return;
}



void __cdecl
lego::front::ScrollInfo_AddStruct1C
					(BOOL index,BOOL use50InsteadOf4c,Area2F *rect,char *opt_filename1,char *opt_filename2)
{
	float fVar1;
	float fVar2;
	ScrollInfoSubStruct_1c *pSVar3;
	Image *pIVar4;
	
	if (use50InsteadOf4c == 0) {
		pSVar3 = (ScrollInfoSubStruct_1c *)std::malloc(0x1c);
		globals::g_ScrollInfos[index].ptr1c_c = pSVar3;
	}
	else {
		pSVar3 = (ScrollInfoSubStruct_1c *)std::malloc(0x1c);
		globals::g_ScrollInfos[index].ptr1c_10 = pSVar3;
	}
	(pSVar3->point1).x = rect->x;
	(pSVar3->point1).y = rect->y;
	(pSVar3->point2).x = rect->width + rect->x;
	fVar1 = rect->height;
	fVar2 = rect->y;
	pSVar3->image1 = NULL;
	pSVar3->image2 = NULL;
	(pSVar3->point2).y = fVar1 + fVar2;
	if (opt_filename1 != NULL) {
		pIVar4 = lego::image::Image_LoadBMPScaled(opt_filename1,0,0);
		pSVar3->image1 = pIVar4;
	}
	if (opt_filename2 != NULL) {
		pIVar4 = lego::image::Image_LoadBMPScaled(opt_filename2,0,0);
		pSVar3->image2 = pIVar4;
	}
	pSVar3->flags = 0;
	return;
}



void __cdecl
lego::front::ScrollInfo_AddCreateStruct28
					(BOOL index,Area2F *area,int number,int param_4,char *filename)
{
	ScrollInfoSubStruct_28 *pSVar1;
	Image *pIVar2;
	
	pSVar1 = (ScrollInfoSubStruct_28 *)std::malloc(0x28);
	globals::g_ScrollInfos[index].substruct28 = pSVar1;
	pIVar2 = lego::image::Image_LoadBMPScaled(filename,0,0);
	(globals::g_ScrollInfos[index].substruct28)->image = pIVar2;
	((globals::g_ScrollInfos[index].substruct28)->point1).x = area->x;
	((globals::g_ScrollInfos[index].substruct28)->point1).y = area->y;
	((globals::g_ScrollInfos[index].substruct28)->point2).x = area->width + area->x;
	((globals::g_ScrollInfos[index].substruct28)->point2).y = area->height + area->y;
	(globals::g_ScrollInfos[index].substruct28)->field_10 = 0;
	(globals::g_ScrollInfos[index].substruct28)->field_14 = 0;
	(globals::g_ScrollInfos[index].substruct28)->intM1_1c = number + -1;
	(globals::g_ScrollInfos[index].substruct28)->int_20 = param_4;
	return;
}



BOOL __cdecl
lego::front::ScrollInfo_Mouse_FUN_00463b60
					(int *out_param_1,uint mouseX,uint mouseY,BOOL param_4,BOOL param_5)
{
	uint uVar1;
	PanelType PVar2;
	float *pfVar3;
	float fVar4;
	float fVar5;
	BOOL BVar6;
	int iVar7;
	BOOL BVar8;
	Image *pIVar9;
	ScrollInfoSubStruct_1c *pSVar10;
	longlong lVar11;
	int local_60;
	PanelType *local_5c;
	
	BVar8 = 0;
	local_60 = 0;
	local_5c = &globals::g_ScrollInfos[0].panelType;
	do {
		if (((*(byte *)(local_5c + 1) & 4) != 0) &&
			 (BVar6 = Panel_IsFlags_4_Not8(*local_5c), BVar6 == 0)) {
			pIVar9 = NULL;
			do {
				if (pIVar9 == NULL) {
					pSVar10 = (ScrollInfoSubStruct_1c *)local_5c[-3];
				}
				else {
					pSVar10 = (ScrollInfoSubStruct_1c *)local_5c[-2];
				}
				if ((BVar8 == 0) &&
					 (BVar6 = ScrollInfo_FUN_00463ec0
															((ScrollInfoStruct_20 *)(local_5c + -6),pSVar10,mouseX,mouseY),
					 BVar6 != 0)) {
					*out_param_1 = local_60;
					if (param_4 == 0) {
						if (globals::g_ScrollInfos[1].image != (Image *)0x3) {
							if (pIVar9 != globals::g_ScrollInfos[1].image) goto LAB_00463c6b;
							PVar2 = local_5c[-1];
							uVar1 = *(uint *)(PVar2 + 0x20);
							if (pIVar9 == NULL) {
								if (uVar1 < *(uint *)(PVar2 + 0x1c)) {
									iVar7 = uVar1 + 1;
LAB_00463c54:
									*(int *)(PVar2 + 0x20) = iVar7;
								}
							}
							else {
								if (uVar1 != 0) {
									iVar7 = uVar1 - 1;
									goto LAB_00463c54;
								}
							}
							*(undefined4 *)(local_5c[-1] + 0x24) = 1;
							pSVar10->flags = pSVar10->flags & 0xfffffffb | 2;
							goto LAB_00463c6b;
						}
						BVar8 = 1;
						pSVar10->flags = pSVar10->flags & 0xfffffffb | 2;
					}
					else {
						if (globals::g_ScrollInfos[1].image == (Image *)0x3) {
							if (param_5 == 0) {
								BVar8 = 1;
								globals::g_ScrollInfos[1].image = pIVar9;
								pSVar10->flags = pSVar10->flags & 0xfffffffd | 4;
							}
							else {
LAB_00463c6b:
								BVar8 = 1;
							}
						}
						else {
							if (pIVar9 != globals::g_ScrollInfos[1].image) goto LAB_00463c6b;
							BVar8 = 1;
							pSVar10->flags = pSVar10->flags & 0xfffffffd | 4;
						}
					}
				}
				else {
					pSVar10->flags = pSVar10->flags & 0xfffffff9;
				}
				pIVar9 = (Image *)((int)&pIVar9->surface + 1);
			} while (pIVar9 < (Image *)0x2);
			if ((BVar8 == 0) &&
				 (BVar6 = ScrollInfo_FUN_00463f50((ScrollInfoStruct_20 *)(local_5c + -6),mouseX,mouseY),
				 BVar6 != 0)) {
				if (param_4 == 0) {
					if (globals::g_ScrollInfos[1].image == (Image *)0x3) {
						globals::g_ScrollInfos[1].image = (Image *)0x2;
					}
					globs::s_ScrollInfo_BOOL_005023c0 = TRUE;
				}
				else {
					if (globals::g_ScrollInfos[1].image == (Image *)0x2) {
						if ((*(byte *)(local_5c + 1) & 8) == 0) {
							pfVar3 = (float *)local_5c[-1];
							fVar4 = (float)(ulonglong)(uint)pfVar3[7] / (pfVar3[2] - *pfVar3);
							fVar5 = (((float)(ulonglong)mouseX - globs::panelGlobs.panelTable[*local_5c].xyOutIn.x
											 ) - (float)local_5c[-5]) - *pfVar3;
						}
						else {
							PVar2 = local_5c[-1];
							fVar4 = (float)(ulonglong)*(uint *)(PVar2 + 0x1c) /
											(*(float *)(PVar2 + PANEL__COUNT) - *(float *)(PVar2 + PANEL_MESSAGESIDE));
							fVar5 = (((float)(ulonglong)mouseY - globs::panelGlobs.panelTable[*local_5c].xyOutIn.y
											 ) - (float)local_5c[-4]) - *(float *)(PVar2 + PANEL_MESSAGESIDE);
						}
						lVar11 = math::ScrollInfo_MathX_RoundToLL(fVar5 / fVar4);
						BVar8 = 1;
						*(int *)(local_5c[-1] + 0x20) = (int)lVar11;
						*(undefined4 *)(local_5c[-1] + 0x24) = 1;
						*out_param_1 = local_60;
						goto LAB_00463da4;
					}
				}
				BVar8 = 1;
				*out_param_1 = local_60;
			}
			else {
				globs::s_ScrollInfo_BOOL_005023c0 = 0;
			}
LAB_00463da4:
			pfVar3 = (float *)local_5c[-1];
			if (pfVar3[9] != 0.0) {
				fVar4 = pfVar3[7];
				if ((*(byte *)(local_5c + 1) & 8) == 0) {
					if (fVar4 == 0.0) {
						fVar4 = *pfVar3 - (float)(ulonglong)*(uint *)((int)pfVar3[6] + 4);
					}
					else {
						fVar4 = (float)(ulonglong)(uint)pfVar3[8] *
										((float)(ulonglong)(uint)fVar4 /
										((pfVar3[2] - *pfVar3) - (float)(ulonglong)*(uint *)((int)pfVar3[6] + 4)));
					}
					pfVar3[4] = fVar4;
				}
				else {
					if (fVar4 == 0.0) {
						pfVar3[5] = 0.0;
					}
					else {
						pfVar3[5] = (float)(ulonglong)(uint)pfVar3[8] *
												((float)(ulonglong)(uint)fVar4 /
												((pfVar3[3] - pfVar3[1]) - (float)(ulonglong)*(uint *)((int)pfVar3[6] + 8)))
						;
					}
				}
				*(undefined4 *)(local_5c[-1] + 0x24) = 0;
			}
		}
		local_5c = local_5c + 8;
		local_60 += 1;
		if ((PanelType *)((int)&globals::g_ScrollInfos[1].substruct28 + 3) < local_5c) {
			if ((param_4 == 0) && (globs::s_ScrollInfo_BOOL_005023c0 == 0)) {
				globals::g_ScrollInfos[1].image = (Image *)0x3;
			}
			return BVar8;
		}
	} while( true );
}



BOOL __cdecl
lego::front::ScrollInfo_FUN_00463ec0
					(ScrollInfoStruct_20 *param_1,ScrollInfoSubStruct_1c *param_2,int mouseX,int mouseY)
{
	PanelType PVar1;
	float fVar2;
	float fVar3;
	longlong lVar4;
	longlong lVar5;
	
	PVar1 = param_1->panelType;
	lVar4 = __ftol((float10)globs::panelGlobs.panelTable[PVar1].xyOutIn.x +
								 (float10)(param_1->pointOrSize).x);
	lVar5 = __ftol((float10)globs::panelGlobs.panelTable[PVar1].xyOutIn.y +
								 (float10)(param_1->pointOrSize).y);
	fVar2 = (float)(mouseX - (int)lVar4);
	if (((((param_2->point1).x <= fVar2) &&
			 (fVar3 = (float)(mouseY - (int)lVar5), fVar3 < (param_2->point2).y)) &&
			((param_2->point1).y <= fVar3)) && (fVar2 < (param_2->point2).x)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::front::ScrollInfo_FUN_00463f50(ScrollInfoStruct_20 *param_1,int mouseX,int mouseY)
{
	ScrollInfoSubStruct_28 *pSVar1;
	float fVar2;
	float fVar3;
	longlong lVar4;
	longlong lVar5;
	PanelType panelType;
	
	panelType = param_1->panelType;
	lVar4 = __ftol((float10)globs::panelGlobs.panelTable[panelType].xyOutIn.x +
								 (float10)(param_1->pointOrSize).x);
	lVar5 = __ftol((float10)globs::panelGlobs.panelTable[panelType].xyOutIn.y +
								 (float10)(param_1->pointOrSize).y);
	fVar2 = (float)(mouseX - (int)lVar4);
	pSVar1 = param_1->substruct28;
	if (((((pSVar1->point1).x <= fVar2) &&
			 (fVar3 = (float)(mouseY - (int)lVar5), fVar3 < (pSVar1->point2).y)) &&
			((pSVar1->point1).y <= fVar3)) && (fVar2 < (pSVar1->point2).x)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::front::ScrollInfo_FUN_00463fe0(BOOL index)
{
	ScrollInfoSubStruct_28 *pSVar1;
	ScrollInfoSubStruct_1c *pSVar2;
	uint uVar3;
	Image *image;
	Point2F local_10;
	Point2F local_8;
	
	local_10.x = globals::g_ScrollInfos[index].pointOrSize.x +
							 globs::panelGlobs.panelTable[globals::g_ScrollInfos[index].panelType].xyOutIn.x;
	local_10.y = globals::g_ScrollInfos[index].pointOrSize.y +
							 globs::panelGlobs.panelTable[globals::g_ScrollInfos[index].panelType].xyOutIn.y;
	lego::image::Image_DisplayScaled(globals::g_ScrollInfos[index].image,NULL,&local_10,NULL);
	uVar3 = 0;
	do {
		if (uVar3 == 0) {
			pSVar2 = globals::g_ScrollInfos[index].ptr1c_c;
		}
		else {
			pSVar2 = globals::g_ScrollInfos[index].ptr1c_10;
		}
		if (((pSVar2->flags & 2) == 0) || (pSVar2->image1 == NULL)) {
			if (((pSVar2->flags & 4) != 0) && (pSVar2->image2 != NULL)) {
				local_8.x = (pSVar2->point1).x;
				local_8.y = (pSVar2->point1).y;
				image = pSVar2->image2;
				goto LAB_004640a7;
			}
		}
		else {
			local_8.x = (pSVar2->point1).x;
			local_8.y = (pSVar2->point1).y;
			image = pSVar2->image1;
LAB_004640a7:
			local_8.y = local_8.y + local_10.y;
			local_8.x = local_8.x + local_10.x;
			lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
		}
		uVar3 += 1;
		if (1 < uVar3) {
			pSVar1 = globals::g_ScrollInfos[index].substruct28;
			local_8.x = (float)pSVar1->field_10 + local_10.x + (pSVar1->point1).x;
			local_8.y = (pSVar1->point1).y + (float)pSVar1->field_14 + local_10.y;
			lego::image::Image_DisplayScaled(pSVar1->image,NULL,&local_8,NULL);
			return;
		}
	} while( true );
}



longlong __cdecl lego::math::ScrollInfo_MathX_RoundToLL(float x)
{
	float10 fVar1;
	longlong lVar2;
	double x_;
	
	x_ = (double)x;
	fVar1 = std::floor(x_);
	if ((float10)x - fVar1 < (float10)0.5) {
		fVar1 = std::floor(x_);
		lVar2 = __ftol(fVar1);
		return lVar2;
	}
	fVar1 = std::ceil(x_);
	lVar2 = __ftol(fVar1);
	return lVar2;
}



void __cdecl
lego::front::ScrollInfo_GetSubStruct28_Fields1C_20(BOOL index,int *out_field1c,int *out_field20)
{
	*out_field1c = (globals::g_ScrollInfos[index].substruct28)->intM1_1c;
	*out_field20 = (globals::g_ScrollInfos[index].substruct28)->int_20;
	return;
}



void __cdecl lego::front::ScrollInfo_SetSubStruct28_Fields1C_20(BOOL index,int field1c,int field20)
{
	(globals::g_ScrollInfos[index].substruct28)->intM1_1c = field1c;
	(globals::g_ScrollInfos[index].substruct28)->int_20 = field20;
	(globals::g_ScrollInfos[index].substruct28)->bool_24 = TRUE;
	return;
}



SelectPlace * __cdecl lego::res::SelectPlace_Create(Container *contRoot,float float5_0)
{
	DWORD DVar1;
	SelectPlace *buffer;
	Container *pCVar2;
	uint *puVar3;
	uint *puVar4;
	DWORD *pDVar5;
	uint *puVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	int iVar10;
	Vector3F *pVVar11;
	D3DRMGroupIndex groupID;
	float TV_COORDS [4];
	float TU_COORDS [4];
	uint FACE_UNK [6];
	Vector3F VERT_POSES [5];
	uint faceData [30];
	D3DRMVertex vertices [4];
	
	buffer = (SelectPlace *)std::malloc(8);
	if (buffer != NULL) {
		buffer->contMesh = NULL;
		buffer->floatValue = 0.0;
		pCVar2 = Container_MakeMesh2(contRoot,CONTAINER_MESHTYPE_TRANSPARENT);
		buffer->contMesh = pCVar2;
		if (pCVar2 != NULL) {
			TU_COORDS[0] = 0.0;
			FACE_UNK[1] = 1;
			FACE_UNK[3] = 1;
			TU_COORDS[1] = 1.0;
			TU_COORDS[2] = 1.0;
			TU_COORDS[3] = 0.0;
			TV_COORDS[0] = 0.0;
			TV_COORDS[1] = 0.0;
			TV_COORDS[2] = 1.0;
			TV_COORDS[3] = 1.0;
			VERT_POSES[0].x = 0.0;
			VERT_POSES[0].y = 0.0;
			VERT_POSES[0].z = -1.0;
			VERT_POSES[1].x = 0.0;
			VERT_POSES[1].y = 1.0;
			VERT_POSES[1].z = 0.0;
			VERT_POSES[2].x = 1.0;
			VERT_POSES[2].y = 0.0;
			VERT_POSES[2].z = 0.0;
			VERT_POSES[3].x = 0.0;
			VERT_POSES[3].y = -1.0;
			VERT_POSES[3].z = 0.0;
			VERT_POSES[4].x = -1.0;
			VERT_POSES[4].y = 0.0;
			VERT_POSES[4].z = 0.0;
			FACE_UNK[0] = 0;
			FACE_UNK[2] = 3;
			FACE_UNK[4] = 2;
			FACE_UNK[5] = 3;
			uVar9 = 0;
			puVar3 = faceData;
			do {
				puVar6 = FACE_UNK;
				iVar10 = 6;
				puVar4 = puVar3;
				do {
					puVar3 = puVar4 + 1;
					uVar7 = *puVar6;
					puVar6 = puVar6 + 1;
					iVar10 += -1;
					*puVar4 = uVar9 + uVar7;
					puVar4 = puVar3;
				} while (iVar10 != 0);
				uVar9 += 4;
			} while (uVar9 < 20);
			groupID = D3DRMGROUP_0;
			buffer->floatValue = float5_0;
			do {
				Container_Mesh_AddGroup(buffer->contMesh,20,10,3,faceData);
				uVar9 = 0;
				pVVar11 = VERT_POSES;
				do {
					pDVar5 = &vertices[0].colour;
					uVar7 = 0;
					do {
						uVar8 = uVar7 + 4;
						pDVar5[-5] = (DWORD)pVVar11->x;
						pDVar5[-4] = (DWORD)pVVar11->y;
						pDVar5[-3] = (DWORD)pVVar11->z;
						DVar1 = *(DWORD *)((int)TU_COORDS + uVar7);
						*pDVar5 = 0xffffffff;
						pDVar5[-2] = DVar1;
						pDVar5[-1] = *(DWORD *)((int)TV_COORDS + uVar7);
						pDVar5 = pDVar5 + 9;
						uVar7 = uVar8;
					} while (uVar8 < 0x10);
					Container_Mesh_SetVertices(buffer->contMesh,groupID,uVar9,4,vertices);
					uVar9 += 4;
					pVVar11 = pVVar11 + 1;
				} while (uVar9 < 20);
				Container_Mesh_SetQuality(buffer->contMesh,groupID,QUALITY_GOURAUD);
				groupID += 1;
			} while (groupID < 10);
			Container_Hide(buffer->contMesh,TRUE);
			return buffer;
		}
		std::free(buffer);
	}
	return NULL;
}



// Translate and rotate a set of integer points (max of 20).
// Returns a pointer to a temporary buffer that will be modified when this function is next called.
// 
// DIRECTION_UP is "no rotation"

Point2I * __cdecl
lego::res::SelectPlace_TransformShapePoints
					(Point2I *translation,Point2I *shapePoints,int shapeCount,Direction rotation)
{
	Point2I *dstPoint;
	uint signBit;
	int swapPoint_x;
	
	if (shapeCount != 0) {
		signBit = (int)(rotation + 0x8000) >> 0x1f;
		dstPoint = globs::s_TransformShapePoints;
		do {
						// POINTER MATH to get shapePoints[i] from dstPoints[i]
						// dstPoint->x = shapePoints[i].x;
						// dstPoint->y = shapePoints[i].y;
			dstPoint->x = *(int *)((int)&dstPoint->x + (int)&shapePoints[-0xa0479].x);
			dstPoint->y = *(int *)((int)((int)shapePoints + -0x5023c4) + (int)dstPoint);
						// apply rotation to dstPoints[i]
						// positive modulus (direction % 4)
			if (true) {
						// case DIRECTION_UP: // (x, y)  no change
				switch(((rotation + 0x8000 ^ signBit) - signBit & 3 ^ signBit) - signBit) {
				default:
					goto switchD_0046441a_caseD_0;
				case DIRECTION_RIGHT:
						// (-y, x)
					swapPoint_x = dstPoint->x;
					dstPoint->x = -dstPoint->y;
					goto LAB_00464440;
				case DIRECTION_DOWN:
						// (-x, -y)
					dstPoint->x = -dstPoint->x;
					swapPoint_x = dstPoint->y;
					break;
				case DIRECTION_LEFT:
						// (y, -x)
					swapPoint_x = dstPoint->x;
					dstPoint->x = dstPoint->y;
				}
				swapPoint_x = -swapPoint_x;
LAB_00464440:
				dstPoint->y = swapPoint_x;
			}
switchD_0046441a_caseD_0:
						// apply translation to dstPoints[i]
			dstPoint->x = dstPoint->x + translation->x;
			shapeCount += -1;
			dstPoint->y = dstPoint->y + translation->y;
			dstPoint = dstPoint + 1;
		} while (shapeCount != 0);
	}
	return globs::s_TransformShapePoints;
}



uint __cdecl
lego::res::SelectPlace_DrawTiles
					(SelectPlace *selectPlace,Point2I *blockPos,Point2I *shapePoints,uint shapeCount,
					Direction direction,SurfaceMap *surfMap,int waterEntrances)
{
	int iVar1;
	D3DRMGroupIndex group;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	byte bVar6;
	Point2I *pShape;
	BOOL BVar7;
	float *pfVar8;
	int *piVar9;
	D3DRMVertex *pDVar10;
	D3DRMVertex *pDVar11;
	uint uVar12;
	int iVar13;
	int *piVar14;
	Point2I *pPVar15;
	int iVar16;
	Point2I *pPVar17;
	float red;
	float green;
	uint local_3d0;
	Point2I *local_3cc;
	Point2I *local_3c8;
	float blue;
	D3DRMGroupIndex local_3c0;
	Point2I local_3ac;
	BOOL okRoughness;
	Point2I DIRECTIONS [4];
	int local_380 [4];
	undefined4 local_370;
	undefined4 local_36c;
	undefined4 local_368;
	undefined4 local_364;
	undefined4 local_360;
	undefined4 local_35c;
	undefined4 local_358;
	undefined4 local_354;
	undefined4 local_350;
	undefined4 local_34c;
	undefined4 local_348;
	undefined4 local_344;
	undefined4 local_340;
	undefined4 local_33c;
	undefined4 local_338;
	undefined4 local_334;
	Vector3F local_330 [8];
	D3DRMVertex local_2d0 [20];
	
	local_380[2] = 2;
	local_354 = 2;
	local_350 = 2;
	local_380[3] = 3;
	local_368 = 5;
	local_35c = 5;
	local_344 = 3;
	local_340 = 3;
	local_380[1] = 1;
	local_364 = 1;
	local_360 = 1;
	bVar6 = 1;
	local_348 = 7;
	local_33c = 7;
	local_358 = 6;
	local_34c = 6;
	uVar12 = 0;
	local_3c0 = D3DRMGROUP_0;
	local_380[0] = 0;
	local_370 = 0;
	local_36c = 4;
	local_338 = 4;
	local_334 = 0;
	pShape = SelectPlace_TransformShapePoints(blockPos,shapePoints,shapeCount,direction);
	okRoughness = game::Map3D_CheckBuildingTolerance
													((globs::legoGlobs.level)->surfaceMap,pShape,shapeCount,
													 (globs::legoGlobs.level)->BuildingTolerance,
													 (globs::legoGlobs.level)->BuildingMaxVariation);
	bVar5 = false;
	bVar4 = false;
	bVar3 = false;
	if (shapeCount != 0) {
		DIRECTIONS[1].x = 1;
		DIRECTIONS[2].y = 1;
		DIRECTIONS[0].x = 0;
		DIRECTIONS[0].y = -1;
		DIRECTIONS[1].y = 0;
		DIRECTIONS[2].x = 0;
		DIRECTIONS[3].x = -1;
		DIRECTIONS[3].y = 0;
		piVar9 = &pShape->y;
		pPVar17 = pShape;
		pPVar15 = pShape;
		do {
			local_3c8 = pPVar15 + 1;
			bVar2 = false;
			piVar14 = &DIRECTIONS[0].y;
			local_3cc = (Point2I *)0x4;
			do {
				local_3ac.x = piVar14[-1] + pPVar17->x;
				local_3ac.y = *piVar9 + *piVar14;
				BVar7 = game::Level_Block_IsPath(&local_3ac);
				if ((BVar7 != 0) && (BVar7 = game::Level_Block_IsPathBuilding(&local_3ac), BVar7 == 0)) {
					bVar4 = true;
					bVar2 = true;
				}
				piVar14 = piVar14 + 2;
				local_3cc = (Point2I *)((int)local_3cc + -1);
			} while (local_3cc != NULL);
			if (((uVar12 < shapeCount - 1) && (pPVar17->x == local_3c8->x)) && (*piVar9 == pPVar15[1].y))
			{
				if (bVar2) {
					bVar5 = true;
				}
				uVar12 += 1;
				pPVar17 = pPVar17 + 1;
				piVar9 = piVar9 + 2;
				bVar3 = true;
				local_3c8 = pPVar15 + 2;
			}
			uVar12 += 1;
			pPVar17 = pPVar17 + 1;
			piVar9 = piVar9 + 2;
			pPVar15 = local_3c8;
		} while (uVar12 < shapeCount);
	}
	if (bVar3) {
		bVar4 = bVar5;
	}
	local_3d0 = 0;
	group = D3DRMGROUP_0;
	if (shapeCount != 0) {
		local_3ac.x = shapeCount - 1;
		pPVar15 = pShape;
		pPVar17 = pShape;
		do {
			local_3cc = pPVar17 + 1;
			if (((local_3d0 < (uint)local_3ac.x) && (pPVar15->x == local_3cc->x)) &&
				 (pPVar15->y == pPVar17[1].y)) {
				iVar13 = TRUE;
				local_3c8 = (Point2I *)TRUE;
				if (waterEntrances + 1 <= local_3c0) goto LAB_0046471f;
			}
			else {
				local_3c8 = NULL;
LAB_0046471f:
				iVar13 = 0;
			}
			BVar7 = game::Level_BlockCheck_SelectPlace_FUN_00431a50
												(pPVar15->x,pPVar15->y,(BOOL)local_3c8,iVar13);
			if (((BVar7 == 0) || (!bVar4)) ||
				 (red = (float)game::Level_BlockPointerCheck(blockPos), red != 0.0)) {
				bVar6 = 0;
				red = 0.6;
				green = 0.0;
LAB_004647ee:
				blue = 0.0;
			}
			else {
				if (iVar13 == 0) {
					if (local_3c8 != NULL) {
						red = 0.7;
						green = 0.7;
						goto LAB_004647ee;
					}
					if (okRoughness == 0) {
						bVar6 = 0;
						red = 0.7;
						green = 0.0;
						blue = 0.7;
					}
					else {
						red = 0.0;
						green = 0.7;
						blue = 0.1;
					}
				}
				else {
					green = 0.7;
					blue = 0.9;
				}
			}
			Container_Mesh_SetColourAlpha(selectPlace->contMesh,local_3c0,red,green,blue,0.2);
			Container_Mesh_SetEmissive(selectPlace->contMesh,local_3c0,red * 0.5,green * 0.5,blue * 0.5);
			BVar7 = game::Map3D_IsInsideDimensions(surfMap,pPVar15->x,pPVar15->y);
			if (BVar7 == 0) {
				Container_Mesh_HideGroup(selectPlace->contMesh,local_3c0,TRUE);
			}
			else {
				game::Map3D_GetBlockVertexPositions1(surfMap,pPVar15->x,pPVar15->y,local_330);
				iVar13 = 4;
				pfVar8 = &local_330[0].z;
				do {
					iVar13 += -1;
					pfVar8[10] = pfVar8[-2];
					pfVar8[0xb] = pfVar8[-1];
					pfVar8[0xc] = *pfVar8;
					*pfVar8 = *pfVar8 - selectPlace->floatValue;
					pfVar8 = pfVar8 + 3;
				} while (iVar13 != 0);
				Container_Mesh_GetVertices(selectPlace->contMesh,local_3c0,0,0x14,local_2d0);
				piVar9 = local_380;
				pDVar10 = local_2d0;
				iVar13 = 5;
				do {
					iVar16 = 4;
					pDVar11 = pDVar10;
					do {
						iVar1 = *piVar9;
						piVar9 = piVar9 + 1;
						pDVar10 = pDVar11 + 1;
						iVar16 += -1;
						(pDVar11->position).x = local_330[iVar1].x;
						(pDVar11->position).y = local_330[iVar1].y;
						(pDVar11->position).z = local_330[iVar1].z;
						pDVar11 = pDVar10;
					} while (iVar16 != 0);
					iVar13 += -1;
				} while (iVar13 != 0);
				Container_Mesh_SetVertices(selectPlace->contMesh,local_3c0,0,0x14,local_2d0);
				Container_Mesh_HideGroup(selectPlace->contMesh,local_3c0,FALSE);
			}
			local_3c0 += 1;
			if (local_3c8 != NULL) {
				local_3d0 += 1;
				pPVar15 = pPVar15 + 1;
				local_3cc = pPVar17 + 2;
			}
			local_3d0 += 1;
			pPVar15 = pPVar15 + 1;
			pPVar17 = local_3cc;
			group = local_3c0;
		} while (local_3d0 < shapeCount);
	}
	for (; group < 10; group = group + 1) {
		Container_Mesh_HideGroup(selectPlace->contMesh,group,TRUE);
	}
	return -(uint)bVar6 & (uint)pShape;
}



void __cdecl lego::res::SelectPlace_Hide(SelectPlace *selectPlace,BOOL hide)
{
	Container_Hide(selectPlace->contMesh,hide);
	return;
}



void __cdecl lego::snd::SFX_InitHashNames(void)
{
	uint uVar1;
	
						// new uint[495]
	globs::sfxGlobs.hashNameList = (uint *)std::malloc(0x7bc);
	uVar1 = util::Util_HashString("SFX_NULL",0,1);
	*globs::sfxGlobs.hashNameList = uVar1;
	uVar1 = util::Util_HashString("SFX_Stamp",0,1);
	globs::sfxGlobs.hashNameList[1] = uVar1;
	uVar1 = util::Util_HashString("SFX_Drill",0,1);
	globs::sfxGlobs.hashNameList[2] = uVar1;
	uVar1 = util::Util_HashString("SFX_DrillFade",0,1);
	globs::sfxGlobs.hashNameList[3] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockBreak",0,1);
	globs::sfxGlobs.hashNameList[4] = uVar1;
	uVar1 = util::Util_HashString("SFX_Drip",0,1);
	globs::sfxGlobs.hashNameList[5] = uVar1;
	uVar1 = util::Util_HashString("SFX_Ambient",0,1);
	globs::sfxGlobs.hashNameList[6] = uVar1;
	uVar1 = util::Util_HashString("SFX_AmbientLoop",0,1);
	globs::sfxGlobs.hashNameList[7] = uVar1;
	uVar1 = util::Util_HashString("SFX_Step",0,1);
	globs::sfxGlobs.hashNameList[8] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonster",0,1);
	globs::sfxGlobs.hashNameList[9] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonster2",0,1);
	globs::sfxGlobs.hashNameList[10] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonsterStep",0,1);
	globs::sfxGlobs.hashNameList[0xb] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFDeposit",0,1);
	globs::sfxGlobs.hashNameList[0xc] = uVar1;
	uVar1 = util::Util_HashString("SFX_ButtonPressed",0,1);
	globs::sfxGlobs.hashNameList[0xd] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFLift",0,1);
	globs::sfxGlobs.hashNameList[0xe] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFThrow",0,1);
	globs::sfxGlobs.hashNameList[0xf] = uVar1;
	uVar1 = util::Util_HashString("SFX_Walker",0,1);
	globs::sfxGlobs.hashNameList[0x10] = uVar1;
	uVar1 = util::Util_HashString("SFX_YesSir",0,1);
	globs::sfxGlobs.hashNameList[0x11] = uVar1;
	uVar1 = util::Util_HashString("SFX_Build",0,1);
	globs::sfxGlobs.hashNameList[0x12] = uVar1;
	uVar1 = util::Util_HashString("SFX_Okay",0,1);
	globs::sfxGlobs.hashNameList[0x13] = uVar1;
	uVar1 = util::Util_HashString("SFX_NotOkay",0,1);
	globs::sfxGlobs.hashNameList[0x14] = uVar1;
	uVar1 = util::Util_HashString("SFX_InterfaceSlideOnScreen",0,1);
	globs::sfxGlobs.hashNameList[0x15] = uVar1;
	uVar1 = util::Util_HashString("SFX_InterfaceSlideOffScreen",0,1);
	globs::sfxGlobs.hashNameList[0x16] = uVar1;
	uVar1 = util::Util_HashString("SFX_PanelSlideOnScreen",0,1);
	globs::sfxGlobs.hashNameList[0x17] = uVar1;
	uVar1 = util::Util_HashString("SFX_PanelSlideOffScreen",0,1);
	globs::sfxGlobs.hashNameList[0x18] = uVar1;
	uVar1 = util::Util_HashString("SFX_Siren",0,1);
	globs::sfxGlobs.hashNameList[0x19] = uVar1;
	uVar1 = util::Util_HashString("SFX_CrystalRecharge",0,1);
	globs::sfxGlobs.hashNameList[0x1a] = uVar1;
	uVar1 = util::Util_HashString("SFX_Laser",0,1);
	globs::sfxGlobs.hashNameList[0x1b] = uVar1;
	uVar1 = util::Util_HashString("SFX_LaserHit",0,1);
	globs::sfxGlobs.hashNameList[0x1c] = uVar1;
	uVar1 = util::Util_HashString("SFX_LazerRecharge",0,1);
	globs::sfxGlobs.hashNameList[0x1d] = uVar1;
	uVar1 = util::Util_HashString("SFX_TopPriority",0,1);
	globs::sfxGlobs.hashNameList[0x1e] = uVar1;
	uVar1 = util::Util_HashString("SFX_ImmovableRock",0,1);
	globs::sfxGlobs.hashNameList[0x1f] = uVar1;
	uVar1 = util::Util_HashString("SFX_Wall",0,1);
	globs::sfxGlobs.hashNameList[0x20] = uVar1;
	uVar1 = util::Util_HashString("SFX_Floor",0,1);
	globs::sfxGlobs.hashNameList[0x21] = uVar1;
	uVar1 = util::Util_HashString("SFX_BoulderHit",0,1);
	globs::sfxGlobs.hashNameList[0x22] = uVar1;
	uVar1 = util::Util_HashString("SFX_Place",0,1);
	globs::sfxGlobs.hashNameList[0x23] = uVar1;
	uVar1 = util::Util_HashString("SFX_PlaceOre",0,1);
	globs::sfxGlobs.hashNameList[0x24] = uVar1;
	uVar1 = util::Util_HashString("SFX_PlaceCrystal",0,1);
	globs::sfxGlobs.hashNameList[0x25] = uVar1;
	uVar1 = util::Util_HashString("SFX_Lava",0,1);
	globs::sfxGlobs.hashNameList[0x26] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockWipe",0,1);
	globs::sfxGlobs.hashNameList[0x27] = uVar1;
	uVar1 = util::Util_HashString("SFX_FallIn",0,1);
	globs::sfxGlobs.hashNameList[0x28] = uVar1;
	uVar1 = util::Util_HashString("SFX_MusicLoop",0,1);
	globs::sfxGlobs.hashNameList[0x29] = uVar1;
	uVar1 = util::Util_HashString("SFX_CaptainSlide",0,1);
	globs::sfxGlobs.hashNameList[0x2a] = uVar1;
	uVar1 = util::Util_HashString("SFX_Dynamite",0,1);
	globs::sfxGlobs.hashNameList[0x2b] = uVar1;
	uVar1 = util::Util_HashString("SFX_AmbientMusicLoop",0,1);
	globs::sfxGlobs.hashNameList[0x2c] = uVar1;
	res::Container_SetSoundTriggerCallback(SFX_Container_SoundTriggerCallback,0);
	return;
}



void __cdecl
lego::snd::SFX_Container_SoundTriggerCallback(char *sampleName,Container *cont,void *data)
{
	BOOL BVar1;
	
	BVar1 = SFX_GetType(sampleName,(SFXType *)&sampleName);
	if (BVar1 != 0) {
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,(SFXType)sampleName,FALSE,TRUE,NULL);
	}
	return;
}



void __cdecl lego::snd::SFX_SetSamplePopulateMode(BOOL populate)
{
	if (populate != 0) {
		globs::sfxGlobs.audioFlags = globs::sfxGlobs.audioFlags | AUDIO_POPULATEMODE;
		return;
	}
	globs::sfxGlobs.audioFlags = globs::sfxGlobs.audioFlags & ~AUDIO_POPULATEMODE;
	return;
}



BOOL __cdecl lego::snd::SFX_GetType(char *sfxName,SFXType *out_sfxType)
{
	SFXType SVar1;
	uint uVar2;
	SFXType SVar3;
	uint *puVar4;
	
	if (sfxName != NULL) {
						// hash_string(sfxName, false (!bIgnoreBlanks), true (bIgnoreCase))
		uVar2 = util::Util_HashString(sfxName,FALSE,TRUE);
		SVar3 = SFX_NULL;
		SVar1 = globs::sfxGlobs.hashNameCount + 0x2d;
		puVar4 = globs::sfxGlobs.hashNameList;
		if (SVar1 != SFX_NULL) {
			do {
				if (uVar2 == *puVar4) {
					*out_sfxType = SVar3;
					return TRUE;
				}
				SVar3 += SFX_STAMP;
				puVar4 = puVar4 + 1;
			} while (SVar3 < SVar1);
		}
						// This flag presumably states the SFX table is still being built
		if (((byte)globs::sfxGlobs.audioFlags & AUDIO_POPULATEMODE) != 0) {
			*out_sfxType = SVar1;
						// hash_string(sfxName, false (!bIgnoreBlanks), true (bIgnoreCase))
			uVar2 = util::Util_HashString(sfxName,FALSE,TRUE);
			globs::sfxGlobs.hashNameList[SVar1] = uVar2;
			globs::sfxGlobs.hashNameCount = globs::sfxGlobs.hashNameCount + 1;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::snd::SFX_Sample_LoadProperty(char *value,int index)
{
	char cVar1;
	uint uVar2;
	SampleProperty *pSVar3;
	char cVar4;
	int iVar5;
	char *pcVar6;
	BOOL stream;
	char *pcVar7;
	SampleProperty *pSVar8;
	char **local_1e0;
	int numParts;
	BOOL success;
	SampleProperty *lastItem;
	char pound_buffer [64];
	char *filename_parts [100];
	
	pSVar8 = globs::sfxGlobs.samplePropTable + index;
	stream = 0;
	success = 1;
	lastItem = NULL;
	globs::sfxGlobs.samplePropTable[index].next = NULL;
	numParts = util::Util_Tokenise(value,filename_parts,",");
	if (numParts != 0) {
		local_1e0 = filename_parts;
		do {
			pcVar7 = *local_1e0;
			cVar1 = *pcVar7;
			if (cVar1 == '*') {
				pcVar7 = pcVar7 + 1;
			}
			iVar5 = 0;
			if (*pcVar7 == '#') {
				cVar4 = pcVar7[1];
				pcVar7 = pcVar7 + 1;
				if (cVar4 != '#') {
					pcVar6 = pound_buffer;
					do {
						*pcVar6 = cVar4;
						cVar4 = pcVar7[1];
						pcVar6 = pcVar6 + 1;
						pcVar7 = pcVar7 + 1;
					} while (cVar4 != '#');
				}
				iVar5 = std::atoi(pound_buffer);
				pcVar7 = pcVar7 + 1;
			}
			if (*pcVar7 == '@') {
				stream = 1;
				pcVar7 = pcVar7 + 1;
			}
			iVar5 = Sound3D_Load(pcVar7,stream,(uint)(cVar1 == '*'),iVar5);
			pSVar8->sampleIndex = iVar5;
			uVar2 = globs::sfxGlobs.sampleGroupCount;
			if (iVar5 == -1) {
				success = 0;
				pSVar3 = lastItem;
			}
			else {
				pSVar3 = pSVar8;
				if (lastItem != NULL) {
					pSVar8 = globs::sfxGlobs.sampleGroupTable + globs::sfxGlobs.sampleGroupCount;
					globs::sfxGlobs.sampleGroupCount += 1;
					lastItem->next = pSVar8;
					globs::sfxGlobs.sampleGroupTable[uVar2].next = NULL;
					pSVar3 = pSVar8;
				}
			}
			lastItem = pSVar3;
			local_1e0 = local_1e0 + 1;
			numParts += -1;
		} while (numParts != 0);
	}
	return success;
}



int __cdecl lego::snd::SFX_Sample_Random_GetSoundHandle(SFXType sfxType)
{
	SampleProperty *pSVar1;
	SampleProperty *pSVar2;
	int iVar3;
	short sVar4;
	uint uVar5;
	
	uVar5 = 0;
	if (sfxType != SFX_NULL) {
		if (globs::sfxGlobs.samplePropTable[sfxType].next != NULL) {
			pSVar1 = globs::sfxGlobs.samplePropTable + sfxType;
			for (pSVar2 = pSVar1; pSVar2 != NULL; pSVar2 = pSVar2->next) {
				uVar5 += 1;
			}
			sVar4 = math::Maths_Rand();
			pSVar2 = pSVar1;
			for (uVar5 = (uint)(int)sVar4 % uVar5; uVar5 != 0; uVar5 -= 1) {
				pSVar2 = pSVar2->next;
			}
			iVar3 = pSVar2->sampleIndex;
			pSVar2->sampleIndex = pSVar1->sampleIndex;
			pSVar1->sampleIndex = iVar3;
		}
		return globs::sfxGlobs.samplePropTable[sfxType].sampleIndex;
	}
	return -1;
}



void __cdecl lego::snd::SFX_StopGlobalSample(void)
{
	if ((globs::sfxGlobs.globalSampleSoundHandle != -1) &&
		 ((ushort)((ushort)(globs::sfxGlobs.globalSampleDuration < 0.0) << 8 |
							(ushort)(globs::sfxGlobs.globalSampleDuration == 0.0) << 0xe) == 0)) {
		SFX_Sample_Sound3D_StopSound(globs::sfxGlobs.globalSampleSoundHandle);
		globs::sfxGlobs.globalSampleSoundHandle = -1;
		globs::sfxGlobs.globalSampleDuration = 0.0;
	}
	return;
}



BOOL __cdecl lego::snd::SFX_SetGlobalSampleDurationIfLE0_AndNullifyHandle(float duration)
{
	if ((ushort)((ushort)(globs::sfxGlobs.globalSampleDuration < 0.0) << 8 |
							(ushort)(globs::sfxGlobs.globalSampleDuration == 0.0) << 0xe) != 0) {
		globs::sfxGlobs.globalSampleDuration = duration;
		globs::sfxGlobs.globalSampleSoundHandle = -1;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::snd::SFX_Sample_Random_SetAndPlayGlobalSample(SFXType sfxType,int *out_handle)
{
	float10 fVar1;
	
	if ((ushort)((ushort)(globs::sfxGlobs.globalSampleDuration < 0.0) << 8 |
							(ushort)(globs::sfxGlobs.globalSampleDuration == 0.0) << 0xe) != 0) {
		globs::sfxGlobs.globalSampleSoundHandle = SFX_Sample_Random_Play_OrAddToQueue(sfxType,FALSE);
		if (globs::sfxGlobs.globalSampleSoundHandle != -1) {
			fVar1 = SFX_Sample_Random_GetSamplePlayTime(sfxType);
			globs::sfxGlobs.globalSampleSFXType = sfxType;
			globs::sfxGlobs.globalSampleDuration = (float)(fVar1 * (float10)25.0);
			if (out_handle != NULL) {
				*out_handle = globs::sfxGlobs.globalSampleSoundHandle;
			}
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::snd::SFX_Sample_AddToQueue(SFXType sfxType,SoundMode mode)
{
	if (globs::sfxGlobs.soundQueueCount_1 < 10) {
		globs::sfxGlobs.soundQueueSFXTable_1[globs::sfxGlobs.soundQueueCount_1] = sfxType;
		globs::sfxGlobs.soundQueueModesTable_1[globs::sfxGlobs.soundQueueCount_1] = mode;
		globs::sfxGlobs.soundQueueCount_1 += 1;
	}
	return;
}



// The return value of this function is a sound3DHandle, BUT ONLY when AudioFlag 0x8 is unset!!!!

int __cdecl lego::snd::SFX_Sample_Random_Play_OrAddToQueue(SFXType sfxType,BOOL loop)
{
	Sound3DInstance *pSVar1;
	uint uVar2;
	Sound3DInstance *in_EAX;
	
	uVar2 = globs::sfxGlobs.sfxInstanceCount;
	if (((byte)globs::sfxGlobs.audioFlags & AUDIO_UNK_8) == 0) {
		in_EAX = (Sound3DInstance *)sfxType;
		if ((sfxType != SFX_NULL) && (((byte)globs::sfxGlobs.audioFlags & AUDIO_SOUNDON) != 0)) {
			in_EAX = (Sound3DInstance *)SFX_Sample_Random_GetSoundHandle(sfxType);
			if (in_EAX != NULL) {
				in_EAX = (Sound3DInstance *)Sound3D_Play2(SOUND3D_PLAY_NORMAL,NULL,(int)in_EAX,loop,NULL);
			}
		}
	}
	else {
		if (globs::sfxGlobs.sfxInstanceCount < 10) {
			pSVar1 = globs::sfxGlobs.sfxInstanceTable + globs::sfxGlobs.sfxInstanceCount;
			globs::sfxGlobs.sfxInstanceCount = globs::sfxGlobs.sfxInstanceCount + 1;
			pSVar1->sampleIndex = sfxType;
			globs::sfxGlobs.sfxInstanceTable[uVar2].flags =
					 globs::sfxGlobs.sfxInstanceTable[uVar2].flags & 0xfffffffe;
			return (int)pSVar1;
		}
	}
	return (int)in_EAX;
}



void __cdecl lego::snd::SFX_Sample_Random_SetBufferVolume(SFXType sfxType,int volume)
{
	int handle;
	
	handle = SFX_Sample_Random_GetSoundHandle(sfxType);
	Sound3D_SetBufferVolume(handle,volume);
	return;
}



int __cdecl lego::snd::SFX_Sample_Random_GetBufferVolume(SFXType sfxType)
{
	int sfxTypeRng;
	
	sfxTypeRng = SFX_Sample_Random_GetSoundHandle(sfxType);
	sfxTypeRng = Sound3D_GetBufferVolume(sfxTypeRng);
	return sfxTypeRng;
}



void __cdecl
lego::res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
					(Container *cont,SFXType sfxType,BOOL loop,BOOL sound3D,Vector3F *opt_position)
{
	IDirect3DRMFrame3 *frame;
	
	if (cont == NULL) {
		frame = NULL;
	}
	else {
		frame = Container_GetMasterFrame(cont);
	}
	snd::SFX_Sample_Random_Play_OrInitSoundUnk(frame,sfxType,loop,sound3D,opt_position);
	return;
}



int __cdecl
lego::snd::SFX_Sample_Random_Play_OrInitSoundUnk
					(IDirect3DRMFrame3 *frame,SFXType sfxType,BOOL loop,BOOL sound3D,Vector3F *opt_position)
{
	Sound3DInstance *pSVar1;
	uint uVar2;
	int iVar3;
	
	uVar2 = globs::sfxGlobs.sfxInstanceCount;
	if (((byte)globs::sfxGlobs.audioFlags & AUDIO_UNK_8) == 0) {
		if ((sfxType != SFX_NULL) && (((byte)globs::sfxGlobs.audioFlags & AUDIO_SOUNDON) != 0)) {
			iVar3 = SFX_Sample_Random_GetSoundHandle(sfxType);
			if (iVar3 != 0) {
				if (sound3D != 0) {
					iVar3 = Sound3D_Play2(SOUND3D_PLAY_ONFRAME,frame,iVar3,loop,NULL);
					return iVar3;
				}
				iVar3 = Sound3D_Play2(SOUND3D_PLAY_ONPOS,NULL,iVar3,loop,opt_position);
				return iVar3;
			}
		}
	}
	else {
		if (globs::sfxGlobs.sfxInstanceCount < 10) {
			pSVar1 = globs::sfxGlobs.sfxInstanceTable + globs::sfxGlobs.sfxInstanceCount;
			globs::sfxGlobs.sfxInstanceCount = globs::sfxGlobs.sfxInstanceCount + 1;
			pSVar1->sampleIndex = sfxType;
			globs::sfxGlobs.sfxInstanceTable[uVar2].frame = frame;
			globs::sfxGlobs.sfxInstanceTable[uVar2].flags =
					 ((sound3D & 1U) << 1 | loop & 1U) << 1 |
					 globs::sfxGlobs.sfxInstanceTable[uVar2].flags & 0xfffffff9 | 1;
			if (opt_position != NULL) {
				globs::sfxGlobs.sfxInstanceTable[uVar2].position.x = opt_position->x;
				globs::sfxGlobs.sfxInstanceTable[uVar2].position.y = opt_position->y;
				globs::sfxGlobs.sfxInstanceTable[uVar2].position.z = opt_position->z;
				return 0;
			}
		}
	}
	return 0;
}



float10 __cdecl lego::snd::SFX_Sample_Random_GetSamplePlayTime(SFXType sfxType)
{
	int handle;
	float10 fVar1;
	
	handle = SFX_Sample_Random_GetSoundHandle(sfxType);
	if (handle != 0) {
		fVar1 = Sound3D_GetSamplePlayTime(handle);
		return fVar1;
	}
	return (float10)0.0;
}



void __cdecl lego::snd::SFX_Sample_Sound3D_StopSound(int handle)
{
	Sound3D_StopSound(handle);
	return;
}



void __cdecl lego::snd::SFX_Update(float elapsed)
{
	BOOL BVar1;
	SFXType *pSVar2;
	SoundMode *pSVar3;
	uint uVar4;
	SFXType *pSVar5;
	SoundMode *pSVar6;
	
	BVar1 = SFX_GetFlag8();
	globs::sfxGlobs.globalSampleDuration = globs::sfxGlobs.globalSampleDuration - elapsed;
	SFX_SetFlag8To_AndOptPlayQueuedInstances(0,0);
	uVar4 = 0;
	if (globs::sfxGlobs.soundQueueCount_2 != 0) {
		pSVar2 = globs::sfxGlobs.soundQueueSFXTable_2;
		do {
			SFX_Sample_Random_Play_OrAddToQueue(*pSVar2,pSVar2[10]);
			uVar4 += 1;
			pSVar2 = pSVar2 + 1;
		} while (uVar4 < globs::sfxGlobs.soundQueueCount_2);
	}
	if (BVar1 != 0) {
		SFX_PlayQueuedInstances_SetFlag8To(1);
	}
						// std::memcpy(globals::g_SoundQueueIndexes_Unk2_TABLE,
						//             globals::g_SoundQueueIndexes_Unk1_TABLE,
						//             globals::g_SoundQueue_Unk1_COUNT * sizeof(int));
	pSVar2 = globs::sfxGlobs.soundQueueSFXTable_1;
	pSVar5 = globs::sfxGlobs.soundQueueSFXTable_2;
	for (uVar4 = globs::sfxGlobs.soundQueueCount_1; uVar4 != 0; uVar4 -= 1) {
		*pSVar5 = *pSVar2;
		pSVar2 = pSVar2 + 1;
		pSVar5 = pSVar5 + 1;
	}
						// globals::g_SoundQueue_Unk2_COUNT = globals::g_SoundQueue_Unk1_COUNT;
						// 
						// std::memcpy(globals::g_SoundQueueModes_Unk2_TABLE,
						//             globals::g_SoundQueueModes_Unk1_TABLE,
						//             globals::g_SoundQueue_Unk1_COUNT * sizeof(int));
	pSVar3 = globs::sfxGlobs.soundQueueModesTable_1;
	pSVar6 = globs::sfxGlobs.soundQueueModesTable_2;
	for (uVar4 = globs::sfxGlobs.soundQueueCount_1;
			globs::sfxGlobs.soundQueueCount_2 = globs::sfxGlobs.soundQueueCount_1, uVar4 != 0; uVar4 -= 1)
	{
		*pSVar6 = *pSVar3;
		pSVar3 = pSVar3 + 1;
		pSVar6 = pSVar6 + 1;
	}
	globs::sfxGlobs.soundQueueCount_1 = 0;
	SFX_Sound3D_Update();
	return;
}



void __cdecl lego::snd::SFX_Sound3D_Update(void)
{
	Sound3D_SoundRecord *pSVar1;
	uint in_ECX;
	Sound3D_SoundRecord *pSVar2;
	IDirect3DRMFrame3 **ppIVar3;
	uint uStack4;
	
	pSVar2 = globs::sound3DGlobs.soundRecord;
	ppIVar3 = globs::sound3DGlobs.updateFrameList;
	uStack4 = in_ECX;
	do {
		if (*ppIVar3 != NULL) {
			Sound3D_SoundCallback(*ppIVar3,NULL,0.0);
		}
		ppIVar3 = ppIVar3 + 1;
	} while (ppIVar3 < &globs::sound3DGlobs.reserved1);
	if (pSVar2 != NULL) {
		do {
			pSVar1 = pSVar2->next;
			(*(code *)pSVar2->soundBuff->lpVtbl->GetStatus)(pSVar2->soundBuff,&uStack4);
			if ((uStack4 & 1) == 0) {
				Sound3D_RemoveSound(pSVar2->frame,pSVar2->sound3DBuff);
			}
			pSVar2 = pSVar1;
		} while (pSVar1 != NULL);
	}
	Sound3D_Stream_CheckPosition(0);
	Sound3D_Stream_CheckPosition(1);
	return;
}



void __cdecl lego::snd::SFX_SetSoundStates_IsOn_StopAll(BOOL isSoundOn,BOOL stopAll)
{
	if (isSoundOn != 0) {
		globs::sfxGlobs.audioFlags = globs::sfxGlobs.audioFlags | AUDIO_SOUNDON;
		return;
	}
	globs::sfxGlobs.audioFlags &= ~AUDIO_SOUNDON;
	if (stopAll != 0) {
		Sound3D_StopAllSounds();
	}
	globs::sfxGlobs.globalSampleSFXType = SFX_NULL;
	return;
}



void __cdecl lego::snd::SFX_StopAll_AndSetSoundState_IsOn(BOOL isSoundOn)
{
	SFX_SetSoundStates_IsOn_StopAll(isSoundOn,TRUE);
	return;
}



BOOL __cdecl lego::snd::SFX_GetFlag8(void)
{
	return globs::sfxGlobs.audioFlags & AUDIO_UNK_8;
}



void __cdecl lego::snd::SFX_PlayQueuedInstances_SetFlag8To(BOOL setFlag8)
{
	SFX_SetFlag8To_AndOptPlayQueuedInstances(setFlag8,TRUE);
	return;
}



void __cdecl lego::snd::SFX_SetFlag8To_AndOptPlayQueuedInstances(BOOL setFlag8,BOOL playQueued)
{
	uint uVar1;
	uint *puVar2;
	uint uVar3;
	
	if (setFlag8 != 0) {
		globs::sfxGlobs.audioFlags = globs::sfxGlobs.audioFlags | AUDIO_UNK_8;
		return;
	}
	globs::sfxGlobs.audioFlags &= ~AUDIO_UNK_8;
	if (playQueued != 0) {
		uVar3 = 0;
		if (globs::sfxGlobs.sfxInstanceCount != 0) {
			puVar2 = &globs::sfxGlobs.sfxInstanceTable[0].flags;
			do {
				uVar1 = *puVar2;
				if ((uVar1 & 1) == 0) {
					SFX_Sample_Random_Play_OrAddToQueue(puVar2[-5],(int)(uVar1 << 0x1e) >> 0x1f);
				}
				else {
					SFX_Sample_Random_Play_OrInitSoundUnk
										((IDirect3DRMFrame3 *)puVar2[-4],puVar2[-5],(int)(uVar1 << 30) >> 31,
										 (int)(uVar1 << 29) >> 31,(Vector3F *)(puVar2 + -3));
				}
				uVar3 += 1;
				puVar2 = puVar2 + 6;
			} while (uVar3 < globs::sfxGlobs.sfxInstanceCount);
		}
		globs::sfxGlobs.sfxInstanceCount = 0;
	}
	return;
}



BOOL __cdecl lego::snd::SFX_IsSoundOn(void)
{
	return globs::sfxGlobs.audioFlags & AUDIO_SOUNDON;
}



BOOL __cdecl lego::effect::Smoke_Initialise(void)
{
	globs::smokeGlobs.firstSmoke = NULL;
	globs::smokeGlobs.lastSmoke = NULL;
	globs::smokeGlobs.count = 0;
	return TRUE;
}



void __cdecl lego::effect::Smoke_LoadTextures(char *dirname,char *basename,uint count)
{
	Container_Texture *pCVar1;
	uint uVar2;
	Smoke_Globs *pSVar3;
	char buffBmp [260];
	char buffDir [260];
	
	uVar2 = 0;
	globs::smokeGlobs.count = count;
	if (count != 0) {
		pSVar3 = &globs::smokeGlobs;
		do {
			std::sprintf(buffDir,"%s\\",dirname);
			std::sprintf(buffBmp,"%s%i.bmp",basename,uVar2);
			pCVar1 = res::Mesh_LoadTexture(buffDir,buffBmp,0,0);
			pSVar3->textureList[0] = pCVar1;
			uVar2 += 1;
			pSVar3 = (Smoke_Globs *)(pSVar3->textureList + 1);
		} while (uVar2 < count);
	}
	return;
}



SurfaceMapStruct_2a8 * __cdecl
lego::effect::Smoke_CreateSmokeArea
					(int zero_1,uint bx,uint by,Vector3F *vector_pt1_pt1_m1,float r,float g,float b,
					float param_8,float param_9,int mode0,uint randomness,int value38)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	SurfaceMapStruct_2a8 *data;
	SurfaceMap *surfMap;
	Container *pCVar5;
	Mesh *pMVar6;
	D3DRMGroupIndex DVar7;
	uint uVar8;
	int iVar9;
	SurfaceMapStruct_2a8 *pSVar10;
	uint uVar11;
	uint uVar12;
	float10 fVar13;
	ulonglong uVar14;
	longlong lVar15;
	float local_24;
	float local_20;
	float local_1c;
	uint faceData [6];
	
	uVar12 = 0;
	faceData[0] = 0;
	faceData[1] = 3;
	faceData[2] = 2;
	faceData[3] = 2;
	faceData[4] = 1;
	faceData[5] = 0;
	data = (SurfaceMapStruct_2a8 *)std::malloc(0x2a8);
	pSVar10 = data;
	for (iVar9 = 0xaa; iVar9 != 0; iVar9 += -1) {
		pSVar10->groupList[0].used_0 = 0;
		pSVar10 = (SurfaceMapStruct_2a8 *)&pSVar10->groupList[0].vector_4;
	}
	if ((mode0 == 0) || (mode0 == 2)) {
		surfMap = lrr::Lego_GetMap();
		pCVar5 = res::GetRoot();
		uVar14 = __ftol((float10)surfMap->BlockSize * (float10)0.6);
		game::Map3D_BlockToWorldPos(surfMap,bx,by,&local_24,&local_20);
		fVar2 = (float)(uVar14 & 0xffffffff) * 0.5;
		local_24 = ((float)(((ulonglong)randomness % 0x109e) % (uVar14 & 0xffffffff)) - fVar2) +
							 local_24;
		local_20 = ((float)(((ulonglong)randomness % 0x5eb) % (uVar14 & 0xffffffff)) - fVar2) + local_20
		;
		fVar13 = game::Map3D_GetWorldZ(surfMap,local_24,local_20);
		local_1c = (float)fVar13;
		pCVar5 = res::Container_Create(pCVar5);
		data->resData_28c = pCVar5;
		res::Container_SetPosition(pCVar5,NULL,local_24,local_20,local_1c);
		data->flags_294 = SURFMAP_STRUCT2A8_UNK_2;
		(data->vector_25c).x = local_24;
		(data->vector_25c).y = local_20;
		(data->vector_25c).z = local_1c;
		if ((randomness & 3) == 0) {
			data->field_2a0 = value38;
		}
	}
	else {
		if (mode0 == 1) {
			data->flags_294 = SURFMAP_STRUCT2A8_UNK_4;
			data->resData_28c = (Container *)zero_1;
		}
	}
	(data->vector_268).x = vector_pt1_pt1_m1->x;
	fVar3 = vector_pt1_pt1_m1->y;
	(data->vector_268).y = fVar3;
	fVar4 = vector_pt1_pt1_m1->z;
	(data->vector_268).z = fVar4;
	fVar2 = (data->vector_268).x;
	fVar2 = 1.0 / SQRT(fVar2 * fVar2 + fVar4 * fVar4 + fVar3 * fVar3);
	(data->vector_268).x = fVar2 * (data->vector_268).x;
	(data->vector_268).y = fVar2 * (data->vector_268).y;
	(data->vector_268).z = fVar2 * (data->vector_268).z;
	(data->colour).red = r;
	(data->colour).green = g;
	(data->colour).blue = b;
	if (mode0 == 2) {
		data->groupCount = 4;
		data->int_284 = 0;
		data->flags_294 = data->flags_294 | SURFMAP_STRUCT2A8_UNK_8;
		data->float_288 = 2.0;
	}
	else {
		if (((ushort)((ushort)(param_8 < 0.0) << 8 | (ushort)(param_8 == 0.0) << 0xe) == 0) ||
			 (param_8 < 1.0)) {
			lVar15 = __ftol((float10)param_8 * (float10)10.0);
			data->groupCount = (uint)lVar15;
		}
		else {
			data->groupCount = 10;
		}
		data->float_288 = param_9;
	}
	pMVar6 = res::Mesh_CreateOnFrame
										 (data->resData_28c->activityFrame,Smoke_MeshRenderCallback,0x4800,data,
											MESH_TYPE_NORM);
	data->mesh = pMVar6;
	if (data->groupCount != 0) {
		do {
			DVar7 = res::Mesh_AddGroup(data->mesh,4,2,3,faceData);
			pSVar1 = data->groupList + DVar7;
			res::Mesh_SetGroupTexture
								(data->mesh,DVar7,globs::smokeGlobs.textureList[uVar12 % globs::smokeGlobs.count]);
			res::Mesh_SetGroupColour(data->mesh,DVar7,r,g,b,MATERIAL_DIFFUSE);
			res::Mesh_SetGroupColour(data->mesh,DVar7,r * 0.2,g * 0.2,b * 0.2,MATERIAL_EMISSIVE);
			res::Mesh_HideGroup(data->mesh,DVar7,1);
			uVar8 = std::rand();
			uVar11 = (int)uVar8 >> 0x1f;
			pSVar1->float_28 = (float)(((uVar8 ^ uVar11) - uVar11 & 3 ^ uVar11) - uVar11) - -6.0;
			uVar8 = std::rand();
			uVar11 = (int)uVar8 >> 0x1f;
			fVar2 = ((float)(((uVar8 ^ uVar11) - uVar11 & 3 ^ uVar11) - uVar11) + pSVar1->float_28) - -2.0
			;
			pSVar1->float_2c = fVar2;
			if ((*(byte *)&data->flags_294 & 8) == 0) {
				pSVar1->float_28 = pSVar1->float_28 * 0.5;
			}
			else {
				pSVar1->float_2c = fVar2 + fVar2;
			}
			uVar12 += 1;
		} while (uVar12 < data->groupCount);
	}
	data->float_258 = 0.0;
	if (mode0 != 2) {
		iVar9 = 10;
		do {
			if ((ushort)((ushort)(data->float_258 < 0.0) << 8 | (ushort)(data->float_258 == 0.0) << 0xe)
					!= 0) {
				DVar7 = D3DRMGROUP_0;
				pSVar10 = data;
				if (data->groupCount != D3DRMGROUP_0) {
					do {
						if (pSVar10->groupList[0].used_0 == 0) {
							Smoke_Group_UpdateUnhide_FUN_00465f10(data,DVar7);
							break;
						}
						DVar7 += 1;
						pSVar10 = (SurfaceMapStruct_2a8 *)(pSVar10->groupList + 1);
					} while (DVar7 < data->groupCount);
				}
			}
			DVar7 = D3DRMGROUP_0;
			data->float_258 = data->float_258 - 5.0;
			pSVar10 = data;
			if (data->groupCount != 0) {
				do {
					if (pSVar10->groupList[0].used_0 != 0) {
						Smoke_Group_Update_FUN_004660c0(data,DVar7,5.0);
					}
					DVar7 += 1;
					pSVar10 = (SurfaceMapStruct_2a8 *)(pSVar10->groupList + 1);
				} while (DVar7 < data->groupCount);
			}
			iVar9 += -1;
		} while (iVar9 != 0);
	}
	data->previous = globs::smokeGlobs.lastSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		(globs::smokeGlobs.lastSmoke)->next = data;
		globs::smokeGlobs.lastSmoke = data;
		return data;
	}
	globs::smokeGlobs.firstSmoke = data;
	globs::smokeGlobs.lastSmoke = data;
	return data;
}



void __cdecl lego::effect::Smoke_RemoveAll(void)
{
	SurfaceMapStruct_2a8 *pSVar1;
	SurfaceMapStruct_2a8 *pSVar2;
	
	pSVar2 = globs::smokeGlobs.firstSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		do {
			pSVar1 = pSVar2->next;
			Smoke_Remove(pSVar2,pSVar2->resData_28c);
			pSVar2 = pSVar1;
		} while (pSVar1 != NULL);
	}
	globs::smokeGlobs.firstSmoke = NULL;
	return;
}



void __cdecl lego::effect::Smoke_Remove(SurfaceMapStruct_2a8 *param_1,Container *cont28c)
{
	if ((*(byte *)&param_1->flags_294 & 2) == 0) {
		res::Mesh_Remove(param_1->mesh,cont28c->activityFrame);
	}
	else {
		res::Mesh_Remove(param_1->mesh,param_1->resData_28c->activityFrame);
		res::Container_Remove(param_1->resData_28c);
	}
	if (globs::smokeGlobs.lastSmoke == param_1) {
		globs::smokeGlobs.lastSmoke = param_1->previous;
		if (globs::smokeGlobs.lastSmoke == NULL) {
			globs::smokeGlobs.firstSmoke = globs::smokeGlobs.lastSmoke;
			std::free(param_1);
			return;
		}
	}
	if (param_1->next != NULL) {
		param_1->next->previous = param_1->previous;
		if (param_1->next->previous == NULL) {
			globs::smokeGlobs.firstSmoke = param_1->next;
		}
	}
	if (param_1->previous != NULL) {
		param_1->previous->next = param_1->next;
	}
	if (param_1->soundHandle != 0) {
		snd::SFX_Sample_Sound3D_StopSound(param_1->soundHandle);
	}
	std::free(param_1);
	return;
}



void __cdecl lego::effect::Smoke_HideAll(BOOL hide)
{
	SurfaceMapStruct_2a8 **ppSVar1;
	SurfaceMapStruct_2a8 *pSVar2;
	
	pSVar2 = globs::smokeGlobs.firstSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		do {
			Smoke_Hide(pSVar2,hide);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != NULL);
	}
	return;
}



void __cdecl lego::effect::Smoke_Hide(SurfaceMapStruct_2a8 *param_1,BOOL hide)
{
	res::Mesh_Hide(param_1->mesh,hide);
	if (hide != 0) {
		param_1->flags_294 = param_1->flags_294 | SURFMAP_STRUCT2A8_HIDDEN;
		return;
	}
	param_1->flags_294 = param_1->flags_294 & ~SURFMAP_STRUCT2A8_HIDDEN;
	return;
}



void __cdecl lego::effect::Smoke_Update(float elapsedGame)
{
	SurfaceMapStruct_2a8 *pSVar1;
	SurfaceMapStruct2A8Flags SVar2;
	bool bVar3;
	Vector3F *opt_position;
	D3DRMGroupIndex DVar4;
	SurfaceMapStruct_2a8 *pSVar5;
	SurfaceMapStruct_2a8 *pSVar6;
	
	pSVar6 = globs::smokeGlobs.firstSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		do {
			pSVar1 = pSVar6->next;
			bVar3 = true;
			if (((*(byte *)&pSVar6->flags_294 & 0x20) == 0) && (pSVar6->soundHandle == 0)) {
				if (pSVar6->field_2a0 != 0) {
					opt_position = &pSVar6->vector_25c;
					res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
										(NULL,pSVar6->field_2a0,1,0,opt_position);
					pSVar6->soundHandle = (int)opt_position;
				}
				if (pSVar6->soundHandle == 0) {
					pSVar6->flags_294 = pSVar6->flags_294 | 0x20;
				}
			}
			SVar2 = pSVar6->flags_294;
			if ((SVar2 & SURFMAP_STRUCT2A8_HIDDEN) == SURFMAP_STRUCT2A8_NONE) {
				if (((SVar2 & SURFMAP_STRUCT2A8_UNK_8) == SURFMAP_STRUCT2A8_NONE) ||
					 ((SVar2 & SURFMAP_STRUCT2A8_UNK_10) == SURFMAP_STRUCT2A8_NONE)) {
					if ((ushort)((ushort)(pSVar6->float_258 < 0.0) << 8 |
											(ushort)(pSVar6->float_258 == 0.0) << 0xe) != 0) {
						DVar4 = D3DRMGROUP_0;
						pSVar5 = pSVar6;
						if (pSVar6->groupCount != D3DRMGROUP_0) {
							do {
								if (pSVar5->groupList[0].used_0 == 0) {
									Smoke_Group_UpdateUnhide_FUN_00465f10(pSVar6,DVar4);
									break;
								}
								DVar4 += 1;
								pSVar5 = (SurfaceMapStruct_2a8 *)(pSVar5->groupList + 1);
							} while (DVar4 < pSVar6->groupCount);
						}
					}
					pSVar6->float_258 = pSVar6->float_258 - elapsedGame;
				}
				DVar4 = D3DRMGROUP_0;
				pSVar5 = pSVar6;
				if (pSVar6->groupCount != 0) {
					do {
						if (pSVar5->groupList[0].used_0 != 0) {
							Smoke_Group_Update_FUN_004660c0(pSVar6,DVar4,elapsedGame);
							bVar3 = false;
						}
						DVar4 += 1;
						pSVar5 = (SurfaceMapStruct_2a8 *)(pSVar5->groupList + 1);
					} while (DVar4 < pSVar6->groupCount);
				}
				if ((((pSVar6->flags_294 & SURFMAP_STRUCT2A8_UNK_8) != SURFMAP_STRUCT2A8_NONE) &&
						((pSVar6->flags_294 & SURFMAP_STRUCT2A8_UNK_10) != SURFMAP_STRUCT2A8_NONE)) && (bVar3))
				{
					Smoke_Remove(pSVar6,pSVar6->resData_28c);
				}
			}
			pSVar6 = pSVar1;
		} while (pSVar1 != NULL);
	}
	return;
}



int __cdecl
lego::effect::Smoke_Group_UpdateUnhide_FUN_00465f10
					(SurfaceMapStruct_2a8 *param_1,D3DRMGroupIndex groupID)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	int iVar3;
	Vector3F local_18;
	Vector3F local_c;
	
	pSVar1 = param_1->groupList + groupID;
	if ((param_1->flags_294 & SURFMAP_STRUCT2A8_UNK_8) != SURFMAP_STRUCT2A8_NONE) {
		if (param_1->int_284 == 3) {
			param_1->flags_294 = param_1->flags_294 | SURFMAP_STRUCT2A8_UNK_10;
		}
		param_1->int_284 = param_1->int_284 + 1;
	}
	pSVar1->used_0 = 1;
	res::Mesh_HideGroup(param_1->mesh,groupID,FALSE);
	math::Maths_Vector3DRandom(&local_18);
	local_18.z = -ABS(local_18.z) * 0.17 - 0.83;
	(pSVar1->vector_4).x = local_18.x * 0.17;
	(pSVar1->vector_4).y = local_18.y * 0.17;
	(pSVar1->vector_4).z = local_18.z;
	local_18.z = (param_1->vector_268).z + local_18.z;
	fVar2 = -param_1->float_288 / local_18.z;
	local_18.z = fVar2 * local_18.z;
	local_18.x = fVar2 * ((param_1->vector_268).x + local_18.x * 0.17);
	local_18.y = fVar2 * ((param_1->vector_268).y + local_18.y * 0.17);
	param_1->flags_294 = SURFMAP_STRUCT2A8_UNK_4;
	res::Container_GetPosition(param_1->resData_28c,NULL,&local_c);
	(pSVar1->vector_1c).x = local_c.x;
	pSVar1->float_30 = 0.0;
	pSVar1->field_38 = 0;
	(pSVar1->vector_1c).y = local_c.y;
	(pSVar1->vector_1c).z = local_c.z;
	(pSVar1->vector_10).x = local_18.x;
	(pSVar1->vector_10).y = local_18.y;
	(pSVar1->vector_10).z = local_18.z;
	iVar3 = std::rand();
	pSVar1->int_34 = iVar3 % 0x1e + 0x28;
	param_1->float_258 = (0.5 / param_1->float_288) * pSVar1->float_2c;
	return iVar3 / 0x1e;
}



void __cdecl
lego::effect::Smoke_Group_Update_FUN_004660c0
					(SurfaceMapStruct_2a8 *param_1,D3DRMGroupIndex groupID,float elapsedGame)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	float fVar3;
	
	fVar2 = param_1->groupList[groupID].vector_10.y;
	pSVar1 = param_1->groupList + groupID;
	fVar3 = (pSVar1->vector_10).z * elapsedGame;
	(pSVar1->vector_1c).x =
			 param_1->groupList[groupID].vector_10.x * elapsedGame + (pSVar1->vector_1c).x;
	(pSVar1->vector_1c).y = (pSVar1->vector_1c).y + fVar2 * elapsedGame;
	(pSVar1->vector_1c).z = (pSVar1->vector_1c).z + fVar3;
	fVar2 = ABS(fVar3) + (float)pSVar1->field_38;
	pSVar1->field_38 = fVar2;
	if ((float)pSVar1->int_34 <= fVar2) {
		pSVar1->used_0 = 0;
		res::Mesh_HideGroup(param_1->mesh,groupID,TRUE);
		return;
	}
	pSVar1->float_30 = elapsedGame + pSVar1->float_30;
	res::Mesh_SetGroupMaterialValues
						(param_1->mesh,groupID,0.7 - (fVar2 / (float)pSVar1->int_34) * 0.7,MATERIAL_ALPHA);
	return;
}



void __cdecl
lego::effect::Smoke_MeshRenderCallback(Mesh *mesh,SurfaceMapStruct_2a8 *data,Viewport *view)
{
	Container *cont;
	SurfaceMapStruct_2a8 *pSVar1;
	D3DRMGroupIndex groupID;
	Vector3F lightPos;
	
	cont = lrr::Lego_GetCurrentViewLight();
	res::Container_GetPosition(cont,NULL,&lightPos);
	groupID = D3DRMGROUP_0;
	pSVar1 = data;
	if (data->groupCount != 0) {
		do {
			if (pSVar1->groupList[0].used_0 != 0) {
				Smoke_Group_MeshRenderCallback(data,groupID,view,&lightPos);
			}
			groupID += 1;
			pSVar1 = (SurfaceMapStruct_2a8 *)(pSVar1->groupList + 1);
		} while (groupID < data->groupCount);
	}
	return;
}



void __cdecl
lego::effect::Smoke_Group_MeshRenderCallback
					(SurfaceMapStruct_2a8 *param_1,D3DRMGroupIndex groupID,Viewport *view,Vector3F *lightPos)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	float fVar3;
	Container *cont;
	Vector3F local_80;
	Vector3F local_74;
	Vector3F vertices [4];
	Vector3F local_38;
	Point2F textCoords [4];
	Vector3F local_c;
	
	textCoords[0].x = 0.0;
	textCoords[0].y = 1.0;
	textCoords[1].x = 0.0;
	textCoords[1].y = 0.0;
	textCoords[2].x = 1.0;
	textCoords[2].y = 0.0;
	textCoords[3].x = 1.0;
	textCoords[3].y = 1.0;
	pSVar1 = param_1->groupList + groupID;
	cont = lego::view::Viewport_GetCamera(view);
	res::Container_GetOrientation(cont,NULL,&local_38,&local_c);
	local_74.y = local_38.x * -1.0 - 0.0;
	local_74.x = 0.0 - local_38.y * -1.0;
	local_80.x = 0.0;
	local_80.y = 0.0;
	local_80.z = -1.0;
	local_74.z = 0.0;
	if ((ushort)((ushort)(local_38.z < 0.3) << 8 | (ushort)(local_38.z == 0.3) << 0xe) == 0) {
		math::Maths_Vector3DRotate(&local_80,&local_80,&local_74,0.7);
	}
	fVar3 = (float)pSVar1->field_38 / (float)pSVar1->int_34 - -1.0;
	fVar2 = pSVar1->float_28 * fVar3;
	fVar3 = pSVar1->float_2c * fVar3;
	local_74.x = fVar2 * local_74.x;
	local_74.y = fVar2 * local_74.y;
	local_74.z = fVar2 * local_74.z;
	vertices[0].x = (pSVar1->vector_1c).x + local_74.x;
	vertices[1].x = (pSVar1->vector_1c).x - local_74.x;
	vertices[0].y = (pSVar1->vector_1c).y + local_74.y;
	vertices[1].y = (pSVar1->vector_1c).y - local_74.y;
	local_80.x = fVar3 * local_80.x;
	vertices[0].z = (pSVar1->vector_1c).z + local_74.z;
	vertices[1].z = (pSVar1->vector_1c).z - local_74.z;
	local_80.y = fVar3 * local_80.y;
	local_80.z = fVar3 * local_80.z;
	vertices[2].x = vertices[1].x - local_80.x;
	vertices[3].x = vertices[0].x - local_80.x;
	vertices[2].y = vertices[1].y - local_80.y;
	vertices[3].y = vertices[0].y - local_80.y;
	vertices[2].z = vertices[1].z - local_80.z;
	vertices[3].z = vertices[0].z - local_80.z;
	res::Mesh_SetVertices_PointNormalAt(param_1->mesh,groupID,0,4,vertices,lightPos,textCoords);
	return;
}



void __cdecl lego::game::SpiderWeb_Initialise(LevelData *level)
{
	uint uVar1;
	int iVar2;
	BlockSpiderWeb *pBVar3;
	
	globs::spiderwebGlobs.webBlocks =
			 (BlockSpiderWeb *)std::malloc((level->dimensions).width * (level->dimensions).height * 0xc);
	if (globs::spiderwebGlobs.webBlocks != NULL) {
		pBVar3 = globs::spiderwebGlobs.webBlocks;
		for (uVar1 = (level->dimensions).width * (level->dimensions).height * 3 & 0x3fffffff; uVar1 != 0
				; uVar1 -= 1) {
			pBVar3->object = NULL;
			pBVar3 = (BlockSpiderWeb *)&pBVar3->health;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pBVar3->object = 0;
			pBVar3 = (BlockSpiderWeb *)((int)&pBVar3->object + 1);
		}
	}
	globs::spiderwebGlobs.level = level;
	return;
}



void __cdecl lego::game::SpiderWeb_Shutdown(void)
{
	if (globs::spiderwebGlobs.webBlocks != NULL) {
		std::free(globs::spiderwebGlobs.webBlocks);
		globs::spiderwebGlobs.webBlocks = NULL;
	}
	return;
}



void __cdecl lego::game::SpiderWeb_ResetAll(LevelData *level)
{
	SpiderWeb_Shutdown();
	SpiderWeb_Initialise(level);
	return;
}



BOOL __cdecl lego::game::SpiderWeb_SpawnAt(uint bx,uint by)
{
	BOOL BVar1;
	LiveObject *webObj;
	Point2F local_8;
	uint by_00;
	
	by_00 = by;
	if ((globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
			 flags & BLOCKWEB_ACTIVE) == BLOCKWEB_NONE) {
		BVar1 = SpiderWeb_GetAngle(bx,by,(float *)&by);
		if (BVar1 != 0) {
			Map3D_BlockToWorldPos
								((globs::spiderwebGlobs.level)->surfaceMap,bx,by_00,&local_8.x,&local_8.y);
			webObj = LiveObject_CreateInWorld
												 (globs::legoGlobs.contSpiderWeb,OBJECT_SPIDERWEB,0,0,local_8.x,local_8.y,
													(float)by);
			SpiderWeb_Add(bx,by_00,webObj);
			(globs::spiderwebGlobs.webBlocks
			 [((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->flags1 =
					 (globs::spiderwebGlobs.webBlocks
						[((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->flags1 |
					 LIVEOBJ1_UNK_100;
			res::Container_SetActivity
								((globs::spiderwebGlobs.webBlocks
									[((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->other,
								 "Expand");
			res::Container_SetAnimationTime
								((globs::spiderwebGlobs.webBlocks
									[((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->other,
								 0.0);
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::SpiderWeb_Add(int bx,int by,LiveObject *webObj)
{
	globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	object = webObj;
	globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].flags
			 = globs::spiderwebGlobs.webBlocks
				 [((globs::spiderwebGlobs.level)->dimensions).width * by + bx].flags | BLOCKWEB_ACTIVE;
						// 100.0f
	globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	health = (float)&DAT_42c80000;
	return;
}



BOOL __cdecl lego::game::SpiderWeb_GetAngle(int bx,int by,float *out_theta)
{
	int idx;
	LevelBlock *blocks;
	int width;
	
	width = ((globs::spiderwebGlobs.level)->dimensions).width;
	blocks = (globs::spiderwebGlobs.level)->blocks;
	idx = by * width + bx;
	if ((*(byte *)&blocks[idx].flags1 & BLOCK1_GROUND) == 0) {
		return 0;
	}
	if (((*(byte *)&(blocks + idx)[1].flags1 & BLOCK1_WALL_UNK) == 0) ||
		 ((*(byte *)&(blocks + idx)[-1].flags1 & BLOCK1_WALL_UNK) == 0)) {
		if ((*(byte *)&blocks[(by + 1) * width + bx].flags1 & BLOCK1_WALL_UNK) == 0) {
			return 0;
		}
		if ((*(byte *)&blocks[(by + -1) * width + bx].flags1 & BLOCK1_WALL_UNK) == 0) {
			return 0;
		}
		if (out_theta != NULL) {
			*out_theta = 0.0;
		}
	}
	else {
		if (out_theta != NULL) {
			*out_theta = 1.570796;
			return TRUE;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::SpiderWeb_CheckCollision(LiveObject *liveObj)
{
	LiveObject *liveObj_00;
	BOOL BVar1;
	uint local_24;
	Point2F local_20;
	Point2F local_18;
	undefined4 local_10;
	Point2F local_c;
	undefined4 local_4;
	
	liveObj_00 = liveObj;
	BVar1 = LiveObject_GetBlockPos(liveObj,(int *)&local_24,(int *)&liveObj);
	if (BVar1 != 0) {
		if ((globs::spiderwebGlobs.webBlocks
				 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].flags &
				BLOCKWEB_ACTIVE) != BLOCKWEB_NONE) {
			Map3D_BlockToWorldPos
								((globs::spiderwebGlobs.level)->surfaceMap,local_24,(uint)liveObj,&local_c.x,
								 &local_c.y);
			LiveObject_GetFaceDirection
								(globs::spiderwebGlobs.webBlocks
								 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].
								 object,&local_20);
			local_18.x = local_20.x;
			local_18.y = local_20.y;
			local_4 = 0;
			local_10 = 0;
			BVar1 = LiveObject_Collision_FUN_00470520(liveObj_00,&local_c,&local_18,0);
			if (BVar1 != 0) {
				liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_CAUGHTINWEB;
				(globs::spiderwebGlobs.webBlocks
				 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].object)->
				flags1 = (globs::spiderwebGlobs.webBlocks
									[((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].
								 object)->flags1 | LIVEOBJ1_CAUGHTINWEB;
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::SpiderWeb_Update(float elapsedGame)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes(SpiderWeb_LiveObjectCallback,&elapsedGame);
	return BVar1;
}



BOOL __cdecl lego::game::SpiderWeb_LiveObjectCallback(LiveObject *liveObj,float *pElapsedGame)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	int idx;
	uint weaponType;
	float10 damage;
	LiveObject *liveObj_00;
	int local_4;
	BlockSpiderWeb *webBlocks;
	
	pLVar1 = liveObj;
	if (liveObj->objType == OBJECT_SPIDERWEB) {
						// Remove inactive SpiderWebs
		LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
		if (((globs::spiderwebGlobs.webBlocks
					[((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4].flags &
				 BLOCKWEB_ACTIVE) != BLOCKWEB_NONE) &&
			 (BVar2 = SpiderWeb_GetAngle(local_4,(int)liveObj,NULL), BVar2 == 0)) {
			SpiderWeb_Remove(local_4,(int)liveObj);
			return 0;
		}
	}
	else {
		if ((liveObj->flags1 & LIVEOBJ1_CAUGHTINWEB) != LIVEOBJ1_NONE) {
						// Object already caught in web, damage web (and remove if health is zeroed)
			LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
			webBlocks = globs::spiderwebGlobs.webBlocks;
			idx = ((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4;
						// if false, object is not longer in a block with spider webs
			if ((globs::spiderwebGlobs.webBlocks[idx].flags & BLOCKWEB_ACTIVE) != BLOCKWEB_NONE) {
				liveObj_00 = pLVar1;
				weaponType = tools::Weapon_GetWeaponTypeByName("SpiderWeb");
				damage = tools::Weapon_GetDamageForLiveObject(weaponType,liveObj_00);
				globs::spiderwebGlobs.webBlocks
				[((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4].health =
						 (float)((float10)webBlocks[idx].health - damage * (float10)*pElapsedGame);
				if (0.0 <= globs::spiderwebGlobs.webBlocks
									 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4].
									 health) {
					return 0;
				}
				SpiderWeb_Remove(local_4,(int)liveObj);
			}
			pLVar1->flags1 = pLVar1->flags1 & ~LIVEOBJ1_CAUGHTINWEB;
			return 0;
		}
		SpiderWeb_CheckCollision(liveObj);
	}
	return 0;
}



void __cdecl lego::game::SpiderWeb_Remove(int bx,int by)
{
	int idx;
	
	(globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	object)->flags3 =
			 (globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx]
			 .object)->flags3 | LIVEOBJ3_UNK_800000;
	(globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	object)->flags1 =
			 (globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx]
			 .object)->flags1 & ~LIVEOBJ1_CAUGHTINWEB;
	idx = ((globs::spiderwebGlobs.level)->dimensions).width * by + bx;
	globs::spiderwebGlobs.webBlocks[idx].flags =
			 globs::spiderwebGlobs.webBlocks[idx].flags & ~BLOCKWEB_ACTIVE;
	return;
}



BOOL __cdecl lego::stats::Stats_Initialise(CFGProperty *root,char *rootPath)
{
	uint *puVar1;
	BoolTri *pBVar2;
	float fVar3;
	char *pcVar4;
	CFGProperty *prop;
	BOOL BVar5;
	uint uVar6;
	ObjectStats **ppOVar7;
	ObjectStats *pOVar8;
	SFXType SVar9;
	BoolTri BVar10;
	int iVar11;
	char **ppcVar12;
	uint uVar13;
	float10 fVar14;
	SFXType *pSVar15;
	ObjectType local_14c;
	int local_148;
	char *local_144;
	uint local_140;
	BoolTri local_13c;
	char **local_138;
	char *local_134;
	char *local_130;
	char **local_12c;
	BoolTri local_128;
	char *local_124;
	float local_120;
	float local_11c;
	char *local_118;
	float local_114;
	float local_110;
	float local_10c;
	float local_108;
	float local_104;
	float local_100;
	float local_fc;
	float local_f8;
	float local_f4;
	float local_f0;
	float local_ec;
	SFXType local_e8;
	SFXType local_e4;
	SFXType local_e0;
	int local_dc;
	int local_d8;
	int local_d4;
	uint local_d0;
	undefined4 uStack204;
	char *local_c8 [32];
	char *local_48;
	char *local_44 [4];
	char *local_34;
	char *local_28;
	char *local_20;
	
	local_48 = NULL;
	ppcVar12 = local_44;
	for (iVar11 = 0x11; iVar11 != 0; iVar11 += -1) {
		*ppcVar12 = NULL;
		ppcVar12 = ppcVar12 + 1;
	}
	pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar4); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		local_128 = BOOL3_FALSE;
		local_13c = BOOL3_FALSE;
		local_140 = 0;
		pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Levels",0);
		pcVar4 = cfg::CFG_ReadString(root,pcVar4);
		if (pcVar4 == NULL) {
			pcVar4 = ____EMPTYSTR__;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Levels",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
		}
		local_134 = (char *)std::atoi(pcVar4);
		BVar5 = game::Object_GetObjectByName(prop->key,&local_14c,&local_148,NULL);
		if (BVar5 != 0) {
			if (globs::statsGlobs.objectStats[local_14c] == NULL) {
				uVar6 = game::Object_GetTypeCount(local_14c);
				ppOVar7 = (ObjectStats **)std::malloc(uVar6 * 4);
				globs::statsGlobs.objectStats[local_14c] = ppOVar7;
				for (uVar6 &= 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
					*ppOVar7 = NULL;
					ppOVar7 = ppOVar7 + 1;
				}
				for (iVar11 = 0; iVar11 != 0; iVar11 += -1) {
					*(undefined *)ppOVar7 = 0;
					ppOVar7 = (ObjectStats **)((int)ppOVar7 + 1);
				}
			}
			globs::statsGlobs.objectLevels[local_14c][local_148] = (uint)local_134;
			uVar6 = (int)local_134 * 0x150;
			pOVar8 = (ObjectStats *)std::malloc(uVar6);
			globs::statsGlobs.objectStats[local_14c][local_148] = pOVar8;
			pOVar8 = globs::statsGlobs.objectStats[local_14c][local_148];
			for (uVar6 >>= 2; uVar6 != 0; uVar6 -= 1) {
				pOVar8->field_0 = 0;
				pOVar8 = (ObjectStats *)&pOVar8->field_4;
			}
			for (iVar11 = 0; iVar11 != 0; iVar11 += -1) {
				*(undefined *)&pOVar8->field_0 = 0;
				pOVar8 = (ObjectStats *)((int)&pOVar8->field_0 + 1);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RouteSpeed",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_12c = local_c8;
					local_144 = NULL;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*local_12c);
						*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
											(int)local_144 + -4) = (float)fVar14;
						local_144 = (char *)((int)local_144 + 0x150);
						local_12c = local_12c + 1;
						local_130 = local_130 + -1;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SoilDrillTime",0);
			local_34 = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"LooseDrillTime",0);
			local_44[3] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"MedDrillTime",0);
			local_44[2] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"HardDrillTime",0);
			local_44[1] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SeamDrillTime",0);
			local_28 = cfg::CFG_CopyString(root,pcVar4);
			if (local_28 == NULL) {
				local_20 = NULL;
			}
			else {
				local_20 = util::_strdup(local_28);
			}
			local_12c = &local_48;
			local_114 = (float)(0x24 - (int)&local_48);
			local_120 = 2.522337e-44;
			do {
				pcVar4 = *local_12c;
				local_118 = pcVar4;
				if (pcVar4 != NULL) {
					util::Util_Tokenise(pcVar4,local_c8,":");
					if (local_134 != NULL) {
						local_144 = (char *)((int)local_114 + (int)local_12c);
						ppcVar12 = local_c8;
						local_130 = local_134;
						do {
							fVar14 = std::atof(*ppcVar12);
							ppcVar12 = ppcVar12 + 1;
							*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
												(int)local_144 + -0x24) = (float)(fVar14 * (float10)25.0);
							local_144 = (char *)((int)local_144 + 0x150);
							local_130 = local_130 + -1;
							pcVar4 = local_118;
						} while (local_130 != NULL);
					}
					std::free(pcVar4);
				}
				local_12c = local_12c + 1;
				local_120 = (float)((int)local_120 + -1);
			} while (local_120 != 0.0);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"BuildingBase",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				local_144 = (char *)0xffffffff;
			}
			else {
				local_144 = (char *)game::Construction_GetBuildingBase(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostCrystal",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostCrystal",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d8 = std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostOre",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostOre",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d4 = std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostRefinedOre",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostRefinedOre",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_124 = (char *)std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrackDist",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrackDist",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_120 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AlertRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AlertRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_114 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollHeight",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollHeight",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_118 = (char *)(float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"HealthDecayRate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"HealthDecayRate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_110 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EnergyDecayRate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EnergyDecayRate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_100 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PickSphere",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PickSphere",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_130 = (char *)(float)fVar14;
			pSVar15 = &local_e0;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DrillSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			BVar5 = snd::SFX_GetType(pcVar4,pSVar15);
			if (BVar5 == 0) {
				local_e0 = SFX_DRILL;
			}
			pSVar15 = &local_e8;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DrillFadeSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			BVar5 = snd::SFX_GetType(pcVar4,pSVar15);
			if (BVar5 == 0) {
				local_e8 = SFX_DRILLFADE;
			}
			pSVar15 = &local_e4;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EngineSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			SVar9 = snd::SFX_GetType(pcVar4,pSVar15);
			if (SVar9 == SFX_NULL) {
				local_e4 = SVar9;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RestPercent",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RestPercent",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_10c = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryMinHealth",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryMinHealth",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_104 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"StampRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"StampRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_fc = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AttackRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AttackRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f8 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WaterEntrances",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WaterEntrances",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_f4 = (float)std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RubbleCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RubbleCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_11c = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PathCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PathCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_138 = (char **)(float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"OxygenCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"OxygenCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_108 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Capacity",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Capacity",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_dc = std::atoi(pcVar4);
			if (local_11c == 0.0) {
				local_11c = 1.0;
			}
			if ((float)local_138 == 0.0) {
				local_138 = (char **)0x3f800000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_12c = (char **)(float)fVar14;
			if ((float10)0.0 == fVar14) {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollBox",0);
				pcVar4 = cfg::CFG_CopyString(root,pcVar4);
				if (pcVar4 != NULL) {
					util::Util_Tokenise(pcVar4,local_c8,",");
					fVar14 = std::atof(local_c8[0]);
					local_f0 = (float)fVar14;
					fVar14 = std::atof(local_c8[1]);
					local_ec = (float)fVar14;
					fVar3 = local_ec;
					if ((ushort)((ushort)(local_f0 < local_ec) << 8 | (ushort)(local_f0 == local_ec) << 0xe)
							== 0) {
						fVar3 = local_f0;
					}
					local_12c = (char **)(fVar3 * 0.5);
					local_140 = 0x100;
				}
			}
			else {
				local_140 = 0x80;
			}
			if (local_134 != NULL) {
				iVar11 = 0;
				pcVar4 = local_134;
				do {
					*(char ***)
					 ((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes + iVar11 + 0x48) =
							 local_12c;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x4c) = local_114;
					pOVar8 = globs::statsGlobs.objectStats[local_14c][local_148];
					*(float *)((int)pOVar8->DrillTimes + iVar11 + 0x7c) = local_f0;
					*(float *)((int)pOVar8->DrillTimes + iVar11 + 0x80) = local_ec;
					*(char **)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x54) = local_130;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x58) = local_120;
					*(char **)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x50) = local_118;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x5c) = local_110;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x60) = local_100;
					*(char **)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->BuildingBase +
										iVar11) = local_144;
					*(SFXType *)
					 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->DrillSound + iVar11) =
							 local_e0;
					*(SFXType *)
					 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->DrillFadeSound + iVar11) =
							 local_e8;
					*(SFXType *)
					 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->EngineSound + iVar11) =
							 local_e4;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x68) = local_10c;
					pcVar4 = pcVar4 + -1;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x6c) = local_104;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x70) = local_fc;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x74) = local_f8;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->WaterEntrances +
										iVar11) = local_f4;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->RubbleCoef + iVar11)
							 = local_11c;
					*(char ***)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->PathCoef + iVar11)
							 = local_138;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->OxygenCoef + iVar11)
							 = local_108;
					*(int *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Capacity + iVar11) =
							 local_dc;
					*(int *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->CostCrystal + iVar11)
							 = local_d8;
					*(int *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->CostOre + iVar11) =
							 local_d4;
					*(char **)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->CostRefinedOre +
										iVar11) = local_124;
					iVar11 = iVar11 + 0x150;
				} while (pcVar4 != NULL);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SingleWidthDig",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags1 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags1 +
															iVar11) | 1;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = local_124;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RepairValue",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(float *)(local_144 +
											(int)&globs::statsGlobs.objectStats[local_14c][local_148]->RepairValue) =
								 (float)fVar14;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SurveyRadius",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globs::statsGlobs.objectStats[local_14c][local_148]->SurveyRadius) =
								 iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"MaxCarry",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 + (int)&globs::statsGlobs.objectStats[local_14c][local_148]->MaxCarry
										) = iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryStart",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globs::statsGlobs.objectStats[local_14c][local_148]->CarryStart) = iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrystalDrain",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globs::statsGlobs.objectStats[local_14c][local_148]->CrystalDrain) =
								 iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"NumOfToolsCanCarry",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globs::statsGlobs.objectStats[local_14c][local_148]->NumOfToolsCanCarry) =
								 iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeTime",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(float *)(local_144 +
											(int)&globs::statsGlobs.objectStats[local_14c][local_148]->UpgradeTime) =
								 (float)(fVar14 * (float10)25.0);
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FunctionCoef",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						local_144 = local_144 + 0x150;
						*(float *)(local_144 +
											(int)&globs::statsGlobs.objectStats[local_14c][local_148][-1].FunctionCoef) =
								 (float)fVar14;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeCostOre",0);
			local_144 = cfg::CFG_CopyString(root,pcVar4);
			if (local_144 != NULL) {
				util::Util_Tokenise(local_144,local_c8,":");
				local_138 = local_c8 + 3;
				uVar6 = 0;
				do {
					iVar11 = std::atoi(*local_138);
					uVar13 = uVar6 + 0x150;
					local_138 = local_138 + -1;
					*(int *)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
									(uVar6 - 0x78)) = iVar11;
					uVar6 = uVar13;
				} while (uVar13 < 0x540);
				std::free(local_144);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeCostStuds",0);
			local_144 = cfg::CFG_CopyString(root,pcVar4);
			if (local_144 != NULL) {
				util::Util_Tokenise(local_144,local_c8,":");
				local_138 = local_c8 + 3;
				uVar6 = 0;
				do {
					iVar11 = std::atoi(*local_138);
					uVar13 = uVar6 + 0x150;
					*(int *)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
									(uVar6 - 0x74)) = iVar11;
					local_138 = local_138 + -1;
					uVar6 = uVar13;
				} while (uVar13 < 0x540);
				std::free(local_144);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ProcessOre",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 2;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ProcessCrystal",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 4;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"StoreObjects",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 8;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ManTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x80000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SmallTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"BigTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WaterTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SnaxULike",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x4000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ToolStore",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x100000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CauseSlip",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x200;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomMove",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x400;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanScare",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x800;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanScareScorpion",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomEnterWall",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x1000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ScaredByPlayer",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x2000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"GrabMinifigure",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x8000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanBeDriven",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanSteal",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x80000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanClearRubble",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RouteAvoidance",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"BumpDamage",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x200000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Debug",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x400000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Smooth",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x800000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrossWater",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x1000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrossLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x2000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_OnGround",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x4000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_QuickDestroy",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x8000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_AnimateByPitch",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ScaredByBigBangs",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c = BVar10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeBuilding",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= BOOL3_ERROR;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanBeShotAt",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x40000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseBigTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x800;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseSmallTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x1000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseWaterTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x2000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseLegoManTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x400000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainPilot",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 +
															iVar11) | 4;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainSailor",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 +
															iVar11) | 8;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainDriver",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 +
															iVar11) | 0x10;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainDynamite",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 +
															iVar11) | 0x20;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainRepair",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 +
															iVar11) | 0x40;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainScanner",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11)
									 = *(uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 +
															iVar11) | 0x80;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Tracker",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x100;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PowerBuilding",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x600;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SelfPowered",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x400;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AttackPaths",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x4000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SplitOnZeroHealth",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x8000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanBeHitByFence",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x10000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanDoubleSelect",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x20000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DrainPower",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x80000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseHoles",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x100000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrossLava",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x200000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DamageCausesCallToArms",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x800000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanFreeze",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x1000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanLaser",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x2000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanPush",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x4000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DontShowDamage",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x8000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RemoveReinforcement",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x10000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DontShowOnRadar",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x20000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"InvisibleDriver",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Unselectable",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x80000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryVehicles",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 = BVar10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"VehicleCanBeCarried",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= BOOL3_ERROR;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanStrafe",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 4;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ClassAsLarge",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 8;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"GetOutAtLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"GetInAtLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x20;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TakeCarryingDrivers",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x40;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ShowHealthBar",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x80;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"NeedsPilot",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x100;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EnterToolStore",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x200;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Turn",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Turn",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_138 = (char **)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_138 = (char **)&DAT_3d75c28f;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Speed",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Speed",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_11c = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_11c = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Tightness",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Tightness",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_12c = (char **)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_12c = (char **)0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_GoalUpdate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_GoalUpdate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_108 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_108 = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Height",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Height",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f4 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_f4 = 30.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Randomness",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Randomness",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f8 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_f8 = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Size",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Size",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d0 = std::atoi(pcVar4);
			uStack204 = 0;
			local_114 = (float)local_d0;
			if ((float)(ulonglong)local_d0 == 0.0) {
				local_114 = 7.006492e-45;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_AttackTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_AttackTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_fc = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_fc = 300.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AwarenessRange",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AwarenessRange",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_104 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_104 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PainThreshold",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PainThreshold",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_10c = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_10c = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_130 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_130 = NULL;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_120 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_120 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDist",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDist",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_110 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_110 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_100 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_100 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"LaserDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"LaserDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_118 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_118 = NULL;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WakeRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WakeRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_144 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_144 = (char *)0x41a00000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomMoveTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomMoveTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			if (fVar14 == (float10)0.0) {
				fVar14 = (float10)200.0;
			}
			if (local_134 != NULL) {
				iVar11 = 0;
				pcVar4 = local_134;
				do {
					puVar1 = (uint *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags1 +
													 iVar11);
					*puVar1 = *puVar1 | local_140;
					pBVar2 = (BoolTri *)
									 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags2 + iVar11);
					*pBVar2 = *pBVar2 | local_13c;
					pBVar2 = (BoolTri *)
									 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->flags3 + iVar11);
					*pBVar2 = *pBVar2 | local_128;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->RandomMoveTime +
										iVar11) = (float)fVar14;
					*(char ***)
					 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_Turn + iVar11) =
							 local_138;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_Speed +
										iVar11) = local_11c;
					*(char ***)
					 ((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_Tightness + iVar11) =
							 local_12c;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_GoalUpdate +
										iVar11) = local_108;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_Height +
										iVar11) = local_f4;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_Randomness +
										iVar11) = local_f8;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_Size + iVar11
										) = local_114;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->Flocks_AttackTime +
										iVar11) = local_fc;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->AwarenessRange +
										iVar11) = local_104;
					pcVar4 = pcVar4 + -1;
					*(float *)((int)&globs::statsGlobs.objectStats[local_14c][local_148]->PainThreshold +
										iVar11) = local_10c;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x5c) = local_100;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x60) = local_110;
					*(char **)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x58) = local_118;
					*(float *)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
										iVar11 + -100) = local_120;
					*(char **)((int)globs::statsGlobs.objectStats[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x68) = local_130;
					*(char **)((int)globs::statsGlobs.objectStats[local_14c][local_148]->DrillTimes +
										iVar11 + 0x78) = local_144;
					iVar11 = iVar11 + 0x150;
				} while (pcVar4 != NULL);
			}
		}
	}
	Stats_AddToolTaskType(TOOL_DRILL,AITASK_DIG);
	Stats_AddToolTaskType(TOOL_SPADE,AITASK_CLEAR);
	Stats_AddToolTaskType(TOOL_HAMMER,AITASK_REINFORCE);
	Stats_AddToolTaskType(TOOL_SPANNER,AITASK_REPAIR);
	return 1;
}



void __cdecl lego::stats::Stats_AddToolTaskType(ToolType toolType,AITaskType taskType)
{
	uint *pTaskCount;
	
	pTaskCount = &globs::statsGlobs.toolStats[toolType].taskCount;
	globs::statsGlobs.toolStats[toolType].taskTypes[globs::statsGlobs.toolStats[toolType].taskCount] =
			 taskType;
	*pTaskCount = *pTaskCount + 1;
	return;
}



int __cdecl lego::stats::Stats_GetCostOre(ObjectType objType,int objIndex,int objLevel)
{
	return globs::statsGlobs.objectStats[objType][objIndex][objLevel].CostOre;
}



int __cdecl lego::stats::Stats_GetCostCrystal(ObjectType objType,int objIndex,int objLevel)
{
	return globs::statsGlobs.objectStats[objType][objIndex][objLevel].CostCrystal;
}



int __cdecl lego::stats::Stats_GetCostRefinedOre(ObjectType objType,int objIndex,int objLevel)
{
	return globs::statsGlobs.objectStats[objType][objIndex][objLevel].CostRefinedOre;
}



int __cdecl lego::stats::StatsObject_GetCrystalDrain(LiveObject *liveObj)
{
	return globs::statsGlobs.objectStats[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 CrystalDrain;
}



int __cdecl lego::stats::StatsObject_GetCapacity(LiveObject *liveObj)
{
	return globs::statsGlobs.objectStats[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 Capacity;
}



int __cdecl lego::stats::StatsObject_GetMaxCarry(LiveObject *liveObj)
{
	return globs::statsGlobs.objectStats[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 MaxCarry;
}



int __cdecl lego::stats::StatsObject_GetCarryStart(LiveObject *liveObj)
{
	return globs::statsGlobs.objectStats[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 CarryStart;
}



BOOL __cdecl lego::stats::StatsObject_SetObjectLevel(LiveObject *liveObj,uint level)
{
	ObjectType objType;
	int objIndex;
	uint oldLevel;
	
	objType = liveObj->objType;
	objIndex = liveObj->objIndex;
	if (level < globs::statsGlobs.objectLevels[objType][objIndex]) {
		oldLevel = liveObj->objLevel;
		if (level != oldLevel) {
			globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][oldLevel] =
					 globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][oldLevel] + 1;
			globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][level] =
					 globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][level] +
					 1;
		}
		liveObj->objLevel = level;
		liveObj->stats = globs::statsGlobs.objectStats[liveObj->objType][liveObj->objIndex] + level;
		return TRUE;
	}
	return 0;
}



float10 __cdecl lego::stats::StatsObject_GetRouteSpeed(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RouteSpeed;
}



float10 __cdecl
lego::stats::StatsObject_GetDrillTimeType(LiveObject *liveObj,SurfaceType surfaceType)
{
	return (float10)liveObj->stats->DrillTimes[surfaceType];
}



float10 __cdecl lego::stats::StatsObject_GetRubbleCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RubbleCoef;
}



float10 __cdecl lego::stats::StatsObject_GetWakeRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->WakeRadius;
}



float10 __cdecl lego::stats::StatsObject_GetPathCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PathCoef;
}



float10 __cdecl lego::stats::StatsObject_GetCollRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CollRadius;
}



float10 __cdecl lego::stats::StatsObject_GetCollHeight(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CollHeight;
}



float10 __cdecl lego::stats::StatsObject_GetPickSphere(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PickSphere;
}



float10 __cdecl lego::stats::StatsObject_GetPainThreshold(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PainThreshold;
}



float10 __cdecl lego::stats::StatsObject_GetAlertRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AlertRadius;
}



int __cdecl lego::stats::StatsObject_GetCollBox(LiveObject *liveObj)
{
	return (int)&liveObj->stats->CollBox;
}



float10 __cdecl lego::stats::StatsObject_GetTrackDist(LiveObject *liveObj)
{
	return (float10)liveObj->stats->TrackDist;
}



float10 __cdecl lego::stats::StatsObject_GetHealthDecayRate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->HealthDecayRate;
}



float10 __cdecl lego::stats::StatsObject_GetEnergyDecayRate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->EnergyDecayRate;
}



float10 __cdecl lego::stats::Stats_GetOxygenCoef(ObjectType objType,int objIndex)
{
	return (float10)globs::statsGlobs.objectStats[objType][objIndex]->OxygenCoef;
}



float10 __cdecl lego::stats::StatsObject_GetOxygenCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->OxygenCoef;
}



int __cdecl lego::stats::StatsObject_GetSurveyRadius(LiveObject *liveObj)
{
	return liveObj->stats->SurveyRadius;
}



ObjectStatsFlags1 __cdecl lego::stats::StatsObject_GetStatsFlags1(LiveObject *liveObj)
{
	return liveObj->stats->flags1;
}



ObjectStatsFlags2 __cdecl lego::stats::StatsObject_GetStatsFlags2(LiveObject *liveObj)
{
	return liveObj->stats->flags2;
}



ObjectStatsFlags3 __cdecl lego::stats::StatsObject_GetStatsFlags3(LiveObject *liveObj)
{
	return liveObj->stats->flags3;
}



ObjectStatsFlags1 __cdecl lego::stats::Stats_GetStatsFlags1(ObjectType objType,int objIndex)
{
	return globs::statsGlobs.objectStats[objType][objIndex]->flags1;
}



ObjectStatsFlags2 __cdecl lego::stats::Stats_GetStatsFlags2(ObjectType objType,int objIndex)
{
	return globs::statsGlobs.objectStats[objType][objIndex]->flags2;
}



ObjectStatsFlags3 __cdecl lego::stats::Stats_GetStatsFlags3(ObjectType objType,int objIndex)
{
	return globs::statsGlobs.objectStats[objType][objIndex]->flags3;
}



float10 __cdecl lego::stats::StatsObject_GetRepairValue(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RepairValue;
}



uint __cdecl lego::stats::Stats_GetLevels(ObjectType objType,int objIndex)
{
	return *(uint *)(objIndex * 4 + 0x503c28 + objType * 0x3c);
}



int __cdecl lego::stats::Stats_GetWaterEntrances(ObjectType objType,int objIndex,int objLevel)
{
	return globs::statsGlobs.objectStats[objType][objIndex][objLevel].WaterEntrances;
}



SFXType __cdecl lego::stats::StatsObject_GetDrillSoundType(LiveObject *liveObj,BOOL fade)
{
	if (fade != 0) {
		return liveObj->stats->DrillFadeSound;
	}
	return liveObj->stats->DrillSound;
}



SFXType __cdecl lego::stats::StatsObject_GetEngineSound(LiveObject *liveObj)
{
	return liveObj->stats->EngineSound;
}



float10 __cdecl lego::stats::StatsObject_GetRestPercent(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RestPercent;
}



float10 __cdecl lego::stats::StatsObject_GetCarryMinHealth(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CarryMinHealth;
}



float10 __cdecl lego::stats::StatsObject_GetAttackRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AttackRadius;
}



float10 __cdecl lego::stats::StatsObject_GetStampRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->StampRadius;
}



int __cdecl lego::stats::StatsObject_GetNumOfToolsCanCarry(LiveObject *liveObj)
{
	return liveObj->stats->NumOfToolsCanCarry;
}



float10 __cdecl lego::stats::StatsObject_GetUpgradeTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->UpgradeTime;
}



float10 __cdecl lego::stats::StatsObject_GetFunctionCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FunctionCoef;
}



int __cdecl lego::stats::Stats_GetUpgradeCostOre(ObjectType objType,int objIndex,int objLevel)
{
	return globs::statsGlobs.objectStats[objType][objIndex][objLevel].UpgradeCostOre;
}



int __cdecl lego::stats::Stats_GetUpgradeCostStuds(ObjectType objType,int objIndex,int objLevel)
{
	return globs::statsGlobs.objectStats[objType][objIndex][objLevel].UpgradeCostStuds;
}



BOOL __cdecl lego::stats::Stats_FindToolFromTaskType(AITaskType taskType,ToolType *out_toolType)
{
	ToolStats *pToolStats;
	uint j;
	AITaskType *pTaskType;
	uint i;
	
	i = 0;
	pToolStats = globs::statsGlobs.toolStats;
	do {
						// pTaskType = &pToolStats->taskTypes[0];
		j = 0;
		pTaskType = pToolStats->taskTypes;
		if (pToolStats->taskCount != 0) {
			do {
				if (taskType == *pTaskType) {
					*out_toolType = i;
					return TRUE;
				}
				j += 1;
				pTaskType = pTaskType + 1;
			} while (j < pToolStats->taskCount);
		}
		pToolStats = pToolStats + 1;
		i += TOOL_SPADE;
	} while (pToolStats < &globals::g_Teleporter_BOOL_00504188);
	return 0;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_Height(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Height;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_Randomness(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Randomness;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_Turn(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Turn;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_Tightness(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Tightness;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_Speed(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Speed;
}



int __cdecl lego::stats::StatsObject_GetFlocks_Size(LiveObject *liveObj)
{
	return liveObj->stats->Flocks_Size;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_GoalUpdate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_GoalUpdate;
}



float10 __cdecl lego::stats::StatsObject_GetFlocks_AttackTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_AttackTime;
}



float10 __cdecl lego::stats::StatsObject_GetAwarenessRange(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AwarenessRange;
}



float10 __cdecl lego::stats::StatsObject_GetPusherDist(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PusherDist;
}



float10 __cdecl lego::stats::StatsObject_GetPusherDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PusherDamage;
}



float10 __cdecl lego::stats::StatsObject_GetLaserDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->LaserDamage;
}



float10 __cdecl lego::stats::StatsObject_GetFreezerDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FreezerDamage;
}



float10 __cdecl lego::stats::StatsObject_GetObjectFreezerTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FreezerTime;
}



// This function will ALTER OBJECT STATS by removing the SelfPowered flag.

void __cdecl lego::debug::StatsObject_Debug_ToggleObjectPower(LiveObject *liveObj)
{
	ObjectStatsFlags2 statsFlags2;
	ObjectStats *stats;
	
	stats = liveObj->stats;
	statsFlags2 = stats->flags2;
	if ((statsFlags2 & STATS2_SELFPOWERED) != STATS2_NONE) {
						// WTF Ghidra...
						// stats->flags2 &= ~STATS2_SELFPOWERED; // 0x400
		stats->flags2 =
				 statsFlags2 &
				 (STATS2_SCAREDBYBIGBANGS|STATS2_UPGRADEBUILDING|STATS2_TRAINPILOT|STATS2_TRAINSAILOR|
					STATS2_TRAINDRIVER|STATS2_TRAINDYNAMITE|STATS2_TRAINREPAIR|STATS2_TRAINSCANNER|
					STATS2_TRACKER|STATS2_GENERATEPOWER|STATS2_USEBIGTELEPORTER|STATS2_USESMALLTELEPORTER|
					STATS2_USEWATERTELEPORTER|STATS2_ATTACKPATHS|STATS2_SPLITONZEROHEALTH|
					STATS2_CANBEHITBYFENCE|STATS2_CANDOUBLESELECT|STATS2_CANBESHOTAT|STATS2_DRAINPOWER|
					STATS2_USEHOLES|STATS2_CROSSLAVA|STATS2_USELEGOMANTELEPORTER|STATS2_DAMAGECAUSESCALLTOARMS
					|STATS2_CANFREEZE|STATS2_CANLASER|STATS2_CANPUSH|STATS2_DONTSHOWDAMAGE|
					STATS2_REMOVEREINFORCEMENT|STATS2_DONTSHOWONRADAR|STATS2_INVISIBLEDRIVER|
				 STATS2_UNSELECTABLE);
		game::LiveObject_UpdatePowerConsumption(liveObj);
		return;
	}
	stats->flags2 = statsFlags2 | STATS2_SELFPOWERED;
	game::LiveObject_UpdatePowerConsumption(liveObj);
	return;
}



void __cdecl lego::unk::Teleporter_Free(TeleporterService *param_1)
{
	if (param_1 != NULL) {
		Teleporter_Free(param_1->next);
		std::free(param_1);
	}
	return;
}



void __cdecl lego::unk::Teleporter_RemoveAll(void)
{
	globs::teleporterGlobs.count = 0;
	Teleporter_Free(globs::teleporterGlobs.current);
	globs::teleporterGlobs.current = NULL;
	return;
}



BOOL __cdecl
lego::unk::Teleporter_LiveObjectCallback_Service(LiveObject *liveObj,SearchTeleporter_10 *search)
{
	uint *puVar1;
	
	if (liveObj->objType == search->objType) {
		liveObj->teleporter_field_390 = search->modeFlags;
		liveObj->teleporter_field_394 = search->teleportFlags;
		if ((*(byte *)&search->modeFlags & 2) != 0) {
			liveObj->teleporter_398 = search->teleporter;
			puVar1 = &search->teleporter->count;
			*puVar1 = *puVar1 + 1;
		}
		globs::teleporterGlobs.count += 1;
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_8;
	}
	return 0;
}



// This function is weird, it returns EDX:EAX, but what for??

Point2F __cdecl lego::unk::Teleporter_GetCameraPosition(void)
{
	SurfaceMap *surfMap;
	Camera *cam;
	Vector3F *out_worldPos;
	Point2F local_14;
	Vector3F surfPosition;
	
	cam = globs::legoGlobs.cameraMain;
	if (globs::legoGlobs.viewMode != VIEW_TOPDOWN) {
		cam = globs::legoGlobs.cameraFP;
	}
	out_worldPos = &surfPosition;
	surfMap = lrr::Lego_GetMap();
	lego::view::Camera_GetTopdownWorldPos(cam,surfMap,out_worldPos);
	return (Point2F)CONCAT44(surfPosition.y,surfPosition.x);
}



void __cdecl lego::unk::Teleporter_Add(TeleporterService *param_1)
{
	param_1->next = globs::teleporterGlobs.current;
	globs::teleporterGlobs.current = param_1;
	return;
}



BOOL __cdecl
lego::unk::Teleporter_LiveObjectCallback_Unk(LiveObject *liveObj,TeleportObjectType teleportObjType)
{
	ObjectType OVar1;
	
	OVar1 = Teleporter_GetServiceObjectType(teleportObjType);
	if ((liveObj->objType == OVar1) && (liveObj->teleporter_field_390 != 0)) {
		globals::g_Teleporter_BOOL_00504188 = 0;
	}
	return 0;
}



BOOL __cdecl lego::unk::Teleporter_ServiceAll(TeleportObjectType teleportObjTypes)
{
	TeleportObjectType teleObjFlag;
	uint i;
	
	i = 0;
	do {
		teleObjFlag = 1 << ((byte)i & 0x1f);
		globals::g_Teleporter_BOOL_00504188 = 1;
		if ((teleportObjTypes & teleObjFlag) != TELEPORT_SERVIVE_NONE) {
			game::Search_LiveObjects_SkipIgnoreMes(Teleporter_LiveObjectCallback_Unk,(void *)teleObjFlag);
			if (globals::g_Teleporter_BOOL_00504188 == 0) {
				return 0;
			}
		}
		i += 1;
	} while (i < 31);
	return TRUE;
}



void __cdecl
lego::unk::Teleporter_Start(TeleportObjectType teleportObjType,uint modeFlags,uint teleportFlags)
{
	Point2F cameraPos;
	SearchTeleporter_10 search;
	
	search.objType = Teleporter_GetServiceObjectType(teleportObjType);
	search.modeFlags = modeFlags;
	search.teleportFlags = teleportFlags;
	if ((modeFlags & 2) != 0) {
		search.teleporter = (TeleporterService *)std::malloc(0x20);
		Teleporter_Add(search.teleporter);
		(search.teleporter)->count = 0;
		if ((teleportFlags & 2) != 0) {
			cameraPos = Teleporter_GetCameraPosition();
			((search.teleporter)->cameraPos).x = SUB84(cameraPos,0);
			((search.teleporter)->cameraPos).y = (float)((ulonglong)cameraPos >> 0x20);
			(search.teleporter)->float_8 = 0.0;
			(search.teleporter)->float_c = globs::teleporterGlobs.floatValue_3_0;
		}
		if ((teleportFlags & 1) != 0) {
			(search.teleporter)->int_14 = globs::teleporterGlobs.intValue_40;
		}
		(search.teleporter)->flags = teleportFlags;
	}
	game::Search_LiveObjects_SkipIgnoreMes(Teleporter_LiveObjectCallback_Service,&search);
	return;
}



BOOL __cdecl lego::unk::Teleporter_LiveObjectCallback_Update(LiveObject *liveObj,void *data_unused)
{
	uint uVar1;
	float fVar2;
	float fVar3;
	short rng;
	Point2F position;
	TeleporterService *teleporter;
	
	if ((liveObj->teleporter_field_390 & 1) != 0) {
		liveObj->health = -1.0;
		liveObj->teleporter_field_394 = 0;
		liveObj->teleporter_field_390 = 4;
		globs::teleporterGlobs.count = globs::teleporterGlobs.count - 1;
		return 0;
	}
	if ((liveObj->teleporter_field_390 & 2) != 0) {
		uVar1 = liveObj->teleporter_field_394;
		if ((uVar1 & 2) == 0) {
			if ((uVar1 & 1) == 0) {
				if ((uVar1 & 4) != 0) {
					liveObj->health = -1.0;
					liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
					globs::teleporterGlobs.count -= 1;
				}
			}
			else {
				teleporter = liveObj->teleporter_398;
				rng = math::Maths_Rand();
				if ((int)rng % teleporter->int_14 == 0) {
					liveObj->health = -1.0;
					teleporter->count = teleporter->count - 1;
					goto LAB_0046a960;
				}
			}
		}
		else {
			teleporter = liveObj->teleporter_398;
						// I think this teleports objects with priority to "near" the camera
						//  when the level completed, as time progresses, units farther away
						//  are teleported.
			game::LiveObject_GetPosition(liveObj,&position.x,&position.y);
			fVar3 = position.x - (teleporter->cameraPos).x;
			fVar2 = position.y - (teleporter->cameraPos).y;
			teleporter = liveObj->teleporter_398;
			if (SQRT(fVar2 * fVar2 + fVar3 * fVar3) < teleporter->float_8) {
				liveObj->health = -1.0;
				teleporter->count = teleporter->count - 1;
LAB_0046a960:
				liveObj->teleporter_field_390 = 4;
				liveObj->teleporter_398 = NULL;
				liveObj->teleporter_field_394 = 0;
				globs::teleporterGlobs.count = globs::teleporterGlobs.count - 1;
				return 0;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::unk::Teleporter_UpdateService(TeleporterService *teleporter,float elapsedGame)
{
	if (teleporter != NULL) {
		do {
			if ((teleporter->count != 0) && (teleporter->flags == 2)) {
				teleporter->float_8 = teleporter->float_c * elapsedGame + teleporter->float_8;
			}
			teleporter = teleporter->next;
		} while (teleporter != NULL);
	}
	return (BOOL)teleporter;
}



void __cdecl lego::unk::Teleporter_Update(float elapsedGame)
{
	Teleporter_UpdateService(globs::teleporterGlobs.current,elapsedGame);
	if (globs::teleporterGlobs.count != 0) {
		game::Search_LiveObjects_SkipIgnoreMes(Teleporter_LiveObjectCallback_Update,NULL);
	}
	return;
}



ObjectType __cdecl lego::unk::Teleporter_GetServiceObjectType(TeleportObjectType teleportObjType)
{
	if ((teleportObjType & TELEPORT_SERVIVE_VEHICLE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_VEHICLE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_MINIFIGURE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_MINIFIGURE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_ROCKMONSTER) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_ROCKMONSTER;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_BUILDING) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_BUILDING;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_BOULDER) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_BOULDER;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_POWERCRYSTAL) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_POWERCRYSTAL;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_ORE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_ORE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_DYNAMITE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_DYNAMITE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_BARRIER) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_BARRIER;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_UPGRADEPART) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_UPGRADEPART;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_ELECTRICFENCE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_ELECTRICFENCE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_SPIDERWEB) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_SPIDERWEB;
	}
						// OBJECT_OOHSCARY
	return -(uint)((teleportObjType & TELEPORT_SERVIVE_OOHSCARY) != TELEPORT_SERVIVE_NONE) & 0xd;
}



void __cdecl
lego::front::Text_Load
					(TextWindow *param_1,TextWindow *param_2,int imageX,int imageY,float pauseTime)
{
	if (pauseTime == 0.0) {
		globs::textGlobs.textName[0] = "Text_Walk";
		globs::textGlobs.textName[1] = "Text_Drill";
		globs::textGlobs.textName[2] = "Text_NoDrill";
		globs::textGlobs.textName[3] = "Text_CantDrill";
		globs::textGlobs.textName[4] = "Text_Reinforce";
		globs::textGlobs.textName[5] = "Text_NoReinforce";
		globs::textGlobs.textName[6] = "Text_CantReinforce";
		globs::textGlobs.textName[7] = "Text_PickupCrystal";
		globs::textGlobs.textName[8] = "Text_Encyclopedia";
		globs::textGlobs.textName[9] = "Text_RadarHelp";
		globs::textGlobs.textName[10] = "Text_BuildHelp";
		globs::textGlobs.textName[11] = "Text_SelectionHelp";
		globs::textGlobs.textName[12] = "Text_Drive";
		globs::textGlobs.textName[13] = "Text_CantDrive";
		globs::textGlobs.textName[14] = "Text_MakeTeleporter";
		globs::textGlobs.textName[15] = "Text_CannotPlaceBuilding";
		globs::textGlobs.textName[16] = "Text_CrystalOreDisabled";
		globs::textGlobs.textName[17] = "Text_CrystalFound";
		globs::textGlobs.textName[18] = "Text_CavernDiscovered";
		globs::textGlobs.textName[19] = "Text_OreFound";
		globs::textGlobs.textName[20] = "Text_AirSupplyLow";
		globs::textGlobs.textName[21] = "Text_AirSupplyRunningOut";
		globs::textGlobs.textName[22] = "Text_SpaceToContinue";
		globs::textGlobs.textName[23] = "Text_GameCompleted";
		globs::textGlobs.textName[24] = "Text_ManTrained";
		globs::textGlobs.textName[25] = "Text_UnitUpgraded";
		globs::textGlobs.currentType = TEXT__COUNT;
		globs::textGlobs.textCount = 26;
		globs::textGlobs.textWnd_48c = param_1;
		globs::textGlobs.textWnd_490 = param_2;
		globs::textGlobs.TextImagePosition.x = imageX;
		globs::textGlobs.TextImagePosition.y = imageY;
		globs::textGlobs.TextPauseTime = (float)&DAT_42c80000;
						// 316 (passed from Game_Init)
						// 425 (passed from Game_Init)
						// 100.0
		return;
	}
	globs::textGlobs.textName[0] = "Text_Walk";
	globs::textGlobs.textName[1] = "Text_Drill";
	globs::textGlobs.textName[2] = "Text_NoDrill";
	globs::textGlobs.textName[3] = "Text_CantDrill";
	globs::textGlobs.textName[4] = "Text_Reinforce";
	globs::textGlobs.textName[5] = "Text_NoReinforce";
	globs::textGlobs.textName[6] = "Text_CantReinforce";
	globs::textGlobs.textName[7] = "Text_PickupCrystal";
	globs::textGlobs.textName[8] = "Text_Encyclopedia";
	globs::textGlobs.textName[9] = "Text_RadarHelp";
	globs::textGlobs.textName[10] = "Text_BuildHelp";
	globs::textGlobs.textName[11] = "Text_SelectionHelp";
	globs::textGlobs.textName[12] = "Text_Drive";
	globs::textGlobs.textName[13] = "Text_CantDrive";
	globs::textGlobs.textName[14] = "Text_MakeTeleporter";
	globs::textGlobs.textName[15] = "Text_CannotPlaceBuilding";
	globs::textGlobs.textName[16] = "Text_CrystalOreDisabled";
	globs::textGlobs.textName[17] = "Text_CrystalFound";
	globs::textGlobs.textName[18] = "Text_CavernDiscovered";
	globs::textGlobs.textName[19] = "Text_OreFound";
	globs::textGlobs.textName[20] = "Text_AirSupplyLow";
	globs::textGlobs.textName[21] = "Text_AirSupplyRunningOut";
	globs::textGlobs.textName[22] = "Text_SpaceToContinue";
	globs::textGlobs.textName[23] = "Text_GameCompleted";
	globs::textGlobs.textName[24] = "Text_ManTrained";
	globs::textGlobs.textName[25] = "Text_UnitUpgraded";
	globs::textGlobs.currentType = TEXT__COUNT;
	globs::textGlobs.textCount = 26;
	globs::textGlobs.textWnd_48c = param_1;
	globs::textGlobs.textWnd_490 = param_2;
	globs::textGlobs.TextImagePosition.x = imageX;
	globs::textGlobs.TextImagePosition.y = imageY;
	globs::textGlobs.TextPauseTime = pauseTime;
	return;
}



void __cdecl
lego::front::Text_Initialise
					(char *filename,uint param_2,uint param_3,uint unused_int,Area2F *param_5,
					Area2F *unused_rect,float param_7)
{
						// 409 (passed from Game_Init)
	globs::textGlobs.uint_498 = param_3;
	globs::textGlobs.MsgPanel_Rect1.x = param_5->x;
	globs::textGlobs.MsgPanel_Rect1.y = param_5->y;
	globs::textGlobs.MsgPanel_Rect1.width = param_5->width;
	globs::textGlobs.MsgPanel_Rect1.height = param_5->height;
	globs::textGlobs.float_4ac =
			 (globs::textGlobs.MsgPanel_Rect1.y + globs::textGlobs.MsgPanel_Rect1.height) -
			 (float)(globs::textGlobs.textWnd_48c)->font->fontHeight;
						// 20.0 (passed from Game_Init)
						// 42   (passed from Game_Init)
	globs::textGlobs.MsgPanel_Float20 = param_7;
	globs::textGlobs.MsgPanel_Float42 = (float)(ulonglong)param_2;
	Text_UpdatePositionAndSize();
	return;
}



void __cdecl lego::front::Text_UpdatePositionAndSize(void)
{
	int ypos;
	uint height;
	longlong lVar1;
	
	globs::textGlobs.float_4b8 = (float)(ulonglong)globs::textGlobs.uint_498;
	lVar1 = __ftol((float10)globs::textGlobs.MsgPanel_Rect1.y);
	ypos = (int)lVar1;
	lVar1 = __ftol((float10)globs::textGlobs.MsgPanel_Rect1.x);
	TextWindow_ChangePosition(globs::textGlobs.textWnd_48c,(int)lVar1,ypos);
	lVar1 = __ftol((float10)globs::textGlobs.MsgPanel_Rect1.height);
	height = (uint)lVar1;
	lVar1 = __ftol((float10)globs::textGlobs.MsgPanel_Rect1.width);
	TextWindow_ChangeSize(globs::textGlobs.textWnd_48c,(uint)lVar1,height);
	globs::textGlobs.MsgPanel_Rect2.x = globs::textGlobs.MsgPanel_Rect1.x;
	globs::textGlobs.MsgPanel_Rect2.y = globs::textGlobs.MsgPanel_Rect1.y;
	globs::textGlobs.MsgPanel_Rect2.width = globs::textGlobs.MsgPanel_Rect1.width;
	globs::textGlobs.MsgPanel_Rect2.height = globs::textGlobs.MsgPanel_Rect1.height;
	globs::textGlobs.TextPanelFlags = globs::textGlobs.TextPanelFlags & 0xfffffffe;
	return;
}



void __cdecl lego::front::Text_Clear(void)
{
	Text_UpdatePositionAndSize();
	globs::textGlobs.currentType = TEXT__COUNT;
	globs::textGlobs.textFlags = 0;
	globs::textGlobs.field_484 = 0;
	globs::textGlobs.TextPanelFlags = 0;
	TextWindow_Clear(globs::textGlobs.textWnd_48c);
	TextWindow_Clear(globs::textGlobs.textWnd_490);
	return;
}



BOOL __cdecl lego::front::Text_GetTextType(char *textName,TextType *out_textType)
{
	int iVar1;
	Text_Globs *pTVar2;
	int index;
	
	index = 0;
	pTVar2 = &globs::textGlobs;
	do {
		iVar1 = std::_stricmp(pTVar2->textName[0],textName);
		if (iVar1 == 0) {
			*out_textType = index;
			return 1;
		}
		pTVar2 = (Text_Globs *)(pTVar2->textName + 1);
						// index++
		index += TEXT_DRILL;
						// index < TEXT__COUNT (26)
	} while (pTVar2 < (Text_Globs *)globs::textGlobs.textMessages);
	return 0;
}



void __cdecl lego::front::Text_SetMessage(TextType textType,char *textMessage)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	
	if (globs::textGlobs.textMessages[textType] != NULL) {
		std::free(globs::textGlobs.textMessages[textType]);
	}
	uVar4 = 0xffffffff;
	pcVar3 = textMessage;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar2 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar2 != '\0');
	pcVar3 = (char *)std::malloc(~uVar4);
	globs::textGlobs.textMessages[textType] = pcVar3;
	cVar2 = *textMessage;
	while (cVar2 != '\0') {
		cVar2 = *textMessage;
		if (cVar2 == '_') {
			*pcVar3 = ' ';
		}
		else {
			if ((cVar2 == '\\') && (textMessage[1] == 'n')) {
				*pcVar3 = '\n';
				textMessage = textMessage + 1;
			}
			else {
				*pcVar3 = cVar2;
			}
		}
		pcVar1 = textMessage + 1;
		pcVar3 = pcVar3 + 1;
		textMessage = textMessage + 1;
		cVar2 = *pcVar1;
	}
	*pcVar3 = '\0';
	if (globs::textGlobs.textImages[textType] != NULL) {
		lego::image::Image_Remove(globs::textGlobs.textImages[textType]);
		globs::textGlobs.textImages[textType] = NULL;
	}
	return;
}



void __cdecl
lego::front::Text_SetMessageWithImage(TextType textType,char *message,char *filename,char *sfxName)
{
	Image *image;
	
	Text_SetMessage(textType,message);
	std::sprintf((char *)globs::textGlobs.textImagesSFX[textType],"%s",sfxName);
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globs::textGlobs.textImages[textType] = image;
	if (image != NULL) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl lego::front::Text_SetNERPsMessage(char *text,uint unkFlags)
{
	globs::textGlobs.field_484 = text;
	if (unkFlags == 0) {
		unkFlags = 0x8000;
	}
	globs::textGlobs.textFlags = unkFlags | 0x10000;
	nerps::NERPs_Level_NERPMessage_Parse(text,NULL,TRUE);
	globs::textGlobs.TextPanelFlags = globs::textGlobs.TextPanelFlags | 1;
	return;
}



void __cdecl lego::front::Text_DisplayMessage(TextType textType,BOOL changeTiming,BOOL setFlag4)
{
	TutorialFlags TVar1;
	BOOL BVar2;
	
	if (changeTiming == SFX_NULL) {
		if ((ushort)((ushort)(globs::textGlobs.float_488 < 0.0) << 8 |
								(ushort)(globs::textGlobs.float_488 == 0.0) << 0xe) != 0) {
			globs::textGlobs.currentType = textType;
		}
	}
	else {
		globs::textGlobs.currentType = textType;
		globs::textGlobs.float_488 = globs::textGlobs.TextPauseTime;
	}
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar1 == TUTORIAL_NONE) {
		BVar2 = snd::SFX_GetType((char *)globs::textGlobs.textImagesSFX[textType],
														 (SFXType *)&changeTiming);
		if (BVar2 != 0) {
			snd::SFX_Sample_Random_SetAndPlayGlobalSample(changeTiming,NULL);
		}
	}
	if ((globs::textGlobs.currentType == textType) && (setFlag4 != 0)) {
		globs::textGlobs.TextPanelFlags = globs::textGlobs.TextPanelFlags | 4;
		return;
	}
	globs::textGlobs.TextPanelFlags = globs::textGlobs.TextPanelFlags & 0xfffffffb;
	return;
}



void __cdecl lego::front::Text_Update(float elapsedAbs)
{
	char *format;
	float fVar1;
	TextType TVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	Image *image;
	TextWindow *pTVar6;
	bool bVar7;
	longlong lVar8;
	int local_20c;
	Point2F local_208;
	undefined4 local_200 [128];
	
	TVar2 = globs::textGlobs.currentType;
	image = NULL;
	bVar7 = true;
	if (globs::textGlobs.textFlags == 0) {
		BVar4 = nerps::NERPsRuntime_IsMessagePermit();
		if ((BVar4 != 0) && (globs::textGlobs.currentType != TEXT__COUNT)) {
			image = globs::textGlobs.textImages[globs::textGlobs.currentType];
			format = globs::textGlobs.textMessages[globs::textGlobs.currentType];
			bVar7 = image == NULL;
			pTVar6 = globs::textGlobs.textWnd_48c;
			if (!bVar7) {
				local_208.x = (float)(ulonglong)(uint)globs::textGlobs.TextImagePosition.x;
				local_208.y = (float)(ulonglong)(uint)globs::textGlobs.TextImagePosition.y;
				pTVar6 = globs::textGlobs.textWnd_490;
			}
			if (format != NULL) {
				iVar3 = 1;
				if ((globs::textGlobs.TextPanelFlags & 4) != 0) {
					iVar3 = Interface_GetBool_004ded1c();
				}
				if (iVar3 != 0) {
					TextWindow_PrintFOverlay(pTVar6,1,format);
				}
			}
			if ((ushort)((ushort)(globs::textGlobs.float_488 < 0.0) << 8 |
									(ushort)(globs::textGlobs.float_488 == 0.0) << 0xe) != 0) {
				globs::textGlobs.currentType = TEXT__COUNT;
			}
			globs::textGlobs.float_488 = globs::textGlobs.float_488 - elapsedAbs;
		}
	}
	else {
		if (globs::textGlobs.field_484 == NULL) {
			globs::textGlobs.textFlags = 0;
		}
		else {
			nerps::NERPs_Level_NERPMessage_Parse(globs::textGlobs.field_484,local_200,0);
			TextWindow_PrintFOverlay(globs::textGlobs.textWnd_48c,0,(char *)local_200);
			if ((globs::textGlobs.textFlags & 0x8000) == 0) {
				globs::textGlobs.textFlags -= 1;
			}
		}
	}
	if (((globs::legoGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) &&
		 (TVar2 != TEXT_SPACETOCONTINUE)) {
		Text_UpdatePositionAndSize();
		Panel_SetXYField3(PANEL_MESSAGES,globs::textGlobs.MsgPanel_Float42,globs::textGlobs.float_4b8);
		Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
		Panel_AirMeter_SetOxygen(PANEL_MESSAGES,(globs::legoGlobs.level)->oxygenLevel);
		Panel_AirMeter_FUN_0045c770(PANEL_MESSAGES);
		return;
	}
	if (!bVar7) {
		Text_UpdatePositionAndSize();
		Panel_SetXYField3(PANEL_MESSAGES,globs::textGlobs.MsgPanel_Float42,globs::textGlobs.float_4b8);
		Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
		Panel_AirMeter_SetOxygen(PANEL_MESSAGES,(globs::legoGlobs.level)->oxygenLevel);
		Panel_AirMeter_FUN_0045c770(PANEL_MESSAGES);
		TextWindow_Update(globs::textGlobs.textWnd_490,0,elapsedAbs,NULL);
		lego::image::Image_DisplayScaled(image,NULL,&local_208,NULL);
		return;
	}
	Panel_SetXYField3(PANEL_MESSAGES,globs::textGlobs.MsgPanel_Float42,globs::textGlobs.float_4b8);
	Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
	Panel_AirMeter_SetOxygen(PANEL_MESSAGES,(globs::legoGlobs.level)->oxygenLevel);
	Panel_AirMeter_FUN_0045c770(PANEL_MESSAGES);
	BVar4 = TextWindow_Update(globs::textGlobs.textWnd_48c,0,elapsedAbs,&local_20c);
	pTVar6 = globs::textGlobs.textWnd_48c;
	if (BVar4 == 0) {
		if ((globs::textGlobs.TextPanelFlags & 1) != 0) {
			if (globs::textGlobs.float_4ac <= (float)local_20c) {
				globs::textGlobs.TextPanelFlags = globs::textGlobs.TextPanelFlags & 0xfffffffe;
				return;
			}
			fVar1 = (float)(ulonglong)(globs::textGlobs.textWnd_48c)->font->fontHeight;
			globs::textGlobs.float_4b8 = fVar1 + globs::textGlobs.float_4b8;
			globs::textGlobs.MsgPanel_Rect2.y = fVar1 + globs::textGlobs.MsgPanel_Rect2.y;
			globs::textGlobs.MsgPanel_Rect2.height = globs::textGlobs.MsgPanel_Rect2.height - fVar1;
			lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.y);
			iVar3 = (int)lVar8;
			lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.x);
			TextWindow_ChangePosition(pTVar6,(int)lVar8,iVar3);
			lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.height);
			uVar5 = (uint)lVar8;
			lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.width);
			TextWindow_ChangeSize(globs::textGlobs.textWnd_48c,(uint)lVar8,uVar5);
			if ((float)(ulonglong)globs::textGlobs.uint_498 <= globs::textGlobs.float_4b8) {
				globs::textGlobs.float_4b8 = (float)(ulonglong)globs::textGlobs.uint_498;
				globs::textGlobs.TextPanelFlags &= 0xfffffffe;
				globs::textGlobs.MsgPanel_Rect2.x = globs::textGlobs.MsgPanel_Rect1.x;
				globs::textGlobs.MsgPanel_Rect2.y = globs::textGlobs.MsgPanel_Rect1.y;
				globs::textGlobs.MsgPanel_Rect2.width = globs::textGlobs.MsgPanel_Rect1.width;
				globs::textGlobs.MsgPanel_Rect2.height = globs::textGlobs.MsgPanel_Rect1.height;
				lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect1.y);
				iVar3 = (int)lVar8;
				lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect1.x);
				TextWindow_ChangePosition(globs::textGlobs.textWnd_48c,(int)lVar8,iVar3);
				lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.height);
				uVar5 = (uint)lVar8;
				lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.width);
				TextWindow_ChangeSize(globs::textGlobs.textWnd_48c,(uint)lVar8,uVar5);
				return;
			}
		}
		return;
	}
	fVar1 = (float)(ulonglong)(globs::textGlobs.textWnd_48c)->font->fontHeight;
	globs::textGlobs.float_4b8 = globs::textGlobs.float_4b8 - fVar1;
	globs::textGlobs.MsgPanel_Rect2.y = globs::textGlobs.MsgPanel_Rect2.y - fVar1;
	globs::textGlobs.MsgPanel_Rect2.height = fVar1 + globs::textGlobs.MsgPanel_Rect2.height;
	lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.y);
	iVar3 = (int)lVar8;
	lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.x);
	TextWindow_ChangePosition(pTVar6,(int)lVar8,iVar3);
	lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.height);
	uVar5 = (uint)lVar8;
	lVar8 = __ftol((float10)globs::textGlobs.MsgPanel_Rect2.width);
	TextWindow_ChangeSize(globs::textGlobs.textWnd_48c,(uint)lVar8,uVar5);
	globs::textGlobs.TextPanelFlags = globs::textGlobs.TextPanelFlags & 0xfffffffe;
	return;
}



void __cdecl
lego::front::ToolTip_Initialise
					(Font *font,int value2,int value1,float float1,uint width,uint height,int value32,
					float red,float green,float blue)
{
	float *pfVar1;
	int iVar2;
	ToolTipData *pTVar3;
	
	globs::toolTipGlobs.toolTipTexts[1] = "ToolTip_RadarBlock";
	globs::toolTipGlobs.toolTipTexts[2] = "ToolTip_UnitSelect";
	globs::toolTipGlobs.toolTipTexts[3] = "ToolTip_Construction";
	globs::toolTipGlobs.toolTipTexts[4] = "ToolTip_InterfaceMenu";
	globs::toolTipGlobs.toolTipTexts[5] = "ToolTip_InterfaceMenuBackButton";
	globs::toolTipGlobs.toolTipTexts[6] = "ToolTip_MapBlock";
	globs::toolTipGlobs.toolTipTexts[7] = "ToolTip_Priority";
	globs::toolTipGlobs.toolTipTexts[8] = "ToolTip_InfoMenuContinue";
	globs::toolTipGlobs.toolTipTexts[9] = "ToolTip_InfoMenuDisableFuture";
	globs::toolTipGlobs.toolTipTexts[10] = "ToolTip_RadarToggle";
	globs::toolTipGlobs.toolTipTexts[11] = "ToolTip_RadarObjectView";
	globs::toolTipGlobs.toolTipTexts[12] = "ToolTip_RadarZoomIn";
	globs::toolTipGlobs.toolTipTexts[13] = "ToolTip_RadarZoomOut";
	globs::toolTipGlobs.toolTipTexts[14] = "ToolTip_RadarMapView";
	globs::toolTipGlobs.toolTipTexts[15] = "ToolTip_InfoDockGoto";
	globs::toolTipGlobs.toolTipTexts[16] = "ToolTip_InfoDockClose";
	globs::toolTipGlobs.toolTipTexts[17] = "ToolTip_TopPanelCallToArms";
	globs::toolTipGlobs.toolTipTexts[18] = "ToolTip_TopPanelInfo";
	globs::toolTipGlobs.toolTipTexts[19] = "ToolTip_TopPanelOptions";
	globs::toolTipGlobs.toolTipTexts[20] = "ToolTip_TopPanelPriorities";
	globs::toolTipGlobs.toolTipTexts[21] = "ToolTip_PriorityDisable";
	globs::toolTipGlobs.toolTipTexts[22] = "ToolTip_PriorityUpOne";
	globs::toolTipGlobs.toolTipTexts[23] = "ToolTip_PriorityReset";
	globs::toolTipGlobs.toolTipTexts[24] = "ToolTip_CamControlZoomIn";
	globs::toolTipGlobs.toolTipTexts[25] = "ToolTip_CamControlZoomOut";
	globs::toolTipGlobs.toolTipTexts[26] = "ToolTip_CamControlCycle";
	globs::toolTipGlobs.toolTipTexts[27] = "ToolTip_CamControlRotate";
	globs::toolTipGlobs.toolTipTexts[28] = "ToolTip_SideBar_Ore";
	globs::toolTipGlobs.toolTipTexts[29] = "ToolTip_SideBar_Crystals";
	globs::toolTipGlobs.toolTipTexts[30] = "ToolTip_Close";
	globs::toolTipGlobs.toolTipTexts[31] = "ToolTip_PreviousMessage";
	globs::toolTipGlobs.toolTipTexts[32] = "ToolTip_NextMessage";
	globs::toolTipGlobs.toolTipTexts[33] = "ToolTip_More";
	globs::toolTipGlobs.toolTipTexts[34] = "ToolTip_Back";
	globs::toolTipGlobs.toolTipTexts[35] = "ToolTip_CamControlCycleMinifigures";
	globs::toolTipGlobs.toolTipTexts[36] = "ToolTip_Reward_Save";
	globs::toolTipGlobs.toolTipTexts[37] = "ToolTip_Reward_Advance";
	globs::toolTipGlobs.toolTipTexts[38] = "ToolTip_FrontEnd_Back";
	globs::toolTipGlobs.font = font;
	globs::toolTipGlobs.fontHeight = lego::image::Font_GetHeight(font);
	globs::toolTipGlobs.hoverTime = float1 * 25.0;
	globs::toolTipGlobs.int2_8 = value2;
	globs::toolTipGlobs.int1_c = value1;
	globs::toolTipGlobs.rgbFloats[1] = red + red * 0.4;
	globs::toolTipGlobs.width = width;
	globs::toolTipGlobs.height = height;
	globs::toolTipGlobs.int32_18 = value32;
	globs::toolTipGlobs.rgbFloats[0] = red;
	globs::toolTipGlobs.rgbFloats[3] = green;
	globs::toolTipGlobs.rgbFloats[6] = blue;
	globs::toolTipGlobs.rgbFloats[4] = green + green * 0.4;
	globs::toolTipGlobs.rgbFloats[7] = blue + blue * 0.4;
	globs::toolTipGlobs.rgbFloats[2] = red - red * 0.4;
	pfVar1 = globs::toolTipGlobs.rgbFloats + 3;
	globs::toolTipGlobs.rgbFloats[5] = green - green * 0.4;
	globs::toolTipGlobs.rgbFloats[8] = blue - blue * 0.4;
	do {
						// Do bounds checking for RGB values
		if ((ushort)((ushort)(pfVar1[-3] < 1.0) << 8 | (ushort)(pfVar1[-3] == 1.0) << 0xe) == 0) {
			pfVar1[-3] = 1.0;
		}
		if ((ushort)((ushort)(*pfVar1 < 1.0) << 8 | (ushort)(*pfVar1 == 1.0) << 0xe) == 0) {
			*pfVar1 = 1.0;
		}
		if ((ushort)((ushort)(pfVar1[3] < 1.0) << 8 | (ushort)(pfVar1[3] == 1.0) << 0xe) == 0) {
			pfVar1[3] = 1.0;
		}
		if (pfVar1[-3] < 0.0) {
			pfVar1[-3] = 0.0;
		}
		if (*pfVar1 < 0.0) {
			*pfVar1 = 0.0;
		}
		if (pfVar1[3] < 0.0) {
			pfVar1[3] = 0.0;
		}
		pfVar1 = pfVar1 + 1;
	} while (pfVar1 < globs::toolTipGlobs.rgbFloats + 6);
	pTVar3 = globs::toolTipGlobs.toolTipDatas;
	for (iVar2 = 0x1839; iVar2 != 0; iVar2 += -1) {
		pTVar3->timer = 0.0;
		pTVar3 = (ToolTipData *)pTVar3->textBuffer;
	}
	return;
}



BOOL __cdecl lego::front::ToolTip_GetType(char *toolTipName,ToolTipType *out_toolTipType)
{
	int iVar1;
	ToolTipData *pTVar2;
	ToolTipType TVar3;
	
	TVar3 = TOOLTIP_RADARBLOCK;
	pTVar2 = (ToolTipData *)(globs::toolTipGlobs.toolTipTexts + 1);
	do {
		iVar1 = std::_stricmp(toolTipName,(char *)pTVar2->timer);
		if (iVar1 == 0) {
			*out_toolTipType = TVar3;
			return TRUE;
		}
		pTVar2 = (ToolTipData *)pTVar2->textBuffer;
		TVar3 += TOOLTIP_RADARBLOCK;
	} while (pTVar2 < globs::toolTipGlobs.toolTipDatas);
	return 0;
}



void __cdecl lego::front::ToolTip_SetText(ToolTipType toolTipType,char *msg,...)
{
	char *msg_00;
	char *pcVar1;
	char cVar2;
	ToolTipFlags TVar3;
	int iVar4;
	int iVar5;
	Image *pIVar6;
	char *pcVar7;
	char *pcVar8;
	char filename [260];
	char tooltipText [512];
	
	std::vsprintf(tooltipText,msg,&stack0x0000000c);
						// Use @ to denote an image...
	if (tooltipText[0] == '@') {
		iVar5 = 1;
		while (tooltipText[1] != '\0') {
			filename[iVar5 + -1] = tooltipText[1];
			iVar4 = iVar5 + 1;
			iVar5 += 1;
			tooltipText[1] = tooltipText[iVar4];
		}
		filename[iVar5 + -1] = '\0';
		pIVar6 = lego::image::Image_LoadBMPScaled(filename,0,0);
		globs::toolTipGlobs.toolTipDatas[toolTipType].tooltipImage = pIVar6;
		globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
				 globs::toolTipGlobs.toolTipDatas[toolTipType].flags | TOOLTIP_FLAG_UNK_8;
	}
	else {
		msg_00 = globs::toolTipGlobs.toolTipDatas[toolTipType].textBuffer;
		pcVar7 = tooltipText;
		pcVar8 = msg_00;
		while (tooltipText[0] != '\0') {
			cVar2 = *pcVar7;
						// an \n as a return character...
			if ((cVar2 == '\\') && (pcVar7[1] == 'n')) {
				*pcVar8 = '\n';
				pcVar7 = pcVar7 + 1;
			}
			else {
						// Use underscores as spaces
				if (cVar2 == '_') {
					*pcVar8 = ' ';
				}
				else {
					*pcVar8 = cVar2;
				}
			}
			pcVar1 = pcVar7 + 1;
			pcVar8 = pcVar8 + 1;
			pcVar7 = pcVar7 + 1;
			tooltipText[0] = *pcVar1;
		}
		*pcVar8 = '\0';
		lego::image::Font_GetStringInfo
							(globs::toolTipGlobs.font,&globs::toolTipGlobs.toolTipDatas[toolTipType].textWidth,
							 &globs::toolTipGlobs.toolTipDatas[toolTipType].textLineCount,msg_00);
		globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
				 globs::toolTipGlobs.toolTipDatas[toolTipType].flags & ~TOOLTIP_FLAG_UNK_8;
	}
	TVar3 = globs::toolTipGlobs.toolTipDatas[toolTipType].flags;
	globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_260 = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_26c = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
			 TVar3 | (TOOLTIP_FLAG_UNK_1|TOOLTIP_FLAG_UNK_2);
	return;
}



void __cdecl lego::front::ToolTip_AddIcon(ToolTipType toolTipType,Image *image)
{
	uint uVar1;
	int iVar2;
	
	if (image == NULL) {
		globs::toolTipGlobs.toolTipDatas[toolTipType].field_260 = 0;
		globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 = 0;
	}
	else {
		iVar2 = globs::toolTipGlobs.toolTipDatas[toolTipType].field_260;
		if (iVar2 < (int)image->height) {
			iVar2 = globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 - iVar2;
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 = iVar2;
			uVar1 = image->height;
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_260 = uVar1;
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 = iVar2 + uVar1;
		}
		iVar2 = globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 + image->width;
		globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 = iVar2;
		if (globs::toolTipGlobs.toolTipDatas[toolTipType].field_26c < iVar2) {
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_26c = iVar2;
		}
	}
						// globs::toolTipGlobs.toolTipDatas[toolTipType].imageList[.imageCount] = image;
	*(Image **)
	 (toolTipType * 0x27c + 0x54d20c + globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount * 4) =
			 image;
	globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount =
			 globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount + 1;
	return;
}



void __cdecl lego::front::ToolTip_SetSFX(ToolTipType toolTipType,SFXType sfxType)
{
	ToolTipFlags TVar1;
	
	TVar1 = globs::toolTipGlobs.toolTipDatas[toolTipType].flags;
	globs::toolTipGlobs.toolTipDatas[toolTipType].sfxType = sfxType;
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
			 TVar1 | (TOOLTIP_FLAG_UNK_1|TOOLTIP_FLAG_UNK_2);
	return;
}



void __cdecl lego::front::ToolTip_SetFlag10(ToolTipType toolTipType,BOOL state)
{
	ToolTipFlags TVar1;
	
	TVar1 = globs::toolTipGlobs.toolTipDatas[toolTipType].flags;
	if (state != 0) {
		globs::toolTipGlobs.toolTipDatas[toolTipType].flags = TVar1 | TOOLTIP_FLAG_UNK_10;
		return;
	}
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags = TVar1 & ~TOOLTIP_FLAG_UNK_10;
	return;
}



void __cdecl lego::front::ToolTip_AddFlag4(ToolTipType toolTipType)
{
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
			 globs::toolTipGlobs.toolTipDatas[toolTipType].flags | TOOLTIP_FLAG_UNK_4;
	return;
}



void __cdecl lego::front::ToolTip_ResetTimer(ToolTipType toolTipType)
{
	globs::toolTipGlobs.toolTipDatas[toolTipType].timer = globs::toolTipGlobs.hoverTime;
	return;
}



void __cdecl lego::front::ToolTip_Update(uint mousex,uint mousey,float elapsedAbs)
{
	ToolTipData *toolTip;
	bool bVar1;
	BOOL BVar2;
	uint uVar3;
	bool bVar4;
	RoofBlock **ppRVar5;
	
	bVar4 = false;
	bVar1 = false;
	ppRVar5 = (RoofBlock **)&globs::toolTipGlobs.toolTipDatas[1].flags;
	uVar3 = globals::g_ToolTipIsSFXPlaying;
	do {
		if (((uint)*ppRVar5 & (TOOLTIP_FLAG_UNK_1|TOOLTIP_FLAG_UNK_2)) != TOOLTIP_FLAG_NONE) {
			if ((((uint)*ppRVar5 & TOOLTIP_FLAG_UNK_4) == TOOLTIP_FLAG_NONE) || (bVar1)) {
				ppRVar5[-0x9e] = NULL;
			}
			else {
				toolTip = (ToolTipData *)(ppRVar5 + -0x9e);
				if (((float)ppRVar5[-0x9e] < globs::toolTipGlobs.hoverTime) || (bVar4)) {
					uVar3 = TRUE;
					globals::g_ToolTipIsSFXPlaying = TRUE;
					bVar1 = true;
					toolTip->timer = elapsedAbs + toolTip->timer;
				}
				else {
					if (((ppRVar5[-1] != NULL) && (uVar3 != 0)) &&
						 ((globs::legoGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE)) {
						BVar2 = snd::SFX_Sample_Random_SetAndPlayGlobalSample((SFXType)ppRVar5[-1],NULL);
						uVar3 = (uint)(BVar2 == 0);
						globals::g_ToolTipIsSFXPlaying = uVar3;
					}
					if (ppRVar5 != (RoofBlock **)0x274) {
						ToolTip_Draw(toolTip,mousex,mousey);
						uVar3 = globals::g_ToolTipIsSFXPlaying;
					}
					bVar4 = true;
					bVar1 = true;
					toolTip->timer = elapsedAbs + toolTip->timer;
				}
			}
			*ppRVar5 = (RoofBlock *)((uint)*ppRVar5 & ~TOOLTIP_FLAG_UNK_4);
		}
		ppRVar5 = ppRVar5 + 0x9f;
	} while (ppRVar5 < globs::roofGlobs.visibleTable + 0x70);
	return;
}



void __cdecl
lego::front::ToolTip_DrawBox
					(Area2F valueRect,float rcRed,float rcGreen,float rcBlue,float ln1Red,float ln1Green,
					float ln1Blue,float ln2Red,float ln2Green,float ln2Blue,BOOL halfTrans)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	Point2F *pPVar7;
	Point2F *pPVar8;
	float *pfVar9;
	float *pfVar10;
	uint count;
	Point2F *pPVar11;
	float *pfVar12;
	Point2F *local_168;
	float *local_164;
	uint local_160;
	uint local_15c;
	Point2F local_140;
	float local_138 [18];
	Point2F local_f0;
	float afStack232 [18];
	Point2F local_a0;
	float local_98 [18];
	Point2F local_50;
	float local_48 [18];
	
	count = 0;
	local_160 = 0;
	local_15c = 0;
	if (globs::toolTipGlobs.int2_8 != 0) {
		local_168 = &local_f0;
		local_164 = &local_f0.y;
		pPVar8 = &local_50;
		pfVar12 = &local_50.y;
		pfVar10 = &local_140.y;
		pPVar11 = &local_140;
		pfVar9 = &local_a0.y;
		pPVar7 = &local_a0;
		do {
			fVar4 = (float)(ulonglong)local_15c;
			fVar2 = valueRect.x + fVar4;
			fVar3 = valueRect.y + fVar4;
			fVar6 = ((valueRect.y + valueRect.height) - 1.0) - fVar4;
			fVar5 = ((valueRect.x + valueRect.width) - 1.0) - fVar4;
			pPVar7->x = fVar2;
			*pfVar9 = fVar3;
			fVar1 = pPVar7->x;
			pPVar8->x = fVar2;
			*pfVar10 = ((valueRect.y + valueRect.height) - 2.0) - fVar4;
			*pfVar12 = fVar6;
			pPVar7[1].x = fVar5;
			pPVar11->x = fVar1;
			local_168->x = ((valueRect.x + valueRect.width) - 2.0) - fVar4;
			pfVar9[2] = fVar3;
			*local_164 = fVar6;
			pPVar8[1].x = fVar5;
			pPVar11[1].x = fVar2 - -1.0;
			pfVar12[2] = fVar6;
			fVar1 = pPVar8[1].x;
			pfVar10[2] = fVar3;
			pPVar7 = pPVar7 + 2;
			pfVar9 = pfVar9 + 4;
			pPVar11 = pPVar11 + 2;
			pfVar12 = pfVar12 + 4;
			local_164[2] = fVar3 - -1.0;
			pPVar8 = pPVar8 + 2;
			local_168[1].x = fVar1;
			count = local_160 + 2;
			local_168 = local_168 + 2;
			pfVar10 = pfVar10 + 4;
			local_164 = local_164 + 4;
			local_15c += 1;
			local_160 = count;
		} while (local_15c < globs::toolTipGlobs.int2_8);
	}
	if (halfTrans == 0) {
		draw::Draw_RectListEx(&valueRect,1,rcRed,rcGreen,rcBlue,DRAWEFFECT_NONE);
		draw::Draw_LineListEx(&local_a0,&local_140,count,ln1Red,ln1Green,ln1Blue,DRAWEFFECT_NONE);
		draw::Draw_LineListEx(&local_50,&local_f0,count,ln2Red,ln2Green,ln2Blue,DRAWEFFECT_NONE);
		return;
	}
	draw::Draw_RectListEx(&valueRect,1,rcRed,rcGreen,rcBlue,DRAWEFFECT_HALFTRANS);
	draw::Draw_LineListEx(&local_a0,&local_140,count,ln1Red,ln1Green,ln1Blue,DRAWEFFECT_NONE);
	draw::Draw_LineListEx(&local_50,&local_f0,count,ln2Red,ln2Green,ln2Blue,DRAWEFFECT_NONE);
	return;
}



void __cdecl lego::front::ToolTip_Draw(ToolTipData *toolTip,uint x,uint y)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	Image **ppIVar4;
	uint uVar5;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar6;
	char *msg;
	char *pcVar7;
	Point2F local_44;
	uint local_3c;
	undefined4 uStack56;
	float local_34;
	float fStack48;
	float local_2c;
	float local_28;
	float fStack36;
	float local_20;
	float local_1c;
	float fStack24;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	local_34 = globs::toolTipGlobs.rgbFloats[0];
	fStack48 = globs::toolTipGlobs.rgbFloats[3];
	local_28 = globs::toolTipGlobs.rgbFloats[1];
	fStack36 = globs::toolTipGlobs.rgbFloats[4];
	local_2c = globs::toolTipGlobs.rgbFloats[6];
	local_1c = globs::toolTipGlobs.rgbFloats[2];
	fStack24 = globs::toolTipGlobs.rgbFloats[5];
	local_20 = globs::toolTipGlobs.rgbFloats[7];
	iVar2 = (globs::toolTipGlobs.int1_c + globs::toolTipGlobs.int2_8) * 2;
	local_14 = globs::toolTipGlobs.rgbFloats[8];
	if ((toolTip->flags & TOOLTIP_FLAG_UNK_8) == TOOLTIP_FLAG_NONE) {
		uVar5 = toolTip->textWidth;
		if (toolTip->textWidth <= (uint)toolTip->field_26c) {
			uVar5 = toolTip->field_26c;
		}
		uVar3 = toolTip->textLineCount * globs::toolTipGlobs.fontHeight + toolTip->field_264;
	}
	else {
		uVar5 = toolTip->tooltipImage->width;
		uVar3 = toolTip->tooltipImage->height;
	}
	uVar3 = iVar2 + uVar3;
	local_44.x = (float)(iVar2 + uVar5);
	if ((toolTip->flags & TOOLTIP_FLAG_UNK_10) == TOOLTIP_FLAG_NONE) {
		if (globs::toolTipGlobs.width < (int)local_44.x + x) {
			local_10 = (float)(ulonglong)(globs::toolTipGlobs.width - (int)local_44.x);
		}
		else {
			local_10 = (float)(ulonglong)x;
		}
	}
	else {
		local_10 = (float)(ulonglong)x - -32.0;
		if ((ushort)((ushort)(local_10 < (float)(ulonglong)globs::toolTipGlobs.width) << 8 |
								(ushort)(local_10 == (float)(ulonglong)globs::toolTipGlobs.width) << 0xe) == 0) {
			local_10 = (float)(ulonglong)(globs::toolTipGlobs.width - (int)local_44.x);
		}
		else {
			local_10 = local_10 - (float)(ulonglong)(uint)local_44.x;
		}
	}
	local_c = (float)(ulonglong)(globs::toolTipGlobs.int32_18 + y);
	local_4 = (float)(ulonglong)uVar3;
	if ((float)(ulonglong)globs::toolTipGlobs.height < local_c + local_4) {
		local_c = (float)(ulonglong)(y - uVar3) - 1.0;
	}
	local_44.y = 0.0;
	local_8 = (float)(ulonglong)(uint)local_44.x;
	ToolTip_DrawBox((Area2F)CONCAT412(local_4,CONCAT48(local_8,CONCAT44(local_c,local_10))),
									globs::toolTipGlobs.rgbFloats[0],globs::toolTipGlobs.rgbFloats[3],
									globs::toolTipGlobs.rgbFloats[6],globs::toolTipGlobs.rgbFloats[1],
									globs::toolTipGlobs.rgbFloats[4],globs::toolTipGlobs.rgbFloats[7],
									globs::toolTipGlobs.rgbFloats[2],globs::toolTipGlobs.rgbFloats[5],
									globs::toolTipGlobs.rgbFloats[8],0);
	if ((*(byte *)&toolTip->flags & TOOLTIP_FLAG_UNK_8) == 0) {
		x = toolTip->textLineCount * globs::toolTipGlobs.fontHeight;
		local_3c = globs::toolTipGlobs.int1_c;
		uStack56 = 0;
		pcVar7 = toolTip->textBuffer;
		uVar3 = 0;
		uVar5 = 0;
		msg = "%s";
		lVar6 = __ftol((float10)local_c + (float10)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
									 (float10)(ulonglong)globs::toolTipGlobs.int2_8);
		iVar2 = (int)lVar6;
		lVar6 = __ftol((float10)local_10 + extraout_ST0 + extraout_ST1);
		lego::image::Font_PrintF(globs::toolTipGlobs.font,(int)lVar6,iVar2,msg,pcVar7);
		y = 0;
		if (toolTip->iconCount != 0) {
			ppIVar4 = toolTip->iconList;
			do {
				if (*ppIVar4 == NULL) {
					x += uVar5;
					uVar5 = 0;
					uVar3 = 0;
				}
				else {
					local_3c = globs::toolTipGlobs.int2_8;
					uStack56 = 0;
					local_34 = (float)globs::toolTipGlobs.int1_c;
					fStack48 = 0.0;
					fStack36 = 0.0;
					fStack24 = 0.0;
					local_1c = (float)x;
					local_44.x = (float)(ulonglong)uVar3 +
											 local_10 + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
											 (float)(ulonglong)globs::toolTipGlobs.int2_8;
					local_44.y = (float)(ulonglong)x +
											 local_c + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
											 (float)(ulonglong)globs::toolTipGlobs.int2_8;
					local_28 = (float)uVar3;
					lego::image::Image_DisplayScaled(*ppIVar4,NULL,&local_44,NULL);
					uVar1 = (*ppIVar4)->height;
					if ((int)uVar5 < (int)uVar1) {
						uVar5 = uVar1;
					}
					uVar3 += (*ppIVar4)->width;
				}
				y += 1;
				ppIVar4 = ppIVar4 + 1;
			} while (y < toolTip->iconCount);
		}
		return;
	}
	local_3c = globs::toolTipGlobs.int1_c;
	uStack56 = 0;
	local_44.x = local_10 + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
							 (float)(ulonglong)globs::toolTipGlobs.int2_8;
	local_44.y = local_c + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
							 (float)(ulonglong)globs::toolTipGlobs.int2_8;
	lego::image::Image_DisplayScaled(toolTip->tooltipImage,NULL,&local_44,NULL);
	return;
}



void __cdecl
lego::res::Upgrade_LoadActivityFile
					(UpgradeData *out_upgrade,int objIndex,Container *resRoot,char *filename)
{
	Container *pCVar1;
	
	out_upgrade->objectIndex = 0;
	out_upgrade->aeResData = NULL;
	out_upgrade->object_8 = NULL;
	out_upgrade->field_c = 0;
	pCVar1 = Container_Load(resRoot,filename,"LWO",1);
	out_upgrade->aeResData = pCVar1;
	if (pCVar1 == NULL) {
		pCVar1 = Container_Load(resRoot,filename,"ACT",1);
		out_upgrade->aeResData = pCVar1;
	}
	if (out_upgrade->aeResData == NULL) {
		pCVar1 = Container_Load(resRoot,filename,"MESH",1);
		out_upgrade->aeResData = pCVar1;
	}
	out_upgrade->object_8 = NULL;
	out_upgrade->objectIndex = objIndex;
	return;
}



void __cdecl lego::res::Upgrade_Duplicate(UpgradeData *in_upgrade,UpgradeData *out_upgrade)
{
	Container *pCVar1;
	
	out_upgrade->objectIndex = in_upgrade->objectIndex;
	out_upgrade->aeResData = in_upgrade->aeResData;
	out_upgrade->object_8 = in_upgrade->object_8;
	out_upgrade->field_c = in_upgrade->field_c;
	pCVar1 = Container_Clone(in_upgrade->aeResData);
	out_upgrade->aeResData = pCVar1;
	return;
}



void __cdecl lego::res::Upgrade_Destroy(UpgradeData *upgrade)
{
	Container_Remove(upgrade->aeResData);
	return;
}



float10 __cdecl
lego::res::Upgrade_DoAnimElapsedCallbacks(UpgradeData *upgrade,float elapsed,BOOL unused_bool)
{
	Container_MoveAnimation(upgrade->aeResData,elapsed);
	return (float10)0.0;
}



BOOL __cdecl lego::res::Upgrade_SetActivity(UpgradeData *upgrade,char *activityName)
{
	BOOL BVar1;
	
	BVar1 = Container_SetActivity(upgrade->aeResData,activityName);
	if (BVar1 == 0) {
		BVar1 = Container_SetActivity(upgrade->aeResData,globs::liveGlobs.Activities_TABLE[0]);
	}
	return BVar1;
}



void __cdecl
lego::res::Upgrade_LoadUpgradeLevels
					(ObjectUpgradesData *upgrades,CFGProperty *aeRoot,char *rootName)
{
	char cVar1;
	ObjectUpgradePartData *pOVar2;
	char *pcVar3;
	CFGProperty *prop;
	undefined4 *puVar4;
	UpgradeData *pUVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	uint local_12c;
	char *local_128;
	char *local_124;
	char *local_120;
	char local_100 [256];
	
	upgrades->count = 0;
	pOVar2 = (ObjectUpgradePartData *)std::malloc(4000);
	upgrades->parts = pOVar2;
	for (iVar6 = 1000; iVar6 != 0; iVar6 += -1) {
		pOVar2->level = 0;
		pOVar2 = (ObjectUpgradePartData *)&pOVar2->NullInstance;
	}
	local_12c = 0;
	do {
		std::sprintf(local_100,"Level%i%i%i%i",local_12c >> 3 & 1,local_12c >> 2 & 1,local_12c >> 1 & 1,
								 local_12c & 1);
		pcVar3 = cfg::CFG_JoinPath(rootName,"Upgrades",local_100,0);
		prop = cfg::CFG_GetChildren(aeRoot,pcVar3);
		if (prop != NULL) {
			upgrades->levelsMask = upgrades->levelsMask | local_12c;
			for (; prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
				uVar7 = 0xffffffff;
				pOVar2 = upgrades->parts + upgrades->count;
				pcVar3 = prop->value;
				do {
					pcVar10 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar10 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar10;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				puVar4 = (undefined4 *)(pcVar10 + -uVar7);
				puVar9 = (undefined4 *)local_100;
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar9 = *puVar4;
					puVar4 = puVar4 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar4;
					puVar4 = (undefined4 *)((int)puVar4 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				iVar6 = util::Util_Tokenise(local_100,&local_128,",");
				if (iVar6 == 3) {
					uVar7 = 0xffffffff;
					pcVar3 = local_120;
					do {
						if (uVar7 == 0) break;
						uVar7 -= 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar3 + 1;
					} while (cVar1 != '\0');
					puVar4 = (undefined4 *)std::malloc(~uVar7);
					uVar7 = 0xffffffff;
					pOVar2->WeaponName = (char *)puVar4;
					pcVar3 = local_120;
					do {
						pcVar10 = pcVar3;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar10 = pcVar3 + 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar10;
					} while (cVar1 != '\0');
					uVar7 = ~uVar7;
					puVar9 = (undefined4 *)(pcVar10 + -uVar7);
					for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
						*puVar4 = *puVar9;
						puVar9 = puVar9 + 1;
						puVar4 = puVar4 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar4 = *(undefined *)puVar9;
						puVar9 = (undefined4 *)((int)puVar9 + 1);
						puVar4 = (undefined4 *)((int)puVar4 + 1);
					}
				}
				pcVar3 = util::_strdup(local_128);
				pOVar2->NullObjectName = pcVar3;
				pOVar2->level = local_12c;
				iVar6 = std::atoi(local_124);
				pOVar2->NullInstance = iVar6 + -1;
				pUVar5 = game::Game_GetUpgradeData(prop->key);
				pOVar2->upgradeData = pUVar5;
				upgrades->count = upgrades->count + 1;
			}
		}
		local_12c += 1;
		if (0xf < local_12c) {
			if (upgrades->count == 0) {
				std::free(upgrades->parts);
				upgrades->parts = NULL;
			}
			return;
		}
	} while( true );
}



void __cdecl lego::res::Upgrade_ChangeUpgradeParts(ObjectUpgradesData *upgrades,int objLevel)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	UpgradeData *pUVar3;
	int iVar4;
	uint objIndex;
	
	iVar4 = 0;
	pLVar2 = (LiveObject *)upgrades->upgradeObjs;
	pUVar3 = (UpgradeData *)objLevel;
	while (pLVar2 != NULL) {
		pUVar3 = pLVar2->upgrade;
		pLVar1 = pUVar3->object_8;
		game::LiveObject_Remove(pLVar2);
		pLVar2 = pLVar1;
	}
	objIndex = 0;
	upgrades->currentLevel = objLevel;
	upgrades->upgradeObjs = NULL;
	if (upgrades->count != 0) {
		do {
			if (*(int *)((int)&upgrades->parts->level + iVar4) == objLevel) {
				pLVar2 = game::LiveObject_Create
													 (*(int ***)((int)&upgrades->parts->upgradeData + iVar4),
														OBJECT_UPGRADEPART,objIndex);
				if (upgrades->upgradeObjs == NULL) {
					upgrades->upgradeObjs = (LiveObject **)pLVar2;
				}
				else {
					pUVar3->object_8 = pLVar2;
				}
				pUVar3 = pLVar2->upgrade;
				pUVar3->field_c = (int)&upgrades->parts->level + iVar4;
			}
			objIndex += 1;
			iVar4 += 0x14;
		} while (objIndex < upgrades->count);
	}
	return;
}



BOOL __cdecl lego::res::Vehicle_IsCameraFlipDir(VehicleData *vehicle)
{
	return (uint)(vehicle->CameraFlipDir == BOOL3_TRUE);
}



BOOL __cdecl
lego::res::Vehicle_SetActivity_AndRemoveCarryCameraFrames
					(VehicleData *vehicle,char *activityName,float elapsed)
{
	uint uVar1;
	uint uVar2;
	BOOL BVar3;
	Container **ppCVar4;
	
	MeshPoly_RemoveTarget(vehicle->polyMedium_1);
	uVar1 = 0;
	vehicle->field_cc = 0;
	vehicle->field_d0 = 0;
	vehicle->resData_d4 = NULL;
	if (vehicle->CameraNullFrames != 0) {
		ppCVar4 = vehicle->cameraFramesTable_10c;
		do {
			*ppCVar4 = NULL;
			uVar1 += 1;
			ppCVar4 = ppCVar4 + 1;
		} while (uVar1 < vehicle->CameraNullFrames);
	}
	uVar1 = 0;
	if (vehicle->CarryNullFrames != 0) {
		ppCVar4 = vehicle->carryFramesTable_e4;
		do {
			*ppCVar4 = NULL;
			uVar1 += 1;
			ppCVar4 = ppCVar4 + 1;
		} while (uVar1 < vehicle->CarryNullFrames);
	}
	uVar2 = Container_SetActivity(vehicle->contAct_1,activityName);
	uVar1 = vehicle->flags;
	vehicle->flags = uVar1 & 0xfffffffb;
	if ((uVar2 == 0) && ((uVar1 & 8) != 0)) {
		BVar3 = Container_IsCurrentActivity(vehicle->contAct_1,activityName);
		if (BVar3 == 0) {
			vehicle->flags = vehicle->flags | 4;
		}
	}
	if (vehicle->contAct_2 != NULL) {
		uVar1 = Container_SetActivity(vehicle->contAct_2,activityName);
		uVar2 |= uVar1;
	}
	if ((*(byte *)&vehicle->flags & 4) == 0) {
		Container_SetAnimationTime(vehicle->contAct_1,elapsed);
	}
	if (vehicle->contAct_2 != NULL) {
		Container_SetAnimationTime(vehicle->contAct_2,elapsed);
	}
	Vehicle_Wheels_FUN_0046d520(vehicle);
	Vehicle_SetUpgradeActivity(vehicle,activityName);
	return uVar2;
}



void __cdecl lego::res::Vehicle_SetUpgradeActivity(VehicleData *vehicle,char *activityName)
{
	Container **opt_instance;
	LiveObject *pLVar1;
	VehicleData *vehicle_00;
	undefined4 *puVar2;
	Container *parent;
	Container *child;
	char *pcVar3;
	Container *pCVar4;
	undefined4 *puVar5;
	int iVar6;
	UpgradeData *upgrade;
	uint local_14;
	int local_10;
	int local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	vehicle_00 = vehicle;
	iVar6 = 3;
	pLVar1 = (LiveObject *)(vehicle->upgrades).upgradeObjs;
	puVar2 = (undefined4 *)&vehicle->field_0x15c;
	puVar5 = (undefined4 *)&vehicle->field_0x138;
	do {
		puVar2[0x1a] = 0;
		*puVar2 = 0;
		puVar2[-3] = 0;
		*puVar5 = 0;
		puVar2 = puVar2 + 1;
		iVar6 += -1;
		puVar5[1] = 0;
		puVar5 = puVar5 + 2;
	} while (iVar6 != 0);
	vehicle->field_1dc = 0;
	do {
		if (pLVar1 == NULL) {
			return;
		}
		upgrade = pLVar1->upgrade;
		pCVar4 = (Container *)upgrade->field_c;
		local_8 = pCVar4;
		local_4 = upgrade;
		parent = Vehicle_GetNull(vehicle_00,pCVar4->hiddenFrame,pCVar4->activityFrame);
		child = Object_GetActivityContainer((BasicObjectData *)upgrade);
		Container_SetParent(child,parent);
		Container_ClearTransform(child);
		if (activityName == NULL) {
			Container_SetActivity(upgrade->aeResData,globs::liveGlobs.Activities_TABLE[0]);
		}
		else {
			Upgrade_SetActivity(upgrade,activityName);
		}
		if (pCVar4->typeData != NULL) {
			iVar6 = vehicle_00->field_1dc;
			local_10 = 0;
			vehicle_00->table6_1c4[iVar6 + -0x15] = NULL;
			local_14 = 0;
			opt_instance = vehicle_00->table6_1c4 + iVar6 + -0x15;
			vehicle = (VehicleData *)(vehicle_00->cameraFramesTable_10c + iVar6 * 2 + 0xb);
			local_c = iVar6;
			do {
				vehicle->objIndex = 0;
				pcVar3 = Container_FormatPartName
													 (vehicle_00->contAct_1,vehicle_00->FireNullName,(int *)opt_instance);
				pCVar4 = Container_SearchTree(child,pcVar3,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
				vehicle_00->cameraFramesTable_10c[(int)&(*opt_instance)->hiddenFrame + iVar6 * 2 + 3] =
						 pCVar4;
				pCVar4 = vehicle_00->cameraFramesTable_10c
								 [(int)&(*opt_instance)->hiddenFrame + iVar6 * 2 + 3];
				*opt_instance = (Container *)((int)&(*opt_instance)->masterFrame + 1);
				if (pCVar4 == NULL) break;
				local_14 += 1;
				vehicle = (VehicleData *)&vehicle->WheelNullName;
			} while (local_14 < 2);
			pcVar3 = Container_FormatPartName(vehicle_00->contAct_1,vehicle_00->xPivot,&local_10);
			pCVar4 = Container_SearchTree(child,pcVar3,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			iVar6 = local_c;
			vehicle_00->cameraFramesTable_10c[local_c + 0x11] = pCVar4;
			pcVar3 = Container_FormatPartName(vehicle_00->contAct_1,vehicle_00->yPivot,&local_10);
			pCVar4 = Container_SearchTree(child,pcVar3,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			vehicle_00->cameraFramesTable_10c[iVar6 + 0x14] = pCVar4;
			vehicle_00->table6_1c4[iVar6] = local_8;
			vehicle_00->field_1dc = vehicle_00->field_1dc + 1;
			upgrade = local_4;
		}
		pLVar1 = upgrade->object_8;
	} while( true );
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe
// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl
lego::res::Vehicle_LoadActivityFile
					(VehicleData *vehicle,int objIndex,Container *resRoot,char *aeFilename,char *rootName)
{
	char cVar1;
	int iVar2;
	Container *pCVar3;
	CFGProperty *prop;
	char *pcVar4;
	BoolTri BVar5;
	PolyMeshData *pPVar6;
	CFGProperty *aeRoot;
	int iVar7;
	uint uVar8;
	uint uVar9;
	int *piVar10;
	undefined4 *puVar11;
	VehicleData *pVVar12;
	Container **ppCVar13;
	char *pcVar14;
	undefined4 *puVar15;
	float10 fVar16;
	char *pcStack4560;
	char *pcStack4556;
	D3DRMBox DStack4520;
	char *pcStack4496;
	int aiStack4492 [99];
	undefined4 auStack4096 [256];
	char acStack3072 [1024];
	char buff2 [1024];
	char buff1 [1024];
	
	buff1._1020_4_ = 0x46c9ba;
	pVVar12 = vehicle;
	for (iVar7 = 0x7b; iVar7 != 0; iVar7 += -1) {
		pVVar12->objIndex = 0;
		pVVar12 = (VehicleData *)&pVVar12->WheelNullName;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar4 = aeFilename;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar4 = aeFilename + 1;
		cVar1 = *aeFilename;
		aeFilename = pcVar4;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar11 = (undefined4 *)(pcVar4 + -uVar8);
	puVar15 = (undefined4 *)buff2;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar15 = *puVar11;
		puVar11 = puVar11 + 1;
		puVar15 = puVar15 + 1;
	}
	for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar15 = *(undefined *)puVar11;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
		puVar15 = (undefined4 *)((int)puVar15 + 1);
	}
	iVar7 = util::Util_Tokenise(buff2,&pcStack4560,",");
	pCVar3 = Container_Load(resRoot,pcStack4560,"ACT",TRUE);
	vehicle->contAct_1 = pCVar3;
	if (pCVar3 != NULL) {
		if (iVar7 == 2) {
			pCVar3 = Container_Load(pCVar3,pcStack4556,"ACT",TRUE);
			vehicle->contAct_2 = pCVar3;
		}
		else {
			vehicle->contAct_2 = NULL;
		}
		uVar8 = 0xffffffff;
		pcVar4 = pcStack4560;
		do {
			pcVar14 = pcVar4;
			if (uVar8 == 0) break;
			uVar8 -= 1;
			pcVar14 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar14;
		} while (cVar1 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar14 + -uVar8);
		puVar15 = auStack4096;
		for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
			*puVar15 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar15 = puVar15 + 1;
		}
		for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
			*(undefined *)puVar15 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar15 = (undefined4 *)((int)puVar15 + 1);
		}
		uVar8 = util::Util_Tokenise((char *)auStack4096,&pcStack4496,"\\");
		if (1 < uVar8) {
			piVar10 = aiStack4492;
			iVar7 = uVar8 - 1;
			do {
				iVar2 = *piVar10;
				piVar10 = piVar10 + 1;
				iVar7 += -1;
				*(undefined *)(iVar2 + -1) = '\\';
			} while (iVar7 != 0);
		}
		std::sprintf(acStack3072,"%s\\%s.%s",(char *)auStack4096,(char *)(&DStack4520.max.z)[uVar8],"ae"
								);
		prop = cfg::CFG_Open(acStack3072);
		if (prop != NULL) {
			pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->CameraNullName = pcVar4;
			if (pcVar4 == NULL) {
				vehicle->CameraNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					pcVar4 = ____EMPTYSTR__;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				}
				uVar8 = std::atoi(pcVar4);
				vehicle->CameraNullFrames = uVar8;
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraFlipDir",0);
				BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
				vehicle->CameraFlipDir = BVar5;
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->CarryNullName = pcVar4;
			if (pcVar4 == NULL) {
				vehicle->CarryNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					uVar8 = std::atoi(____EMPTYSTR__);
					vehicle->CarryNullFrames = uVar8;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					uVar8 = std::atoi(pcVar4);
					vehicle->CarryNullFrames = uVar8;
				}
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"DrillNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DrillNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DepositNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DriverNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DriverNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"FireNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->FireNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"yPivot",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->yPivot = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"xPivot",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->xPivot = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == NULL) {
				vehicle->PivotMaxZ = 1.0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					fVar16 = std::atof(____EMPTYSTR__);
					vehicle->PivotMaxZ = (float)fVar16;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					fVar16 = std::atof(pcVar4);
					vehicle->PivotMaxZ = (float)fVar16;
				}
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == NULL) {
				vehicle->PivotMinZ = -1.0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					fVar16 = std::atof(____EMPTYSTR__);
					vehicle->PivotMinZ = (float)fVar16;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					fVar16 = std::atof(pcVar4);
					vehicle->PivotMinZ = (float)fVar16;
				}
			}
			Upgrade_LoadUpgradeLevels(&vehicle->upgrades,prop,rootName);
			pcVar4 = cfg::CFG_JoinPath(rootName,"WheelMesh",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			if (pcVar4 != NULL) {
				std::sprintf(buff1,"%s\\%s",(char *)auStack4096,pcVar4);
				std::free(pcVar4);
				pcVar4 = cfg::CFG_JoinPath(rootName,"WheelNullName",0);
				pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
				vehicle->WheelNullName = pcVar4;
				if (pcVar4 != NULL) {
					ppCVar13 = vehicle->WheelMeshes;
					for (iVar7 = 6; iVar7 != 0; iVar7 += -1) {
						*ppCVar13 = NULL;
						ppCVar13 = ppCVar13 + 1;
					}
					pCVar3 = Container_Load(vehicle->contAct_1,buff1,"LWO",0);
					vehicle->WheelMeshes[0] = pCVar3;
					vehicle->numWheelNulls = 1;
					puVar11 = vehicle->wheel_fields_28;
					for (iVar7 = 6; iVar7 != 0; iVar7 += -1) {
						*puVar11 = 0;
						puVar11 = puVar11 + 1;
					}
					if (vehicle->WheelMeshes[0] == NULL) {
						vehicle->WheelRadius = 0.0;
						vehicle->WheelMeshes[1] = NULL;
						vehicle->WheelMeshes[2] = NULL;
						vehicle->WheelMeshes[3] = NULL;
						vehicle->WheelMeshes[4] = NULL;
						vehicle->WheelMeshes[5] = NULL;
					}
					else {
						pcVar4 = cfg::CFG_JoinPath(rootName,"WheelRadius",0);
						pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
						if (pcVar4 == NULL) {
							pcVar4 = ____EMPTYSTR__;
						}
						else {
							pcVar4 = cfg::CFG_JoinPath(rootName,"WheelRadius",0);
							pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
						}
						fVar16 = std::atof(pcVar4);
						vehicle->WheelRadius = (float)fVar16;
						if ((float)fVar16 == 0.0) {
							if (vehicle->WheelMeshes[0]->type == CONTAINER_MESH) {
								Container_Mesh_GetBox(vehicle->WheelMeshes[0],&DStack4520);
								vehicle->WheelRadius = (DStack4520.max.y - DStack4520.min.y) * 0.5;
								Container_Mesh_SetQuality(vehicle->WheelMeshes[0],D3DRMGROUP_0,QUALITY_GOURAUD);
							}
							else {
								vehicle->WheelRadius = 3.0;
							}
						}
					}
					pPVar6 = Res_LoadPolyMesh(prop,rootName,pcStack4560,POLY_MEDIUM,1);
					vehicle->polyMedium_1 = pPVar6;
					if (vehicle->contAct_2 != NULL) {
						uVar8 = 0xffffffff;
						pcVar4 = pcStack4556;
						do {
							pcVar14 = pcVar4;
							if (uVar8 == 0) break;
							uVar8 -= 1;
							pcVar14 = pcVar4 + 1;
							cVar1 = *pcVar4;
							pcVar4 = pcVar14;
						} while (cVar1 != '\0');
						uVar8 = ~uVar8;
						puVar11 = (undefined4 *)(pcVar14 + -uVar8);
						puVar15 = auStack4096;
						for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
							*puVar15 = *puVar11;
							puVar11 = puVar11 + 1;
							puVar15 = puVar15 + 1;
						}
						for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
							*(undefined *)puVar15 = *(undefined *)puVar11;
							puVar11 = (undefined4 *)((int)puVar11 + 1);
							puVar15 = (undefined4 *)((int)puVar15 + 1);
						}
						uVar8 = util::Util_Tokenise((char *)auStack4096,&pcStack4496,"\\");
						if (1 < uVar8) {
							piVar10 = aiStack4492;
							iVar7 = uVar8 - 1;
							do {
								iVar2 = *piVar10;
								piVar10 = piVar10 + 1;
								iVar7 += -1;
								*(undefined *)(iVar2 + -1) = '\\';
							} while (iVar7 != 0);
						}
						std::sprintf(acStack3072,"%s\\%s.%s",(char *)auStack4096,
												 (char *)(&DStack4520.max.z)[uVar8],"ae");
						aeRoot = cfg::CFG_Open(acStack3072);
						if (aeRoot != NULL) {
							pPVar6 = Res_LoadPolyMesh(aeRoot,rootName,pcStack4556,POLY_MEDIUM,1);
							vehicle->polyMedium_2 = pPVar6;
						}
					}
					vehicle->flags = 1;
					pcVar4 = cfg::CFG_JoinPath(rootName,"HoldMissing",0);
					BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
					if (BVar5 == BOOL3_TRUE) {
						vehicle->flags = vehicle->flags | 8;
					}
					vehicle->field_60 = 0;
					vehicle->field_5c = 0;
					vehicle->float_64 = -1.0;
					vehicle->objIndex = objIndex;
					cfg::CFG_Close(prop);
					return TRUE;
				}
			}
			cfg::CFG_Close(prop);
		}
	}
	return 0;
}



void __cdecl lego::res::Vehicle_Destroy(VehicleData *vehicle)
{
	int iVar1;
	Container **ppCVar2;
	
	Vehicle_ChangeUpgradeParts(vehicle,-1);
	if ((*(byte *)&vehicle->flags & 1) != 0) {
		if (vehicle->CameraNullName != NULL) {
			std::free(vehicle->CameraNullName);
		}
		if (vehicle->WheelNullName != NULL) {
			std::free(vehicle->WheelNullName);
		}
		if (vehicle->DrillNullName != NULL) {
			std::free(vehicle->DrillNullName);
		}
		if (vehicle->FireNullName != NULL) {
			std::free(vehicle->FireNullName);
		}
	}
	ppCVar2 = (Container **)vehicle->wheel_fields_28;
	iVar1 = 6;
	do {
		if (ppCVar2[-6] != NULL) {
			Container_Remove(ppCVar2[-6]);
		}
		if (*ppCVar2 != NULL) {
			Container_Remove(*ppCVar2);
		}
		ppCVar2 = ppCVar2 + 1;
		iVar1 += -1;
	} while (iVar1 != 0);
	Container_Remove(vehicle->contAct_1);
	if (vehicle->contAct_2 != NULL) {
		Container_Remove(vehicle->contAct_2);
	}
	return;
}



void __cdecl lego::res::Vehicle_SwapPolyMedium(VehicleData *vehicle,BOOL swap)
{
	MeshPoly_Container_SwapFrame(vehicle->polyMedium_1,vehicle->contAct_1,(uint)(swap == 0),0);
	if ((vehicle->contAct_2 != NULL) && (vehicle->polyMedium_2 != NULL)) {
		MeshPoly_Container_SwapFrame(vehicle->polyMedium_2,vehicle->contAct_2,(uint)(swap == 0),0);
	}
	return;
}



// There's no stored HighPoly data, this just calls `Vehicle_SwapPolyMedium`

void __cdecl lego::res::Vehicle_SwapPolyHigh(VehicleData *vehicle,BOOL swap)
{
	Vehicle_SwapPolyMedium(vehicle,swap);
	return;
}



BOOL __cdecl
lego::res::Vehicle_HasUpgradeLevelMask(VehicleData *vehicle,int levelBit,BOOL condition)
{
	uint uVar1;
	uint uVar2;
	
	uVar2 = 1 << ((byte)levelBit & 0x1f);
	if (condition != 0) {
		uVar1 = Vehicle_GetUpgradesCurrentLevel(vehicle);
		if ((uVar2 & uVar1) != 0) {
			return 0;
		}
	}
	return (vehicle->upgrades).levelsMask & uVar2;
}



int __cdecl lego::res::Vehicle_GetUpgradesCurrentLevel(VehicleData *vehicle)
{
	return (vehicle->upgrades).currentLevel;
}



void __cdecl lego::res::Vehicle_ChangeUpgradeParts(VehicleData *vehicle,int objLevel)
{
	Upgrade_ChangeUpgradeParts(&vehicle->upgrades,objLevel);
	Vehicle_SetUpgradeActivity(vehicle,NULL);
	return;
}



void __cdecl lego::res::Vehicle_HideWheels(VehicleData *vehicle,BOOL hide)
{
	Container **ppCVar1;
	int iVar2;
	
	ppCVar1 = vehicle->WheelMeshes;
	iVar2 = 6;
	do {
		if (*ppCVar1 != NULL) {
			Container_Hide(*ppCVar1,hide);
		}
		ppCVar1 = ppCVar1 + 1;
		iVar2 += -1;
	} while (iVar2 != 0);
	return;
}



BOOL __cdecl lego::res::Vehicle_Duplicate(VehicleData *in_vehicle,VehicleData *out_vehicle)
{
	Container *pCVar1;
	PolyMeshData *pPVar2;
	int iVar3;
	VehicleData *pVVar4;
	Container **ppCVar5;
	VehicleData *pVVar6;
	uint uVar7;
	
	pVVar4 = in_vehicle;
	pVVar6 = out_vehicle;
	for (iVar3 = 0x7b; iVar3 != 0; iVar3 += -1) {
		pVVar6->objIndex = pVVar4->objIndex;
		pVVar4 = (VehicleData *)&pVVar4->WheelNullName;
		pVVar6 = (VehicleData *)&pVVar6->WheelNullName;
	}
	out_vehicle->flags = out_vehicle->flags & 0xfffffffe;
	pCVar1 = Container_Clone(in_vehicle->contAct_1);
	out_vehicle->contAct_1 = pCVar1;
	if (pCVar1 != NULL) {
		if (in_vehicle->contAct_2 != NULL) {
			pCVar1 = Container_Clone(in_vehicle->contAct_2);
			out_vehicle->contAct_2 = pCVar1;
			Container_SetParent(pCVar1,out_vehicle->contAct_1);
			Container_SetPosition(out_vehicle->contAct_2,out_vehicle->contAct_1,0.0,0.0,0.0);
			Container_SetOrientation
								(out_vehicle->contAct_2,out_vehicle->contAct_1,0.0,0.0,1.0,0.0,1.0,0.0);
			Container_SetPerspectiveCorrection(out_vehicle->contAct_2,1);
		}
		pPVar2 = MeshPoly_Duplicate(in_vehicle->polyMedium_1);
		out_vehicle->polyMedium_1 = pPVar2;
		if (in_vehicle->polyMedium_2 != NULL) {
			pPVar2 = MeshPoly_Duplicate(in_vehicle->polyMedium_2);
			out_vehicle->polyMedium_2 = pPVar2;
		}
		Container_SetPerspectiveCorrection(out_vehicle->contAct_1,1);
		Vehicle_Wheels_FUN_0046d520(out_vehicle);
		if ((in_vehicle->WheelMeshes[0] != NULL) && (uVar7 = 0, out_vehicle->numWheelNulls != 0)) {
			ppCVar5 = out_vehicle->WheelMeshes;
			do {
				pCVar1 = Container_Clone(in_vehicle->WheelMeshes[0]);
				*ppCVar5 = pCVar1;
				if (pCVar1 != NULL) {
					Container_SetParent(pCVar1,out_vehicle->contAct_1);
					Container_SetPerspectiveCorrection(*ppCVar5,1);
				}
				uVar7 += 1;
				ppCVar5 = ppCVar5 + 1;
			} while (uVar7 < out_vehicle->numWheelNulls);
		}
		return 1;
	}
	return 0;
}



void __cdecl lego::res::Vehicle_SetOwnerObject(VehicleData *vehicle,void *liveObj)
{
	Container **ppCVar1;
	uint uVar2;
	
	Container_SetUserData(vehicle->contAct_1,liveObj);
	if (vehicle->contAct_2 != NULL) {
		Container_SetUserData(vehicle->contAct_2,liveObj);
	}
	uVar2 = 0;
	if (vehicle->numWheelNulls != 0) {
		ppCVar1 = vehicle->WheelMeshes;
		do {
			if (*ppCVar1 != NULL) {
				Container_SetUserData(*ppCVar1,liveObj);
			}
			uVar2 += 1;
			ppCVar1 = ppCVar1 + 1;
		} while (uVar2 < vehicle->numWheelNulls);
	}
	return;
}



float10 __cdecl lego::res::Vehicle_GetAnimationTime(VehicleData *vehicle)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(vehicle->contAct_1);
	return fVar1;
}



float10 __cdecl
lego::res::Vehicle_FUN_0046d480(VehicleData *vehicle,float elapsed,float elapsed2,uint param_4)
{
	float fVar1;
	uint uVar2;
	float10 fVar3;
	
	if ((*(byte *)&vehicle->flags & 4) == 0) {
		fVar3 = Container_MoveAnimation(vehicle->contAct_1,elapsed);
	}
	else {
		fVar3 = (float10)0.0;
	}
	if (vehicle->contAct_2 != NULL) {
		fVar3 = Container_MoveAnimation(vehicle->contAct_2,elapsed2);
	}
	fVar1 = (float)fVar3;
	if ((1 < param_4) && (fVar1 != 0.0)) {
		uVar2 = Container_GetAnimationFrames(vehicle->contAct_1);
		return (float10)fVar1 - (float10)(ulonglong)(uVar2 * (param_4 - 1));
	}
	return (float10)fVar1;
}



void __cdecl lego::res::Vehicle_Wheels_FUN_0046d520(VehicleData *vehicle)
{
	VehicleData *pVVar1;
	char *name;
	Container *pCVar2;
	
	pVVar1 = vehicle;
	vehicle = NULL;
	pVVar1->numWheelNulls = 0;
	do {
		name = Container_FormatPartName(pVVar1->contAct_1,pVVar1->WheelNullName,(int *)&vehicle);
		pCVar2 = Container_SearchTree(pVVar1->contAct_1,name,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
		pVVar1->wheel_fields_28[(int)vehicle] = pCVar2;
		if (pVVar1->wheel_fields_28[(int)vehicle] != 0) {
			pVVar1->numWheelNulls = pVVar1->numWheelNulls + 1;
		}
		vehicle = (VehicleData *)((int)&vehicle->objIndex + 1);
	} while (vehicle < (VehicleData *)0x6);
	return;
}



void __cdecl lego::res::Vehicle_HideAll(VehicleData *vehicle,BOOL hide)
{
	Container **ppCVar1;
	uint uVar2;
	
	if (hide == 0) {
		uVar2 = vehicle->flags & 0xfffffffd;
	}
	else {
		uVar2 = vehicle->flags | 2;
	}
	vehicle->flags = uVar2;
	Container_Hide(vehicle->contAct_1,hide);
	if (vehicle->contAct_2 != NULL) {
		Container_Hide(vehicle->contAct_2,hide);
	}
	uVar2 = 0;
	if (vehicle->numWheelNulls != 0) {
		ppCVar1 = vehicle->WheelMeshes;
		do {
			if (*ppCVar1 != NULL) {
				Container_Hide(*ppCVar1,hide);
			}
			uVar2 += 1;
			ppCVar1 = ppCVar1 + 1;
		} while (uVar2 < vehicle->numWheelNulls);
	}
	return;
}



BOOL __cdecl lego::res::Vehicle_GetFlag2(VehicleData *vehicle)
{
	return (vehicle->flags & 0xff) >> 1 & 1;
}



void __cdecl lego::res::Vehicle_SetOrientation(VehicleData *vehicle,float x,float y,float z)
{
	Container_SetOrientation(vehicle->contAct_1,NULL,x,y,z,0.0,0.0,-1.0);
	return;
}



void __cdecl
lego::res::Vehicle_SetPosition
					(VehicleData *vehicle,float x,float y,GetSurfaceZFunc getSurfaceZFunc,SurfaceMap *surfMap)
{
	float fVar1;
	int iVar2;
	uint uVar3;
	Container **ppCVar4;
	float *pfVar5;
	Vector3F *pVVar6;
	float10 fVar7;
	Vector3F local_a4;
	float local_98;
	float local_94;
	float local_90;
	float local_8c;
	Vector3F local_88;
	float local_7c;
	float local_78;
	float local_74;
	Vector3F local_70;
	Vector3F local_64;
	uint local_58;
	Vector3F local_54;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_c;
	
	fVar7 = (*getSurfaceZFunc)(x,y,surfMap);
	Container_SetPosition(vehicle->contAct_1,NULL,x,y,(float)fVar7);
	Container_GetOrientation(vehicle->contAct_1,NULL,&local_88,&local_c);
	Container_SetOrientation(vehicle->contAct_1,NULL,local_88.x,local_88.y,local_88.z,0.0,0.0,-1.0);
	if (vehicle->numWheelNulls != 0) {
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = (Container **)vehicle->wheel_fields_28;
			do {
				Container_GetPosition(*ppCVar4,NULL,pVVar6);
				fVar7 = (*getSurfaceZFunc)(pVVar6->x,pVVar6->y,surfMap);
				pVVar6->z = (float)fVar7;
				uVar3 += 1;
				ppCVar4 = ppCVar4 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		local_98 = local_48 - local_3c;
		local_94 = local_44 - local_38;
		local_90 = local_40 - local_34;
		local_7c = local_48 - local_54.x;
		local_78 = local_44 - local_54.y;
		local_74 = local_40 - local_54.z;
		local_70.x = local_90 * local_78 - local_94 * local_74;
		local_70.y = local_98 * local_74 - local_90 * local_7c;
		local_70.z = local_94 * local_7c - local_98 * local_78;
		math::Maths_Vector3DScale
							(&local_70,&local_70,
							 1.0 / SQRT(local_70.z * local_70.z +
													local_70.y * local_70.y + local_70.x * local_70.x));
		local_7c = local_30 - local_3c;
		local_78 = local_2c - local_38;
		local_74 = local_28 - local_34;
		local_98 = local_30 - local_54.x;
		local_94 = local_2c - local_54.y;
		local_64.x = (local_28 - local_54.z) * local_78 - local_94 * local_74;
		local_64.y = local_98 * local_74 - (local_28 - local_54.z) * local_7c;
		local_64.z = local_94 * local_7c - local_98 * local_78;
		math::Maths_Vector3DScale
							(&local_64,&local_64,
							 1.0 / SQRT(local_64.z * local_64.z +
													local_64.y * local_64.y + local_64.x * local_64.x));
		local_a4.x = local_64.x + local_70.x;
		local_a4.y = local_64.y + local_70.y;
		local_a4.z = local_64.z + local_70.z;
		math::Maths_Vector3DScale
							(&local_a4,&local_a4,
							 1.0 / SQRT(local_a4.z * local_a4.z +
													local_a4.y * local_a4.y + local_a4.x * local_a4.x));
		pfVar5 = (float *)&vehicle->field_5c;
		iVar2 = std::_finite((double)(float)vehicle->field_5c);
		if (((iVar2 == 0) || (iVar2 = std::_finite((double)(float)vehicle->field_60), iVar2 == 0)) ||
			 (iVar2 = std::_finite((double)(float)vehicle->field_60), iVar2 == 0)) {
			*pfVar5 = local_a4.x;
			vehicle->field_60 = local_a4.y;
			vehicle->float_64 = local_a4.z;
		}
		local_a4.x = *pfVar5 * 0.4 + local_a4.x;
		local_a4.y = (float)vehicle->field_60 * 0.4 + local_a4.y;
		local_a4.z = vehicle->float_64 * 0.4 + local_a4.z;
		local_8c = 1.0 / SQRT(local_a4.z * local_a4.z +
													local_a4.y * local_a4.y + local_a4.x * local_a4.x);
		local_a4.x = local_8c * local_a4.x;
		local_a4.y = local_8c * local_a4.y;
		local_a4.z = local_8c * local_a4.z;
		fVar1 = local_88.z * local_a4.z + local_88.y * local_a4.y + local_88.x * local_a4.x;
		*pfVar5 = local_a4.x;
		local_88.x = local_88.x - fVar1 * local_a4.x;
		local_88.y = local_88.y - fVar1 * local_a4.y;
		local_88.z = local_88.z - fVar1 * local_a4.z;
		vehicle->field_60 = local_a4.y;
		vehicle->float_64 = local_a4.z;
		Container_SetOrientation
							(vehicle->contAct_1,NULL,local_88.x,local_88.y,local_88.z,-local_a4.x,-local_a4.y,
							 -local_a4.z);
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = (Container **)vehicle->wheel_fields_28;
			do {
				Container_GetPosition(*ppCVar4,NULL,pVVar6);
				fVar7 = (*getSurfaceZFunc)(pVVar6->x,pVVar6->y,surfMap);
				Container_AddTranslation
									(*ppCVar4,D3DRMCOMBINE_AFTER,0.0,
									 (float)-((fVar7 - (float10)pVVar6->z) - (float10)vehicle->WheelRadius),0.0);
				uVar3 += 1;
				ppCVar4 = ppCVar4 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			ppCVar4 = vehicle->WheelMeshes;
			do {
				if (*ppCVar4 != NULL) {
					Container_SetPosition(*ppCVar4,ppCVar4[6],0.0,0.0,0.0);
				}
				uVar3 += 1;
				ppCVar4 = ppCVar4 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		local_58 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = vehicle->WheelMeshes;
			pfVar5 = (float *)&vehicle->field_0x74;
			do {
				if (*ppCVar4 != NULL) {
					Container_GetPosition(*ppCVar4,NULL,pVVar6);
					local_98 = pVVar6->x - pfVar5[-2];
					local_94 = pVVar6->y - pfVar5[-1];
					local_90 = pVVar6->z - *pfVar5;
					local_8c = SQRT(local_90 * local_90 + local_94 * local_94 + local_98 * local_98) /
										 vehicle->WheelRadius;
					if (local_90 * local_88.z + local_94 * local_88.y + local_98 * local_88.x < 0.0) {
						local_8c = -local_8c;
					}
					Container_AddRotation(*ppCVar4,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,local_8c);
				}
				local_58 += 1;
				ppCVar4 = ppCVar4 + 1;
				pfVar5 = pfVar5 + 3;
				pVVar6 = pVVar6 + 1;
			} while (local_58 < vehicle->numWheelNulls);
		}
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			ppCVar4 = vehicle->WheelMeshes;
			pVVar6 = (Vector3F *)&vehicle->field_0x6c;
			do {
				if (*ppCVar4 != NULL) {
					Container_GetPosition(*ppCVar4,NULL,pVVar6);
				}
				uVar3 += 1;
				pVVar6 = pVVar6 + 1;
				ppCVar4 = ppCVar4 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		return;
	}
	return;
}



Container * __cdecl lego::res::Vehicle_GetActivityContainer(VehicleData *vehicle)
{
	return vehicle->contAct_1;
}



Container * __cdecl lego::res::Vehicle_GetNull(VehicleData *vehicle,char *nullName,int nullIndex)
{
	Container *pCVar1;
	char *pcVar2;
	
	pCVar1 = NULL;
	if (vehicle->contAct_2 != NULL) {
		pcVar2 = Container_FormatPartName(vehicle->contAct_2,nullName,&nullIndex);
		pCVar1 = Container_SearchTree(vehicle->contAct_2,pcVar2,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
	}
	if (pCVar1 == NULL) {
		pcVar2 = Container_FormatPartName(vehicle->contAct_1,nullName,&nullIndex);
		pCVar1 = Container_SearchTree(vehicle->contAct_1,pcVar2,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetCameraNull(VehicleData *vehicle,int cameraIndex)
{
	Container *pCVar1;
	
	if (vehicle->CameraNullName == NULL) {
		return NULL;
	}
	if (vehicle->cameraFramesTable_10c[cameraIndex] != NULL) {
		return vehicle->cameraFramesTable_10c[cameraIndex];
	}
	pCVar1 = Vehicle_GetNull(vehicle,vehicle->CameraNullName,cameraIndex);
	vehicle->cameraFramesTable_10c[cameraIndex] = pCVar1;
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDrillNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DrillNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)vehicle->field_cc;
		if (pCVar1 == NULL) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DrillNullName,0);
			vehicle->field_cc = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDepositNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DepositNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)vehicle->field_d0;
		if (pCVar1 == NULL) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DepositNullName,0);
			vehicle->field_d0 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDriverNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DriverNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = vehicle->resData_d4;
		if (pCVar1 == NULL) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DriverNullName,0);
			vehicle->resData_d4 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetCarryNull(VehicleData *vehicle,int carryIndex)
{
	Container *pCVar1;
	
	if (vehicle->CarryNullName == NULL) {
		return NULL;
	}
	if (vehicle->carryFramesTable_e4[carryIndex] != NULL) {
		return vehicle->carryFramesTable_e4[carryIndex];
	}
	pCVar1 = Vehicle_GetNull(vehicle,vehicle->CarryNullName,carryIndex);
	vehicle->carryFramesTable_e4[carryIndex] = pCVar1;
	return pCVar1;
}



int __cdecl lego::res::Vehicle_GetCarryNullFrames(VehicleData *vehicle)
{
	return vehicle->CarryNullFrames;
}



float10 __cdecl lego::res::Vehicle_GetTransCoef(VehicleData *vehicle)
{
	float10 fVar1;
	
	fVar1 = Container_GetTransCoef(vehicle->contAct_1);
	return fVar1;
}



// Module for handling the unfinished "Flood water" feature.
//  This is designed for the block "SurfaceType_Water" (0x7),
//  which is unused.

void __cdecl lego::game::Water_Initialise(Container *contRoot,LevelData *level)
{
	WaterEntry *entry;
	uint j;
	uint width;
	int iVar1;
	uint *pPointsCount;
	uint x;
	uint y;
	WaterEntry **pPairSecond;
	uint water_xMax;
	uint water_xAlign;
	Point2F *pPVar2;
	uint i;
	WaterEntry *first;
	WaterEntry *second;
	
	y = 0;
	globs::waterGlobs.entryCount = 0;
	globs::waterGlobs.pairCount = 0;
						// Assigned, but never used, level->DigDepth is always used instead
	globs::waterGlobs.digDepth = level->DigDepth;
	if ((level->dimensions).height != 0) {
		do {
			water_xMax = 0;
			water_xAlign = 0;
			x = 0;
			width = (level->dimensions).width;
			if (width != 0) {
				do {
					if (level->blocks[y * width + x].terrain == TERRAIN_WATER_unused) {
						if (water_xAlign == water_xMax) {
							water_xAlign = x;
						}
						water_xMax = x + 1;
					}
					else {
						if (water_xAlign != water_xMax) {
							entry = Water_InitSearchAddPairs(y,water_xAlign,water_xMax);
							if (entry == NULL) {
								Water_InitAddPointFirst(y,water_xAlign,water_xMax);
							}
							else {
								Water_InitAddPoint(entry,y,water_xAlign,water_xMax);
							}
						}
						water_xMax = 0;
						water_xAlign = 0;
					}
					width = (level->dimensions).width;
					x += 1;
				} while (x < width);
			}
			y += 1;
		} while (y < (uint)(level->dimensions).height);
	}
	i = 0;
	if (globs::waterGlobs.pairCount != 0) {
		pPairSecond = &globs::waterGlobs.pairTable[0].second;
		do {
			second = *pPairSecond;
			first = pPairSecond[-1];
			if (second->pointCount != 0) {
						// std::memcpy(&first->points[first->pointsCount], &second->points[0],
						// second->pointsCount * sizeof(uint));
						// 
						// first->pointsCount += second->pointsCount;
						// second->pointsCount = 0;
				entry = second;
				pPVar2 = first->points + first->pointCount;
				for (y = (second->pointCount << 3) >> 2; y != 0; y -= 1) {
					pPVar2->x = entry->points[0].x;
					entry = (WaterEntry *)&entry->points[0].y;
					pPVar2 = (Point2F *)&pPVar2->y;
				}
				for (iVar1 = 0; iVar1 != 0; iVar1 += -1) {
					*(undefined *)&pPVar2->x = *(undefined *)&entry->points[0].x;
					entry = (WaterEntry *)((int)&entry->points[0].x + 1);
					pPVar2 = (Point2F *)((int)&pPVar2->x + 1);
				}
				first->pointCount = first->pointCount + second->pointCount;
				second->pointCount = 0;
			}
			i += 1;
			pPairSecond = pPairSecond + 2;
		} while (i < globs::waterGlobs.pairCount);
	}
						// Sort by pointsCount, highest to lowest
	std::qsort(&globs::waterGlobs,globs::waterGlobs.entryCount,0x428,Water_QsortCompare);
						// Then cap entryCount to number of entries with non-zero pointsCount's
	j = 0;
	if (globs::waterGlobs.entryCount != 0) {
		pPointsCount = &globs::waterGlobs.entryTable[0].pointCount;
		y = globs::waterGlobs.entryCount;
		do {
			if (*pPointsCount == 0) {
				y = j;
				globs::waterGlobs.entryCount = j;
			}
			j += 1;
			pPointsCount = pPointsCount + 0x10a;
		} while (j < y);
	}
	Water_InitGroups(contRoot,level);
	Water_InitVertices(contRoot,level);
	return;
}



void __cdecl lego::game::Water_InitGroups(Container *contRoot,LevelData *level)
{
	int iVar1;
	int iVar2;
	int iVar3;
	uint uVar4;
	float *pfVar5;
	longlong lVar6;
	Point2F *local_30;
	uint local_2c;
	uint *local_28;
	uint i;
	Point2F DIRECTIONS [4];
	TerrainType terrain;
	
	DIRECTIONS[0].x = 0.0;
	DIRECTIONS[0].y = -1.0;
	DIRECTIONS[1].x = 1.0;
	DIRECTIONS[1].y = 0.0;
	DIRECTIONS[2].x = 0.0;
	DIRECTIONS[2].y = 1.0;
	DIRECTIONS[3].x = -1.0;
	DIRECTIONS[3].y = 0.0;
	i = 0;
	if (globs::waterGlobs.entryCount != 0) {
		local_28 = &globs::waterGlobs.entryTable[0].pointCount;
		do {
			local_30 = (Point2F *)(local_28 + -200);
			local_28[0x3d] = 0;
			local_2c = 0;
			if (*local_28 != 0) {
				do {
					uVar4 = 0;
					pfVar5 = &DIRECTIONS[0].y;
					do {
						lVar6 = __ftol((float10)pfVar5[-1] + (float10)local_30->x);
						iVar2 = (int)lVar6;
						lVar6 = __ftol((float10)local_30->y + (float10)*pfVar5);
						iVar3 = (int)lVar6;
						if ((((-1 < iVar2) && (iVar1 = (level->dimensions).width, iVar2 < iVar1)) &&
								(-1 < iVar3)) &&
							 (((iVar3 < (level->dimensions).height &&
								 (terrain = level->blocks[iVar3 * iVar1 + iVar2].terrain,
								 terrain != TERRAIN_WATER_unused)) && (terrain != TERRAIN_IMMOVABLE)))) {
							local_28[local_28[0x3d] * 6 + 1] = local_2c;
							local_28[local_28[0x3d] * 6 + 2] = uVar4;
							local_28[0x3d] = local_28[0x3d] + 1;
							break;
						}
						uVar4 += 1;
						pfVar5 = pfVar5 + 2;
					} while (uVar4 < 4);
					local_30 = local_30 + 1;
					local_2c += 1;
				} while (local_2c < *local_28);
			}
			i += 1;
			local_28 = local_28 + 0x10a;
		} while (i < globs::waterGlobs.entryCount);
	}
	return;
}



void __cdecl lego::game::Water_InitVertices(Container *contRoot,LevelData *level)
{
	int iVar1;
	float fVar2;
	uint uVar3;
	Container *cont;
	D3DRMGroupIndex groupID;
	float *pfVar4;
	uint uVar5;
	float *pfVar6;
	Point2F *pPVar7;
	float *pfVar8;
	longlong lVar9;
	longlong lVar10;
	Vector3F *pVVar11;
	uint j;
	uint *pEntryOff320;
	float *local_130;
	int local_12c;
	uint i;
	float TU_COORDS [4];
	float TV_COORDS [4];
	uint FACEDATA [6];
	Point2F DIRECTIONS [4];
	Vector3F vertPoses [4];
	D3DRMVertex vertices [4];
	
	FACEDATA[1] = 1;
	FACEDATA[3] = 1;
	DIRECTIONS[0].x = 0.0;
	DIRECTIONS[0].y = 0.0;
	DIRECTIONS[1].x = 1.0;
	DIRECTIONS[1].y = 0.0;
	DIRECTIONS[2].x = 1.0;
	DIRECTIONS[2].y = 1.0;
	DIRECTIONS[3].x = 0.0;
	DIRECTIONS[3].y = 1.0;
	FACEDATA[0] = 0;
	FACEDATA[2] = 3;
	FACEDATA[4] = 2;
	FACEDATA[5] = 3;
	TU_COORDS[0] = 0.0;
	TU_COORDS[1] = 1.0;
	TU_COORDS[2] = 1.0;
	TU_COORDS[3] = 0.0;
	TV_COORDS[0] = 0.0;
	TV_COORDS[1] = 0.0;
	TV_COORDS[2] = 1.0;
	TV_COORDS[3] = 1.0;
	i = 0;
	if (globs::waterGlobs.entryCount != 0) {
		pEntryOff320 = &globs::waterGlobs.entryTable[0].pointCount;
		do {
			pfVar8 = (float *)(pEntryOff320 + -200);
						// structTable[i].float_z_418 = -10000.0;
			pEntryOff320[0x3e] = 0xc61c4000;
			j = 0;
			pfVar6 = pfVar8;
			if (*pEntryOff320 != 0) {
				do {
					pVVar11 = vertPoses;
					lVar9 = __ftol((float10)pfVar6[1]);
					uVar3 = (uint)lVar9;
					lVar9 = __ftol((float10)*pfVar6);
					Map3D_GetBlockVertexPositions2(level->surfaceMap,(uint)lVar9,uVar3,pVVar11);
					local_130 = &vertPoses[0].z;
					pPVar7 = DIRECTIONS;
					local_12c = 4;
					do {
						lVar9 = __ftol((float10)pPVar7->y + (float10)pfVar6[1]);
						iVar1 = (level->dimensions).width;
						lVar10 = __ftol((float10)*pfVar6 + (float10)pPVar7->x);
						if (level->blocks[(int)lVar9 * iVar1 + (int)lVar10].predug == PREDUG_WALL) {
							if ((ushort)((ushort)(*local_130 < (float)pEntryOff320[0x3e]) << 8 |
													(ushort)(*local_130 == (float)pEntryOff320[0x3e]) << 0xe) == 0) {
						// structTable[i].dig_z_418 = vertPoses[k].z;
								pEntryOff320[0x3e] = (uint)*local_130;
							}
						}
						else {
							pEntryOff320[0x41] = pEntryOff320[0x41] | 1;
						}
						pPVar7 = pPVar7 + 1;
						local_130 = local_130 + 3;
						local_12c += -1;
					} while (local_12c != 0);
					j += 1;
					pfVar6 = pfVar6 + 2;
				} while (j < *pEntryOff320);
			}
						// structTable[i].float_z2_41c = structTable[i].float_z_418;
			pEntryOff320[0x3f] = pEntryOff320[0x3e];
			cont = res::Container_MakeMesh2(contRoot,CONTAINER_MESHTYPE_TRANSPARENT);
			pEntryOff320[0x40] = (uint)cont;
			res::Container_Hide(cont,~pEntryOff320[0x41] & 1);
			j = 0;
			if (*pEntryOff320 != 0) {
				do {
					groupID = res::Container_Mesh_AddGroup((Container *)pEntryOff320[0x40],4,2,3,FACEDATA);
					res::Container_Mesh_SetColourAlpha
										((Container *)pEntryOff320[0x40],groupID,0.0,0.3,0.8,0.6);
					pVVar11 = vertPoses;
					lVar9 = __ftol((float10)pfVar8[1]);
					uVar3 = (uint)lVar9;
					lVar9 = __ftol((float10)*pfVar8);
					Map3D_GetBlockVertexPositions2(level->surfaceMap,(uint)lVar9,uVar3,pVVar11);
					pfVar6 = &vertPoses[0].y;
					pfVar4 = &vertices[0].position.y;
					uVar3 = 0;
					do {
						// vertices[k].position.x = vertPoses[k].x;
						// vertices[k].position.y = vertPoses[k].y;
						// vertices[k].position.z = structTable[i].float_z_418;
						// vertices[k].normal.x = 0.0f;
						// vertices[k].normal.y = 0.0f;
						// vertices[k].normal.z = -1.0f;
						// vertices[k].tu = TU_COORDS[k];
						// vertices[k].tv = TV_COORDS[k];
						// vertices[k].colour = 0;
						pfVar4[-1] = pfVar6[-1];
						*pfVar4 = *pfVar6;
						pfVar4[1] = (float)pEntryOff320[0x3e];
						uVar5 = uVar3 + 4;
						pfVar6 = pfVar6 + 3;
						pfVar4[2] = 0.0;
						pfVar4[3] = 0.0;
						pfVar4[4] = -1.0;
						fVar2 = *(float *)((int)TU_COORDS + uVar3);
						pfVar4[7] = 0.0;
						pfVar4[5] = fVar2;
						pfVar4[6] = *(float *)((int)TV_COORDS + uVar3);
						pfVar4 = pfVar4 + 9;
						uVar3 = uVar5;
					} while (uVar5 < 0x10);
					res::Container_Mesh_SetVertices((Container *)pEntryOff320[0x40],j,0,4,vertices);
					j += 1;
					pfVar8 = pfVar8 + 2;
				} while (j < *pEntryOff320);
			}
			i += 1;
			pEntryOff320 = pEntryOff320 + 0x10a;
		} while (i < globs::waterGlobs.entryCount);
	}
	return;
}



// This function can be completely ignored, since there's not actual information on what
// logf_removed is doing.

void __cdecl lego::debug::Water_Debug_LogContainerMesh(BOOL logWithValues)
{
	Container **pContMeshTrans;
	uint i;
	Container *message;
	undefined4 arg1;
	undefined4 arg2;
	
	i = 0;
	if (globs::waterGlobs.entryCount != 0) {
		pContMeshTrans = &globs::waterGlobs.entryTable[0].contMeshTrans;
		do {
			if (logWithValues == 0) {
						// contMeshTrans (Container*), 0.0, 0.0
				message = *pContMeshTrans;
				arg2 = 0;
				arg1 = 0;
			}
			else {
				message = *pContMeshTrans;
						// contMeshTrans (Container*), 0.12, 0.32
				arg2 = 1050924810;
				arg1 = 1039516304;
			}
			util::logf_removed((char *)message,0,arg1,arg2);
			i += 1;
			pContMeshTrans = pContMeshTrans + 0x10a;
		} while (i < globs::waterGlobs.entryCount);
	}
	return;
}



void __cdecl lego::game::Water_Block_DestroyWallComplete(LevelData *level,uint bx,uint by)
{
	float fVar1;
	WaterEntry *entry;
	uint by_00;
	longlong lVar2;
	Vector3F *out_vertPoses;
	Point2I VERT_OFFSETS [4];
	Vector3F vertPoses [4];
	uint groupIndex;
	WaterEntryGroup *item;
	
	VERT_OFFSETS[1].y = 2;
	VERT_OFFSETS[2].x = 2;
	VERT_OFFSETS[2].y = 3;
	VERT_OFFSETS[3].x = 3;
	VERT_OFFSETS[0].x = 0;
	VERT_OFFSETS[0].y = 1;
	VERT_OFFSETS[1].x = 1;
	VERT_OFFSETS[3].y = 0;
	entry = Water_Block_SubDestroyWall_AndDebug_WKey(bx,by,&by);
	if (entry != NULL) {
		entry->flags = entry->flags & ~WATER_STATE_B | WATER_HIDDEN_UNK;
		res::Container_Hide(entry->contMeshTrans,0);
		out_vertPoses = vertPoses;
		groupIndex = entry->groups[by].index;
		item = entry->groups + by;
		item->bool_14 = 1;
		item->elapsedUp_c = 0.0;
		item->elapsedDown_10 = 0.0;
		lVar2 = __ftol((float10)entry->points[groupIndex].y);
		by_00 = (uint)lVar2;
		lVar2 = __ftol((float10)entry->points[groupIndex].x);
		Map3D_GetBlockVertexPositions2(level->surfaceMap,(uint)lVar2,by_00,out_vertPoses);
		fVar1 = -vertPoses[VERT_OFFSETS[item->direction].x].z;
		if (-vertPoses[VERT_OFFSETS[item->direction].y].z <=
				-vertPoses[VERT_OFFSETS[item->direction].x].z) {
			fVar1 = -vertPoses[VERT_OFFSETS[item->direction].y].z;
		}
		item->float_maxDirZ_8 = -fVar1;
	}
	return;
}



void __cdecl lego::game::Water_Block_Debug_WKey(uint bx,uint by)
{
	WaterEntry *entry;
	
	entry = Water_Block_SubDestroyWall_AndDebug_WKey(bx,by,&by);
	if (entry != NULL) {
						// &= ~0x2;
						//  |= 0x1;
		entry->flags = entry->flags & ~WATER_STATE_A | WATER_HIDDEN_UNK;
		res::Container_Hide(entry->contMeshTrans,FALSE);
		entry->groups[by].bool_14 = FALSE;
	}
	return;
}



void __cdecl lego::game::Water_Update(LevelData *level,float elapsedGame)
{
	float fVar1;
	float *pVertPosZ;
	float *pGroupOff8;
	int k;
	uint j;
	uint *pEntryOff414;
	D3DRMGroupIndex groupID;
	bool bFlag4;
	uint unkCount;
	uint i;
	D3DRMVertex vertices [4];
	uint flags;
	bool bElapseFloat10;
	bool bFlag2;
	float dig_diff;
	float dig_z2;
	
	unkCount = 0;
	i = 0;
	if (globs::waterGlobs.entryCount != 0) {
		pEntryOff414 = &globs::waterGlobs.entryTable[0].groupCount;
		do {
			bFlag2 = false;
			dig_z2 = (float)pEntryOff414[1];
			bFlag4 = (*(byte *)(pEntryOff414 + 4) & 2) == 0;
			j = 0;
			if (*pEntryOff414 != 0) {
				pGroupOff8 = (float *)(pEntryOff414 + -0x3a);
				do {
					bElapseFloat10 = false;
					if ((pGroupOff8[3] == 0.0) ||
						 ((ushort)((ushort)((float)pEntryOff414[2] < *pGroupOff8) << 8 |
											(ushort)((float)pEntryOff414[2] == *pGroupOff8) << 0xe) == 0)) {
LAB_0046e6eb:
						bElapseFloat10 = true;
					}
					else {
						if (dig_z2 < *pGroupOff8) {
							dig_z2 = *pGroupOff8;
						}
						bFlag4 = false;
						unkCount += 1;
						bFlag2 = true;
						if ((float)pEntryOff414[2] == *pGroupOff8) goto LAB_0046e6eb;
					}
					dig_diff = pGroupOff8[1] + elapsedGame * 1.5;
					pGroupOff8[1] = dig_diff;
					if (bElapseFloat10) {
						pGroupOff8[2] = elapsedGame * 0.5 + pGroupOff8[2];
					}
					if ((ushort)((ushort)(dig_diff < 240.0) << 8 | (ushort)(dig_diff == 240.0) << 0xe) == 0) {
						pGroupOff8[1] = 240.0;
					}
					if ((ushort)((ushort)(pGroupOff8[2] < 240.0) << 8 |
											(ushort)(pGroupOff8[2] == 240.0) << 0xe) == 0) {
						pGroupOff8[2] = 240.0;
					}
					j += 1;
					pGroupOff8 = pGroupOff8 + 6;
				} while (j < *pEntryOff414);
			}
			flags = pEntryOff414[4];
			if ((flags & 4) != 0) {
				bFlag2 = false;
			}
			if ((bFlag2) || (bFlag4)) {
				dig_diff = ((float)pEntryOff414[2] - (float)pEntryOff414[1]) / level->DigDepth;
				if (bFlag2) {
					pEntryOff414[4] = flags & 0xfffffffd;
					fVar1 = ((float)(ulonglong)unkCount * elapsedGame * 0.3) / (dig_diff - -1.0) +
									(float)pEntryOff414[2];
					pEntryOff414[2] = (uint)fVar1;
					if (dig_z2 <= fVar1) {
						pEntryOff414[2] = (uint)dig_z2;
						pEntryOff414[4] = flags & 0xfffffffd | 4;
					}
				}
				else {
					pEntryOff414[4] = flags & 0xfffffffb;
					fVar1 = (float)pEntryOff414[2] - elapsedGame * 0.05;
					pEntryOff414[2] = (uint)fVar1;
					if ((ushort)((ushort)(fVar1 < dig_z2) << 8 | (ushort)(fVar1 == dig_z2) << 0xe) != 0) {
						pEntryOff414[2] = (uint)dig_z2;
						pEntryOff414[4] = flags & 0xfffffffb | 2;
					}
				}
						// rgb(  0, 76,204) + alpha change  "deep blue, desaturated"
				res::Container_SetColourAlpha((Container *)pEntryOff414[3],0.0,0.3,0.8,0.6 - dig_diff * 0.4)
				;
				groupID = D3DRMGROUP_0;
				if (pEntryOff414[-0x3d] != 0) {
					do {
						res::Container_Mesh_GetVertices((Container *)pEntryOff414[3],groupID,0,4,vertices);
						pVertPosZ = &vertices[0].position.z;
						k = 4;
						do {
							*pVertPosZ = (float)pEntryOff414[2];
							pVertPosZ = pVertPosZ + 9;
							k += -1;
						} while (k != 0);
						res::Container_Mesh_SetVertices((Container *)pEntryOff414[3],groupID,0,4,vertices);
						groupID += 1;
					} while (groupID < pEntryOff414[-0x3d]);
				}
			}
			i += 1;
			pEntryOff414 = pEntryOff414 + 0x10a;
		} while (i < globs::waterGlobs.entryCount);
	}
	Water_UpdateMap3DBlocks(level);
	return;
}



void __cdecl lego::game::Water_UpdateMap3DBlocks(LevelData *level)
{
	uint uVar1;
	uint uVar2;
	uint *puVar3;
	uint *puVar4;
	longlong lVar5;
	Vector3F *pVVar6;
	uint by;
	uint bx;
	uint i;
	uint j;
	Point2F worldPos;
	Point2I VERT_OFFSETS [4];
	Vector3F DIRECTIONS3 [4];
	Vector3F vertPoses [4];
	
	VERT_OFFSETS[0].y = 1;
	VERT_OFFSETS[1].x = 1;
	DIRECTIONS3[0].x = 0.0;
	VERT_OFFSETS[1].y = 2;
	VERT_OFFSETS[2].x = 2;
	DIRECTIONS3[0].y = 1.0;
	VERT_OFFSETS[2].y = 3;
	VERT_OFFSETS[3].x = 3;
	DIRECTIONS3[0].z = 0.0;
	DIRECTIONS3[1].x = 1.0;
	DIRECTIONS3[1].y = 0.0;
	DIRECTIONS3[1].z = 0.0;
	DIRECTIONS3[2].x = 0.0;
	DIRECTIONS3[2].y = -1.0;
	DIRECTIONS3[2].z = 0.0;
	DIRECTIONS3[3].x = -1.0;
	DIRECTIONS3[3].y = 0.0;
	DIRECTIONS3[3].z = 0.0;
	VERT_OFFSETS[0].x = 0;
	VERT_OFFSETS[3].y = 0;
	i = 0;
	if (globs::waterGlobs.entryCount != 0) {
		puVar3 = &globs::waterGlobs.entryTable[0].groupCount;
		do {
			j = 0;
			if (*puVar3 != 0) {
				puVar4 = puVar3 + -0x3b;
				do {
					uVar1 = puVar4[-1];
					pVVar6 = vertPoses;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x104]);
					uVar2 = (uint)lVar5;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x105]);
					Map3D_GetBlockVertexPositions2(level->surfaceMap,(uint)lVar5,uVar2,pVVar6);
					uVar1 = *puVar4;
					worldPos.x = (vertPoses[VERT_OFFSETS[uVar1].y].x + vertPoses[VERT_OFFSETS[uVar1].x].x) *
											 0.5 + DIRECTIONS3[uVar1].x * (float)puVar4[2];
					worldPos.y = DIRECTIONS3[uVar1].y * (float)puVar4[2] +
											 (vertPoses[VERT_OFFSETS[uVar1].x].y + vertPoses[VERT_OFFSETS[uVar1].y].y) *
											 0.5;
					Map3D_WorldToBlockPos_NoZ(level->surfaceMap,worldPos.x,worldPos.y,(int *)&bx,(int *)&by);
					Level_Block_SetFlags1_200_AndUpdateSurface_LevelStruct428(level,bx,by,TRUE);
					uVar1 = puVar4[-1];
					pVVar6 = vertPoses;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x104]);
					uVar2 = (uint)lVar5;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x105]);
					Map3D_GetBlockVertexPositions2(level->surfaceMap,(uint)lVar5,uVar2,pVVar6);
					uVar1 = *puVar4;
					worldPos.x = (vertPoses[VERT_OFFSETS[uVar1].y].x + vertPoses[VERT_OFFSETS[uVar1].x].x) *
											 0.5 + DIRECTIONS3[uVar1].x * (float)puVar4[3];
					worldPos.y = DIRECTIONS3[uVar1].y * (float)puVar4[3] +
											 (vertPoses[VERT_OFFSETS[uVar1].x].y + vertPoses[VERT_OFFSETS[uVar1].y].y) *
											 0.5;
					Map3D_WorldToBlockPos_NoZ(level->surfaceMap,worldPos.x,worldPos.y,(int *)&bx,(int *)&by);
					Level_Block_SetFlags1_200_AndUpdateSurface_LevelStruct428(level,bx,by,FALSE);
					j += 1;
					puVar4 = puVar4 + 6;
				} while (j < *puVar3);
			}
			i += 1;
			puVar3 = puVar3 + 0x10a;
		} while (i < globs::waterGlobs.entryCount);
	}
	return;
}



WaterEntry * __cdecl
lego::game::Water_Block_SubDestroyWall_AndDebug_WKey(uint bx,uint by,uint *out_pointIndex)
{
	uint j;
	WaterEntryGroup *pWVar1;
	WaterEntryGroup *pGroup;
	float10 extraout_ST0;
	longlong lVar2;
	uint i;
	Point2F DIRECTIONS [4];
	
	DIRECTIONS[0].x = 0.0;
	DIRECTIONS[0].y = -1.0;
	DIRECTIONS[1].x = 1.0;
	DIRECTIONS[1].y = 0.0;
	DIRECTIONS[2].x = 0.0;
	DIRECTIONS[2].y = 1.0;
	DIRECTIONS[3].x = -1.0;
	DIRECTIONS[3].y = 0.0;
	i = 0;
	if (globs::waterGlobs.entryCount == 0) {
		return NULL;
	}
						// pVar1 ~= &globs::levelstruct428Globs.structTable[i];
	pWVar1 = globs::waterGlobs.entryTable[0].groups;
	do {
						// pItem = &globs::levelstruct428Globs.structTable[i].items[0];
		j = 0;
		pGroup = pWVar1;
						// if (globs::levelstruct428Globs.structTable[i].count != 0)
		if (pWVar1[10].index != 0) {
			do {
						// if ((bx == (uint)__ftol(structTable[i].points[j].x +
						// DIRECTIONS_F[structTable[i].items[j]->direction].x) && 
						//     (by == (uint)__ftol(structTable[i].points[j].y +
						// DIRECTIONS_F[structTable[i].items[j]->direction].y))
				lVar2 = __ftol((float10)((WaterEntry *)&pWVar1[-0x22].elapsedUp_c)->points[pGroup->index].x
											 + (float10)DIRECTIONS[pGroup->direction].x);
				if ((bx == (uint)lVar2) && (lVar2 = __ftol(extraout_ST0), by == (uint)lVar2)) {
					if (out_pointIndex != NULL) {
						// This may also be a count up to the matching point
						*out_pointIndex = j;
					}
						// return &globs::levelstruct428Globs.structTable[i];
					return (WaterEntry *)&pWVar1[-0x22].elapsedUp_c;
				}
				j += 1;
				pGroup = pGroup + 1;
						// while (j < globs::levelstruct428Globs.structTable[i].count);
			} while (j < pWVar1[10].index);
		}
		i += 1;
						// pVar1 ~= &globs::levelstruct428Globs.structTable[++i];
		pWVar1 = (WaterEntryGroup *)&pWVar1[0x2c].float_maxDirZ_8;
		if (globs::waterGlobs.entryCount <= i) {
			return NULL;
		}
	} while( true );
}



// Qsort comparison for ordering by pointsCount, from highest to lowest.

int __cdecl lego::game::Water_QsortCompare(WaterEntry *a,WaterEntry *b)
{
	if (b->pointCount < a->pointCount) {
		return 0xffffffff;
	}
	return (uint)(a->pointCount < b->pointCount);
}



// At this point I don't believe these x and y values are really
//  just coordinates. They don't seem to be used like that, and the
//  only reason they're labaled as such is due to creation from the
//  map dimensions 2D loop.

WaterEntry * __cdecl lego::game::Water_InitSearchAddPairs(int y,uint xAlign,uint xMax)
{
	Water_Globs *pWVar1;
	Water_Globs *pWVar2;
	uint uVar3;
	Water_Globs *pWVar4;
	Water_Globs *pWVar5;
	uint uVar6;
	
	pWVar4 = NULL;
	if ((y != 0) && (xAlign < xMax)) {
		do {
			uVar3 = 0;
			if (globs::waterGlobs.entryCount != 0) {
				pWVar1 = &globs::waterGlobs;
				do {
					uVar6 = 0;
					if (*(uint *)pWVar1->entryTable != 0) {
						pWVar2 = pWVar1;
						pWVar5 = pWVar4;
						do {
							pWVar4 = pWVar5;
							if (((((float)(ulonglong)xAlign == pWVar2->entryTable[0].points[0].x) &&
									 ((float)(ulonglong)(y - 1) == pWVar2->entryTable[0].points[0].y)) &&
									(pWVar4 = pWVar1, pWVar5 != NULL)) && (pWVar4 = pWVar5, pWVar5 != pWVar1)) {
								globs::waterGlobs.pairTable[globs::waterGlobs.pairCount].first = pWVar5->entryTable;
								globs::waterGlobs.pairTable[globs::waterGlobs.pairCount].second = pWVar1->entryTable
								;
								globs::waterGlobs.pairCount += 1;
							}
							uVar6 += 1;
							pWVar2 = (Water_Globs *)(pWVar2->entryTable[0].points + 1);
							pWVar5 = pWVar4;
						} while (uVar6 < *(uint *)pWVar1->entryTable);
					}
					uVar3 += 1;
					pWVar1 = (Water_Globs *)(pWVar1->entryTable + 1);
				} while (uVar3 < globs::waterGlobs.entryCount);
			}
			xAlign += 1;
		} while (xAlign < xMax);
	}
	return pWVar4->entryTable;
}



void __cdecl lego::game::Water_InitAddPoint(WaterEntry *entry,uint y,uint xAlign,uint xMax)
{
	if (xAlign < xMax) {
		do {
			entry->points[entry->pointCount].x = (float)(ulonglong)xAlign;
			entry->points[entry->pointCount].y = (float)(ulonglong)y;
			xAlign += 1;
			entry->pointCount = entry->pointCount + 1;
		} while (xAlign < xMax);
	}
	return;
}



void __cdecl lego::game::Water_InitAddPointFirst(uint y,uint xAlign,uint xMax)
{
	WaterEntry *entry;
	
	entry = globs::waterGlobs.entryTable + globs::waterGlobs.entryCount;
	globs::waterGlobs.entryTable[globs::waterGlobs.entryCount].pointCount = 0;
	Water_InitAddPoint(entry,y,xAlign,xMax);
	globs::waterGlobs.entryCount = globs::waterGlobs.entryCount + 1;
	return;
}



BOOL __cdecl lego::tools::Weapon_Initialise(CFGProperty *root,char *rootPath)
{
	char cVar1;
	CFGProperty *prop;
	char *pcVar2;
	CFGProperty *pCVar3;
	int iVar4;
	BOOL BVar5;
	void *pvVar6;
	uint uVar7;
	int iVar8;
	uint uVar9;
	int iVar10;
	char **ppcVar11;
	int iVar12;
	undefined4 *puVar13;
	uint uVar14;
	undefined4 *puVar15;
	float10 fVar16;
	ObjectType local_d8;
	uint local_d4;
	CFGProperty *local_d0;
	int local_cc;
	int local_c8;
	int local_c4;
	char *local_c0 [16];
	char local_80 [128];
	
	uVar14 = 0;
	globs::weaponGlobs.cfgRoot = root;
	globs::weaponGlobs.weaponCount = 0;
	pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",0);
	pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
	if (pCVar3 != NULL) {
		do {
			globs::weaponGlobs.weaponCount += 1;
			pCVar3 = cfg::CFG_NextFlat(pCVar3);
		} while (pCVar3 != NULL);
		globs::weaponGlobs.weaponStatsList =
				 (WeaponStats *)std::malloc(globs::weaponGlobs.weaponCount * 0x4b68);
		if (globs::weaponGlobs.weaponStatsList != NULL) {
			if (globs::weaponGlobs.weaponCount != 0) {
				iVar12 = 0;
				iVar10 = 0;
				do {
					local_d8 = OBJECT_NONE;
					do {
						local_d4 = 0;
						do {
							uVar9 = 0;
							do {
								uVar7 = uVar9 + 1;
								(globs::weaponGlobs.weaponStatsList)->ObjectRatios[local_d8][local_d4]
								[uVar9 + iVar10] = -1.0;
								uVar9 = uVar7;
							} while (uVar7 < 0x10);
							local_d4 += 1;
						} while (local_d4 < 0xf);
						local_d8 += OBJECT_VEHICLE;
					} while (local_d8 < 0x14);
					*(undefined4 *)
					 ((int)(globs::weaponGlobs.weaponStatsList)->WallDestroyTimes + iVar12 + -0x20) = 0;
					*(undefined4 *)
					 ((int)(globs::weaponGlobs.weaponStatsList)->WallDestroyTimes + iVar12 + -0x14) = 0;
					*(undefined4 *)
					 ((int)(globs::weaponGlobs.weaponStatsList)->WallDestroyTimes + iVar12 + -0x10) = 0;
					iVar8 = 0x12;
						// 150.0
					*(undefined4 *)((int)(globs::weaponGlobs.weaponStatsList)->WallDestroyTimes + iVar12 + -4)
							 = 0x43160000;
					iVar4 = iVar12 + 0x4b20;
					do {
						iVar8 += -1;
						// 5.0
						*(undefined4 *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar4) =
								 1084227584;
						iVar4 = iVar4 + 4;
					} while (iVar8 != 0);
					uVar14 += 1;
					iVar10 += 0x12da;
					iVar12 += 0x4b68;
				} while (uVar14 < globs::weaponGlobs.weaponCount);
			}
			globs::weaponGlobs.weaponNameList = (char **)std::malloc(globs::weaponGlobs.weaponCount * 4);
			if (globs::weaponGlobs.weaponNameList != NULL) {
				pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",0);
				local_d0 = cfg::CFG_GetChildren(root,pcVar2);
				if (local_d0 != NULL) {
					iVar10 = 0x4b04;
					local_c8 = 0;
					local_cc = 0;
					local_c4 = 0x4b04;
LAB_0046f010:
					prop = local_d0;
					pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",local_d0->key,0);
					pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
joined_r0x0046f044:
					do {
						if (pCVar3 == NULL) goto LAB_0046f2cb;
						iVar12 = std::_stricmp(pCVar3->key,"SlowDeath");
						if (iVar12 == 0) {
							util::Util_Tokenise(pCVar3->value,local_c0,":");
							*(undefined4 *)
							 ((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios[-1][0xe] + iVar10 + 0x3c) =
									 1;
							fVar16 = std::atof(local_c0[0]);
							*(float *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10) =
									 (float)fVar16;
							fVar16 = std::atof(local_c0[1]);
							*(float *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 4) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"RechargeTime");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 8) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"DefaultDamage");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 0xc) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"DischargeRate");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 0x10) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"WeaponRange");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 0x18) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = 0;
						ppcVar11 = globs::legoGlobs.SurfaceTypes_TABLE;
						do {
							std::sprintf(local_80,"WallDestroyTime_%s",*ppcVar11 + 0x11);
							iVar4 = std::_stricmp(pCVar3->key,local_80);
							if (iVar4 == 0) {
								fVar16 = std::atof(pCVar3->value);
								(globs::weaponGlobs.weaponStatsList)->WallDestroyTimes[iVar12 + local_cc] =
										 (float)fVar16;
								pCVar3 = cfg::CFG_NextFlat(pCVar3);
								break;
							}
							ppcVar11 = ppcVar11 + 1;
							iVar12 += 1;
						} while (ppcVar11 < globs::legoGlobs.SurfaceTypeDescriptions_name_TABLE);
						prop = local_d0;
						if (iVar12 == 0x12) {
							iVar12 = std::_stricmp(pCVar3->key,"Ammo");
							if (iVar12 == 0) {
								iVar12 = std::atoi(pCVar3->value);
								*(int *)((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 0x14) =
										 iVar12;
							}
							else {
								*(undefined4 *)
								 ((int)(globs::weaponGlobs.weaponStatsList)->ObjectRatios + iVar10 + 0x14) = 0;
								BVar5 = game::Object_GetObjectByName(pCVar3->key,&local_d8,(int *)&local_d4,NULL);
								prop = local_d0;
								if (BVar5 == 0) goto joined_r0x0046f044;
								uVar14 = stats::Stats_GetLevels(local_d8,local_d4);
								util::Util_Tokenise(pCVar3->value,local_c0,":");
								if (uVar14 != 0) {
									ppcVar11 = local_c0;
									uVar9 = 0;
									do {
										fVar16 = std::atof(*ppcVar11);
										ppcVar11 = ppcVar11 + 1;
										uVar7 = uVar9 + 1;
										(globs::weaponGlobs.weaponStatsList)->ObjectRatios[local_d8][local_d4]
										[uVar9 + local_cc] = (float)fVar16;
										iVar10 = local_c4;
										uVar9 = uVar7;
									} while (uVar7 < uVar14);
								}
							}
LAB_0046f2b4:
							pCVar3 = cfg::CFG_NextFlat(pCVar3);
							prop = local_d0;
						}
					} while( true );
				}
LAB_0046f345:
				if (local_d0 == NULL) {
					return 1;
				}
				std::free(globs::weaponGlobs.weaponNameList);
			}
			std::free(globs::weaponGlobs.weaponStatsList);
		}
	}
	return 0;
LAB_0046f2cb:
	uVar14 = 0xffffffff;
	pcVar2 = prop->key;
	do {
		if (uVar14 == 0) break;
		uVar14 -= 1;
		cVar1 = *pcVar2;
		pcVar2 = pcVar2 + 1;
	} while (cVar1 != '\0');
	pvVar6 = std::malloc(~uVar14);
	iVar10 += 0x4b68;
	*(void **)((int)globs::weaponGlobs.weaponNameList + local_c8) = pvVar6;
	uVar14 = 0xffffffff;
	puVar13 = (undefined4 *)prop->key;
	do {
		if (uVar14 == 0) break;
		uVar14 -= 1;
		cVar1 = *(char *)puVar13;
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	} while (cVar1 != '\0');
	puVar13 = (undefined4 *)prop->key;
	puVar15 = *(undefined4 **)((int)globs::weaponGlobs.weaponNameList + local_c8);
	for (uVar9 = ~uVar14 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar15 = *puVar13;
		puVar13 = puVar13 + 1;
		puVar15 = puVar15 + 1;
	}
	local_cc += 0x12da;
	for (uVar14 = ~uVar14 & 3; uVar14 != 0; uVar14 -= 1) {
		*(undefined *)puVar15 = *(undefined *)puVar13;
		puVar13 = (undefined4 *)((int)puVar13 + 1);
		puVar15 = (undefined4 *)((int)puVar15 + 1);
	}
	local_c8 = local_c8 + 4;
	local_c4 = iVar10;
	local_d0 = cfg::CFG_NextFlat(prop);
	if (local_d0 == NULL) goto LAB_0046f345;
	goto LAB_0046f010;
}



// On failure, returns g_WeaponTypes_COUNT

uint __cdecl lego::tools::Weapon_GetWeaponTypeByName(char *weaponName)
{
	int cmp;
	uint uVar1;
	
	uVar1 = 0;
	if (globs::weaponGlobs.weaponCount == 0) {
		return 1;
	}
	do {
		cmp = std::_stricmp(globs::weaponGlobs.weaponNameList[uVar1],weaponName);
		if (cmp == 0) {
			return uVar1;
		}
		uVar1 += 1;
	} while (uVar1 < globs::weaponGlobs.weaponCount);
	return globs::weaponGlobs.weaponCount + 1;
}



float10 __cdecl lego::tools::Weapon_GetRechargeTime(int weaponType)
{
	return (float10)globs::weaponGlobs.weaponStatsList[weaponType].RechargeTime;
}



float10 __cdecl lego::tools::Weapon_GetDischargeRate(int weaponType)
{
	return (float10)globs::weaponGlobs.weaponStatsList[weaponType].DischargeRate;
}



float10 __cdecl lego::tools::Weapon_GetWeaponRange(int weaponType)
{
	return (float10)globs::weaponGlobs.weaponStatsList[weaponType].WeaponRange;
}



float10 __cdecl lego::tools::Weapon_GetWallDestroyTime(int weaponType,SurfaceType surfaceType)
{
	return (float10)globs::weaponGlobs.weaponStatsList[weaponType].WallDestroyTimes[surfaceType];
}



float10 __cdecl lego::tools::Weapon_GetDamageForLiveObject(int weaponType,LiveObject *liveObj)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (globs::weaponGlobs.weaponStatsList[weaponType].ObjectRatios
			[OVar1 * 3 + liveObj->objIndex + OVar1 * 0xc][liveObj->objLevel] == -1.0) {
		return (float10)globs::weaponGlobs.weaponStatsList[weaponType].DefaultDamage;
	}
	return (float10)globs::weaponGlobs.weaponStatsList[weaponType].ObjectRatios[OVar1]
									[liveObj->objIndex][liveObj->objLevel];
}



void __cdecl
lego::tools::Weapon_LiveObject_FUN_0046f530
					(LiveObject *liveObj,int weaponType,BOOL param_3,float param_4,Point2F *param_5)
{
	float fVar1;
	BOOL BVar2;
	float10 fVar3;
	
	fVar3 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
	fVar1 = (float)fVar3;
	if ((liveObj->flags3 & LIVEOBJ3_UNK_40000) != LIVEOBJ3_NONE) {
		BVar2 = game::LiveObject_CheckCondition_AndIsPowered(liveObj,TRUE);
		if (BVar2 != 0) {
			if (globs::weaponGlobs.weaponStatsList[weaponType].isSlowDeath != 0) {
				if (param_3 != 0) {
					game::LiveObject_AddDamage2
										(liveObj,globs::weaponGlobs.weaponStatsList[weaponType].SlowDeath_initial *
														 fVar1,TRUE,param_4);
					fVar1 = globs::weaponGlobs.weaponStatsList[weaponType].SlowDeath_duration;
					liveObj->field_35c = weaponType;
					liveObj->field_358 = fVar1;
					game::LiveObject_FUN_00447c10(liveObj,param_5,TRUE);
					return;
				}
				game::LiveObject_AddDamage2(liveObj,fVar1 * param_4,TRUE,param_4);
				return;
			}
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				reward::Rewards_RockMonsterAttacked();
			}
			game::LiveObject_AddDamage2(liveObj,fVar1,TRUE,param_4);
			if (param_3 != 0) {
				game::LiveObject_FUN_00447c10(liveObj,param_5,TRUE);
			}
		}
	}
	return;
}



void __cdecl
lego::tools::Weapon_LiveObject_FUN_0046f640(LiveObject *liveObj,float param_2,int param_3)
{
	game::LiveObject_AddDamage2(liveObj,param_2,1,1.0);
	game::LiveObject_FUN_00447c10(liveObj,NULL,param_3);
	return;
}



void __cdecl lego::tools::Weapon_Struct2B0_FUN_0046f670(Struct_2b0 *param_1)
{
	float10 fVar1;
	float10 fVar2;
	float10 fVar3;
	float10 fVar4;
	Vector3F local_30;
	Vector3F local_24;
	SearchData18_2 local_18;
	
	if (param_1->object_2a4 != NULL) {
		local_18.field_14 = param_1->field_2a0;
		local_18.vectorp_c = &local_24;
		local_18.field_0 = NULL;
		local_18.ref_float_4 = 1.0;
		local_18.field_10 = 0;
		local_18.vectorp_8 = &param_1->position_280;
		fVar1 = Weapon_GetWeaponRange(param_1->weaponType);
		if (fVar1 != (float10)0.0) {
			fVar2 = (float10)(param_1->vector_268).x - (float10)(param_1->vector_274).x;
			fVar3 = (float10)(param_1->vector_268).y - (float10)(param_1->vector_274).y;
			fVar4 = (float10)(param_1->vector_268).z - (float10)(param_1->vector_274).z;
			local_30.y = (float)fVar3;
			local_30.z = (float)fVar4;
			if (fVar1 <= SQRT(fVar4 * (float10)local_30.z + fVar3 * (float10)local_30.y + fVar2 * fVar2))
			{
				game::LiveObject_Remove(param_1->object_2a4);
				param_1->object_2a4 = NULL;
				return;
			}
		}
		local_24.x = (param_1->vector_274).x - (param_1->position_280).x;
		local_24.y = (param_1->vector_274).y - (param_1->position_280).y;
		local_24.z = (param_1->vector_274).z - (param_1->position_280).z;
		game::Search_LiveObjects_SkipIgnoreMes(game::LiveObject_Callback_FUN_00471630,&local_18);
		FUN_004718f0(&local_18);
		if (local_18.field_10 != 0) {
			game::LiveObject_Remove(param_1->object_2a4);
			param_1->object_2a4 = NULL;
			if (local_18.field_0 != NULL) {
				local_30.x = (local_18.vectorp_c)->x * local_18.ref_float_4 + (local_18.vectorp_8)->x;
				local_30.y = (local_18.vectorp_8)->y + (local_18.vectorp_c)->y * local_18.ref_float_4;
				local_30.z = (local_18.vectorp_8)->z + (local_18.vectorp_c)->z * local_18.ref_float_4;
				Weapon_LiveObject_FUN_0046fa30
									(local_18.field_0,(int **)&param_1->vector_290,&local_30,
									 (int *)param_1->weaponType,param_1->field_2ac);
			}
		}
	}
	return;
}



void __cdecl lego::tools::Weapon_Struct2B0_Update_Table_FUN_0046f810(float elapsedGame)
{
	Struct_2b0 *pSVar1;
	
	pSVar1 = globs::weaponGlobs.Struct2B0Unk_TABLE;
	do {
		if (pSVar1->object_2a4 != NULL) {
			Weapon_Struct2B0_FUN_0046fbe0(pSVar1,elapsedGame);
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < (Struct_2b0 *)&globs::weaponGlobs.cfgRoot);
	game::Search_LiveObjects_SkipIgnoreMes(Weapon_LiveObject_Callback_FUN_0046f8d0,&elapsedGame);
	pSVar1 = globs::weaponGlobs.Struct2B0Unk_TABLE;
	do {
		Weapon_Struct2B0_FUN_0046f670(pSVar1);
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < (Struct_2b0 *)&globs::weaponGlobs.cfgRoot);
	pSVar1 = (Struct_2b0 *)globs::weaponGlobs.ItemStruct34Unk_TABLE;
	do {
		if ((Mesh *)pSVar1->unseen_0 != NULL) {
			if ((pSVar1->routing).points[0].y < 0.0) {
				res::Mesh_Remove((Mesh *)pSVar1->unseen_0,
												 *(IDirect3DRMFrame3 **)((int)(pSVar1->routing).points[0].x + 4));
				res::Mesh_Remove((Mesh *)(pSVar1->routing).count,
												 *(IDirect3DRMFrame3 **)((int)(pSVar1->routing).points[0].x + 4));
				pSVar1->unseen_0 = NULL;
			}
			(pSVar1->routing).points[0].y = (pSVar1->routing).points[0].y - elapsedGame;
		}
		pSVar1 = (Struct_2b0 *)((pSVar1->routing).points + 1);
	} while (pSVar1 < globs::weaponGlobs.Struct2B0Unk_TABLE);
	return;
}



BOOL __cdecl
lego::tools::Weapon_LiveObject_Callback_FUN_0046f8d0(LiveObject *liveObj,float *lpElapsed)
{
	float fVar1;
	void *pvVar2;
	Container *cont;
	uint uVar3;
	float10 fVar4;
	float10 fVar5;
	Container *opt_ref;
	uint uVar6;
	Vector3F *out_pos;
	Vector3F local_c;
	
	if ((ushort)((ushort)((float)liveObj->field_360 < 0.0) << 8 |
							(ushort)((float)liveObj->field_360 == 0.0) << 0xe) == 0) {
		liveObj->field_360 = (float)liveObj->field_360 - *lpElapsed;
	}
	pvVar2 = game::LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	if (pvVar2 != NULL) {
		uVar3 = 0;
		pvVar2 = game::LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar2 + 0xa4) != 0) {
			do {
				fVar4 = game::LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
				if ((ushort)((ushort)(fVar4 < (float10)0.0) << 8 | (ushort)(fVar4 == (float10)0.0) << 0xe)
						== 0) {
					uVar6 = uVar3;
					fVar5 = game::LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
					game::LiveObject_PtrSetter_FUN_004715d0
										(liveObj,(float)(fVar5 - (float10)*lpElapsed),uVar6);
					fVar5 = snd::SFX_Sample_Random_GetSamplePlayTime(SFX_LAZERRECHARGE);
					fVar1 = (float)(fVar5 * (float10)25.0 * (float10)globs::legoGlobs.gameSpeed);
					fVar5 = game::LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
					if ((fVar5 < (float10)fVar1) &&
						 ((ushort)((ushort)((float)fVar4 < fVar1) << 8 | (ushort)((float)fVar4 == fVar1) << 0xe)
							== 0)) {
						out_pos = &local_c;
						opt_ref = NULL;
						cont = game::LiveObject_GetContainer(liveObj);
						res::Container_GetPosition(cont,opt_ref,out_pos);
						res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
											(NULL,SFX_LAZERRECHARGE,0,0,&local_c);
					}
				}
				uVar3 += 1;
				pvVar2 = game::LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while (uVar3 < *(uint *)((int)pvVar2 + 0xa4));
		}
	}
	if ((ushort)((ushort)((float)liveObj->field_358 < 0.0) << 8 |
							(ushort)((float)liveObj->field_358 == 0.0) << 0xe) == 0) {
		Weapon_LiveObject_FUN_0046f530(liveObj,liveObj->field_35c,0,*lpElapsed,NULL);
		liveObj->field_358 = (float)liveObj->field_358 - *lpElapsed;
	}
	return 0;
}



void __cdecl
lego::tools::Weapon_LiveObject_FUN_0046fa30
					(LiveObject *liveObj,int **param_2,Vector3F *param_3,int *param_4,int param_5)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	float10 fVar3;
	float10 fVar4;
	Point2F local_8;
	
	local_8.x = (float)*param_2;
	local_8.y = (float)param_2[1];
	BVar1 = game::LiveObject_IsRockMonsterCanGather(liveObj);
	if (BVar1 != 0) {
		effect::Effect_Spawn_BoulderExplode(param_3);
	}
	if (param_5 == 1) {
		OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_CANLASER) != STATS2_NONE) {
			fVar3 = stats::StatsObject_GetLaserDamage(liveObj);
			Weapon_LiveObject_FUN_0046f640(liveObj,(float)fVar3,1);
		}
		if (param_3 != NULL) {
			effect::Effect_Spawn_Particle(MISCOBJECT_LAZERHIT,param_3,NULL);
		}
	}
	else {
		if (param_5 == 2) {
			OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_CANPUSH) != STATS2_NONE) {
				fVar3 = stats::StatsObject_GetPusherDist(liveObj);
				fVar4 = stats::StatsObject_GetPusherDamage(liveObj);
				local_8.x = local_8.x * 1.5;
				local_8.y = local_8.y * 1.5;
				Weapon_LiveObject_FUN_0046f640(liveObj,(float)fVar4,1);
				game::LiveObject_Unk_AndSetVector3B4(liveObj,&local_8,(float)fVar3);
			}
			if (param_3 != NULL) {
				effect::Effect_Spawn_Particle(MISCOBJECT_PUSHERHIT,param_3,NULL);
				return;
			}
		}
		else {
			if (param_5 != 3) {
				Weapon_LiveObject_FUN_0046f530(liveObj,(int)param_4,1,0.0,&local_8);
				return;
			}
			param_2 = (int **)0x41200000;
			OVar2 = stats::StatsObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_CANFREEZE) != STATS2_NONE) {
				fVar3 = stats::StatsObject_GetObjectFreezerTime(liveObj);
				if ((ushort)((ushort)(fVar3 < (float10)0.0) << 8 | (ushort)(fVar3 == (float10)0.0) << 0xe)
						== 0) {
					param_2 = (int **)(float)fVar3;
				}
				fVar3 = stats::StatsObject_GetFreezerDamage(liveObj);
				Weapon_LiveObject_FUN_0046f640(liveObj,(float)fVar3,0);
				game::LiveObject_FUN_0044c2f0(liveObj,(float)param_2);
			}
			if (param_3 != NULL) {
				effect::Effect_Spawn_Particle(MISCOBJECT_FREEZERHIT,param_3,NULL);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::tools::Weapon_Struct2B0_FUN_0046fbe0(Struct_2b0 *param_1,float elapsed)
{
	float fVar1;
	float dirx;
	Container *cont;
	float fVar2;
	Point2F local_14;
	float local_8;
	
	cont = game::LiveObject_GetContainer(param_1->object_2a4);
	res::Container_GetPosition(cont,NULL,&param_1->position_280);
	fVar2 = param_1->float_28c * elapsed;
	if (param_1->unseen_0 == 0) {
		local_8 = (param_1->vector_290).y * fVar2;
		fVar1 = (param_1->vector_290).z;
		(param_1->vector_274).x = (param_1->vector_290).x * fVar2 + (param_1->vector_274).x;
		(param_1->vector_274).y = (param_1->vector_274).y + local_8;
		(param_1->vector_274).z = (param_1->vector_274).z + fVar1 * fVar2;
		res::Container_SetPosition
							(cont,NULL,(param_1->vector_274).x,(param_1->vector_274).y,(param_1->vector_274).z);
		fVar2 = (param_1->vector_290).z;
		fVar1 = (param_1->vector_290).y;
		dirx = (param_1->vector_290).x;
	}
	else {
		fVar2 = fVar2 + param_1->float_264;
		param_1->float_264 = fVar2;
		game::Routing_Calculate_FUN_004067f0(&param_1->routing,fVar2,&local_14);
		fVar2 = (param_1->vector_290).y;
		(param_1->vector_274).x = (param_1->vector_290).x * local_14.x + (param_1->vector_268).x;
		(param_1->vector_274).y = (param_1->vector_268).y + fVar2 * local_14.x;
		(param_1->vector_274).z = (param_1->vector_268).z + local_14.y;
		res::Container_SetPosition
							(cont,NULL,(param_1->vector_274).x,(param_1->vector_274).y,(param_1->vector_274).z);
		fVar2 = ((param_1->vector_274).z - (param_1->position_280).z) * 0.25;
		fVar1 = (param_1->vector_274).y - (param_1->position_280).y;
		dirx = (param_1->vector_274).x - (param_1->position_280).x;
	}
	res::Container_SetOrientation(cont,NULL,dirx,fVar1,fVar2,0.0,0.0,-1.0);
	return;
}



BOOL __cdecl
lego::tools::Weapon_Struct2B0_FUN_0046fdb0
					(LiveObject *liveObj,Vector3F *param_2,Vector3F *param_3,uint weaponType,uint param_5)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	uint uVar4;
	uint knownWeapon;
	BOOL BVar5;
	int iVar6;
	LiveObject *pLVar7;
	
	knownWeapon = param_5;
	uVar4 = weaponType;
	pLVar7 = liveObj;
	if (param_5 == 1) {
		game::LiveObject_Weapon_FUN_004375c0(liveObj,weaponType,1.0);
	}
	Weapon_GetObjectTypeIndex_ByKnownWeaponType(knownWeapon,&weaponType,(int *)&param_5);
	BVar5 = game::Object_GetTypeResource(weaponType,param_5,(Container **)&liveObj);
	if (BVar5 != 0) {
		iVar6 = Weapon_Struct2B0_Table_FUN_00504bc0();
		if (iVar6 != -1) {
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].unseen_0 = 0;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].weaponType = uVar4;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].field_2ac = knownWeapon;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_274.x = param_2->x;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_274.y = param_2->y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_274.z = param_2->z;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_268.x = param_2->x;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_268.y = param_2->y;
			fVar3 = param_2->z;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].float_28c = 5.0;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_268.z = fVar3;
			pVVar1 = &globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290;
			pVVar1->x = param_3->x;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.y = param_3->y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.z = param_3->z;
			fVar3 = globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.y;
			fVar2 = globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.z;
			fVar3 = 1.0 / SQRT(pVVar1->x * pVVar1->x + fVar2 * fVar2 + fVar3 * fVar3);
			pVVar1->x = pVVar1->x * fVar3;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.y =
					 fVar3 * globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.z =
					 fVar3 * globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].vector_290.z;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].field_2a0 = pLVar7;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].field_29c = 0;
			pLVar7 = game::LiveObject_CreateInWorld
												 (liveObj,weaponType,param_5,0,param_2->x,param_2->y,0.0);
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar6].object_2a4 = pLVar7;
			Weapon_Struct2B0_FUN_0046fbe0(globs::weaponGlobs.Struct2B0Unk_TABLE + iVar6,0.0);
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::tools::Weapon_UpdateRoutingUnk_FUN_0046ff30
					(undefined4 param_1,Vector3F *param_2,Vector3F *param_3,int param_4,
					WeaponKnownType knownWeapon)
{
	RoutingData *route;
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	int iVar5;
	LiveObject *pLVar6;
	float10 fVar7;
	int objIndex;
	ObjectType objType;
	Container *local_24;
	Point2F local_20;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	local_8.x = 0.0;
	local_8.y = 0.0;
	local_18.x = 1.0;
	local_18.y = -1.3;
	local_20.x = 0.3;
	local_20.y = 1.0;
	Weapon_GetObjectTypeIndex_ByKnownWeaponType(knownWeapon,&objType,&objIndex);
	BVar4 = game::Object_GetTypeResource(objType,objIndex,&local_24);
	if (BVar4 != 0) {
		iVar5 = Weapon_Struct2B0_Table_FUN_00504bc0();
		if (iVar5 != -1) {
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].field_2ac = knownWeapon;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].weaponType = param_4;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].unseen_0 = 1;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_268.x = param_2->x;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_268.y = param_2->y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_268.z = param_2->z;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_274.x = param_2->x;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_274.y = param_2->y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_274.z = param_2->z;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.x = param_3->x - param_2->x;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.y = param_3->y - param_2->y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.z = param_3->z - param_2->z;
			fVar1 = globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.y;
			fVar2 = globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.z;
			fVar3 = globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.x;
			fVar2 = 1.0 / SQRT(fVar3 * fVar3 + fVar2 * fVar2 + fVar1 * fVar1);
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.x =
					 globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.x * fVar2;
			fVar1 = globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.z;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.y =
					 fVar2 * globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.y;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].vector_290.z = fVar2 * fVar1;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].float_28c = 4.0;
			fVar3 = param_2->y - param_3->y;
			fVar1 = param_2->z - param_3->z;
			fVar2 = param_2->x - param_3->x;
			local_10.y = param_3->z - param_2->z;
			fVar1 = SQRT(fVar2 * fVar2 + fVar1 * fVar1 + fVar3 * fVar3);
			local_10.x = fVar1;
			math::Routing_Maths_Vector2DChangeLength(&local_18,fVar1 * 0.2);
			math::Routing_Maths_Vector2DChangeLength(&local_20,fVar1 * 0.3333333);
			route = &globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].routing;
			game::Routing_DoMath_FUN_00406750(route,&local_8,&local_18,&local_10,&local_20,50);
			fVar7 = game::Routing_UpdateDistances_RetTotal(route);
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].unseen_260 = (float)fVar7;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].float_264 = 0.0;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].field_2a0 = param_1;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].field_29c = 0;
			pLVar6 = game::LiveObject_CreateInWorld(local_24,objType,objIndex,0,param_2->x,param_2->y,0.0)
			;
			globs::weaponGlobs.Struct2B0Unk_TABLE[iVar5].object_2a4 = pLVar6;
			Weapon_Struct2B0_FUN_0046fbe0(globs::weaponGlobs.Struct2B0Unk_TABLE + iVar5,0.0);
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::tools::Weapon_GetObjectTypeIndex_ByKnownWeaponType
					(WeaponKnownType knownWeapon,ObjectType *out_objType,int *out_objIndex)
{
	switch(knownWeapon) {
	case WEAPONKNOWN_LAZER_1:
		*out_objType = OBJECT_LASERSHOT;
		*out_objIndex = 0;
		return;
	case WEAPONKNOWN_PUSHER:
		*out_objType = OBJECT_PUSHER;
		*out_objIndex = 0;
		return;
	case WEAPONKNOWN_FREEZER:
		*out_objType = OBJECT_FREEZER;
		*out_objIndex = 0;
		return;
	case WEAPONKNOWN_LAZER_4:
		*out_objType = OBJECT_BOULDER;
		*out_objIndex = 0;
	}
	return;
}



int __cdecl lego::tools::Weapon_Struct2B0_Table_FUN_00504bc0(void)
{
	int iVar1;
	LiveObject **ppLVar2;
	
	iVar1 = 0;
	ppLVar2 = &globs::weaponGlobs.Struct2B0Unk_TABLE[0].object_2a4;
	do {
		if (*ppLVar2 == NULL) {
			return iVar1;
		}
		ppLVar2 = ppLVar2 + 0xac;
		iVar1 += 1;
	} while (ppLVar2 < globs::s_FormatPartName_name + 0x2a0);
	return -1;
}



int __cdecl lego::tools::Weapon_ItemStruct34_GetTableCount(void)
{
	int iVar1;
	Struct_2b0 *pSVar2;
	
	iVar1 = 0;
	pSVar2 = (Struct_2b0 *)globs::weaponGlobs.ItemStruct34Unk_TABLE;
	do {
		if ((Mesh *)pSVar2->unseen_0 == NULL) {
			return iVar1;
		}
		pSVar2 = (Struct_2b0 *)((pSVar2->routing).points + 1);
		iVar1 += 1;
	} while (pSVar2 < globs::weaponGlobs.Struct2B0Unk_TABLE);
	return -1;
}



LiveObject * __cdecl
lego::tools::Weapon_DoLaserUnk_FUN_00470270
					(Vector3F *sndPosition,Vector3F *param_2,LiveObject *in_liveObj,float param_4,
					float param_5,int weaponType,float param_7)
{
	TerrainType TVar1;
	Vector3F *pVVar2;
	LiveObject *liveObj;
	int weaponType_00;
	Container *resData;
	SurfaceMap *surfMap;
	BOOL BVar3;
	LevelData *level;
	float10 fVar4;
	float fVar5;
	float fVar6;
	LiveObject *opt_position;
	Point2F *pPVar7;
	Vector3F *vector2;
	float *out_by;
	float local_24;
	Point2F local_20;
	Vector3F local_18;
	Vector3F local_c;
	
	opt_position = (LiveObject *)sndPosition;
	local_24 = 1.0;
	sndPosition = NULL;
	res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
						(NULL,SFX_LASER,FALSE,FALSE,(Vector3F *)opt_position);
	liveObj = in_liveObj;
	pVVar2 = param_2;
	local_18.x = param_5 * param_2->x;
	local_18.y = param_5 * param_2->y;
	local_18.z = param_2->z * param_5;
	game::Game_DoCallbacksSearch_FUN_00471b20
						((Vector3F *)opt_position,&local_18,(LiveObject **)&sndPosition,&local_24,in_liveObj);
	local_18.x = local_24 * local_18.x;
	local_18.y = local_24 * local_18.y;
	local_18.z = local_24 * local_18.z;
	local_c.x = local_18.x + ((Vector3F *)opt_position)->x;
	local_c.y = ((Vector3F *)opt_position)->y + local_18.y;
	local_c.z = (float)((Vector3F *)opt_position)->z + local_18.z;
	vector2 = &local_c;
	resData = game::LiveObject_GetContainer(liveObj);
	Weapon_ItemStruct34_FUN_00470950(resData,(Vector3F *)opt_position,vector2);
	weaponType_00 = weaponType;
	if (((LiveObject *)sndPosition != NULL) || (1.0 <= local_24)) {
		if ((LiveObject *)sndPosition != NULL) {
			effect::Effect_Spawn_Particle(MISCOBJECT_LAZERHIT,&local_c,NULL);
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_LASERHIT,0,0,&local_c);
			if ((LiveObject *)sndPosition != NULL) {
				if ((liveObj == NULL) || (liveObj->objType != OBJECT_MINIFIGURE)) {
					pPVar7 = NULL;
				}
				else {
					local_20.x = pVVar2->x;
					local_20.y = pVVar2->y;
					pPVar7 = &local_20;
				}
				game::LiveObject_FUN_00447c10((LiveObject *)sndPosition,pPVar7,1);
			}
		}
	}
	else {
		effect::Effect_Spawn_BoulderExplode(&local_c);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_LASERHIT,FALSE,FALSE,&local_c);
		out_by = &local_20.y;
		pPVar7 = &local_20;
		fVar5 = local_c.x;
		fVar6 = local_c.y;
		surfMap = lrr::Lego_GetMap();
		game::Map3D_WorldToBlockPos_NoZ(surfMap,fVar5,fVar6,(int *)pPVar7,(int *)out_by);
		BVar3 = game::Level_Block_IsWall((uint)local_20.x,(uint)local_20.y);
		if (BVar3 != 0) {
			BVar3 = game::Level_Block_IsImmovable((Point2I *)&local_20);
			if ((BVar3 == 0) &&
				 (TVar1 = (globs::legoGlobs.level)->blocks
									[((globs::legoGlobs.level)->dimensions).width * (int)local_20.y + (int)local_20.x]
									.terrain, TVar1 != TERRAIN_RECHARGESEAM)) {
				fVar4 = Weapon_GetWallDestroyTime(weaponType_00,(uint)TVar1);
				param_5 = (float)fVar4;
				BVar3 = game::Level_Block_GetUnkField14Test
													((uint)local_20.x,(uint)local_20.y,param_5,param_4);
				if (BVar3 != 0) {
					BVar3 = 0;
					fVar5 = local_20.x;
					fVar6 = local_20.y;
					level = lrr::Lego_GetLevel();
					game::Level_DestroyWall(level,(uint)fVar5,(uint)fVar6,BVar3);
				}
				goto LAB_004704fa;
			}
		}
		BVar3 = game::Level_Block_IsPath((Point2I *)&local_20);
		if (BVar3 != 0) {
			ai::AITask_DoClearTypeAction((Point2I *)&local_20,MESSAGE_CLEARREMOVEPATH_COMPLETE);
			game::Level_BlockUpdateSurface(globs::legoGlobs.level,(int)local_20.x,(int)local_20.y,0);
		}
	}
LAB_004704fa:
	game::LiveObject_Weapon_FUN_004375c0(liveObj,weaponType_00,param_7);
	return (LiveObject *)sndPosition;
}



BOOL __cdecl
lego::game::LiveObject_Collision_FUN_00470520
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3,BOOL param_4)
{
	ObjectStatsFlags1 OVar1;
	BOOL BVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLBOX) != STATS1_NONE) {
		BVar2 = LiveObject_CollisionBox_FUN_00470570(liveObj,param_2,param_3,NULL,param_4);
		return BVar2;
	}
	BVar2 = LiveObject_CollisionRadius_FUN_00470800(liveObj,param_2,param_3,param_4);
	return BVar2;
}



BOOL __cdecl
lego::game::LiveObject_CollisionBox_FUN_00470570
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3,Point2F *optout_point,BOOL param_5)
{
	float fVar1;
	ushort uVar2;
	Container *cont;
	BOOL BVar3;
	float *pfVar4;
	int iVar5;
	Point2F *pPVar6;
	Vector3F *out_vector;
	Point2F *pPVar7;
	uint uVar8;
	Point2F local_78;
	Point2F local_70;
	Point2F local_68;
	Point2F local_60;
	Point2F local_58;
	float local_50 [6];
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	undefined4 local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	cont = LiveObject_GetContainer(liveObj);
	local_68.x = param_2->x;
	local_68.y = param_2->y;
	local_70.x = param_3->x;
	local_70.y = param_3->y;
	if ((param_5 != 0) &&
		 (BVar3 = LiveObject_TestCollision_FUN_004708f0(liveObj,&local_68,&local_70), BVar3 != 0)) {
		return 0;
	}
	pfVar4 = (float *)stats::StatsObject_GetCollBox(liveObj);
	local_30.x = *pfVar4 * -0.5;
	iVar5 = stats::StatsObject_GetCollBox(liveObj);
	local_30.z = *(float *)(iVar5 + 4) * 0.5;
	pfVar4 = (float *)stats::StatsObject_GetCollBox(liveObj);
	local_24 = *pfVar4 * 0.5;
	iVar5 = stats::StatsObject_GetCollBox(liveObj);
	local_1c = *(float *)(iVar5 + 4) * 0.5;
	pfVar4 = (float *)stats::StatsObject_GetCollBox(liveObj);
	local_18 = *pfVar4 * 0.5;
	iVar5 = stats::StatsObject_GetCollBox(liveObj);
	local_10 = *(float *)(iVar5 + 4) * -0.5;
	pfVar4 = (float *)stats::StatsObject_GetCollBox(liveObj);
	local_c = *pfVar4 * -0.5;
	iVar5 = stats::StatsObject_GetCollBox(liveObj);
	local_4 = *(float *)(iVar5 + 4) * -0.5;
	local_8 = 0;
	local_14 = 0;
	local_20 = 0;
	local_30.y = 0.0;
	pPVar7 = &local_58;
	out_vector = &local_30;
	iVar5 = 4;
	do {
		res::Container_Transform(cont,out_vector,out_vector);
		fVar1 = out_vector->y;
		pPVar7->x = out_vector->x;
		pPVar7->y = fVar1;
		out_vector = out_vector + 1;
		pPVar7 = pPVar7 + 1;
		iVar5 += -1;
	} while (iVar5 != 0);
	local_38 = local_58.x;
	local_34 = local_58.y;
	uVar8 = 0;
	pPVar7 = &local_58;
	do {
		local_60.x = pPVar7->x - pPVar7[1].x;
		local_60.y = pPVar7->y - pPVar7[1].y;
		pPVar6 = math::Maths_Vector2DIntersection(&local_78,&local_68,&local_70,pPVar7,&local_60);
		if (pPVar6 != NULL) {
			if (ABS(pPVar7->x - pPVar7[1].x) <= ABS(pPVar7->y - pPVar7[1].y)) {
				if (((ushort)((ushort)(local_78.y < pPVar7->y) << 8 |
										 (ushort)(local_78.y == pPVar7->y) << 0xe) == 0) && (local_78.y < pPVar7[1].y))
				goto LAB_004707ca;
				if (local_78.y < pPVar7->y) {
					uVar2 = (ushort)(local_78.y < pPVar7[1].y) << 8 |
									(ushort)(local_78.y == pPVar7[1].y) << 0xe;
					goto joined_r0x004707b1;
				}
			}
			else {
				if (((ushort)((ushort)(local_78.x < pPVar7->x) << 8 |
										 (ushort)(local_78.x == pPVar7->x) << 0xe) == 0) && (local_78.x < pPVar7[1].x))
				goto LAB_004707ca;
				if (local_78.x < pPVar7->x) {
					uVar2 = (ushort)(local_78.x < pPVar7[1].x) << 8 |
									(ushort)(local_78.x == pPVar7[1].x) << 0xe;
joined_r0x004707b1:
					if (uVar2 == 0) {
LAB_004707ca:
						if (optout_point != NULL) {
							optout_point->x = local_78.x;
							optout_point->y = local_78.y;
						}
						return TRUE;
					}
				}
			}
		}
		uVar8 += 1;
		pPVar7 = pPVar7 + 1;
		if (3 < uVar8) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl
lego::game::LiveObject_CollisionRadius_FUN_00470800
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3,BOOL param_4)
{
	BOOL BVar1;
	float10 fVar2;
	Point2F local_28;
	Point2F local_20;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	local_28.x = param_2->x;
	local_28.y = param_2->y;
	local_20.x = param_3->x;
	local_20.y = param_3->y;
	if ((param_4 != 0) &&
		 (BVar1 = LiveObject_TestCollision_FUN_004708f0(liveObj,&local_28,&local_20), BVar1 != 0)) {
		return 0;
	}
	local_10.x = local_20.x + local_28.x;
	local_10.y = local_20.y + local_28.y;
	LiveObject_GetPosition(liveObj,&local_18.x,&local_18.y);
	math::Collision_Maths_FUN_00408a90(&local_28,&local_10,&local_18,&local_8);
	fVar2 = stats::StatsObject_GetCollRadius(liveObj);
	if (fVar2 <= (float10)SQRT((local_8.y - local_18.y) * (local_8.y - local_18.y) +
														 (local_8.x - local_18.x) * (local_8.x - local_18.x))) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_TestCollision_FUN_004708f0
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3)
{
	Point2F position;
	
	LiveObject_GetPosition(liveObj,&position.x,&position.y);
	if ((position.x - param_2->x) * param_3->x + (position.y - param_2->y) * param_3->y < 0.0) {
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::tools::Weapon_ItemStruct34_FUN_00470950
					(Container *resData,Vector3F *vector1,Vector3F *vector2)
{
	int iVar1;
	Mesh *pMVar2;
	
	iVar1 = Weapon_ItemStruct34_GetTableCount();
	if (iVar1 != -1) {
		pMVar2 = res::Mesh_CreateOnFrame(resData->activityFrame,NULL,0x4400,NULL,MESH_TYPE_NORM);
		globs::weaponGlobs.ItemStruct34Unk_TABLE[iVar1].struct34_1 = pMVar2;
		pMVar2 = res::Mesh_CreateOnFrame(resData->activityFrame,NULL,0x4400,NULL,MESH_TYPE_NORM);
		globs::weaponGlobs.ItemStruct34Unk_TABLE[iVar1].struct34_2 = pMVar2;
		res::Struct34_FUN_00470a20
							(globs::weaponGlobs.ItemStruct34Unk_TABLE[iVar1].struct34_1,0.3,vector1,vector2,0.6,
							 0.6,0.6,1.0);
		res::Struct34_FUN_00470a20
							(globs::weaponGlobs.ItemStruct34Unk_TABLE[iVar1].struct34_2,1.0,vector1,vector2,0.1,
							 0.2,0.5,1.0);
		globs::weaponGlobs.ItemStruct34Unk_TABLE[iVar1].resData = resData;
		globs::weaponGlobs.ItemStruct34Unk_TABLE[iVar1].time = 5.0;
	}
	return;
}



void __cdecl
lego::res::Struct34_FUN_00470a20
					(Mesh *param_1,float scalar,Vector3F *vector1,Vector3F *vector2,float param_5,
					float param_6,float param_7,float param_8)
{
	float *pfVar1;
	float *pfVar2;
	float *pfVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float fVar12;
	float fVar13;
	Vector3F *pVVar14;
	D3DRMGroupIndex groupID;
	uint uVar15;
	uint uVar16;
	float local_404;
	float local_400;
	uint local_3e0;
	undefined4 local_3dc;
	undefined4 local_3d8;
	undefined4 local_3d4;
	undefined4 local_3d0;
	undefined4 local_3cc;
	undefined4 local_3c8;
	undefined4 local_3c4;
	undefined4 local_3c0;
	undefined4 local_3bc;
	undefined4 local_3b8;
	undefined4 local_3b4;
	undefined4 local_3b0;
	undefined4 local_3ac;
	undefined4 local_3a8;
	undefined4 local_3a4;
	undefined4 local_3a0;
	undefined4 local_39c;
	undefined4 local_398;
	undefined4 local_394;
	undefined4 local_390;
	undefined4 local_38c;
	undefined4 local_388;
	undefined4 local_384;
	undefined4 local_380;
	undefined4 local_37c;
	undefined4 local_378;
	undefined4 local_374;
	undefined4 local_370;
	undefined4 local_36c;
	undefined4 local_368;
	undefined4 local_364;
	undefined4 local_360;
	undefined4 local_35c;
	undefined4 local_358;
	undefined4 local_354;
	undefined4 local_350;
	undefined4 local_34c;
	undefined4 local_348;
	undefined4 local_344;
	undefined4 local_340;
	undefined4 local_33c;
	undefined4 local_338;
	undefined4 local_334;
	undefined4 local_330;
	undefined4 local_32c;
	undefined4 local_328;
	undefined4 local_324;
	Point2F local_320;
	undefined4 local_318;
	undefined4 local_314;
	undefined4 local_310;
	undefined4 local_30c;
	undefined4 local_308;
	undefined4 local_304;
	undefined4 local_300;
	undefined4 local_2fc;
	undefined4 local_2f8;
	undefined4 local_2f4;
	undefined4 local_2f0;
	undefined4 local_2ec;
	undefined4 local_2e8;
	undefined4 local_2e4;
	undefined4 local_2e0;
	undefined4 local_2dc;
	undefined4 local_2d8;
	undefined4 local_2d4;
	undefined4 local_2d0;
	undefined4 local_2cc;
	undefined4 local_2c8;
	undefined4 local_2c4;
	undefined4 local_2c0;
	undefined4 local_2bc;
	undefined4 local_2b8;
	undefined4 local_2b4;
	undefined4 local_2b0;
	undefined4 local_2ac;
	undefined4 local_2a8;
	undefined4 local_2a4;
	undefined4 local_2a0;
	undefined4 local_29c;
	undefined4 local_298;
	undefined4 local_294;
	undefined4 local_290;
	undefined4 local_28c;
	undefined4 local_288;
	undefined4 local_284;
	undefined4 local_280;
	undefined4 local_27c;
	undefined4 local_278;
	undefined4 local_274;
	undefined4 local_270;
	undefined4 local_26c;
	undefined4 local_268;
	undefined4 local_264;
	undefined4 local_260;
	undefined4 local_25c;
	undefined4 local_258;
	undefined4 local_254;
	undefined4 local_250;
	undefined4 local_24c;
	undefined4 local_248;
	undefined4 local_244;
	undefined4 local_240;
	undefined4 local_23c;
	undefined4 local_238;
	undefined4 local_234;
	undefined4 local_230;
	undefined4 local_22c;
	undefined4 local_228;
	undefined4 local_224;
	undefined4 local_220;
	undefined4 local_21c;
	undefined4 local_218;
	undefined4 local_214;
	undefined4 local_210;
	undefined4 local_20c;
	undefined4 local_208;
	undefined4 local_204;
	undefined4 local_200;
	undefined4 local_1fc;
	undefined4 local_1f8;
	undefined4 local_1f4;
	undefined4 local_1f0;
	undefined4 local_1ec;
	undefined4 local_1e8;
	undefined4 local_1e4;
	undefined4 local_1e0;
	undefined4 local_1dc;
	undefined4 local_1d8;
	undefined4 local_1d4;
	undefined4 local_1d0;
	undefined4 local_1cc;
	undefined4 local_1c8;
	undefined4 local_1c4;
	undefined4 local_1c0;
	undefined4 local_1bc;
	undefined4 local_1b8;
	undefined4 local_1b4;
	undefined4 local_1b0;
	undefined4 local_1ac;
	undefined4 local_1a8;
	undefined4 local_1a4;
	undefined4 local_1a0;
	undefined4 local_19c;
	undefined4 local_198;
	undefined4 local_194;
	undefined4 local_190;
	undefined4 local_18c;
	undefined4 local_188;
	undefined4 local_184;
	undefined4 local_180;
	undefined4 local_17c;
	undefined4 local_178;
	undefined4 local_174;
	undefined4 local_170;
	undefined4 local_16c;
	undefined4 local_168;
	undefined4 local_164;
	undefined4 local_160;
	undefined4 local_15c;
	undefined4 local_158;
	undefined4 local_154;
	undefined4 local_150;
	undefined4 local_14c;
	undefined4 local_148;
	undefined4 local_144;
	undefined4 local_140;
	undefined4 local_13c;
	undefined4 local_138;
	undefined4 local_134;
	undefined4 local_130;
	undefined4 local_12c;
	undefined4 local_128;
	undefined4 local_124;
	Vector3F local_120;
	float local_114;
	float local_110;
	float local_10c;
	float local_108;
	float local_104;
	float local_100;
	float local_fc;
	float local_f8;
	float local_f4;
	float local_f0;
	float local_ec;
	float local_e8;
	float local_e4;
	float local_e0;
	float local_dc;
	float local_d8;
	float local_d4;
	float local_d0;
	float local_cc;
	float local_c8;
	float local_c4;
	float afStack192 [24];
	Vector3F local_60 [8];
	
	local_320.y = 1.0;
	local_310 = 0x3f800000;
	local_308 = 0x3f800000;
	local_304 = 0x3f800000;
	local_2fc = 0x3f800000;
	local_2f0 = 0x3f800000;
	local_2e8 = 0x3f800000;
	local_2e4 = 0x3f800000;
	local_2dc = 0x3f800000;
	local_2d0 = 0x3f800000;
	local_2c8 = 0x3f800000;
	local_2c4 = 0x3f800000;
	local_2bc = 0x3f800000;
	local_2b0 = 0x3f800000;
	local_2a8 = 0x3f800000;
	local_2a4 = 0x3f800000;
	local_29c = 0x3f800000;
	local_290 = 0x3f800000;
	local_288 = 0x3f800000;
	local_284 = 0x3f800000;
	local_27c = 0x3f800000;
	local_270 = 0x3f800000;
	local_268 = 0x3f800000;
	local_264 = 0x3f800000;
	local_25c = 0x3f800000;
	local_250 = 0x3f800000;
	local_248 = 0x3f800000;
	local_244 = 0x3f800000;
	local_23c = 0x3f800000;
	local_230 = 0x3f800000;
	local_228 = 0x3f800000;
	local_224 = 0x3f800000;
	local_21c = 0x3f800000;
	local_210 = 0x3f800000;
	local_208 = 0x3f800000;
	local_204 = 0x3f800000;
	local_1fc = 0x3f800000;
	local_320.x = 0.0;
	local_318 = 0;
	local_314 = 0;
	local_30c = 0;
	local_300 = 0;
	local_2f8 = 0;
	local_2f4 = 0;
	local_2ec = 0;
	local_2e0 = 0;
	local_2d8 = 0;
	local_2d4 = 0;
	local_2cc = 0;
	local_2c0 = 0;
	local_2b8 = 0;
	local_2b4 = 0;
	local_2ac = 0;
	local_2a0 = 0;
	local_298 = 0;
	local_294 = 0;
	local_28c = 0;
	local_280 = 0;
	local_278 = 0;
	local_274 = 0;
	local_26c = 0;
	local_260 = 0;
	local_258 = 0;
	local_254 = 0;
	local_24c = 0;
	local_240 = 0;
	local_238 = 0;
	local_234 = 0;
	local_22c = 0;
	local_220 = 0;
	local_218 = 0;
	local_214 = 0;
	local_20c = 0;
	local_200 = 0;
	local_1f8 = 0;
	local_1f4 = 0;
	local_1f0 = 0x3f800000;
	local_1e8 = 0x3f800000;
	local_1e4 = 0x3f800000;
	local_1dc = 0x3f800000;
	local_1d0 = 0x3f800000;
	local_1c8 = 0x3f800000;
	local_1c4 = 0x3f800000;
	local_1bc = 0x3f800000;
	local_1b0 = 0x3f800000;
	local_1a8 = 0x3f800000;
	local_1a4 = 0x3f800000;
	local_19c = 0x3f800000;
	local_190 = 0x3f800000;
	local_188 = 0x3f800000;
	local_184 = 0x3f800000;
	local_17c = 0x3f800000;
	local_170 = 0x3f800000;
	local_168 = 0x3f800000;
	local_164 = 0x3f800000;
	local_15c = 0x3f800000;
	local_150 = 0x3f800000;
	local_148 = 0x3f800000;
	local_144 = 0x3f800000;
	local_13c = 0x3f800000;
	local_130 = 0x3f800000;
	local_128 = 0x3f800000;
	local_124 = 0x3f800000;
	local_3dc = 1;
	local_3d8 = 9;
	local_3d4 = 9;
	local_3c8 = 1;
	local_3c0 = 10;
	local_3bc = 10;
	local_3b8 = 9;
	local_3b4 = 1;
	local_3a0 = 10;
	local_1ec = 0;
	local_1e0 = 0;
	local_1d8 = 0;
	local_1d4 = 0;
	local_1cc = 0;
	local_1c0 = 0;
	local_1b8 = 0;
	local_1b4 = 0;
	local_1ac = 0;
	local_1a0 = 0;
	local_198 = 0;
	local_194 = 0;
	local_18c = 0;
	local_180 = 0;
	local_178 = 0;
	local_174 = 0;
	local_16c = 0;
	local_160 = 0;
	local_158 = 0;
	local_154 = 0;
	local_14c = 0;
	local_140 = 0;
	local_138 = 0;
	local_134 = 0;
	local_12c = 0;
	local_3e0 = 0;
	local_3d0 = 8;
	local_3cc = 0;
	local_3c4 = 2;
	local_3b0 = 2;
	local_3ac = 3;
	local_3a8 = 0xb;
	local_3a4 = 0xb;
	local_39c = 2;
	local_398 = 3;
	local_394 = 4;
	local_384 = 3;
	local_390 = 0xc;
	local_38c = 0xc;
	local_370 = 0xc;
	local_378 = 0xd;
	local_374 = 0xd;
	local_358 = 0xd;
	local_360 = 0xe;
	local_35c = 0xe;
	local_340 = 0xe;
	local_348 = 0xf;
	local_344 = 0xf;
	local_328 = 0xf;
	local_388 = 0xb;
	fVar6 = vector2->x - vector1->x;
	fVar7 = vector2->y - vector1->y;
	fVar5 = vector2->z - vector1->z;
	local_380 = 4;
	local_36c = 4;
	local_37c = 5;
	local_368 = 5;
	local_364 = 6;
	local_354 = 5;
	local_350 = 6;
	local_34c = 7;
	local_33c = 6;
	local_338 = 7;
	local_334 = 0;
	local_330 = 8;
	local_32c = 8;
	local_324 = 7;
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar7 * fVar7 + fVar6 * fVar6);
	fVar7 = fVar4 * fVar7;
	fVar5 = fVar4 * fVar5;
	if ((fVar7 == 0.0) && (fVar5 == 0.0)) {
		local_400 = 1.0;
		local_404 = 0.0;
	}
	else {
		if (fVar7 == 0.0) {
			local_404 = 1.0;
			local_400 = 0.0;
		}
		else {
			local_400 = SQRT(1.0 / ((fVar5 * fVar5) / (fVar7 * fVar7) - -1.0));
			local_404 = -((fVar5 / fVar7) * local_400);
		}
	}
	fVar8 = local_404 * scalar;
	fVar9 = local_400 * scalar;
	fVar5 = (local_400 * fVar7 - local_404 * fVar5) * scalar;
	fVar7 = -(local_400 * fVar4 * fVar6) * scalar;
	fVar6 = local_404 * fVar4 * fVar6 * scalar;
	fVar12 = fVar8 * 0.4142136;
	fVar4 = fVar5 * 0.4142136;
	fVar10 = fVar7 * 0.4142136;
	fVar11 = fVar6 * 0.4142136;
	fVar13 = fVar9 * 0.4142136;
	local_120.x = fVar4 + 0.0;
	local_120.y = fVar8 + fVar10;
	local_120.z = fVar9 + fVar11;
	local_114 = fVar5 + 0.0;
	local_110 = fVar7 + fVar12;
	local_10c = fVar6 + fVar13;
	local_108 = fVar5 + -0.0;
	local_104 = fVar7 + -fVar12;
	local_100 = fVar6 + -fVar13;
	local_fc = fVar4 - 0.0;
	local_f8 = fVar10 - fVar8;
	local_f4 = fVar11 - fVar9;
	local_f0 = -0.0 - fVar4;
	local_ec = -fVar8 - fVar10;
	local_e8 = -fVar9 - fVar11;
	local_e4 = -0.0 - fVar5;
	local_e0 = -fVar12 - fVar7;
	local_dc = -fVar13 - fVar6;
	local_d8 = 0.0 - fVar5;
	local_d4 = fVar12 - fVar7;
	local_d0 = fVar13 - fVar6;
	local_cc = 0.0 - fVar4;
	local_c8 = fVar8 - fVar10;
	local_c4 = fVar9 - fVar11;
	pVVar14 = &local_120;
	uVar15 = 0;
	do {
		fVar4 = vector2->x;
		pfVar3 = (float *)((int)&local_60[0].z + uVar15);
		fVar5 = pVVar14->x;
		fVar6 = pVVar14->y;
		*(float *)((int)&local_60[0].x + uVar15) = pVVar14->x;
		pfVar1 = &pVVar14->y;
		fVar7 = pVVar14->z;
		uVar16 = uVar15 + 0xc;
		*(float *)((int)&local_60[0].y + uVar15) = fVar6;
		pfVar2 = &pVVar14->z;
		*pfVar3 = fVar7;
		fVar7 = *(float *)((int)&local_60[0].y + uVar15);
		fVar6 = *(float *)((int)&local_60[0].x + uVar15);
		fVar8 = *pfVar3;
		*(float *)((int)afStack192 + uVar15) = fVar4 + fVar5;
		fVar9 = 1.0 / SQRT(fVar6 * fVar6 + fVar8 * fVar8 + fVar7 * fVar7);
		*(float *)((int)afStack192 + uVar15 + 4) = *pfVar1 + vector2->y;
		fVar4 = vector1->x;
		pVVar14[8].z = *pfVar2 + vector2->z;
		fVar5 = *(float *)((int)&local_60[0].x + uVar15);
		pVVar14->x = fVar4 + pVVar14->x;
		fVar4 = *(float *)((int)&local_60[0].y + uVar15);
		fVar6 = *pfVar3;
		*pfVar1 = *pfVar1 + vector1->y;
		fVar7 = *pfVar2;
		fVar8 = vector1->z;
		*(float *)((int)&local_60[0].x + uVar15) = fVar9 * fVar5;
		*(float *)((int)&local_60[0].y + uVar15) = fVar9 * fVar4;
		*pfVar3 = fVar9 * fVar6;
		*pfVar2 = fVar7 + fVar8;
		pVVar14 = pVVar14 + 1;
		uVar15 = uVar16;
	} while (uVar16 < 0x60);
	groupID = Mesh_AddGroup(param_1,0x10,0x10,3,&local_3e0);
	Mesh_SetGroupColour(param_1,groupID,param_5,param_6,param_7,MATERIAL_EMISSIVE);
	Mesh_SetGroupMaterialValues(param_1,groupID,param_8,MATERIAL_ALPHA);
	Mesh_SetVertices_SameNormal(param_1,groupID,0,0x10,&local_120,local_60,&local_320);
	return;
}



void * __cdecl lego::game::LiveObject_GetBuildingVehicleFields_138_a0(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_VEHICLE) {
		return (void *)&liveObj->vehicle->field_0x138;
	}
	if (liveObj->objType != OBJECT_BUILDING) {
		return NULL;
	}
	return (void *)&liveObj->building->field_0xa0;
}



float10 __cdecl lego::game::LiveObject_PtrGetter_FUN_004715b0(LiveObject *liveObj,int param_2)
{
	void *pvVar1;
	
	pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	return (float10)*(float *)((int)pvVar1 + param_2 * 4 + 0x98);
}



void __cdecl
lego::game::LiveObject_PtrSetter_FUN_004715d0(LiveObject *liveObj,undefined4 param_2,int param_3)
{
	void *pvVar1;
	
	pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	*(undefined4 *)((int)pvVar1 + param_3 * 4 + 0x98) = param_2;
	return;
}



BOOL __cdecl
lego::math::MathUnk_CheckVectorsZScalar_InRange
					(Vector3F *vectorPos,Vector3F *vectorScaled,float minZ,float maxZ,float scalar)
{
	float fVar1;
	
	fVar1 = vectorScaled->z * scalar + vectorPos->z;
	if (((ushort)((ushort)(fVar1 < maxZ) << 8 | (ushort)(fVar1 == maxZ) << 0xe) != 0) &&
		 (maxZ - minZ <= fVar1)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_FUN_00471630(LiveObject *liveObj,SearchData18_2 *search)
{
	float fVar1;
	SearchData18_2 *pSVar2;
	SurfaceMap *surfMap;
	BOOL BVar3;
	float10 fVar4;
	float fVar5;
	float maxZ;
	float fVar6;
	float scalar;
	SearchData18_2 *scalar_00;
	Point2F local_28;
	float local_20;
	float local_1c;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	pSVar2 = search;
	local_8.x = search->vectorp_8->x;
	local_8.y = search->vectorp_8->y;
	local_28.x = search->vectorp_c->x;
	local_28.y = search->vectorp_c->y;
	fVar1 = SQRT(local_28.y * local_28.y + local_28.x * local_28.x);
	if ((liveObj != (LiveObject *)search->field_14) &&
		 (((ushort)((ushort)(fVar1 < -1e-05) << 8 | (ushort)(fVar1 == -1e-05) << 0xe) != 0 ||
			(1e-05 <= fVar1)))) {
		LiveObject_GetPosition(liveObj,&local_18.x,&local_18.y);
		fVar5 = local_18.x;
		fVar6 = local_18.y;
		surfMap = lrr::Lego_GetMap();
		fVar4 = Map3D_GetWorldZ(surfMap,fVar5,fVar6);
		fVar5 = (float)fVar4;
		math::Collision_MathUnk_Vector2D_FUN_00408b20(&local_8,&local_28,&local_18,&local_10);
		local_18.x = local_10.x - local_18.x;
		local_18.y = local_10.y - local_18.y;
		fVar4 = stats::StatsObject_GetCollRadius(liveObj);
		if ((float10)SQRT(local_18.y * local_18.y + local_18.x * local_18.x) <= fVar4) {
			local_20 = local_10.x - local_8.x;
			local_1c = local_10.y - local_8.y;
			fVar6 = SQRT(local_1c * local_1c + local_20 * local_20);
			if (((ushort)((ushort)(fVar6 < -1e-05) << 8 | (ushort)(fVar6 == -1e-05) << 0xe) == 0) &&
				 (fVar6 < 1e-05)) {
				scalar = 0.0;
				maxZ = fVar5;
				fVar4 = stats::StatsObject_GetCollHeight(liveObj);
				BVar3 = math::MathUnk_CheckVectorsZScalar_InRange
													(search->vectorp_8,search->vectorp_c,(float)fVar4,maxZ,scalar);
				if (BVar3 != 0) {
					search->field_0 = liveObj;
					search->ref_float_4 = 0.0;
					search->field_10 = 1;
					return 0;
				}
			}
			search = (SearchData18_2 *)(fVar6 / fVar1);
			if (((((ushort)((ushort)(local_28.x < -1e-05) << 8 | (ushort)(local_28.x == -1e-05) << 0xe) !=
						 0) || (1e-05 <= local_28.x)) ||
					((ushort)((ushort)(local_20 < -1e-05) << 8 | (ushort)(local_20 == -1e-05) << 0xe) != 0))
				 || (1e-05 <= local_20)) {
				fVar1 = local_28.x / local_20;
			}
			else {
				if ((((ushort)((ushort)(local_28.y < -1e-05) << 8 | (ushort)(local_28.y == -1e-05) << 0xe)
							== 0) && (local_28.y < 1e-05)) &&
					 (((ushort)((ushort)(local_1c < -1e-05) << 8 | (ushort)(local_1c == -1e-05) << 0xe) == 0
						&& (local_1c < 1e-05)))) {
					return 0;
				}
				fVar1 = local_28.y / local_1c;
			}
			if (fVar1 < 0.0) {
				search = (SearchData18_2 *)((float)search * -1.0);
			}
			if (((ushort)((ushort)((float)search < 0.0) << 8 | (ushort)((float)search == 0.0) << 0xe) == 0
					) && ((float)search < pSVar2->ref_float_4)) {
				scalar_00 = search;
				fVar4 = stats::StatsObject_GetCollHeight(liveObj);
				BVar3 = math::MathUnk_CheckVectorsZScalar_InRange
													(pSVar2->vectorp_8,pSVar2->vectorp_c,(float)fVar4,fVar5,(float)scalar_00);
				if (BVar3 != 0) {
					pSVar2->field_0 = liveObj;
					pSVar2->ref_float_4 = (float)search;
					pSVar2->field_10 = TRUE;
				}
			}
		}
	}
	return 0;
}



void __cdecl FUN_004718f0(SearchData18_2 *search)
{
	SurfaceMap *pSVar1;
	BOOL BVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	float fVar8;
	float fVar9;
	Vector3F *pVVar10;
	uint *puVar11;
	uint *puVar12;
	Vector3F *pVVar13;
	Vector3F *pVVar14;
	uint local_34;
	uint local_30;
	uint local_2c;
	uint local_28;
	float local_24;
	float local_20;
	float local_1c;
	Vector3F local_18;
	float local_8;
	float local_4;
	
	lego::lrr::Lego_GetMap();
	lego::lrr::Lego_GetMap();
	puVar11 = &local_28;
	pVVar14 = search->vectorp_c;
	pVVar13 = search->vectorp_8;
	local_18.x = pVVar14->x + pVVar13->x;
	local_18.y = pVVar13->y + pVVar14->y;
	local_18.z = pVVar13->z + pVVar14->z;
	puVar12 = &local_30;
	fVar9 = pVVar13->y;
	fVar8 = pVVar13->x;
	pSVar1 = lego::lrr::Lego_GetMap();
	BVar2 = lego::game::Map3D_WorldToBlockPos_NoZ(pSVar1,fVar8,fVar9,(int *)puVar11,(int *)puVar12);
	if (BVar2 == 0) {
		pSVar1 = lego::lrr::Lego_GetMap();
		if ((uint)(pSVar1->smallDimensions).width <= local_28) {
			pSVar1 = lego::lrr::Lego_GetMap();
			local_28 = (pSVar1->smallDimensions).width - 1;
		}
		pSVar1 = lego::lrr::Lego_GetMap();
		if ((uint)(pSVar1->smallDimensions).height <= local_30) {
			pSVar1 = lego::lrr::Lego_GetMap();
			local_30 = (pSVar1->smallDimensions).height - 1;
		}
	}
	puVar11 = &local_34;
	puVar12 = &local_2c;
	fVar9 = local_18.x;
	fVar8 = local_18.y;
	pSVar1 = lego::lrr::Lego_GetMap();
	BVar2 = lego::game::Map3D_WorldToBlockPos_NoZ(pSVar1,fVar9,fVar8,(int *)puVar12,(int *)puVar11);
	if (BVar2 == 0) {
		pSVar1 = lego::lrr::Lego_GetMap();
		if ((uint)(pSVar1->smallDimensions).width <= local_2c) {
			pSVar1 = lego::lrr::Lego_GetMap();
			local_2c = (pSVar1->smallDimensions).width - 1;
		}
		pSVar1 = lego::lrr::Lego_GetMap();
		if ((uint)(pSVar1->smallDimensions).height <= local_34) {
			pSVar1 = lego::lrr::Lego_GetMap();
			local_34 = (pSVar1->smallDimensions).height - 1;
		}
	}
	uVar4 = local_2c;
	uVar3 = local_34;
	if (local_2c < local_28) {
		local_2c = local_28;
		local_28 = uVar4;
	}
	if (local_34 < local_30) {
		local_34 = local_30;
		local_30 = uVar3;
	}
	uVar3 = local_34;
	uVar4 = local_2c;
	uVar5 = local_28;
	uVar6 = local_30;
	if (local_28 <= local_2c) {
		do {
			uVar7 = uVar6;
			if (uVar6 <= uVar3) {
				do {
					pVVar13 = search->vectorp_c;
					pVVar10 = search->vectorp_8;
					pVVar14 = &local_18;
					uVar3 = uVar5;
					uVar4 = uVar6;
					pSVar1 = lego::lrr::Lego_GetMap();
					BVar2 = lego::game::Map3D_Intersections_Sub2_FUN_004518a0
														(pSVar1,uVar3,uVar4,pVVar10,pVVar13,pVVar14);
					if (BVar2 != 0) {
						pVVar14 = search->vectorp_8;
						pVVar13 = search->vectorp_c;
						fVar9 = local_18.x - pVVar14->x;
						local_8 = local_18.y - pVVar14->y;
						local_4 = local_18.z - pVVar14->z;
						local_24 = pVVar13->z;
						local_20 = pVVar13->x;
						local_1c = SQRT(local_20 * local_20 + local_24 * local_24 + pVVar13->y * pVVar13->y);
						fVar9 = SQRT(local_4 * local_4 + local_8 * local_8 + fVar9 * fVar9) / local_1c;
						if (fVar9 < search->ref_float_4) {
							search->ref_float_4 = fVar9;
							search->field_10 = 1;
							search->field_0 = 0;
						}
					}
					uVar6 += 1;
					uVar3 = local_34;
					uVar4 = local_2c;
					uVar7 = local_30;
				} while (uVar6 <= local_34);
			}
			uVar5 += 1;
			uVar6 = uVar7;
		} while (uVar5 <= uVar4);
	}
	return;
}



BOOL __cdecl
lego::game::Game_DoCallbacksSearch_FUN_00471b20
					(Vector3F *vecCector,Vector3F *vecDistance,LiveObject **out_liveObj,float *ref_float_4,
					undefined4 param_5)
{
	SearchData18_2 search;
	
	search.field_0 = NULL;
	search.field_10 = 0;
	search.ref_float_4 = *ref_float_4;
	search.vectorp_8 = vecCector;
	search.vectorp_c = vecDistance;
	search.field_14 = param_5;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_00471630,&search);
	FUN_004718f0(&search);
	*ref_float_4 = search.ref_float_4;
	*out_liveObj = search.field_0;
	return search.field_10;
}



BOOL __cdecl
lego::game::LiveObject_DoCallbacksSearch_FUN_00471b90(LiveObject *liveObj1,LiveObject *liveObj2)
{
	BOOL BVar1;
	float local_28;
	Vector3F collCenter1;
	Vector3F collCenter2;
	Vector3F collDiff;
	LiveObject *liveObj1_00;
	LiveObject *liveObj2_00;
	
	liveObj1_00 = liveObj1;
	local_28 = 1.0;
	LiveObject_GetCollCenterPosition(liveObj1,&collCenter1);
	liveObj2_00 = liveObj2;
	LiveObject_GetCollCenterPosition(liveObj2,&collCenter2);
	collDiff.x = collCenter2.x - collCenter1.x;
	collDiff.y = collCenter2.y - collCenter1.y;
	collDiff.z = collCenter2.z - collCenter1.z;
	BVar1 = Game_DoCallbacksSearch_FUN_00471b20
										(&collCenter1,&collDiff,&liveObj1,&local_28,liveObj1_00);
	if ((BVar1 != 0) && (liveObj1 != liveObj2_00)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_SeeThroughWalls_FUN_00471c20(LiveObject *liveObj,LiveObject *liveObj2)
{
	LevelData *pLVar1;
	BoolTri BVar2;
	char *pcVar3;
	undefined4 uVar4;
	Vector3F local_3c;
	Vector3F local_30;
	Vector3F local_24;
	SearchData18_2 local_18;
	
	local_18.vectorp_8 = &local_3c;
	local_18.vectorp_c = &local_24;
	uVar4 = 0;
	pcVar3 = "SeeThroughWalls";
	local_18.field_0 = 0;
	local_18.ref_float_4 = 1.0;
	local_18.field_10 = 0;
	local_18.field_14 = 0;
	pLVar1 = lrr::Lego_GetLevel();
	pcVar3 = cfg::CFG_JoinPath(globs::legoGlobs.gameName,pLVar1->levelName,pcVar3,uVar4);
	BVar2 = cfg::CFG_ReadBool(globs::weaponGlobs.cfgRoot,pcVar3);
	if (BVar2 != BOOL3_FALSE) {
		return 0;
	}
	LiveObject_GetCollCenterPosition(liveObj,&local_3c);
	LiveObject_GetCollCenterPosition(liveObj2,&local_30);
	local_24.x = local_30.x - local_3c.x;
	local_24.y = local_30.y - local_3c.y;
	local_24.z = local_30.z - local_3c.z;
	FUN_004718f0(&local_18);
	return local_18.field_10;
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471ce0(int param_1,int param_2,int param_3)
{
	return *(undefined4 *)(param_1 + param_2 * 8 + param_3 * 4);
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471d00(int param_1,int param_2)
{
	return *(undefined4 *)(param_1 + 0x18 + param_2 * 4);
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471d10(int param_1,int param_2)
{
	return *(undefined4 *)(param_1 + 0x24 + param_2 * 4);
}



void __cdecl
lego::unk::UnkStruct_FUN_00471d20
					(int param_1,undefined4 *param_2,float param_3,int param_4,int param_5)
{
	int iVar1;
	undefined4 *puVar2;
	float fVar3;
	float fVar4;
	Container *cont;
	Container *cont_00;
	Vector3F local_c;
	
	if (param_4 != 0) {
		puVar2 = (undefined4 *)(param_1 + 0x68 + param_5 * 0xc);
		*puVar2 = *param_2;
		puVar2[1] = param_2[1];
		puVar2[2] = param_2[2];
	}
	cont = (Container *)UnkStruct_Getter_FUN_00471d00(param_1,param_5);
	if ((cont != NULL) &&
		 ((ushort)((ushort)(param_3 < 1e-05) << 8 | (ushort)(param_3 == 1e-05) << 0xe) == 0)) {
		res::Container_GetPosition(cont,NULL,&local_c);
		fVar3 = 5.0 / param_3;
		iVar1 = param_1 + param_5 * 0xc;
		local_c.x = *(float *)(iVar1 + 0x68) - local_c.x;
		local_c.y = *(float *)(iVar1 + 0x6c) - local_c.y;
		local_c.z = *(float *)(iVar1 + 0x70) - local_c.z;
		fVar4 = 1.0 / SQRT(local_c.z * local_c.z + local_c.y * local_c.y + local_c.x * local_c.x);
		*(float *)(iVar1 + 0x44) = *(float *)(iVar1 + 0x44) * fVar3;
		*(float *)(iVar1 + 0x48) = *(float *)(iVar1 + 0x48) * fVar3;
		*(float *)(iVar1 + 0x4c) = *(float *)(iVar1 + 0x4c) * fVar3;
		*(float *)(iVar1 + 0x44) = fVar4 * local_c.x + *(float *)(iVar1 + 0x44);
		*(float *)(iVar1 + 0x48) = fVar4 * local_c.y + *(float *)(iVar1 + 0x48);
		*(float *)(iVar1 + 0x4c) = fVar4 * local_c.z + *(float *)(iVar1 + 0x4c);
		fVar3 = 1.0 / SQRT(*(float *)(iVar1 + 0x44) * *(float *)(iVar1 + 0x44) +
											 *(float *)(iVar1 + 0x4c) * *(float *)(iVar1 + 0x4c) +
											 *(float *)(iVar1 + 0x48) * *(float *)(iVar1 + 0x48));
		*(float *)(iVar1 + 0x44) = *(float *)(iVar1 + 0x44) * fVar3;
		*(float *)(iVar1 + 0x48) = fVar3 * *(float *)(iVar1 + 0x48);
		*(float *)(iVar1 + 0x4c) = fVar3 * *(float *)(iVar1 + 0x4c);
		if ((ushort)((ushort)(*(float *)(iVar1 + 0x4c) < *(float *)(param_1 + 0x30)) << 8 |
								(ushort)(*(float *)(iVar1 + 0x4c) == *(float *)(param_1 + 0x30)) << 0xe) == 0) {
			*(undefined4 *)(iVar1 + 0x4c) = *(undefined4 *)(param_1 + 0x30);
		}
		cont_00 = (Container *)UnkStruct_Getter_FUN_00471d10(param_1,param_5);
		if (cont_00 != NULL) {
			res::Container_SetOrientation
								(cont_00,NULL,*(float *)(iVar1 + 0x44),*(float *)(param_1 + (param_5 + 6) * 0xc),0.0
								 ,0.0,0.0,-1.0);
		}
		res::Container_SetOrientation
							(cont,NULL,*(float *)(iVar1 + 0x44),*(float *)(param_1 + (param_5 + 6) * 0xc),
							 *(float *)(iVar1 + 0x4c),0.0,0.0,-1.0);
	}
	return;
}



void __cdecl
lego::unk::UnkStructC_GetTable44_Vector_FUN_00471f30(int param_1,Vector3F *out_vector44,int index)
{
	float *pfVar1;
	
	pfVar1 = (float *)(param_1 + 0x44 + index * 0xc);
	out_vector44->x = *pfVar1;
	out_vector44->y = pfVar1[1];
	out_vector44->z = pfVar1[2];
	return;
}



BOOL __cdecl lego::game::LiveObject_GetCollCenterPosition(LiveObject *liveObj,Vector3F *out_vector)
{
	Container *cont;
	float10 fVar1;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,out_vector);
	fVar1 = stats::StatsObject_GetCollHeight(liveObj);
	out_vector->z = (float)((float10)out_vector->z - fVar1 * (float10)0.5);
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_UnkTracker_FUN_00471fa0(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	
	OVar1 = stats::StatsObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_TRACKER) != STATS2_NONE) {
		BVar2 = LiveObject_CheckCondition_AndIsPowered
											(liveObj,(uint)(liveObj->objType != OBJECT_BUILDING));
		if (BVar2 != 0) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00471fe0(LiveObject *in_liveObj,float param_2,float param_3)
{
	LiveObject *liveObj;
	float fVar1;
	void *pvVar2;
	BOOL BVar3;
	uint uVar4;
	uint mouseX;
	Container *cont;
	LiveObject *pLVar5;
	float10 fVar6;
	Vector3F *pVVar7;
	float fVar8;
	int iVar9;
	float fVar10;
	LiveObject **ref_param_3;
	LiveObject *local_34;
	float local_30;
	Point2F local_2c;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	fVar1 = param_3;
	liveObj = in_liveObj;
	Game_GetVector_45c(&local_18);
	pVVar7 = &local_18;
	iVar9 = 1;
	fVar8 = param_2;
	fVar10 = param_3;
	pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(in_liveObj);
	unk::UnkStruct_FUN_00471d20((int)pvVar2,&pVVar7->x,fVar8,iVar9,(int)fVar10);
	BVar3 = input::mslb();
	if (((BVar3 != 0) && ((globs::legoGlobs.flags2 & GAME2_MOUSE_INSIDEGAMEVIEW) != GAME2_NONE)) &&
		 (fVar6 = LiveObject_PtrGetter_FUN_004715b0(in_liveObj,(int)param_3),
		 (ushort)((ushort)(fVar6 < (float10)0.0) << 8 | (ushort)(fVar6 == (float10)0.0) << 0xe) != 0)) {
		ref_param_3 = &local_34;
		uVar4 = input::msy();
		mouseX = input::msx();
		iVar9 = LiveManager_DoPickSphereCallbacks_MouseXY(mouseX,uVar4,ref_param_3);
		if ((iVar9 == 0) || (local_34 != in_liveObj)) {
			in_liveObj = NULL;
			do {
				iVar9 = Level_GetCrystalCount(1);
				if (iVar9 != 0) {
					fVar8 = fVar1;
					pLVar5 = in_liveObj;
					pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
					cont = (Container *)unk::UnkStruct_Getter_FUN_00471ce0((int)pvVar2,(int)fVar8,(int)pLVar5)
					;
					if (cont == NULL) {
						return 1;
					}
					pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
					uVar4 = tools::Weapon_GetWeaponTypeByName
														(*(char **)(*(int *)((int)pvVar2 + (int)fVar1 * 4 + 0x8c) + 0xc));
					fVar6 = tools::Weapon_GetWeaponRange(uVar4);
					local_30 = (float)fVar6;
					fVar6 = stats::StatsObject_GetFunctionCoef(liveObj);
					param_3 = (float)fVar6;
					if (fVar6 == (float10)0.0) {
						param_3 = 1.0;
					}
					if (in_liveObj == NULL) {
						fVar8 = fVar1;
						fVar6 = tools::Weapon_GetRechargeTime(uVar4);
						LiveObject_PtrSetter_FUN_004715d0(liveObj,(float)fVar6,(int)fVar8);
						pVVar7 = &local_24;
						fVar8 = fVar1;
						pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
						unk::UnkStructC_GetTable44_Vector_FUN_00471f30((int)pvVar2,pVVar7,(int)fVar8);
						Game_SetPointer_AndPlayEnumSFX(0);
					}
					res::Container_GetPosition(cont,NULL,&local_c);
					pLVar5 = tools::Weapon_DoLaserUnk_FUN_00470270
														 (&local_c,&local_24,liveObj,param_2,local_30,uVar4,param_3);
					if (pLVar5 != NULL) {
						local_2c.x = local_24.x;
						local_2c.y = local_24.y;
						tools::Weapon_LiveObject_FUN_0046f530(pLVar5,uVar4,1,0.0,&local_2c);
						liveObj->object_3c4 = pLVar5;
					}
				}
				in_liveObj = (LiveObject *)((int)&in_liveObj->objType + 1);
			} while (in_liveObj < (LiveObject *)0x2);
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_FUN_004721c0(LiveObject *liveObj,float param_2,int param_3)
{
	Container *cont;
	void *pvVar1;
	float *pfVar2;
	int iVar3;
	Vector3F local_30;
	Vector3F local_24;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	cont = LiveObject_GetContainer(liveObj);
	if (cont != NULL) {
		res::Container_GetOrientation(cont,NULL,&local_30,&local_c);
		res::Container_GetPosition(cont,NULL,&local_24);
		local_30.x = local_30.x * 10000.0;
		pfVar2 = &local_18;
		local_30.y = local_30.y * 10000.0;
		iVar3 = 1;
		local_30.z = local_30.z * 10000.0;
		local_18 = local_30.x + local_24.x;
		local_14 = local_30.y + local_24.y;
		local_10 = local_30.z + local_24.z;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		unk::UnkStruct_FUN_00471d20((int)pvVar1,pfVar2,param_2,iVar3,param_3);
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00472280(LiveObject *liveObj,float param_2)
{
	void *pvVar1;
	float fVar2;
	uint uVar3;
	
	if ((*(byte *)&liveObj->flags4 & 1) == 0) {
		uVar3 = 0;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar1 + 0xa4) != 0) {
			do {
				LiveObject_FUN_004721c0(liveObj,param_2,uVar3);
				uVar3 += 1;
				pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while (uVar3 < *(uint *)((int)pvVar1 + 0xa4));
		}
	}
	else {
		fVar2 = 0.0;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar1 + 0xa4) != 0) {
			do {
				LiveObject_FUN_00471fe0(liveObj,param_2,fVar2);
				fVar2 = (float)((int)fVar2 + 1);
				pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while ((uint)fVar2 < (uint)*(float *)((int)pvVar1 + 0xa4));
			return TRUE;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_SetField_3c4(LiveObject *liveObj,int field3c4)
{
	if (liveObj->object_3c4 == (LiveObject *)field3c4) {
		liveObj->object_3c4 = NULL;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00472340(LiveObject *liveObj,undefined4 *param_2)
{
	uint weaponType;
	float10 fVar1;
	Vector3F local_18;
	Vector3F local_c;
	
	weaponType = LiveObject_GetEquippedBeam(liveObj);
	if (((liveObj != NULL) && (param_2 != NULL)) && (weaponType != 0)) {
		fVar1 = tools::Weapon_GetWeaponRange(weaponType);
		LiveObject_GetCollCenterPosition(liveObj,&local_c);
		LiveObject_GetCollCenterPosition((LiveObject *)param_2,&local_18);
		if (SQRT((local_18.z - local_c.z) * (local_18.z - local_c.z) +
						 (local_18.y - local_c.y) * (local_18.y - local_c.y) +
						 (local_18.x - local_c.x) * (local_18.x - local_c.x)) < (float)fVar1) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004723f0(LiveObject *liveObj,undefined4 *param_2)
{
	uint uVar1;
	float10 fVar2;
	Vector3F local_18;
	Vector3F local_c;
	
	uVar1 = LiveObject_GetEquippedBeam(liveObj);
	if (((liveObj != NULL) && (param_2 != NULL)) && (uVar1 != 0)) {
		fVar2 = stats::StatsObject_GetAwarenessRange(liveObj);
		LiveObject_GetCollCenterPosition(liveObj,&local_c);
		LiveObject_GetCollCenterPosition((LiveObject *)param_2,&local_18);
		if (SQRT((local_18.z - local_c.z) * (local_18.z - local_c.z) +
						 (local_18.y - local_c.y) * (local_18.y - local_c.y) +
						 (local_18.x - local_c.x) * (local_18.x - local_c.x)) < (float)fVar2) {
			return 1;
		}
	}
	return 0;
}



bool __thiscall
lego::video::G98CMovie__InitSample(G98CMovie *this,IAMMultiMediaStream *lpAMMMStream)
{
	IMediaStream **ppIVar1;
	IAMMultiMediaStreamVtbl *pIVar2;
	IDirectDrawMediaStream *This;
	IDirectDrawStreamSample *This_00;
	IDirectDrawSurface *This_01;
	HRESULT HVar3;
	
	pIVar2 = lpAMMMStream->lpVtbl;
	ppIVar1 = &this->m_sampleBaseStream;
	HVar3 = (*pIVar2->GetMediaStream)(lpAMMMStream,&idl::MSPID_PrimaryVideo,ppIVar1);
	this->m_err = HVar3;
	if (-1 < HVar3) {
		HVar3 = (*(*ppIVar1)->lpVtbl->QueryInterface)
											(*ppIVar1,&idl::IID_IDirectDrawMediaStream,&this->m_sampleStream);
		this->m_err = HVar3;
		if (-1 < HVar3) {
			This = this->m_sampleStream;
						// IDirectDrawMediaStream->CreateSample(this, IDirectDrawSurface* pSurface, const RECT*
						// pRect, DWORD dwFlags, IDirectDrawStreamSample** ppSample)
			HVar3 = (*(code *)This->lpVtbl->CreateSample)(This,NULL,NULL,0,&this->m_sample);
			this->m_err = HVar3;
			if (-1 < HVar3) {
				This_00 = this->m_sample;
						// IDirectDrawStreamSample->GetSurface(this, IDirectDrawSurface** ppDirectDrawSurface,
						// RECT* pRect)
				HVar3 = (*(code *)This_00->lpVtbl->GetSurface)(This_00,&this->m_baseSurf,&this->m_movieRect)
				;
				this->m_err = HVar3;
				if (-1 < HVar3) {
					This_01 = this->m_baseSurf;
					HVar3 = (*This_01->lpVtbl->QueryInterface)
														(This_01,&idl::IID_IDirectDrawSurface3,(IUnknown **)&this->m_surf);
					this->m_err = HVar3;
					if (-1 < HVar3) {
						// STREAMSTATE_RUN (0x1)
						HVar3 = (*pIVar2->SetState)(lpAMMMStream,STREAMSTATE_RUN);
						this->m_err = HVar3;
						if (-1 < HVar3) {
							return true;
						}
					}
				}
			}
		}
	}
	(*(*ppIVar1)->lpVtbl->Release)(*ppIVar1);
	(*this->m_sampleStream->lpVtbl->Release)(this->m_sampleStream);
	(*this->m_sample->lpVtbl->Release)(this->m_sample);
	(*this->m_baseSurf->lpVtbl->Release)(this->m_baseSurf);
	return -1 < this->m_err;
}



bool __thiscall
lego::video::G98CMovie__OpenAMStream
					(G98CMovie *this,char *fName,IAMMultiMediaStream **lplpAMMMStream,IDirectDraw2 *ddraw2)
{
	IAMMultiMediaStreamVtbl *pIVar1;
	HRESULT HVar2;
	IAMMultiMediaStream *amMMStream;
	WCHAR wfilenameBuffer [260];
	
						// CLSCTX_INPROC_SERVER (0x1)
	HVar2 = CoCreateInstance((IID *)&idl::CLSID_AMMultiMediaStream,NULL,1,
													 (IID *)&idl::IID_IAMMultiMediaStream,&amMMStream);
	if (-1 < HVar2) {
						//  STREAMTYPE_READ (0x0)
		HVar2 = (*amMMStream->lpVtbl->Initialize)(amMMStream,STREAMTYPE_READ,0,NULL);
		if (-1 < HVar2) {
			HVar2 = (*amMMStream->lpVtbl->AddMediaStream)
												(amMMStream,(IUnknown *)ddraw2,&idl::MSPID_PrimaryVideo,0,NULL);
			if (-1 < HVar2) {
						// AMMSF_ADDDEFAULTRENDERER (0x1)
				HVar2 = (*amMMStream->lpVtbl->AddMediaStream)
													(amMMStream,NULL,&idl::MSPID_PrimaryAudio,1,NULL);
				if (HVar2 < 0) {
						// failure is just outright ignored here?
					HVar2 = 0;
				}
						// The IAMMultiMediaStream::OpenFile function only supports unicode,
						// so convert our filename to wide chars.
				MultiByteToWideChar(CP_ACP,0,fName,-1,wfilenameBuffer,0x104);
				(*amMMStream->lpVtbl->OpenFile)(amMMStream,wfilenameBuffer,0);
				pIVar1 = amMMStream->lpVtbl;
				*lplpAMMMStream = amMMStream;
				(*pIVar1->AddRef)(amMMStream);
			}
		}
	}
	(*amMMStream->lpVtbl->Release)(amMMStream);
	return -1 < HVar2;
}



G98CMovie * __thiscall
lego::video::G98CMovie___ctor
					(G98CMovie *this,char *fName,IDirectDrawSurface3 *bSurf3,IDirectDraw2 *ddraw2)
{
	char cVar1;
	bool bVar2;
	undefined4 *puVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	
	this->m_sampleBaseStream = NULL;
	this->m_sampleStream = NULL;
	this->m_baseSurf = NULL;
	this->m_surf = NULL;
	this->m_sample = NULL;
	this->m_bSurf = bSurf3;
	this->m_ddraw2 = ddraw2;
	CoInitialize(NULL);
	if (fName != NULL) {
						// *(char **)((int)this + 0x30) = std::_strdup(filename);
		iVar4 = -1;
		pcVar8 = fName;
		do {
			if (iVar4 == 0) break;
			iVar4 += -1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar8 + 1;
		} while (cVar1 != '\0');
						// if (std::strlen(filename) != 0)
		if (iVar4 != -2) {
			uVar5 = 0xffffffff;
			pcVar8 = fName;
			do {
				if (uVar5 == 0) break;
				uVar5 -= 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar8 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar5);
			uVar5 = 0xffffffff;
			this->m_filename = (char *)puVar3;
			pcVar8 = fName;
			do {
				pcVar9 = pcVar8;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar9 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar9;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar9 + -uVar5);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar3 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar3 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
						// end of std::_strdup
			bVar2 = G98CMovie__OpenAMStream(this,fName,&this->m_amStream,ddraw2);
			if (bVar2 != false) {
				G98CMovie__InitSample(this,this->m_amStream);
			}
		}
	}
	return this;
}



void __thiscall lego::video::G98CMovie___dtor(G98CMovie *this)
{
	IMediaStream *This;
	IDirectDrawMediaStream *This_00;
	IDirectDrawStreamSample *This_01;
	IDirectDrawSurface *This_02;
	IDirectDrawSurface3 *This_03;
	IDirectDraw2 *This_04;
	IAMMultiMediaStream *This_05;
	
	This = this->m_sampleBaseStream;
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
	}
	This_00 = this->m_sampleStream;
	if (This_00 != NULL) {
		(*This_00->lpVtbl->Release)((IUnknown *)This_00);
	}
	This_01 = this->m_sample;
	if (This_01 != NULL) {
		(*This_01->lpVtbl->Release)((IUnknown *)This_01);
	}
	This_02 = this->m_baseSurf;
	if (This_02 != NULL) {
		(*This_02->lpVtbl->Release)((IUnknown *)This_02);
	}
	This_03 = this->m_bSurf;
	if (This_03 != NULL) {
		(*This_03->lpVtbl->Release)((IUnknown *)This_03);
	}
	This_04 = this->m_ddraw2;
	if (This_04 != NULL) {
		(*This_04->lpVtbl->Release)((IUnknown *)This_04);
	}
	This_05 = this->m_amStream;
	if (This_05 != NULL) {
		(*This_05->lpVtbl->Release)((IUnknown *)This_05);
	}
	if (this->m_filename != NULL) {
		std::free(this->m_filename);
	}
	return;
}



bool __thiscall lego::video::G98CMovie__Update(G98CMovie *this,float speed,RECT *destRect)
{
	IDirectDrawStreamSample *pIVar1;
	IAMMultiMediaStream *pIVar2;
	HRESULT HVar3;
	
	pIVar1 = this->m_sample;
	if (pIVar1 != NULL) {
		HVar3 = (*(code *)pIVar1->lpVtbl->Update)(pIVar1,0,NULL,NULL,NULL);
		if (HVar3 == 0) {
						// DDBLT_WAIT (0x1000000)
			HVar3 = (*(code *)this->m_bSurf->lpVtbl->Blt)
												(this->m_bSurf,destRect,this->m_surf,NULL,0x1000000,NULL);
			return HVar3 == 0;
		}
						// On failure... SHUTDOWN EVERYTHING!
		(*this->m_sampleBaseStream->lpVtbl->Release)(this->m_sampleBaseStream);
		this->m_sampleBaseStream = NULL;
		(*this->m_sampleStream->lpVtbl->Release)(this->m_sampleStream);
		this->m_sampleStream = NULL;
		(*this->m_sample->lpVtbl->Release)(this->m_sample);
		this->m_sample = NULL;
		(*this->m_baseSurf->lpVtbl->Release)(this->m_baseSurf);
		pIVar2 = this->m_amStream;
		this->m_baseSurf = NULL;
		if (pIVar2 != NULL) {
			(*pIVar2->lpVtbl->Release)(pIVar2);
			this->m_amStream = NULL;
			return false;
		}
	}
	return false;
}



// WARNING: Could not reconcile some variable overlaps

longlong __thiscall lego::video::G98CMovie__GetDuration(G98CMovie *this)
{
	longlong lVar1;
	longlong duration;
	
	(*this->m_amStream->lpVtbl->GetDuration)(this->m_amStream,&duration);
						// __alldiv - 64-bit integer division in 32-bit environments
						// 
						// return duration / 10000LL; // 100-nanosecond units -> milliseconds
	lVar1 = __alldiv((uint)duration,duration._4_4_,10000,0);
	return lVar1;
}



Movie_t * __cdecl lego::video::Movie_Load(char *fName)
{
	char *filename;
	IDirectDraw4 *pIVar1;
	IDirectDrawSurface4 *pIVar2;
	FILE *stream;
	BOOL BVar3;
	G98CMovie *videoPlayer;
	undefined4 *in_FS_OFFSET;
	IDirectDrawSurface3 *ddSurface3;
	IDirectDraw2 *ddraw2;
	G98CMovie *This;
	char cdFileBuffer [512];
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
						// C++ function start guards (ignore these)
	local_c = *in_FS_OFFSET;
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e06c;
	*in_FS_OFFSET = &local_c;
						// actual start of C++ function
	filename = lego::file::File_VerifyFilename(fName);
	videoPlayer = NULL;
	pIVar1 = ddraw::DirectDraw();
	(*pIVar1->lpVtbl->QueryInterface)(pIVar1,&idl::IID_IDirectDraw2,(IUnknown **)&ddraw2);
	pIVar2 = ddraw::DirectDraw_bSurf();
	(*pIVar2->lpVtbl->QueryInterface)(pIVar2,&idl::IID_IDirectDrawSurface3,(IUnknown **)&ddSurface3);
	stream = std::fopen(filename,"r");
	if (stream == NULL) {
						// File not found in local Data folder, Try open in CDROM/Data folder
		BVar3 = lego::file::File_GetCDFilePath(cdFileBuffer,fName);
		if (BVar3 == 0) goto LAB_0047290d;
		This = (G98CMovie *)std::operator_new(0x38);
		local_4 = 1;
		if (This != NULL) {
			videoPlayer = G98CMovie___ctor(This,cdFileBuffer,ddSurface3,ddraw2);
			goto LAB_0047290d;
		}
	}
	else {
						// Open file in local Data folder
		std::fclose(stream);
		This = (G98CMovie *)std::operator_new(0x38);
		local_4 = 0;
		if (This != NULL) {
			videoPlayer = G98CMovie___ctor(This,filename,ddSurface3,ddraw2);
			goto LAB_0047290d;
		}
	}
	videoPlayer = NULL;
LAB_0047290d:
						// C++ function end guard (ignore this)
	*in_FS_OFFSET = local_c;
	return (Movie_t *)videoPlayer;
}



void __cdecl lego::video::Movie_GetSize(Movie_t *mov,uint *out_width,uint *out_height)
{
	DDSURFACEDESC *pDVar1;
	int iVar2;
	DDSURFACEDESC surfDesc;
	
	pDVar1 = &surfDesc;
	for (iVar2 = 0x1b; iVar2 != 0; iVar2 += -1) {
		pDVar1->dwSize = 0;
		pDVar1 = (DDSURFACEDESC *)((int)pDVar1 + 4);
	}
	surfDesc.dwSize = 0x6c;
	(*(code *)mov->m_surf->lpVtbl->GetSurfaceDesc)(mov->m_surf,&surfDesc);
	*out_width = surfDesc.dwWidth;
	*out_height = surfDesc.dwHeight;
	return;
}



// Gets the movie duration in milliseconds.

longlong __cdecl lego::video::Movie_GetDuration(Movie_t *mov)
{
	longlong lVar1;
	
	lVar1 = G98CMovie__GetDuration((G98CMovie *)mov);
	return lVar1;
}



BOOL __cdecl lego::video::Movie_Update(Movie_t *mov,float speed,RECT *destRect)
{
	bool bVar1;
	
	bVar1 = G98CMovie__Update((G98CMovie *)mov,speed,destRect);
	return (uint)(bVar1 != false);
}



void __cdecl lego::video::Movie_Free(Movie_t *mov)
{
	if (mov != NULL) {
		G98CMovie___dtor((G98CMovie *)mov);
						// This function is multi-purpose (the linker assigned functions with the same
						// functionality to different areas). So distinguishing is annoying
		game::RadarMap_Free_UnwindMultiUse((RadarMap *)mov);
	}
	return;
}



Container * __cdecl lego::res::Container_Initialise(char *gameName)
{
	Container *pCVar1;
	int iVar2;
	Container_Globs *pCVar3;
	
	pCVar3 = &globs::containerGlobs;
	for (iVar2 = 0x806; iVar2 != 0; iVar2 += -1) {
		pCVar3->listSet[0] = NULL;
		pCVar3 = (Container_Globs *)(pCVar3->listSet + 1);
	}
	pCVar3 = &globs::containerGlobs;
	for (iVar2 = 0x14; iVar2 != 0; iVar2 += -1) {
		pCVar3->listSet[0] = NULL;
		pCVar3 = (Container_Globs *)(pCVar3->listSet + 1);
	}
	globs::containerGlobs.extensionName[1] = "x";
	globs::containerGlobs.extensionName[2] = "x";
	globs::containerGlobs.extensionName[3] = "x";
	globs::containerGlobs.typeName[0] = "NULL";
	globs::containerGlobs.typeName[1] = "MESH";
	globs::containerGlobs.typeName[2] = "FRAME";
	globs::containerGlobs.typeName[3] = "ANIM";
	globs::containerGlobs.typeName[7] = "LWS";
	globs::containerGlobs.typeName[8] = "LWO";
	globs::containerGlobs.typeName[4] = "ACT";
	globs::containerGlobs.typeName[5] = NULL;
	globs::containerGlobs.extensionName[0] = ____EMPTYSTR__;
	globs::containerGlobs.extensionName[4] = "ae";
	globs::containerGlobs.extensionName[5] = ____EMPTYSTR__;
	globs::containerGlobs.gameName = gameName;
	globs::containerGlobs.freeList = NULL;
	globs::containerGlobs.listCount = 0;
	globs::containerGlobs.flags = CONTAINER_FLAG_INITIALISED;
	globs::containerGlobs.textureCount = 0;
	globs::containerGlobs.sharedDir = NULL;
	pCVar1 = Container_Create(NULL);
						// D3DRMSORT_NONE (0x1)
	globs::containerGlobs.rootContainer = pCVar1;
	(*pCVar1->masterFrame->lpVtbl->SetSortMode)(pCVar1->masterFrame,D3DRMSORT_NONE);
	return pCVar1;
}



void __cdecl lego::res::Container_Shutdown(void)
{
	int iVar1;
	Container *in_cont;
	byte bVar2;
	int iVar3;
	Container_TextureRef *pCVar4;
	Container_Globs *pCVar5;
	uint uVar6;
	
	bVar2 = 0;
	pCVar5 = &globs::containerGlobs;
	do {
		if (pCVar5->listSet[0] != NULL) {
			iVar1 = 1 << (bVar2 & 0x1f);
			if (iVar1 != 0) {
				iVar3 = 0;
				do {
					in_cont = (Container *)((int)&pCVar5->listSet[0]->masterFrame + iVar3);
					if ((in_cont != NULL) && (in_cont->nextFree == in_cont)) {
						Container_Remove2(in_cont,TRUE);
					}
					iVar3 += 0x2c;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			std::free(pCVar5->listSet[0]);
		}
		pCVar5 = (Container_Globs *)(pCVar5->listSet + 1);
		bVar2 += 1;
	} while (pCVar5 < (Container_Globs *)&globs::containerGlobs.freeList);
	uVar6 = 0;
	globs::containerGlobs.freeList = NULL;
	globs::containerGlobs.flags = CONTAINER_FLAG_NONE;
	if (globs::containerGlobs.textureCount != 0) {
		pCVar4 = globs::containerGlobs.textureSet;
		do {
			if (pCVar4->filename != NULL) {
				std::free(pCVar4->filename);
			}
			uVar6 += 1;
			pCVar4 = pCVar4 + 1;
		} while (uVar6 < globs::containerGlobs.textureCount);
	}
	if (globs::containerGlobs.sharedDir != NULL) {
		std::free(globs::containerGlobs.sharedDir);
	}
	return;
}



void __cdecl lego::res::Container_SetSharedTextureDirectory(char *path)
{
	globs::containerGlobs.sharedDir = util::_strdup(path);
	return;
}



void __cdecl lego::res::Container_EnableSoundTriggers(BOOL on)
{
	if (on != 0) {
		globs::containerGlobs.flags = globs::containerGlobs.flags | CONTAINER_FLAG_TRIGGERENABLED;
		return;
	}
	globs::containerGlobs.flags = globs::containerGlobs.flags & ~CONTAINER_FLAG_TRIGGERENABLED;
	return;
}



void __cdecl
lego::res::Container_SetTriggerFrameCallback(ContainerTriggerFrameCallback callback,void *data)
{
	globs::containerGlobs.triggerFrameCallback = callback;
	globs::containerGlobs.triggerFrameData = data;
	return;
}



void __cdecl
lego::res::Container_SetSoundTriggerCallback(ContainerSoundTriggerCallback callback,void *data)
{
	globs::containerGlobs.soundTriggerCallback = callback;
	globs::containerGlobs.soundTriggerData = data;
	globs::containerGlobs.flags = globs::containerGlobs.flags | CONTAINER_FLAG_TRIGGERENABLED;
	return;
}



// OFFICIAL: Container_GetRoot(void)

Container * __cdecl lego::res::GetRoot(void)
{
	return globs::containerGlobs.rootContainer;
}



Container * __cdecl lego::res::Container_Create(Container *opt_parent)
{
	Container *cont;
	HRESULT HVar1;
	int iVar2;
	IDirect3DRMFrame3 *parentFrame1;
	IDirect3DRMFrame3 *parentFrame3;
	Container *pCVar3;
	
	parentFrame1 = NULL;
	parentFrame3 = NULL;
	if (opt_parent != NULL) {
		parentFrame1 = opt_parent->masterFrame;
		parentFrame3 = opt_parent->hiddenFrame;
	}
	if (globs::containerGlobs.freeList == NULL) {
		Container_AddList();
	}
	cont = globs::containerGlobs.freeList;
	pCVar3 = globs::containerGlobs.freeList;
	globs::containerGlobs.freeList = (globs::containerGlobs.freeList)->nextFree;
	for (iVar2 = 0xb; iVar2 != 0; iVar2 += -1) {
		pCVar3->masterFrame = NULL;
		pCVar3 = (Container *)&pCVar3->activityFrame;
	}
	cont->nextFree = cont;
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
										(globs::mainGlobs.lpD3DRM,parentFrame1,&cont->masterFrame);
	if (HVar1 == 0) {
		HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
											(globs::mainGlobs.lpD3DRM,cont->masterFrame,&cont->activityFrame);
		if (HVar1 == 0) {
			HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
												(globs::mainGlobs.lpD3DRM,parentFrame3,&cont->hiddenFrame);
			if (HVar1 == 0) {
				Container_Frame_SetAppData
									(cont->masterFrame,cont,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
				Container_Frame_SetAppData
									(cont->activityFrame,cont,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
				Container_Frame_SetAppData
									(cont->hiddenFrame,cont,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
				return cont;
			}
		}
	}
	Container_Remove(cont);
	return NULL;
}



void __cdecl lego::res::Container_Remove(Container *cont)
{
	Container_Remove2(cont,FALSE);
	return;
}



void __cdecl lego::res::Container_Remove2(Container *in_cont,BOOL kill)
{
	Container_CloneData *pCVar1;
	Container_Type CVar2;
	Container_TypeData *pCVar3;
	IDirect3DRMVisual *pIVar4;
	Container *cont;
	uint uVar5;
	AnimClone **out_acList;
	IDirect3DRMFrame3 **out_frameList;
	void **buffer;
	AnimClone *actFrameRes;
	void *pvVar6;
	AnimClone **buffer_00;
	IDirect3DRMFrame3 **ppIVar7;
	
	cont = in_cont;
	if (in_cont->type != CONTAINER_REFERENCE) {
		Container_SetParent(in_cont,NULL);
	}
	if (((cont->type == CONTAINER_FROMACTIVITY) || (cont->type == CONTAINER_ANIM)) &&
		 (pCVar1 = cont->cloneData, pCVar1 != NULL)) {
		if (kill == 0) {
			pCVar1->used = 0;
			return;
		}
		if (pCVar1->cloneTable != NULL) {
			std::free(pCVar1->cloneTable);
		}
		std::free(cont->cloneData);
	}
	CVar2 = cont->type;
	if (CVar2 == CONTAINER_FROMACTIVITY) {
		uVar5 = Container_GetActivities(cont,NULL,NULL,NULL);
		out_acList = (AnimClone **)std::malloc(uVar5 * 4);
		kill = (BOOL)out_acList;
		out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar5 * 4);
		Container_GetActivities(cont,out_frameList,out_acList,NULL);
		buffer_00 = out_acList;
		if (uVar5 != 0) {
			ppIVar7 = out_frameList;
			do {
				AnimClone_Remove(*(AnimClone **)(((int)out_acList - (int)out_frameList) + (int)ppIVar7));
				Container_Frame_FreeName(*ppIVar7);
				Container_Frame_RemoveAppData(*ppIVar7);
				(*(*ppIVar7)->lpVtbl->Release)((IUnknown *)*ppIVar7);
				ppIVar7 = ppIVar7 + 1;
				uVar5 -= 1;
				buffer_00 = (AnimClone **)kill;
			} while (uVar5 != 0);
		}
		std::free(buffer_00);
		std::free(out_frameList);
	}
	else {
		if (CVar2 == CONTAINER_MESH) {
			pCVar3 = cont->typeData;
			if (pCVar3 != NULL) {
				if (pCVar3->transMesh == NULL) {
					buffer = (*pCVar3->mesh->lpVtbl->GetAppData)(pCVar3->mesh);
					if (buffer != NULL) {
						pvVar6 = NULL;
						if (buffer[1] != NULL) {
							do {
								pIVar4 = *(IDirect3DRMVisual **)((int)*buffer + (int)pvVar6 * 4);
								(*cont->activityFrame->lpVtbl->DeleteVisual)(cont->activityFrame,pIVar4);
								(*pIVar4->lpVtbl->Release)(pIVar4);
								pvVar6 = (void *)((int)pvVar6 + 1);
							} while (pvVar6 < buffer[1]);
						}
						std::free(*buffer);
						std::free(buffer);
					}
				}
				else {
					Mesh_Remove(pCVar3->transMesh,cont->activityFrame);
				}
			}
		}
		else {
			if ((CVar2 == CONTAINER_ANIM) &&
				 (actFrameRes = Container_Frame_GetAnimClone(cont->activityFrame), actFrameRes != NULL)) {
				AnimClone_Remove(actFrameRes);
			}
		}
	}
	Container_FreeTypeData(cont);
	if ((cont->type != CONTAINER_REFERENCE) ||
		 ((*(byte *)&cont->flags & CONTAINER_FLAG_DEADREFERENCE) == 0)) {
		Container_Frame_RemoveAppData(cont->masterFrame);
	}
	if (cont->type != CONTAINER_REFERENCE) {
		Container_Frame_RemoveAppData(cont->activityFrame);
	}
	Container_Frame_RemoveAppData(cont->hiddenFrame);
	if (cont->type == CONTAINER_REFERENCE) {
		(*cont->hiddenFrame->lpVtbl->Release)(cont->hiddenFrame);
	}
	else {
		(*cont->masterFrame->lpVtbl->GetParent)(cont->masterFrame,(IDirect3DRMFrame3 **)&in_cont);
		if (in_cont != NULL) {
						// IDirect3DRMFrame3->DeleteChild(this, IDirect3DRMFrame3* lpChild)
						//  (this = resData->frame1->GetParent, lpChild = resData->frame1)
			(*(code *)in_cont->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_cont,cont->masterFrame);
						// IDirect3DRMFrame3->Release(this)
						//  (this = resData->frame1->GetParent)
			(*(code *)in_cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_cont);
		}
		(*cont->masterFrame->lpVtbl->Release)(cont->masterFrame);
		(*cont->activityFrame->lpVtbl->Release)(cont->activityFrame);
		(*cont->hiddenFrame->lpVtbl->GetParent)(cont->hiddenFrame,(IDirect3DRMFrame3 **)&in_cont);
		if (in_cont != NULL) {
						// IDirect3DRMFrame3->DeleteChild(this, IDirect3DRMFrame3* lpChild)
						//  (this = resData->frame3->GetParent, lpChild = resData->frame3)
			(*(code *)in_cont->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_cont,cont->hiddenFrame);
						// IDirect3DRMFrame3->Release(this)
						//  (this = resData->frame3->GetParent)
			(*(code *)in_cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_cont);
		}
		(*cont->hiddenFrame->lpVtbl->Release)(cont->hiddenFrame);
	}
	cont->nextFree = globs::containerGlobs.freeList;
	globs::containerGlobs.freeList = cont;
	return;
}



Container * __cdecl
lego::res::Container_Load(Container *parent,char *filename,char *typestr,BOOL looping)
{
	char cVar1;
	Container_Type CVar2;
	int iVar3;
	CFGProperty *prop;
	CFGProperty *prop_00;
	char *pcVar4;
	BoolTri BVar5;
	BoolTri BVar6;
	char *pcVar7;
	BOOL BVar8;
	Container *pCVar9;
	byte *file_data;
	IDirect3DRMMesh *mesh;
	Mesh *transMesh;
	AnimClone *animClone;
	uint uVar10;
	uint uVar11;
	undefined4 *puVar12;
	undefined4 *puVar13;
	float10 fVar14;
	Container *local_864;
	float local_860;
	char *local_85c;
	BOOL isNoTexture;
	uint local_854;
	char filenameBuffer [512];
	char local_650 [508];
	char *apcStack1108 [21];
	char filenameBuffer2 [512];
	char local_200 [512];
	
	local_864 = NULL;
	CVar2 = Container_ParseTypeString(typestr,&isNoTexture);
	uVar10 = 0xffffffff;
	do {
		pcVar4 = filename;
		if (uVar10 == 0) break;
		uVar10 -= 1;
		pcVar4 = filename + 1;
		cVar1 = *filename;
		filename = pcVar4;
	} while (cVar1 != '\0');
	uVar10 = ~uVar10;
	puVar12 = (undefined4 *)(pcVar4 + -uVar10);
	puVar13 = (undefined4 *)filenameBuffer2;
	for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
		*puVar13 = *puVar12;
		puVar12 = puVar12 + 1;
		puVar13 = puVar13 + 1;
	}
	for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
		*(undefined *)puVar13 = *(undefined *)puVar12;
		puVar12 = (undefined4 *)((int)puVar12 + 1);
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	}
	if (CVar2 == CONTAINER_FROMACTIVITY) {
		uVar10 = 0xffffffff;
		pcVar4 = filenameBuffer2;
		do {
			pcVar7 = pcVar4;
			if (uVar10 == 0) break;
			uVar10 -= 1;
			pcVar7 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar7;
		} while (cVar1 != '\0');
		uVar10 = ~uVar10;
		puVar12 = (undefined4 *)(pcVar7 + -uVar10);
		puVar13 = (undefined4 *)local_200;
		for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
			*puVar13 = *puVar12;
			puVar12 = puVar12 + 1;
			puVar13 = puVar13 + 1;
		}
		for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
			*(undefined *)puVar13 = *(undefined *)puVar12;
			puVar12 = (undefined4 *)((int)puVar12 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		iVar3 = util::Util_Tokenise(filenameBuffer2,apcStack1108 + 1,"\\");
		std::sprintf(filenameBuffer,"%s\\%s.%s",local_200,apcStack1108[iVar3],
								 globs::containerGlobs.extensionName[4]);
		prop = cfg::CFG_Open(filenameBuffer);
		if (prop != NULL) {
			std::sprintf(filenameBuffer,"%s%s%s",globs::containerGlobs.gameName,"::","Activities");
			prop_00 = cfg::CFG_GetChildren(prop,filenameBuffer);
			if (prop_00 != NULL) {
				local_864 = Container_Create(parent);
				local_864->type = CONTAINER_FROMACTIVITY;
				do {
					local_85c = prop_00->key;
					if (*local_85c == '!') {
						if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
							if (true) {
								local_85c = local_85c + 1;
							}
							goto LAB_004730ee;
						}
					}
					else {
LAB_004730ee:
						std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value,
												 "::","FILE");
						pcVar4 = cfg::CFG_ReadString(prop,local_650);
						if (pcVar4 != NULL) {
							std::sprintf(filenameBuffer,"%s\\%s",local_200,pcVar4);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","TRANSCOEF");
							pcVar4 = cfg::CFG_ReadString(prop,local_650);
							if (pcVar4 == NULL) {
								pcVar4 = ____EMPTYSTR__;
							}
							else {
								pcVar4 = cfg::CFG_ReadString(prop,local_650);
							}
							fVar14 = std::atof(pcVar4);
							local_860 = (float)fVar14;
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","TRIGGER");
							pcVar4 = cfg::CFG_ReadString(prop,local_650);
							if (pcVar4 == NULL) {
								pcVar4 = ____EMPTYSTR__;
							}
							else {
								pcVar4 = cfg::CFG_ReadString(prop,local_650);
							}
							local_854 = std::atoi(pcVar4);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","LWSFILE");
							BVar5 = cfg::CFG_ReadBool(prop,local_650);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","LOOPING");
							BVar6 = cfg::CFG_ReadBool(prop,local_650);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","SAMPLE");
							pcVar7 = cfg::CFG_CopyString(prop,local_650);
							pcVar4 = local_85c;
							BVar8 = Container_AddActivity2
																(local_864,filenameBuffer,local_85c,local_860,local_854,pcVar7,NULL,
																 (uint)(BVar5 == BOOL3_TRUE),(uint)(BVar6 != BOOL3_FALSE));
							if ((BVar8 != 0) && (local_864->typeData == NULL)) {
								Container_SetActivity(local_864,pcVar4);
							}
						}
					}
					prop_00 = cfg::CFG_NextFlat(prop_00);
				} while (prop_00 != NULL);
			}
			std::sprintf(filenameBuffer,"%s%s%s",globs::containerGlobs.gameName,"::","SCALE");
			pcVar4 = cfg::CFG_ReadString(prop,filenameBuffer);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_ReadString(prop,filenameBuffer);
			}
			fVar14 = std::atof(pcVar4);
			local_85c = (char *)(float)fVar14;
			if ((float)local_85c != 0.0) {
				(*local_864->activityFrame->lpVtbl->AddScale)
									(local_864->activityFrame,D3DRMCOMBINE_REPLACE,(float)local_85c,(float)local_85c,
									 (float)local_85c);
			}
			cfg::CFG_Close(prop);
			return local_864;
		}
	}
	else {
		if (CVar2 == CONTAINER_FRAME) {
			pCVar9 = Container_Create(parent);
			pCVar9->type = CONTAINER_FRAME;
			std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[2]);
			Container_FrameLoad(filenameBuffer,pCVar9->activityFrame);
			return pCVar9;
		}
		if (CVar2 == CONTAINER_MESH) {
			std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[1]);
			file_data = lego::file::File_LoadBinary(filenameBuffer,(uint *)&local_860);
			if (file_data != NULL) {
				pCVar9 = Container_Create(parent);
				pCVar9->type = CONTAINER_MESH;
				mesh = Container_MeshLoad(file_data,(uint)local_860,filenameBuffer,pCVar9->activityFrame,
																	isNoTexture);
				if (mesh != NULL) {
					Container_SetTypeData(pCVar9,NULL,NULL,mesh,NULL);
				}
				std::free(file_data);
				return pCVar9;
			}
		}
		else {
			if ((CVar2 == CONTAINER_ANIM) || (CVar2 == CONTAINER_LWS)) {
				pCVar9 = Container_Create(parent);
				pCVar9->type = CONTAINER_ANIM;
				std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[3]);
				animClone = Container_LoadAnimSet
															(filenameBuffer,pCVar9->activityFrame,(uint *)&local_860,
															 (uint)(CVar2 == CONTAINER_LWS),looping);
				if (animClone != NULL) {
					Container_Frame_SetAppData
										(pCVar9->activityFrame,pCVar9,animClone,filenameBuffer2,(uint *)&local_860,NULL,
										 NULL,NULL,NULL,NULL,NULL);
					return pCVar9;
				}
			}
			else {
				if (CVar2 != CONTAINER_LWO) {
					return NULL;
				}
				pCVar9 = Container_Create(parent);
				pCVar9->type = CONTAINER_LWO;
				transMesh = Mesh_Load(filenameBuffer2,pCVar9->activityFrame,isNoTexture);
				if (transMesh != NULL) {
					Container_SetTypeData(pCVar9,NULL,NULL,NULL,transMesh);
					return pCVar9;
				}
			}
			Container_Remove(pCVar9);
		}
	}
	return NULL;
}



BOOL __cdecl lego::res::Container_IsCurrentActivity(Container *cont,char *actname)
{
	IDirect3DRMFrame3 *frame;
	
	if (cont->type == CONTAINER_FROMACTIVITY) {
		frame = Container_Frame_Find(cont,actname,0);
		if (frame != NULL) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::res::Container_SetActivity(Container *cont,char *actname)
{
	char cVar1;
	IDirect3DRMFrame3 *child;
	IDirect3DRMFrame3 *child_00;
	undefined4 *name;
	uint uVar2;
	uint uVar3;
	char *buffer;
	BOOL BVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	BVar4 = 0;
	if (cont->type == CONTAINER_FROMACTIVITY) {
		child = Container_Frame_Find(cont,actname,1);
		if (child == NULL) {
			BVar4 = 0;
		}
		else {
			buffer = NULL;
			if (((cont->typeData != NULL) && (pcVar6 = cont->typeData->name, pcVar6 != NULL)) &&
				 (child_00 = Container_Frame_Find(cont,pcVar6,0), buffer = pcVar6, child_00 != NULL)) {
				Container_Frame_SafeAddChild(cont->hiddenFrame,child_00);
			}
			Container_Frame_SafeAddChild(cont->activityFrame,child);
			uVar2 = 0xffffffff;
			pcVar6 = actname;
			do {
				if (uVar2 == 0) break;
				uVar2 -= 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			name = (undefined4 *)std::malloc(~uVar2);
			uVar2 = 0xffffffff;
			do {
				pcVar6 = actname;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar6 = actname + 1;
				cVar1 = *actname;
				actname = pcVar6;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			puVar5 = (undefined4 *)(pcVar6 + -uVar2);
			puVar7 = name;
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*puVar7 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar7 = puVar7 + 1;
			}
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar7 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
			}
			Container_SetTypeData(cont,(char *)name,NULL,NULL,NULL);
			BVar4 = 1;
			cont->flags = cont->flags | CONTAINER_FLAG_TRIGGERSAMPLE;
			if (buffer != NULL) {
				std::free(buffer);
			}
		}
		if (cont->activityCallback != NULL) {
			(*cont->activityCallback)(cont,cont->activityCallbackData);
		}
	}
	return BVar4;
}



BOOL __cdecl lego::res::Container_Light_SetSpotPenumbra(Container *spotlight,float angle)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetPenumbra)(This,angle);
	return (uint)(HVar1 == 0);
}



BOOL __cdecl lego::res::Container_Light_SetSpotUmbra(Container *spotlight,float angle)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetUmbra)(This,angle);
	return (uint)(HVar1 == 0);
}



BOOL __cdecl lego::res::Container_Light_SetSpotRange(Container *spotlight,float dist)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetRange)(This,dist);
	return (uint)(HVar1 == 0);
}



void __cdecl lego::res::Container_Light_SetEnableContainer(Container *light,Container *enable)
{
	IDirect3DRMLight *This;
	
						// IDirect3DRMFrame3->QueryInterface(this, IID_IDirect3DRMFrame, IDirect3DRMFrame**
						// lplpOut)
						//  (downcast: IDirect3DRMFrame3 -> IDirect3DRMFrame)
	(*enable->masterFrame->lpVtbl->QueryInterface)
						((IUnknown *)enable->masterFrame,(IID *)&idl::IID_IDirect3DRMFrame,
						 (IDirect3DRMFrame **)&enable);
	This = light->typeData->light;
						// IDirect3DRMLight->SetEnableFrame(this, IDirect3DRMFrame* lpEnableFrame)
	(*This->lpVtbl->SetEnableFrame)(This,(IDirect3DRMFrame *)enable);
	return;
}



Container * __cdecl
lego::res::Container_MakeLight(Container *parent,D3DRMLightType type,float r,float g,float b)
{
	Container *cont;
	HRESULT HVar1;
	IDirect3DRM3 *light;
	IDirect3DRMLight *lpD3DRMLight;
	
	cont = Container_Create(parent);
	if (cont != NULL) {
		cont->type = CONTAINER_LIGHT;
						// IDirect3DRM3->CreateLightRGB(this, TD3DRMLightType ltLightType, float vRed, float
						// vGreen, float vBlue, IDirect3DRMLight** lplpD3DRMLight)
		light = globs::mainGlobs.lpD3DRM;
		lpD3DRMLight = (IDirect3DRMLight *)r;
		HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateLightRGB)
											(globs::mainGlobs.lpD3DRM,type,r,g,b,(IDirect3DRMLight **)&parent);
		if (HVar1 == 0) {
						// IDirect3DRMFrame3->AddLight(this, IDirect3DRMLight* lpD3DRMLight)
			(*cont->activityFrame->lpVtbl->AddLight)(cont->activityFrame,lpD3DRMLight);
			Container_SetTypeData(cont,NULL,(IDirect3DRMLight *)light,NULL,NULL);
		}
	}
	return cont;
}



Container * __cdecl lego::res::Container_MakeMesh2(Container *parent,Container_MeshType type)
{
	Container_MeshType CVar1;
	Container *cont;
	HRESULT HVar2;
	void **data;
	void *pvVar3;
	uint renderFlags;
	Mesh *transMesh;
	IDirect3DRMMesh *unaff_ESI;
	
	cont = Container_Create(parent);
	CVar1 = type;
	if (cont != NULL) {
		cont->type = CONTAINER_MESH;
		if (((type == CONTAINER_MESHTYPE_TRANSPARENT) || (type == CONTAINER_MESHTYPE_IMMEDIATE)) ||
			 (type == CONTAINER_MESHTYPE_ADDITIVE)) {
			renderFlags = 0x2000;
			if (type == CONTAINER_MESHTYPE_TRANSPARENT) {
				renderFlags = 0x3000;
			}
			else {
				if (type == CONTAINER_MESHTYPE_ADDITIVE) {
					renderFlags = 0x2800;
				}
			}
			transMesh = Mesh_CreateOnFrame(cont->activityFrame,NULL,renderFlags,NULL,MESH_TYPE_NORM);
			Container_SetTypeData(cont,NULL,NULL,NULL,transMesh);
		}
		else {
			HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMesh)
												(globs::mainGlobs.lpD3DRM,(IDirect3DRMMesh **)&parent);
			if (HVar2 == 0) {
				(*cont->activityFrame->lpVtbl->AddVisual)(cont->activityFrame,(IDirect3DRMVisual *)parent);
				Container_SetTypeData(cont,NULL,NULL,unaff_ESI,NULL);
				if (CVar1 == CONTAINER_MESHTYPE_SEPARATEMESHES) {
					data = (void **)std::malloc(0x14);
					data[2] = &DAT_00000014;
					data[1] = NULL;
					pvVar3 = std::malloc(0x50);
					*data = pvVar3;
					data[3] = NULL;
					data[4] = (void *)0x1;
					(*unaff_ESI->lpVtbl->SetAppData)((IUnknown *)unaff_ESI,(DWORD)data);
					return cont;
				}
				(*unaff_ESI->lpVtbl->SetAppData)((IUnknown *)unaff_ESI,0);
				return cont;
			}
		}
	}
	return cont;
}



IDirect3DRMFrame3 * __cdecl lego::res::Container_GetMasterFrame(Container *cont)
{
	return cont->masterFrame;
}



// WARNING: Type propagation algorithm not settling

Container * __cdecl lego::res::Container_Clone(Container *orig)
{
	char cVar1;
	IDirect3DRMMesh *pIVar2;
	Container_TypeData *pCVar3;
	Container_Type CVar4;
	Container *pCVar5;
	Container *parent;
	Container **ppCVar6;
	Container_TypeData *pCVar7;
	char *pcVar8;
	Container_CloneData *pCVar9;
	float fVar10;
	IDirect3DRMFrame3 **out_frameList;
	char **out_nameList;
	char *pcVar11;
	AnimClone *pAVar12;
	Mesh *pMVar13;
	uint uVar14;
	uint uVar15;
	Container *cont;
	undefined4 *puVar16;
	IDirect3DRMFrame3 **ppIVar17;
	Container *pCVar18;
	undefined4 *puVar19;
	float10 fVar20;
	IDirect3DRMFrame3 *This;
	float fVar21;
	int iVar22;
	int iVar23;
	char **ppcVar24;
	IDirect3DRMFrame3 **ppIVar25;
	undefined local_54 [52];
	float fStack32;
	int *piStack28;
	IDirect3DRMFrame3 *pIStack4;
	
	cont = orig;
	pCVar18 = NULL;
	if (orig->type == CONTAINER_MESH) {
		pIVar2 = orig->typeData->mesh;
		(*pIVar2->lpVtbl->GetAppData)((IUnknown *)pIVar2);
	}
	if ((cont->type == CONTAINER_FROMACTIVITY) || (cont->type == CONTAINER_ANIM)) {
		if ((cont->cloneData != NULL) && (pCVar5 = cont->cloneData->clonedFrom, pCVar5 != NULL)) {
			cont = pCVar5;
		}
		pCVar9 = cont->cloneData;
		if (pCVar9 == NULL) {
			pCVar5 = Container_GetParent(cont);
			pCVar5 = Container_Create(pCVar5);
			pCVar9 = (Container_CloneData *)std::malloc(0x14);
			cont->cloneData = pCVar9;
			pCVar9->cloneCount = 1;
			ppCVar6 = (Container **)std::malloc(4);
			cont->cloneData->cloneTable = ppCVar6;
			((Container *)cont->cloneData->cloneTable)->masterFrame = (IDirect3DRMFrame3 *)pCVar5;
			cont->cloneData->clonedFrom = NULL;
			cont->cloneData->cloneNumber = NULL;
			cont->cloneData->used = 1;
		}
		else {
			pCVar5 = cont;
			if (pCVar9->used != 0) {
				uVar14 = 0;
				pCVar5 = pCVar18;
				if (pCVar9->cloneCount != 0) {
					ppCVar6 = pCVar9->cloneTable;
					do {
						pCVar5 = *ppCVar6;
						if ((pCVar5 != NULL) && (pCVar5->cloneData->used == 0)) break;
						uVar14 += 1;
						ppCVar6 = ppCVar6 + 1;
						pCVar5 = pCVar18;
					} while (uVar14 < pCVar9->cloneCount);
				}
			}
			pCVar18 = pCVar5;
			if (pCVar5 == NULL) {
				pCVar5 = Container_GetParent(cont);
				pCVar5 = Container_Create(pCVar5);
				uVar14 = cont->cloneData->cloneCount;
				cont->cloneData->cloneCount = uVar14 + 1;
				ppCVar6 = (Container **)
									std::realloc(cont->cloneData->cloneTable,cont->cloneData->cloneCount << 2);
				cont->cloneData->cloneTable = ppCVar6;
				cont->cloneData->cloneTable[uVar14] = pCVar5;
			}
			else {
				pCVar5->cloneData->used = 1;
				parent = Container_GetParent(cont);
				Container_SetParent(pCVar5,parent);
				Container_SetAnimationTime(pCVar5,0.0);
			}
		}
	}
	else {
		pCVar5 = Container_GetParent(cont);
		pCVar5 = Container_Create(pCVar5);
	}
	(*cont->activityFrame->lpVtbl->GetParent)(cont->activityFrame,(IDirect3DRMFrame3 **)&orig);
	This = cont->activityFrame;
	(*This->lpVtbl->GetTransform)(This,pIStack4,(Matrix4F *)(local_54 + 0xc));
	(*pCVar5->activityFrame->lpVtbl->AddTransform)
						(pCVar5->activityFrame,D3DRMCOMBINE_REPLACE,(Matrix4F *)local_54);
	(**(code **)(*piStack28 + 8))(piStack28);
	if (pCVar18 == NULL) {
		pCVar5->type = cont->type;
		if (cont->typeData == NULL) {
			pCVar5->typeData = NULL;
		}
		else {
			pCVar7 = (Container_TypeData *)std::malloc(0x10);
			pCVar5->typeData = pCVar7;
			pCVar3 = cont->typeData;
			pCVar7->name = pCVar3->name;
			pCVar7->light = pCVar3->light;
			pCVar7->mesh = pCVar3->mesh;
			pCVar7->transMesh = pCVar3->transMesh;
			pcVar8 = cont->typeData->name;
			if (pcVar8 != NULL) {
				uVar14 = 0xffffffff;
				do {
					if (uVar14 == 0) break;
					uVar14 -= 1;
					cVar1 = *pcVar8;
					pcVar8 = pcVar8 + 1;
				} while (cVar1 != '\0');
				pcVar8 = (char *)std::malloc(~uVar14);
				pCVar5->typeData->name = pcVar8;
				uVar14 = 0xffffffff;
				pcVar8 = cont->typeData->name;
				do {
					pcVar11 = pcVar8;
					if (uVar14 == 0) break;
					uVar14 -= 1;
					pcVar11 = pcVar8 + 1;
					cVar1 = *pcVar8;
					pcVar8 = pcVar11;
				} while (cVar1 != '\0');
				uVar14 = ~uVar14;
				puVar16 = (undefined4 *)(pcVar11 + -uVar14);
				puVar19 = (undefined4 *)pCVar5->typeData->name;
				for (uVar15 = uVar14 >> 2; uVar15 != 0; uVar15 -= 1) {
					*puVar19 = *puVar16;
					puVar16 = puVar16 + 1;
					puVar19 = puVar19 + 1;
				}
				for (uVar14 &= 3; uVar14 != 0; uVar14 -= 1) {
					*(undefined *)puVar19 = *(undefined *)puVar16;
					puVar16 = (undefined4 *)((int)puVar16 + 1);
					puVar19 = (undefined4 *)((int)puVar19 + 1);
				}
			}
		}
		if ((cont->type == CONTAINER_FROMACTIVITY) || (cont->type == CONTAINER_ANIM)) {
			pCVar9 = (Container_CloneData *)std::malloc(0x14);
			pCVar5->cloneData = pCVar9;
			pCVar9->cloneTable = NULL;
			pCVar5->cloneData->cloneCount = 0;
			pCVar5->cloneData->clonedFrom = cont;
			pCVar5->cloneData->cloneNumber = This;
			pCVar5->cloneData->used = 1;
		}
		CVar4 = pCVar5->type;
		if (CVar4 == CONTAINER_MESH) {
			pIVar2 = pCVar5->typeData->mesh;
			(*pCVar5->activityFrame->lpVtbl->AddVisual)(pCVar5->activityFrame,(IDirect3DRMVisual *)pIVar2)
			;
			(*pIVar2->lpVtbl->AddRef)((IUnknown *)pIVar2);
			return pCVar5;
		}
		if (CVar4 == CONTAINER_FROMACTIVITY) {
			fVar10 = (float)Container_GetActivities(cont,NULL,NULL,NULL);
			uVar14 = (int)fVar10 * 4;
			out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar14);
			ppIVar25 = out_frameList;
			out_nameList = (char **)std::malloc(uVar14);
			ppcVar24 = out_nameList;
			Container_GetActivities(cont,out_frameList,NULL,out_nameList);
			fStack32 = 0.0;
			if (fVar10 != 0.0) {
				ppIVar17 = out_frameList;
				iVar22 = (int)out_nameList - (int)out_frameList;
				out_nameList = ppcVar24;
				out_frameList = ppIVar25;
				do {
					pcVar8 = Container_Frame_GetAnimSetFileName(*ppIVar17);
					fVar20 = Container_Frame_GetTransCo(*ppIVar17);
					fVar21 = (float)fVar20;
					pcVar11 = Container_Frame_GetSample(*ppIVar17);
					pAVar12 = Container_Frame_GetAnimClone(*ppIVar17);
					uVar14 = Container_Frame_GetTrigger(*ppIVar17);
					Container_Frame_SetAppData(*ppIVar17,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
					iVar23 = iVar22;
					Container_AddActivity2
										(pCVar5,pcVar8,(char *)(*(int *)(iVar22 + (int)ppIVar17) + 9),fVar21,uVar14,
										 pcVar11,pAVar12,0,0);
					std::free(*(void **)(iVar22 + (int)ppIVar17));
					fVar21 = fStack32;
					if ((uint)fStack32 % 0x19 == 0) {
						snd::Sound3D_Update();
					}
					fStack32 = (float)((int)fVar21 + 1);
					ppIVar17 = ppIVar17 + 1;
					iVar22 = iVar23;
				} while ((uint)fStack32 < (uint)fVar10);
			}
			std::free(out_frameList);
			std::free(out_nameList);
			if (pCVar5->typeData != NULL) {
				Container_SetActivity(pCVar5,pCVar5->typeData->name);
				return pCVar5;
			}
		}
		else {
			if (CVar4 == CONTAINER_ANIM) {
				pcVar8 = Container_Frame_GetAnimSetFileName(cont->activityFrame);
				pAVar12 = Container_Frame_GetAnimClone(cont->activityFrame);
				pAVar12 = AnimClone_Make(pAVar12,pCVar5->activityFrame,(uint *)&fStack32);
				Container_Frame_SetAppData
									(pCVar5->activityFrame,pCVar5,pAVar12,pcVar8,(uint *)&fStack32,NULL,NULL,NULL,NULL
									 ,NULL,NULL);
				return pCVar5;
			}
			if (CVar4 == CONTAINER_LWO) {
				pMVar13 = Mesh_Clone(pCVar5->typeData->transMesh,pCVar5->activityFrame);
				pCVar5->typeData->transMesh = pMVar13;
			}
		}
	}
	return pCVar5;
}



void __cdecl lego::res::Container_Hide2(Container *cont,BOOL hide)
{
	if (hide != 0) {
		cont->flags = cont->flags | CONTAINER_FLAG_HIDDEN2;
		return;
	}
	cont->flags = cont->flags & ~CONTAINER_FLAG_HIDDEN2;
	return;
}



void __cdecl lego::res::Container_Hide(Container *cont,BOOL hide)
{
	ContainerFlags CVar1;
	
	CVar1 = cont->flags & CONTAINER_FLAG_HIDDEN;
	if (hide != 0) {
		if (CVar1 == CONTAINER_FLAG_NONE) {
			Container_Frame_SafeAddChild(cont->hiddenFrame,cont->activityFrame);
			cont->flags = cont->flags | CONTAINER_FLAG_HIDDEN;
			return;
		}
		if (hide != 0) {
			return;
		}
	}
	if (CVar1 != CONTAINER_FLAG_NONE) {
		Container_Frame_SafeAddChild(cont->masterFrame,cont->activityFrame);
		cont->flags = cont->flags & ~CONTAINER_FLAG_HIDDEN;
	}
	return;
}



BOOL __cdecl lego::res::Container_IsHidden(Container *cont)
{
	return (cont->flags & 0xff) >> 3 & 1;
}



Container * __cdecl
lego::res::Container_SearchTree
					(Container *root,char *name,Container_SearchMode mode,uint *ref_count)
{
	char cVar1;
	Container *pCVar2;
	uint uVar3;
	Container_SearchData search;
	
	uVar3 = 0xffffffff;
	search.string = name;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *name;
		name = name + 1;
	} while (cVar1 != '\0');
	search.stringLen = ~uVar3 - 1;
	search.caseSensitive = 0;
	search.resultFrame = NULL;
	search.count = 0;
	search.mode = mode;
	if (ref_count == NULL) {
		search.matchNumber = 0;
	}
	else {
		search.matchNumber = *ref_count;
	}
	Container_Frame_WalkTree(root->masterFrame,0,Container_Frame_SearchCallback,&search);
	if ((mode == CONTAINER_SEARCHMODE_FIRSTMATCH) || (mode == CONTAINER_SEARCHMODE_NTHMATCH)) {
		if (search.resultFrame != NULL) {
			pCVar2 = Container_Frame_GetContainer(search.resultFrame);
			return pCVar2;
		}
	}
	else {
		if (mode == CONTAINER_SEARCHMODE_MATCHCOUNT) {
			*ref_count = search.count;
			return NULL;
		}
	}
	return NULL;
}



// Returns a temporary buffer that must be used immediately before the next call to this function.

char * __cdecl lego::res::Container_FormatPartName(Container *cont,char *partname,int *opt_instance)
{
	char *pcVar1;
	AnimClone *clone;
	BOOL BVar2;
	char *pcVar3;
	char *pcVar4;
	IDirect3DRMFrame3 *frame;
	char tempString [1024];
	
	if (cont->type == CONTAINER_FROMACTIVITY) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
	}
	else {
		if (cont->type == CONTAINER_ANIM) {
			frame = cont->activityFrame;
		}
	}
	clone = Container_Frame_GetAnimClone(frame);
	BVar2 = AnimClone_IsLws__Flic_GetWidth(clone);
	if (BVar2 == 0) {
		pcVar3 = Container_Frame_GetAnimSetFileName(frame);
		std::sprintf(tempString,"%s",pcVar3);
		std::_strlwr(tempString);
		pcVar4 = tempString;
		pcVar3 = tempString;
		while (tempString[0] != '\0') {
			if (tempString[0] == '\\') {
				pcVar3 = pcVar4 + 1;
			}
			pcVar1 = pcVar4 + 1;
			pcVar4 = pcVar4 + 1;
			tempString[0] = *pcVar1;
		}
		if (opt_instance != NULL) {
			std::sprintf(globs::s_FormatPartName_name,"xf_????????_%s_%s_%0.2d_DDc_00",partname,pcVar3,
									 *opt_instance);
			return globs::s_FormatPartName_name;
		}
		pcVar4 = "xf_????????_%s_%s_??_DDc_00";
	}
	else {
		if (opt_instance == NULL) {
			std::sprintf(globs::s_FormatPartName_name,"%s_??",partname);
			return globs::s_FormatPartName_name;
		}
		pcVar3 = (char *)*opt_instance;
		pcVar4 = "%s_%0.2i";
	}
	std::sprintf(globs::s_FormatPartName_name,pcVar4,partname,(int)pcVar3);
	return globs::s_FormatPartName_name;
}



void __cdecl lego::res::Container_SetUserData(Container *cont,void *data)
{
	cont->userData = data;
	return;
}



void * __cdecl lego::res::Container_GetUserData(Container *cont)
{
	return cont->userData;
}



void __cdecl lego::res::Container_EnableFog(BOOL on)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogEnable)
						((globs::containerGlobs.rootContainer)->masterFrame,on);
	if (on != 0) {
		(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneBackground)
							((globs::containerGlobs.rootContainer)->masterFrame,globs::containerGlobs.fogColour);
		return;
	}
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneBackground)
						((globs::containerGlobs.rootContainer)->masterFrame,0);
	return;
}



void __cdecl lego::res::Container_SetFogColour(float r,float g,float b)
{
	longlong lVar1;
	longlong lVar2;
	longlong lVar3;
	
	lVar1 = __ftol((float10)g * (float10)255.0);
	lVar2 = __ftol((float10)r * (float10)255.0);
	lVar3 = __ftol((float10)b * (float10)255.0);
	globs::containerGlobs.fogColour =
			 ((uint)lVar1 | ((uint)lVar2 | 0xffffff00) << 8) << 8 | (uint)lVar3;
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogColor)
						((globs::containerGlobs.rootContainer)->masterFrame,globs::containerGlobs.fogColour);
	return;
}



void __cdecl lego::res::Container_SetFogMode(D3DRMSceneFogMethod mode)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogMode)
						((globs::containerGlobs.rootContainer)->masterFrame,mode);
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogMethod)
						((globs::containerGlobs.rootContainer)->masterFrame,globs::mainGlobs.fogMethod);
	return;
}



void __cdecl lego::res::Container_SetFogParams(float start,float end,float density)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogParams)
						((globs::containerGlobs.rootContainer)->masterFrame,start,end,density);
	return;
}



void __cdecl lego::res::Container_SetPerspectiveCorrection(Container *cont,BOOL on)
{
	uint uVar1;
	IDirect3DRMFrame3 **out_frameList;
	D3DRMGroupIndex DVar2;
	IDirect3DRMFrame3 **ppIVar3;
	D3DRMGroupIndex groupID;
	
	if (cont->type == CONTAINER_FROMACTIVITY) {
		uVar1 = Container_GetActivities(cont,NULL,NULL,NULL);
		out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar1 * 4);
		Container_GetActivities(cont,out_frameList,NULL,NULL);
		ppIVar3 = out_frameList;
		for (; uVar1 != 0; uVar1 -= 1) {
			Container_Frame_WalkTree(*ppIVar3,0,Container_SetPerspectiveCorrectionCallback,&on);
			ppIVar3 = ppIVar3 + 1;
		}
		std::free(out_frameList);
		return;
	}
	if (cont->type == CONTAINER_MESH) {
		DVar2 = Container_Mesh_GetGroupCount(cont);
		groupID = D3DRMGROUP_0;
		if (DVar2 != D3DRMGROUP_0) {
			do {
				Container_Mesh_SetPerspectiveCorrection(cont,groupID,on);
				groupID += 1;
			} while (groupID < DVar2);
		}
	}
	return;
}



BOOL __cdecl
lego::res::Container_SetPerspectiveCorrectionCallback(IDirect3DRMFrame3 *frame,BOOL *lpArg_on)
{
	BOOL BVar1;
	HRESULT HVar2;
	IDirect3DRMVisual *pIVar3;
	IDirect3DRMVisual **ppIVar4;
	int *unaff_ESI;
	IDirect3DRMVisual *lpD3DRMVisual;
	BOOL *local_8;
	LPVOID local_4;
	
	BVar1 = *lpArg_on;
						// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount, IDirect3DRMVisualArray**
						// lplpVisuals)
						// 
						// First get count of array, to confirm its non-zero
	(*frame->lpVtbl->GetVisuals)(frame,(DWORD *)&lpArg_on,NULL);
	if (lpArg_on != NULL) {
						// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount, IDirect3DRMVisualArray**
						// lplpVisuals)
						// 
						// Then get the actual array
		(*frame->lpVtbl->GetVisuals)
							(frame,(DWORD *)&lpArg_on,(IDirect3DRMVisualArray **)globs::containerGlobs.visualArray
							);
		local_8 = NULL;
		if (lpArg_on != NULL) {
			ppIVar4 = globs::containerGlobs.visualArray;
			do {
				pIVar3 = *ppIVar4;
				HVar2 = (*pIVar3->lpVtbl->QueryInterface)
													((IUnknown *)pIVar3,(IID *)&idl::IID_IDirect3DRMMeshBuilder2,&local_4);
				if (HVar2 == 0) {
					(**(code **)(*unaff_ESI + 0x7c))(unaff_ESI,BVar1);
				}
				else {
					HVar2 = (*pIVar3->lpVtbl->QueryInterface)
														((IUnknown *)pIVar3,(IID *)&idl::IID_IDirect3DRMMesh,&local_8);
					if (HVar2 == 0) {
						pIVar3 = (IDirect3DRMVisual *)(*frame->lpVtbl->GetMaterialMode)(frame);
						lpD3DRMVisual = NULL;
						if (pIVar3 != NULL) {
							do {
								(*frame->lpVtbl->AddVisual)(frame,lpD3DRMVisual);
								lpD3DRMVisual =
										 (IDirect3DRMVisual *)((int)&lpD3DRMVisual->lpVtbl + D3DRMMATERIAL_FROMPARENT);
							} while (lpD3DRMVisual < pIVar3);
						}
					}
				}
				local_8 = (BOOL *)((int)local_8 + 1);
				ppIVar4 = ppIVar4 + 1;
			} while (local_8 < lpArg_on);
		}
	}
	return 0;
}



// WARNING: Type propagation algorithm not settling

IDirectDrawSurface4 * __cdecl
lego::res::Container_LoadTextureSurface
					(char *fname,BOOL managed,uint *out_width,uint *out_height,BOOL *out_trans)
{
	BITMAP_FILE_INFO_STRUCT *data;
	HRESULT HVar1;
	BOOL BVar2;
	IDirectDrawSurface4 *pIVar3;
	int iVar4;
	uint uVar5;
	DDSURFACEDESC2 *pDVar6;
	undefined4 *puVar7;
	DDSURFACEDESC2 *pDVar8;
	undefined4 *puVar9;
	DDPIXELFORMAT *pDVar10;
	IDirectDrawSurface4 *ddSurface4;
	uint local_14c;
	DDCOLORKEY local_148;
	IDirectDrawPalette *ddPal2;
	uint length;
	D3DRMImage d3dImage;
	DDSURFACEDESC2 surfDesc;
	DDSURFACEDESC2 local_7c;
	
	ddSurface4 = NULL;
	local_148.dwColorSpaceLowValue = 0;
	data = (BITMAP_FILE_INFO_STRUCT *)lego::file::File_LoadBinary(fname,&length);
	if (data != NULL) {
		lego::image::BMP_Parse(data,length,&d3dImage);
		if ((d3dImage.rgb == 0) && (d3dImage.depth == 8)) {
			pDVar6 = &surfDesc;
			for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
				pDVar6->dwSize = 0;
				pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
			}
			surfDesc.dwSize = 0x7c;
						// CMD_NM 0x20
			surfDesc.dwFlags = 0x1007;
			surfDesc.dwWidth = d3dImage.width;
			surfDesc.dwHeight = d3dImage.height;
			surfDesc.ddsCaps.dwCaps = 0x1000;
			if ((((byte)globs::mainGlobs.flags & 0x20) == 0) && (managed != 0)) {
				surfDesc.ddsCaps.dwCaps2 = 0x10;
			}
			else {
				surfDesc.ddsCaps.dwCaps = 0x5000;
			}
			surfDesc.ddpfPixelFormat.dwSize = 0x20;
			HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
												(globs::mainGlobs.device,0x800,4,&surfDesc.ddpfPixelFormat);
			if (HVar1 != 0) {
				pDVar6 = &surfDesc;
				pDVar8 = &local_7c;
				for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
					pDVar8->dwSize = pDVar6->dwSize;
					pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
					pDVar8 = (DDSURFACEDESC2 *)&pDVar8->dwFlags;
				}
				pDVar10 = &surfDesc.ddpfPixelFormat;
				for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
					pDVar10->dwSize = 0;
					pDVar10 = (DDPIXELFORMAT *)&pDVar10->dwFlags;
				}
				surfDesc.ddsCaps.dwCaps2 &= 0xffffffef;
				surfDesc.ddsCaps.dwCaps = surfDesc.ddsCaps.dwCaps & 0xffffafff | 0x840;
				surfDesc.ddpfPixelFormat.dwSize = 0x20;
				surfDesc.ddpfPixelFormat.dwFlags = 0x60;
				surfDesc.ddpfPixelFormat.dwRGBBitCount = 8;
				local_148.dwColorSpaceLowValue = 1;
			}
			HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
												(globs::directDrawGlobs.lpDirectDraw,&surfDesc,&ddSurface4,NULL);
			if (HVar1 == 0) {
				pDVar6 = &surfDesc;
				for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
					pDVar6->dwSize = 0;
					pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
				}
				surfDesc.dwSize = 0x7c;
				HVar1 = (*ddSurface4->lpVtbl->Lock)(ddSurface4,NULL,&surfDesc,1,NULL);
				if (HVar1 == 0) {
					iVar4 = 0;
					if (0 < d3dImage.height) {
						do {
							puVar7 = (undefined4 *)d3dImage.buffer1;
							puVar9 = (undefined4 *)surfDesc.lpSurface;
							for (uVar5 = (uint)d3dImage.bytes_per_line >> 2; uVar5 != 0; uVar5 -= 1) {
								*puVar9 = *puVar7;
								puVar7 = puVar7 + 1;
								puVar9 = puVar9 + 1;
							}
							for (uVar5 = d3dImage.bytes_per_line & 3; uVar5 != 0; uVar5 -= 1) {
								*(undefined *)puVar9 = *(undefined *)puVar7;
								puVar7 = (undefined4 *)((int)puVar7 + 1);
								puVar9 = (undefined4 *)((int)puVar9 + 1);
							}
							surfDesc.lpSurface = (LPVOID)((int)surfDesc.lpSurface + surfDesc.lPitch);
							d3dImage.buffer1 = (byte *)((int)d3dImage.buffer1 + d3dImage.bytes_per_line);
							iVar4 += 1;
						} while (iVar4 < d3dImage.height);
					}
					(*ddSurface4->lpVtbl->Unlock)(ddSurface4,NULL);
					HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreatePalette)
														(globs::directDrawGlobs.lpDirectDraw,0x4c,
														 (D3DRMPaletteEntry *)d3dImage.alpha_mask,
														 (IDirectDrawPalette **)&local_148.dwColorSpaceHighValue,NULL);
					if (HVar1 == 0) {
						HVar1 = (*ddSurface4->lpVtbl->SetPalette)(ddSurface4,ddPal2);
						if (HVar1 == 0) {
							if (local_148.dwColorSpaceLowValue != 0) {
								pDVar10 = &local_7c.ddpfPixelFormat;
								for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
									pDVar10->dwSize = 0;
									pDVar10 = (DDPIXELFORMAT *)&pDVar10->dwFlags;
								}
								local_7c.ddpfPixelFormat.dwSize = 0x20;
								HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
																	(globs::mainGlobs.device,0x400,0,&local_7c.ddpfPixelFormat);
								pIVar3 = ddSurface4;
								if ((HVar1 == 0) &&
									 (HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
																			(globs::directDrawGlobs.lpDirectDraw,&local_7c,&ddSurface4,
																			 NULL), HVar1 == 0)) {
									if (local_7c.ddpfPixelFormat.dwRGBBitCount == 0x10) {
										ddraw::DirectDraw_Blt8To16(ddSurface4,pIVar3,d3dImage.palette);
									}
									(*pIVar3->lpVtbl->Release)(pIVar3);
								}
							}
							if (out_trans != NULL) {
								BVar2 = Container_GetDecalColour(fname,&local_14c);
								if (BVar2 == 0) {
									*out_trans = 0;
								}
								else {
									if (local_148.dwColorSpaceLowValue != 0) {
										local_14c = ddraw::DirectDraw_GetColour
																					(ddSurface4,
																					 (uint)CONCAT21(CONCAT11(d3dImage.palette[local_14c].red,
																																	 d3dImage.palette[local_14c].green
																																	),d3dImage.palette[local_14c].blue
																												 ));
									}
									local_148.dwColorSpaceLowValue = local_14c;
									local_148.dwColorSpaceHighValue = local_14c;
									(*ddSurface4->lpVtbl->SetColorKey)(ddSurface4,8,&local_148);
									*out_trans = 1;
								}
							}
							if (out_width != NULL) {
								*out_width = d3dImage.width;
							}
							if (out_height != NULL) {
								*out_height = d3dImage.height;
							}
							(*ddSurface4->lpVtbl->AddRef)((IUnknown *)ddSurface4);
						}
						(*ddPal2->lpVtbl->Release)(ddPal2);
					}
				}
				pIVar3 = (IDirectDrawSurface4 *)(*ddSurface4->lpVtbl->Release)(ddSurface4);
				if (pIVar3 == NULL) {
					ddSurface4 = pIVar3;
				}
			}
		}
		lego::image::BMP_Cleanup(&d3dImage);
		std::free(data);
	}
	return ddSurface4;
}



BOOL __cdecl lego::res::Container_GetDecalColour(char *fname,uint *out_colour)
{
	char *pcVar1;
	byte *str;
	char cVar2;
	uint uVar3;
	char *pcVar4;
	
	cVar2 = *fname;
	pcVar4 = fname;
	while (cVar2 != '\0') {
		if (cVar2 == '\\') {
			pcVar4 = fname + 1;
		}
		pcVar1 = fname + 1;
		fname = fname + 1;
		cVar2 = *pcVar1;
	}
	if ((*pcVar4 == 'a') || (*pcVar4 == 'A')) {
		str = (byte *)(pcVar4 + 1);
						// std::isdigit(c)
		if (std::globals::_pcharwidth < 2) {
			uVar3 = *(byte *)(std::globals::_pctype + *str) & C1_DIGIT;
		}
		else {
			uVar3 = std::_isctype((uint)*str,4);
		}
		if (uVar3 != 0) {
						// std::isdigit(c)
			if (std::globals::_pcharwidth < 2) {
				uVar3 = *(byte *)(std::globals::_pctype + (byte)pcVar4[2]) & C1_DIGIT;
			}
			else {
				uVar3 = std::_isctype((uint)(byte)pcVar4[2],4);
			}
			if (uVar3 != 0) {
						// std::isdigit(c)
				if (std::globals::_pcharwidth < 2) {
					uVar3 = *(byte *)(std::globals::_pctype + (byte)pcVar4[3]) & C1_DIGIT;
				}
				else {
					uVar3 = std::_isctype((uint)(byte)pcVar4[3],4);
				}
				if ((uVar3 != 0) && (pcVar4[4] == '_')) {
					uVar3 = std::atoi((char *)str);
					*out_colour = uVar3;
					return TRUE;
				}
			}
		}
	}
	return 0;
}



// WARNING: Type propagation algorithm not settling

Container_Texture * __cdecl
lego::res::Container_LoadTexture2(char *fname,BOOL immediate,uint *out_width,uint *out_height)
{
	byte bVar1;
	byte bVar2;
	D3DRMPaletteEntry *pDVar3;
	int *piVar4;
	char *lpFileName;
	Container_Texture *buffer;
	IDirectDrawSurface4 *This;
	HRESULT HVar5;
	BOOL BVar6;
	D3DRMImage *pDVar7;
	int *piVar8;
	byte bVar9;
	undefined uVar10;
	ushort uVar11;
	undefined uVar12;
	undefined uVar13;
	undefined2 uVar14;
	IDirect3DRMTexture3 *local_c;
	Container_Texture *local_8;
	undefined4 uStack4;
	
	local_c = NULL;
	lpFileName = lego::file::File_VerifyFilename(fname);
	buffer = (Container_Texture *)std::malloc(0xc);
	if (buffer != NULL) {
		local_8 = buffer;
		if (immediate == 0) {
			HVar5 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->LoadTexture)
												(globs::mainGlobs.lpD3DRM,lpFileName,&local_c);
			if (HVar5 == 0) {
				pDVar7 = (*local_c->lpVtbl->GetImage)(local_c);
				if (pDVar7 != NULL) {
					BVar6 = Container_GetDecalColour(fname,(uint *)&fname);
					if (BVar6 != 0) {
						pDVar3 = pDVar7->palette;
						bVar9 = pDVar3[(int)fname].red;
						bVar1 = pDVar3[(int)fname].blue;
						bVar2 = pDVar3[(int)fname].green;
						(*local_c->lpVtbl->SetDecalTransparency)(local_c,1);
						(*local_c->lpVtbl->SetDecalTransparentColor)
											(local_c,(uint)CONCAT21(CONCAT11(bVar9,bVar2),bVar1));
						buffer = local_8;
					}
					if (out_width != NULL) {
						*out_width = pDVar7->width;
					}
					if ((IDirectDrawPalette *)out_height != NULL) {
						*out_height = (uint)((IDirectDrawPalette *)&pDVar7->height)->lpVtbl;
					}
				}
				buffer->surface = NULL;
				buffer->texture = local_c;
				(*local_c->lpVtbl->SetAppData)((IUnknown *)local_c,(DWORD)buffer);
				return buffer;
			}
		}
		else {
			This = Container_LoadTextureSurface(fname,immediate,out_width,out_height,NULL);
			if (This != NULL) {
				HVar5 = (*This->lpVtbl->QueryInterface)
													((IUnknown *)This,(IID *)&idl::IID_IDirectDrawSurface,&out_width);
				if (HVar5 == 0) {
					HVar5 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateTextureFromSurface)
														(globs::mainGlobs.lpD3DRM,(IDirectDrawSurface4 *)out_width,&local_c);
					if (HVar5 == 0) {
						(**(code **)(*out_width + 8))((IUnknown *)out_width);
						BVar6 = Container_GetDecalColour(fname,(uint *)&fname);
						if (BVar6 != 0) {
							(*This->lpVtbl->GetPalette)(This,(IDirectDrawPalette **)&out_height);
							uVar12 = 1;
							uVar13 = 0;
							uVar14 = 0;
							bVar9 = (byte)uStack4;
							uVar10 = (undefined)((uint)uStack4 >> 8);
							uVar11 = (ushort)((uint)uStack4 >> 0x10);
							piVar8 = NULL;
						// IDirectDrawPalette::GetEntries(THIS_ DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries,
						// D3DRMPALETTEENTRY* lpEntries)
							(**(code **)(*(int *)immediate + 0x10))(immediate,0,bVar9,1,&stack0xfffffff0);
							(*local_c->lpVtbl->Release)((IUnknown *)local_c);
							piVar4 = (int *)CONCAT22(uVar14,CONCAT11(uVar13,uVar12));
							(**(code **)(*piVar4 + 0x50))(piVar4,1);
							(**(code **)(*piVar8 + 0x54))
												(piVar8,((uint)bVar9 << 8 | CONCAT21(uVar11,uVar10) & 0xff) << 8 |
																uVar11 & 0xff);
						}
						buffer->surface = This;
						buffer->texture = local_c;
						(*local_c->lpVtbl->SetAppData)((IUnknown *)local_c,(DWORD)buffer);
						return buffer;
					}
					(**(code **)(*out_width + 8))();
				}
				(*This->lpVtbl->Release)((IUnknown *)This);
				std::free(buffer);
				return NULL;
			}
		}
		std::free(buffer);
	}
	return NULL;
}



void __cdecl lego::res::Container_FreeTexture(Container_Texture *text)
{
	IDirectDrawSurface4 *pIVar1;
	IDirect3DRMTexture3 *pIVar2;
	ULONG UVar3;
	
	if (text != NULL) {
		pIVar1 = text->surface;
		if (pIVar1 != NULL) {
			UVar3 = (*pIVar1->lpVtbl->Release)(pIVar1);
			while (UVar3 != 0) {
				UVar3 = (*text->surface->lpVtbl->Release)(text->surface);
			}
		}
		pIVar2 = text->texture;
		if (pIVar2 != NULL) {
			UVar3 = (*pIVar2->lpVtbl->Release)(pIVar2);
			while (UVar3 != 0) {
				UVar3 = (*text->texture->lpVtbl->Release)(text->texture);
			}
		}
	}
	return;
}



void __cdecl lego::res::Container_Mesh_Swap(Container *target,Container *origin,BOOL restore)
{
	IDirect3DRMVisual *pIVar1;
	IDirect3DRMMesh *lpD3DRMVisual;
	int unaff_EBX;
	uint uVar2;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMFrame3 *This;
	
	if (target->type == CONTAINER_REFERENCE) {
		This = target->masterFrame;
	}
	else {
		This = target->activityFrame;
	}
	if (restore != 0) {
						// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount, IDirect3DRMVisualArray**
						// lplpVisuals)
						// 
						// First get count of array, to confirm its non-zero
		(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,NULL);
		if (restore != 0) {
						// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount, IDirect3DRMVisualArray**
						// lplpVisuals)
						// 
						// Then get the actual array
			(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,globs::containerGlobs.visualArray);
			uVar2 = 0;
			if (restore != 0) {
				ppIVar3 = globs::containerGlobs.visualArray;
				do {
					(*This->lpVtbl->DeleteVisual)(This,*ppIVar3);
					uVar2 += 1;
					ppIVar3 = ppIVar3 + 1;
				} while (uVar2 < (uint)restore);
			}
		}
		(*target->hiddenFrame->lpVtbl->GetVisuals)(target->hiddenFrame,(DWORD *)&restore,NULL);
		if (restore != 0) {
			(*target->hiddenFrame->lpVtbl->GetVisuals)
								(target->hiddenFrame,(DWORD *)&restore,globs::containerGlobs.visualArray);
			uVar2 = 0;
			if (restore != 0) {
				ppIVar3 = globs::containerGlobs.visualArray;
				do {
					pIVar1 = *ppIVar3;
					(*This->lpVtbl->AddVisual)(This,pIVar1);
					(**(code **)(**(int **)(unaff_EBX + 8) + 0xa0))(*(int **)(unaff_EBX + 8),pIVar1);
					uVar2 += 1;
					ppIVar3 = ppIVar3 + 1;
				} while (uVar2 < (uint)restore);
			}
		}
		target->flags = target->flags & ~CONTAINER_FLAG_MESHSWAPPED;
		return;
	}
	(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,NULL);
	if (restore != 0) {
		(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,(IDirect3DRMVisual **)0x76be24);
		uVar2 = 0;
		if (restore != 0) {
			ppIVar3 = globs::containerGlobs.visualArray;
			do {
				pIVar1 = *ppIVar3;
				(*target->hiddenFrame->lpVtbl->AddVisual)(target->hiddenFrame,pIVar1);
				(*This->lpVtbl->DeleteVisual)(This,pIVar1);
				uVar2 += 1;
				ppIVar3 = ppIVar3 + 1;
			} while (uVar2 < (uint)restore);
		}
	}
	if (origin != NULL) {
		lpD3DRMVisual = origin->typeData->mesh;
		if (lpD3DRMVisual == NULL) {
			(*This->lpVtbl->AddVisual)(This,(IDirect3DRMVisual *)origin->typeData->transMesh->uv);
			target->flags = target->flags | CONTAINER_FLAG_MESHSWAPPED;
			return;
		}
		(*This->lpVtbl->AddVisual)(This,(IDirect3DRMVisual *)lpD3DRMVisual);
	}
	target->flags = target->flags | CONTAINER_FLAG_MESHSWAPPED;
	return;
}



uint __cdecl
lego::res::Container_Mesh_AddGroup
					(Container *cont,uint vertexCount,uint faceCount,uint vPerFace,uint *faceData)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	void *pvVar1;
	void **ppvVar2;
	HRESULT HVar3;
	int *unaff_EDI;
	IDirect3DRMVisual *local_4;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		pvVar1 = (void *)Mesh_AddGroup(mesh,vertexCount,faceCount,vPerFace,faceData);
		return (uint)pvVar1;
	}
	This = cont->typeData->mesh;
	ppvVar2 = (void **)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (ppvVar2 != NULL) {
		if (ppvVar2[4] == NULL) {
			if (ppvVar2[1] == ppvVar2[2]) {
				return (uint)(void *)0xffffffff;
			}
			HVar3 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMesh)
												(globs::mainGlobs.lpD3DRM,(IDirect3DRMMesh **)&cont);
			if (HVar3 != 0) {
				return (uint)(void *)0xffffffff;
			}
			*(IDirect3DRMVisual **)((int)*ppvVar2 + (int)ppvVar2[1] * 4) = local_4;
			ppvVar2[1] = (void *)((int)ppvVar2[1] + 1);
			(*cont->activityFrame->lpVtbl->AddVisual)(cont->activityFrame,local_4);
			(**(code **)(*unaff_EDI + 0x18))(unaff_EDI,(uint)ppvVar2[1] | 0x80000000);
			if ((ppvVar2[1] == ppvVar2[2]) &&
				 (pvVar1 = std::realloc(*ppvVar2,(int)ppvVar2[2] * 4 + 0x50), pvVar1 != NULL)) {
				*ppvVar2 = pvVar1;
				ppvVar2[2] = (void *)((int)ppvVar2[2] + 0x14);
			}
		}
		else {
			ppvVar2[4] = NULL;
		}
	}
	HVar3 = (*This->lpVtbl->AddGroup)
										(This,vertexCount,faceCount,vPerFace,faceData,(D3DRMGroupIndex *)&local_4);
	if (HVar3 != 0) {
		return (uint)(void *)0xffffffff;
	}
	if (ppvVar2 == NULL) {
		return (uint)(void *)faceCount;
	}
	return (uint)ppvVar2[1];
}



uint __cdecl lego::res::Container_Mesh_GetGroupCount(Container *cont)
{
	Mesh *mesh;
	IDirect3DRMMesh *pIVar1;
	uint uVar2;
	DWORD DVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		uVar2 = Mesh_GetGroupCount(mesh);
		return uVar2;
	}
	pIVar1 = cont->typeData->mesh;
	DVar3 = (*pIVar1->lpVtbl->GetAppData)((IUnknown *)pIVar1);
	if (DVar3 != 0) {
		return *(int *)(DVar3 + 4) + 1;
	}
	pIVar1 = cont->typeData->mesh;
	uVar2 = (*pIVar1->lpVtbl->GetGroupCount)(pIVar1);
	return uVar2;
}



void __cdecl
lego::res::Container_Mesh_SetQuality
					(Container *cont,D3DRMGroupIndex groupID,GraphicsQuality quality)
{
	Container *pCVar1;
	D3DRMRenderQuality uVar2;
	
	pCVar1 = cont;
	if (cont->typeData->transMesh == NULL) {
						// D3DRM render quality, same as seen with Main::Quality
		uVar2 = 0x40;
		if (quality != QUALITY_WIREFRAME) {
			uVar2 = groupID;
		}
		if (quality == QUALITY_UNLITFLAT) {
			uVar2 = D3DRMRENDER_UNLITFLAT;
		}
		if (quality == QUALITY_FLAT) {
			uVar2 = 0x88;
		}
		if (quality == QUALITY_GOURAUD) {
			uVar2 = 0x89;
		}
		cont = (Container *)cont->typeData->mesh;
		Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
		(*pCVar1->typeData->mesh->lpVtbl->SetGroupQuality)((IDirect3DRMMesh *)cont,groupID,uVar2);
	}
	return;
}



BOOL __cdecl lego::res::Container_Mesh_IsGroupHidden(Container *cont,D3DRMGroupIndex group)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	Container *pCVar1;
	int *piVar2;
	uint uVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		pCVar1 = (Container *)Mesh_IsGroupHidden(mesh,group);
		return (BOOL)pCVar1;
	}
	This = cont->typeData->mesh;
	piVar2 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (piVar2 != NULL) {
		if (cont != NULL) {
			piVar2 = *(int **)(*piVar2 + -4 + (int)cont * 4);
			uVar3 = (**(code **)(*piVar2 + 0x1c))(piVar2);
			return (BOOL)(~uVar3 >> 0x1f);
		}
		return (BOOL)(Container *)piVar2[3];
	}
	return (BOOL)cont;
}



void __cdecl lego::res::Container_Mesh_HideGroup(Container *cont,D3DRMGroupIndex group,BOOL hide)
{
	Mesh *mesh;
	int *piVar1;
	DWORD DVar2;
	uint uVar3;
	IDirect3DRMMesh *This;
	IDirect3DRMMesh *This_00;
	int unaff_retaddr;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_HideGroup(mesh,group,hide);
		return;
	}
	This_00 = cont->typeData->mesh;
	piVar1 = (int *)(*This_00->lpVtbl->GetAppData)((IUnknown *)This_00);
	if (piVar1 == NULL) {
		return;
	}
	if (cont == NULL) {
		uVar3 = piVar1[3];
		This = NULL;
	}
	else {
		This = *(IDirect3DRMMesh **)(*piVar1 + -4 + (int)cont * 4);
		DVar2 = (*This->lpVtbl->GetAppData)((IUnknown *)This);
		uVar3 = ~DVar2 >> 0x1f;
		This_00 = This;
	}
	if (group != D3DRMGROUP_0) {
		if (uVar3 == 0) {
			(**(code **)(**(int **)(unaff_retaddr + 4) + 0xa0))(*(int **)(unaff_retaddr + 4),This_00);
			goto LAB_00474e84;
		}
		if (group != D3DRMGROUP_0) goto LAB_00474e84;
	}
	if (uVar3 != 0) {
		(**(code **)(**(int **)(unaff_retaddr + 4) + 0x48))(*(int **)(unaff_retaddr + 4),This_00);
	}
LAB_00474e84:
	if (This == NULL) {
		piVar1[3] = group;
		return;
	}
	DVar2 = (*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (group == D3DRMGROUP_0) {
		(*This->lpVtbl->SetAppData)((IUnknown *)This,DVar2 & 0x7fffffff | 0x80000000);
		return;
	}
	(*This->lpVtbl->SetAppData)((IUnknown *)This,DVar2 & 0x7fffffff);
	return;
}



BOOL __cdecl
lego::res::Container_Mesh_HandleSeperateMeshGroups
					(IDirect3DRMMesh **ref_mesh,D3DRMGroupIndex *ref_groupID)
{
	int *piVar1;
	
	piVar1 = (int *)(*(*ref_mesh)->lpVtbl->GetAppData)(*ref_mesh);
	if (piVar1 != NULL) {
		if (*ref_groupID != D3DRMGROUP_0) {
			*ref_mesh = *(IDirect3DRMMesh **)(*piVar1 + -4 + *ref_groupID * 4);
		}
		*ref_groupID = D3DRMGROUP_0;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::res::Container_Mesh_GetGroup
					(Container *cont,D3DRMGroupIndex groupID,uint *out_vertexCount,uint *out_faceCount,
					uint *out_vPerFace,uint *out_faceDataSize,uint *out_faceData)
{
	Mesh *mesh;
	Mesh_Group *pMVar1;
	int iVar2;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		pMVar1 = Mesh_GetGroup(mesh,groupID,out_vertexCount,out_faceCount,out_vPerFace,out_faceDataSize,
													 out_faceData);
		return (BOOL)pMVar1;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	iVar2 = (*(code *)cont->masterFrame[0x17].lpVtbl)
										(cont,groupID,out_vertexCount,out_faceCount,out_vPerFace,out_faceDataSize,
										 out_faceData);
	return (BOOL)(Mesh_Group *)(uint)(iVar2 == 0);
}



// Returns -1 on failure, and 0 on success

uint __cdecl
lego::res::Container_Mesh_GetVertices
					(Container *cont,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *out_retArray)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_GetVertices(mesh,groupID,index,count,out_retArray);
		return groupID;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	DVar1 = (*(code *)cont->masterFrame[0x18].lpVtbl)(cont,groupID,index,count,out_retArray);
	if (DVar1 != D3DRMGROUP_0) {
		DVar1 = D3DRMGROUP_ALLGROUPS;
	}
	return DVar1;
}



uint __cdecl
lego::res::Container_Mesh_SetVertices
					(Container *cont,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *values)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	
						// Returns 0 on success and -1 on failure
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetVertices(mesh,groupID,index,count,values);
		return groupID;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	DVar1 = (*(code *)cont->masterFrame[0xf].lpVtbl)(cont,groupID,index,count,values);
	if (DVar1 != D3DRMGROUP_0) {
		DVar1 = D3DRMGROUP_ALLGROUPS;
	}
	return DVar1;
}



void __cdecl
lego::res::Container_Mesh_SetTexture
					(Container *cont,D3DRMGroupIndex groupID,Container_Texture *ref_itext)
{
	Mesh *mesh;
	IDirect3DRMTexture3 *This;
	int *unaff_retaddr;
	
	if (ref_itext == NULL) {
		This = NULL;
	}
	else {
		This = ref_itext->texture;
	}
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetGroupTexture(mesh,groupID,ref_itext);
		return;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	if (This == NULL) {
		ref_itext = NULL;
	}
	else {
		(*This->lpVtbl->QueryInterface)((IUnknown *)This,(IID *)&idl::IID_IDirect3DRMTexture,&ref_itext)
		;
	}
						// IDirect3DRMMesh->SetGroupTexture(this, D3DRMGroupIndex id, IDirect3DRMTexture*
						// lpTexture)
	(*(code *)cont->masterFrame[0x15].lpVtbl)(cont,groupID,ref_itext);
	if (unaff_retaddr != NULL) {
		(**(code **)(*unaff_retaddr + 8))(unaff_retaddr);
	}
	return;
}



void __cdecl
lego::res::Container_Mesh_SetPerspectiveCorrection(Container *cont,D3DRMGroupIndex groupID,BOOL on)
{
	if (cont->typeData->transMesh == NULL) {
		cont = (Container *)cont->typeData->mesh;
		Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
						// IDirect3DRMMesh->SetGroupMapping(this, int id, D3DRMMapping value)
						//   D3DRMMAP_WRAPU        = 0x1,
						//   D3DRMMAP_WRAPV        = 0x2,
						//   D3DRMMAP_PERSPCORRECT = 0x4,
		if (on != 0) {
			(*(code *)cont->masterFrame[0x12].lpVtbl)((IDirect3DRMMesh *)cont,groupID,4);
			return;
		}
		(*(code *)cont->masterFrame[0x12].lpVtbl)((IDirect3DRMMesh *)cont,groupID,0);
	}
	return;
}



BOOL __cdecl lego::res::Container_Mesh_Scale(Container *cont,float x,float y,float z)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	int *piVar1;
	int *piVar2;
	undefined4 unaff_ESI;
	uint uVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_Scale(mesh,x,y,z);
		return 0;
	}
	This = cont->typeData->mesh;
	(*This->lpVtbl->Scale)(This,x,y,z);
	piVar2 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if ((piVar2 != NULL) && (uVar3 = 0, piVar2[1] != 0)) {
		do {
			piVar1 = *(int **)(*piVar2 + uVar3 * 4);
			(**(code **)(*piVar1 + 0x2c))(piVar1,unaff_ESI,y,z);
			uVar3 += 1;
		} while (uVar3 < (uint)piVar2[1]);
	}
	return 0;
}



BOOL __cdecl lego::res::Container_Mesh_GetBox(Container *cont,D3DRMBox *out_box)
{
	float fVar1;
	IDirect3DRMMesh *This;
	int *piVar2;
	int *piVar3;
	float unaff_EBX;
	float unaff_ESI;
	float unaff_EDI;
	uint uVar4;
	float local_18;
	float local_14;
	float local_10;
	
	This = cont->typeData->mesh;
	(*This->lpVtbl->GetBox)(This,out_box);
	piVar3 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if ((piVar3 != NULL) && (uVar4 = 0, piVar3[1] != 0)) {
		do {
			piVar2 = *(int **)(*piVar3 + uVar4 * 4);
			(**(code **)(*piVar2 + 0x34))(piVar2,&stack0xffffffdc);
			if (unaff_EDI < (out_box->min).x) {
				(out_box->min).x = unaff_EDI;
			}
			if (unaff_ESI < (out_box->min).y) {
				(out_box->min).y = unaff_ESI;
			}
			if (unaff_EBX < (out_box->min).z) {
				(out_box->min).z = unaff_EBX;
			}
			fVar1 = (out_box->max).x;
			if ((ushort)((ushort)(local_18 < fVar1) << 8 | (ushort)(local_18 == fVar1) << 0xe) == 0) {
				(out_box->max).x = local_18;
			}
			fVar1 = (out_box->max).y;
			if ((ushort)((ushort)(local_14 < fVar1) << 8 | (ushort)(local_14 == fVar1) << 0xe) == 0) {
				(out_box->max).y = local_14;
			}
			fVar1 = (out_box->max).z;
			if ((ushort)((ushort)(local_10 < fVar1) << 8 | (ushort)(local_10 == fVar1) << 0xe) == 0) {
				(out_box->max).z = local_10;
			}
			uVar4 += 1;
		} while (uVar4 < (uint)piVar3[1]);
	}
	return 0;
}



void __cdecl
lego::res::Container_Mesh_SetEmissive
					(Container *cont,D3DRMGroupIndex groupID,float r,float g,float b)
{
	Mesh *mesh;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetGroupColour(mesh,groupID,r,g,b,MATERIAL_EMISSIVE);
	}
	return;
}



void __cdecl
lego::res::Container_Mesh_SetColourAlpha
					(Container *cont,D3DRMGroupIndex groupID,float r,float g,float b,float a)
{
	Mesh *mesh;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetGroupColour(mesh,groupID,r,g,b,MATERIAL_DIFFUSE);
		Mesh_SetGroupMaterialValues(mesh,groupID,a,MATERIAL_ALPHA);
	}
	return;
}



void __cdecl
lego::res::Container_Transform(Container *cont,Vector3F *out_vector,Vector3F *in_vector)
{
	(*(code *)cont->masterFrame->lpVtbl->Transform)(cont->masterFrame,out_vector,in_vector);
	return;
}



void __cdecl
lego::res::Container_InverseTransform(Container *cont,Vector3F *out_vector,Vector3F *in_vector)
{
	(*cont->masterFrame->lpVtbl->InverseTransform)(cont->masterFrame,out_vector,in_vector);
	return;
}



void __cdecl lego::res::Container_SetColourAlpha(Container *cont,float r,float g,float b,float a)
{
	IDirect3DRMLight *This;
	longlong lVar1;
	longlong lVar2;
	longlong lVar3;
	longlong lVar4;
	
	lVar1 = __ftol((float10)r * (float10)255.0);
	lVar2 = __ftol((float10)a * (float10)255.0);
	lVar3 = __ftol((float10)g * (float10)255.0);
	lVar4 = __ftol((float10)b * (float10)255.0);
	if (cont->type == CONTAINER_LIGHT) {
		This = cont->typeData->light;
		(*This->lpVtbl->SetColor)
							(This,(((uint)lVar1 | (int)lVar2 << 8) << 8 | (uint)lVar3) << 8 | (uint)lVar4);
	}
	return;
}



float10 __cdecl lego::res::Container_MoveAnimation(Container *cont,float delta)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(cont);
	fVar1 = Container_SetAnimationTime(cont,(float)(fVar1 + (float10)delta));
	return fVar1;
}



float10 __cdecl lego::res::Container_SetAnimationTime(Container *cont,float time)
{
	float fVar1;
	IDirect3DRMFrame3 *frame;
	char *sampleName;
	uint uVar2;
	uint uVar3;
	ContainerFlags CVar4;
	float10 fVar5;
	AnimClone *local_14;
	float local_10;
	
	local_14 = NULL;
	local_10 = 0.0;
	if (cont->type == CONTAINER_FROMACTIVITY) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
		if ((frame != NULL) &&
			 (local_14 = Container_Frame_GetAnimClone(frame),
			 (*(byte *)&cont->flags & CONTAINER_FLAG_TRIGGERSAMPLE) != 0)) {
			sampleName = Container_Frame_GetSample(frame);
			if ((sampleName != NULL) &&
				 ((globs::containerGlobs.soundTriggerCallback != NULL &&
					(((byte)globs::containerGlobs.flags & CONTAINER_FLAG_TRIGGERENABLED) != 0)))) {
				(*globs::containerGlobs.soundTriggerCallback)
									(sampleName,cont,globs::containerGlobs.soundTriggerData);
			}
			cont->flags = cont->flags & ~CONTAINER_FLAG_TRIGGERSAMPLE;
		}
	}
	else {
		frame = (IDirect3DRMFrame3 *)time;
		if (cont->type == CONTAINER_ANIM) {
			local_14 = Container_Frame_GetAnimClone(cont->activityFrame);
			frame = cont->activityFrame;
		}
	}
	if (local_14 != NULL) {
		CVar4 = cont->flags & CONTAINER_FLAG_HIDDEN;
		fVar5 = Container_GetAnimationTime(cont);
		uVar2 = Container_Frame_GetFrameCount(frame);
		Container_Frame_SetAppData(frame,NULL,NULL,NULL,NULL,NULL,&time,NULL,NULL,NULL,NULL);
		if (uVar2 != 0) {
			uVar2 -= 1;
			fVar1 = (float)(ulonglong)uVar2;
			if ((ushort)((ushort)(time < fVar1) << 8 | (ushort)(time == fVar1) << 0xe) == 0) {
				local_10 = time - fVar1;
				CVar4 = CONTAINER_FLAG_NONE;
			}
		}
		if (CVar4 == CONTAINER_FLAG_NONE) {
			uVar3 = Container_Frame_GetTrigger(frame);
			fVar1 = (float)(ulonglong)uVar3;
			if ((((uVar2 != 1) &&
					 (AnimClone_SetTime(local_14,time,NULL),
					 globs::containerGlobs.triggerFrameCallback != NULL)) && (fVar1 != 0.0)) &&
				 (((float)fVar5 < fVar1 && (fVar1 <= time)))) {
				(*globs::containerGlobs.triggerFrameCallback)(cont,globs::containerGlobs.triggerFrameData);
				return (float10)local_10;
			}
		}
		else {
			cont->flags = cont->flags | CONTAINER_FLAG_ANIMATIONSKIPPED;
		}
	}
	return (float10)local_10;
}



void __cdecl lego::res::Container_ForceAnimationUpdate(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	Container *pCVar1;
	float10 fVar2;
	
	if ((*(byte *)&cont->flags & CONTAINER_FLAG_ANIMATIONSKIPPED) != 0) {
		pCVar1 = cont;
		if (cont->type == CONTAINER_FROMACTIVITY) {
			frame = Container_Frame_Find(cont,cont->typeData->name,0);
			if (frame != NULL) {
				pCVar1 = (Container *)Container_Frame_GetAnimClone(frame);
				fVar2 = Container_Frame_GetCurrTime(frame);
				cont = (Container *)(float)fVar2;
			}
		}
		else {
			if (cont->type == CONTAINER_ANIM) {
				pCVar1 = (Container *)Container_Frame_GetAnimClone(cont->activityFrame);
				fVar2 = Container_Frame_GetCurrTime(cont->activityFrame);
				cont = (Container *)(float)fVar2;
			}
		}
		if (pCVar1 != NULL) {
			AnimClone_SetTime((AnimClone *)pCVar1,(float)cont,NULL);
		}
	}
	return;
}



float10 __cdecl lego::res::Container_GetAnimationTime(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	float10 fVar1;
	
	fVar1 = (float10)0.0;
	if (cont->type == CONTAINER_FROMACTIVITY) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
		if (frame != NULL) {
			fVar1 = Container_Frame_GetCurrTime(frame);
			return fVar1;
		}
		fVar1 = (float10)(float)fVar1;
	}
	else {
		if (cont->type == CONTAINER_ANIM) {
			fVar1 = Container_Frame_GetCurrTime(cont->activityFrame);
			return fVar1;
		}
	}
	return fVar1;
}



uint __cdecl lego::res::Container_GetAnimationFrames(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	uint uVar1;
	
	frame = NULL;
	if (cont->type == CONTAINER_FROMACTIVITY) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
	}
	else {
		if (cont->type == CONTAINER_ANIM) {
			frame = cont->activityFrame;
		}
	}
	if (frame != NULL) {
		uVar1 = Container_Frame_GetFrameCount(frame);
		return uVar1;
	}
	return 0;
}



void __cdecl
lego::res::Container_SetPosition(Container *cont,Container *opt_ref,float x,float y,float z)
{
						// IDirect3DRMFrame3->SetPosition(this, IDirect3DRMFrame3* lpRef, float rvX, float rvY,
						// float rvZ)
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
	(*(code *)opt_ref->masterFrame[0x3c].lpVtbl)(opt_ref,cont,x,y,z);
	return;
}



void __cdecl
lego::res::Container_SetOrientation
					(Container *cont,Container *opt_ref,float dirx,float diry,float dirz,float upx,float upy,
					float upz)
{
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
						// IDirect3DRMFrame3->SetOrientation(this, IDirect3DRMFrame3* lpRef, float rvDx, float
						// rvDy, float rvDz, float rvUx, float rvUy, float rvUz)
	(*(code *)opt_ref->masterFrame[0x3b].lpVtbl)(opt_ref,cont,dirx,diry,dirz,upx,upy,upz);
	return;
}



void __cdecl lego::res::Container_GetPosition(Container *cont,Container *opt_ref,Vector3F *out_pos)
{
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
						// IDirect3DRMFrame3->GetPosition(this, IDirect3DRMFrame3* lpRef, Vector3F* lprvPos)
	(*(code *)opt_ref->masterFrame[0x18].lpVtbl)(opt_ref,cont,out_pos);
	return;
}



void __cdecl
lego::res::Container_GetOrientation
					(Container *cont,Container *opt_ref,Vector3F *out_dir,Vector3F *out_up)
{
	Vector3F **unaff_retaddr;
	Vector3F *pVVar1;
	Vector3F *pVVar2;
	Vector3F dvector;
	Vector3F uvector;
	
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
	pVVar1 = &dvector;
	pVVar2 = &uvector;
						// IDirect3DRMFrame3->GetOrientation(this, IDirect3DRMFrame3* lpRef, Vector3F* lprvDir,
						// Vector3F* lprvUp)
	(*(code *)opt_ref->masterFrame[0x1f].lpVtbl)();
	if (uvector.z != 0.0) {
		*(Container **)uvector.z = opt_ref;
		*(Container **)((int)uvector.z + 4) = cont;
		*(Vector3F **)((int)uvector.z + 8) = pVVar1;
	}
	if (unaff_retaddr != NULL) {
		*unaff_retaddr = pVVar2;
		unaff_retaddr[1] = (Vector3F *)dvector.x;
		unaff_retaddr[2] = (Vector3F *)dvector.y;
	}
	return;
}



void __cdecl
lego::res::Container_AddRotation
					(Container *cont,D3DRMCombineType combine,float x,float y,float z,float angle)
{
						// enum D3DRMCombineType
						//   D3DRMCOMBINE_REPLACE = 0,
						//   D3DRMCOMBINE_BEFORE  = 1,
						//   D3DRMCOMBINE_AFTER   = 2,
						// 
						// IDirect3DRMFrame3->AddRotation(this, D3DRMCombineType rctCombine, float rvX, float
						// rvY, float rvZ, float rvTheta)
	(*cont->masterFrame->lpVtbl->AddRotation)(cont->masterFrame,combine,x,y,z,angle);
	return;
}



void __cdecl
lego::res::Container_AddScale(Container *cont,D3DRMCombineType combine,float x,float y,float z)
{
						// enum D3DRMCombineType
						//   D3DRMCOMBINE_REPLACE = 0,
						//   D3DRMCOMBINE_BEFORE  = 1,
						//   D3DRMCOMBINE_AFTER   = 2,
						// 
						// IDirect3DRMFrame3->AddScale(this, D3DRMCombineType rctCombine, float rvX, float rvY,
						// float rvZ)
	(*cont->masterFrame->lpVtbl->AddScale)(cont->masterFrame,combine,x,y,z);
	return;
}



void __cdecl
lego::res::Container_AddTranslation
					(Container *cont,D3DRMCombineType combine,float x,float y,float z)
{
						// enum D3DRMCombineType
						//   D3DRMCOMBINE_REPLACE = 0,
						//   D3DRMCOMBINE_BEFORE  = 1,
						//   D3DRMCOMBINE_AFTER   = 2,
						// 
						// IDirect3DRMFrame3->AddTranslation(this, D3DRMCombineType rctCombine, float rvX, float
						// rvY, float rvZ)
	(*cont->masterFrame->lpVtbl->AddTranslation)(cont->masterFrame,combine,x,y,z);
	return;
}



void __cdecl lego::res::Container_ClearTransform(Container *cont)
{
	Matrix4F identity;
	
	identity.values[0][0] = 1.0;
	identity.values[1][0] = 0.0;
	identity.values[2][0] = 0.0;
	identity.values[3][0] = 0.0;
	identity.values[0][1] = 0.0;
	identity.values[1][1] = 1.0;
	identity.values[2][1] = 0.0;
	identity.values[3][1] = 0.0;
	identity.values[0][2] = 0.0;
	identity.values[1][2] = 0.0;
	identity.values[2][2] = 1.0;
	identity.values[3][2] = 0.0;
	identity.values[0][3] = 0.0;
	identity.values[1][3] = 0.0;
	identity.values[2][3] = 0.0;
	identity.values[3][3] = 1.0;
	Container_AddTransform(cont,D3DRMCOMBINE_REPLACE,&identity);
	return;
}



void __cdecl
lego::res::Container_AddTransform(Container *cont,D3DRMCombineType combine,Matrix4F *mat)
{
						// IDirect3DRMFrame3->AddTransform(this, D3DRMCombineType rctCombine, D3DRMMatrix4D*
						// rmMatrix)
	(*cont->masterFrame->lpVtbl->AddTransform)(cont->masterFrame,combine,mat);
	return;
}



float10 __cdecl lego::res::Container_GetZXRatio(Container *cont)
{
	IDirect3DRMFrame3 *pIVar1;
	float unaff_ESI;
	Matrix4F mat;
	
	pIVar1 = cont->masterFrame;
	(*pIVar1->lpVtbl->GetParent)(pIVar1,(IDirect3DRMFrame3 **)&cont);
	(*pIVar1->lpVtbl->GetTransform)(pIVar1,(IDirect3DRMFrame3 *)cont,&mat);
	(*(code *)cont->masterFrame[2].lpVtbl)(cont);
						// Decompile is wrong. This is correct: mat[2][2] / mat[0][0];
	return (float10)mat.values[2][1] / (float10)unaff_ESI;
}



// When resParent is NULL, resChild's current parent will be removed instead.

void __cdecl lego::res::Container_SetParent(Container *child,Container *parent)
{
	IDirect3DRMFrame3 *childHidden;
	IDirect3DRMFrame3 *childMaster;
	Container *parent_00;
	
	parent_00 = parent;
	childMaster = child->masterFrame;
	childHidden = child->hiddenFrame;
	if (parent == NULL) {
						// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
						//  (for resData1->frame1)
		(*childMaster->lpVtbl->GetParent)(childMaster,(IDirect3DRMFrame3 **)&child);
		if (child != NULL) {
						// IDirect3DRMFrame3->DeleteChild(this, IDIrect3DRMFrame3* lpChild)
			(*(code *)child->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)child,childMaster);
						// IDirect3DRMFrame3->Release(this)
						//  (releasing GetParent frame)
			(*(code *)child->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)child);
		}
						// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
						//  (for resData1->frame3)
		(*childMaster->lpVtbl->GetParent)(childHidden,(IDirect3DRMFrame3 **)&child);
		if (child != NULL) {
			(*(code *)child->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)child,childHidden);
			(*(code *)child->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)child);
			return;
		}
	}
	else {
		child = (Container *)parent->masterFrame;
		Container_Frame_SafeAddChild((IDirect3DRMFrame3 *)child,childMaster);
		child = (Container *)parent_00->hiddenFrame;
		Container_Frame_SafeAddChild((IDirect3DRMFrame3 *)child,childHidden);
	}
	return;
}



Container * __cdecl lego::res::Container_GetParent(Container *cont)
{
	Container *pCVar1;
	
	if (cont == globs::containerGlobs.rootContainer) {
		return NULL;
	}
	(*cont->masterFrame->lpVtbl->GetParent)(cont->masterFrame,(IDirect3DRMFrame3 **)&cont);
	if (cont != NULL) {
		pCVar1 = Container_Frame_GetContainer((IDirect3DRMFrame3 *)cont);
		(*(code *)cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)cont);
		return pCVar1;
	}
	return NULL;
}



float10 __cdecl lego::res::Container_GetTransCoef(Container *cont)
{
	char *findName;
	IDirect3DRMFrame3 *frame;
	float10 fVar1;
	
	if (((cont->type == CONTAINER_FROMACTIVITY) && (cont->typeData != NULL)) &&
		 (findName = cont->typeData->name, findName != NULL)) {
		frame = Container_Frame_Find(cont,findName,0);
		if (frame != NULL) {
			fVar1 = Container_Frame_GetTransCo(frame);
			return fVar1;
		}
	}
	return (float10)0.0;
}



Container * __cdecl lego::res::Container_SearchOwner(IDirect3DRMFrame3 *in_frame)
{
	Container *pCVar1;
	IDirect3DRMFrame3 *frame;
	Container *pCVar2;
	
	pCVar2 = NULL;
	frame = in_frame;
	do {
		if (frame == NULL) {
			return pCVar2;
		}
		pCVar1 = Container_Frame_GetOwner(frame);
		if ((pCVar1 != NULL) && (pCVar1->type != CONTAINER_REFERENCE)) {
			pCVar2 = pCVar1;
		}
		(*frame->lpVtbl->GetParent)(frame,&in_frame);
		frame = in_frame;
		if (in_frame == NULL) {
			frame = NULL;
		}
		else {
			(*in_frame->lpVtbl->Release)(in_frame);
		}
	} while (pCVar2 == NULL);
	return pCVar2;
}



Container * __cdecl lego::res::Container_Frame_GetContainer(IDirect3DRMFrame3 *frame)
{
	Container *owner;
	
	owner = Container_Frame_GetOwner(frame);
	if (owner == NULL) {
		owner = Container_Create(NULL);
		if (owner != NULL) {
			(*owner->masterFrame->lpVtbl->Release)((IUnknown *)owner->masterFrame);
			(*owner->activityFrame->lpVtbl->Release)((IUnknown *)owner->activityFrame);
			owner->masterFrame = frame;
			owner->activityFrame = NULL;
			owner->type = CONTAINER_REFERENCE;
			(*frame->lpVtbl->AddDestroyCallback)
								((IUnknown *)frame,Container_Frame_ReferenceDestroyCallback,NULL);
			Container_Frame_SetAppData(frame,owner,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
		}
	}
	return owner;
}



// #ifndef CONTAINER_MATCHHIDDENHIERARCHY

void __cdecl
lego::res::Container_GetFrames
					(Container *cont,Container *opt_ref,IDirect3DRMFrame3 **out_contFrame,
					IDirect3DRMFrame3 **out_refFrame)
{
	*out_contFrame = cont->masterFrame;
	if (opt_ref == NULL) {
		*out_refFrame = (globs::containerGlobs.rootContainer)->masterFrame;
		return;
	}
	*out_refFrame = opt_ref->masterFrame;
	return;
}



Container_Type __cdecl lego::res::Container_ParseTypeString(char *str,BOOL *out_noTexture)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char **ppcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	Container_Type CVar9;
	undefined4 local_50 [10];
	char *local_28;
	char *local_24;
	
	if (str == NULL) {
		return CONTAINER_INVALID;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar7 = str;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar7 = str + 1;
		cVar1 = *str;
		str = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar7 + -uVar3);
	puVar8 = local_50;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar8 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	uVar3 = util::Util_Tokenise((char *)local_50,&local_28,":");
	if (1 < uVar3) {
		iVar2 = std::_stricmp(local_24,"NOTEXTURE");
		if (iVar2 == 0) {
			*out_noTexture = 1;
			goto LAB_00475c6a;
		}
	}
	*out_noTexture = 0;
LAB_00475c6a:
	CVar9 = CONTAINER_NULL;
	ppcVar6 = globs::containerGlobs.typeName;
	do {
		if (*ppcVar6 != NULL) {
			iVar2 = std::_stricmp(*ppcVar6,(char *)local_50);
			if (iVar2 == 0) {
				return CVar9;
			}
		}
		ppcVar6 = ppcVar6 + 1;
		CVar9 += CONTAINER_MESH;
	} while (ppcVar6 < globs::containerGlobs.extensionName);
	return CONTAINER_INVALID;
}



void __cdecl lego::res::Container_AddList(void)
{
	Container *pCVar1;
	Container *pCVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::containerGlobs.listCount & 0x1f);
	pCVar2 = (Container *)std::malloc(uVar4 * 0x2c);
	globs::containerGlobs.listSet[globs::containerGlobs.listCount] = pCVar2;
	pCVar2 = globs::containerGlobs.listSet[globs::containerGlobs.listCount];
	if (pCVar2 != NULL) {
		globs::containerGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pCVar1 = pCVar2;
			do {
				pCVar1->nextFree = pCVar1 + 1;
				iVar3 += -1;
				pCVar1 = pCVar1 + 1;
			} while (iVar3 != 0);
		}
		pCVar2[uVar4 - 1].nextFree = globs::containerGlobs.freeList;
		globs::containerGlobs.freeList = pCVar2;
	}
	return;
}



// WARNING: Exceeded maximum restarts with more pending

uint __cdecl
lego::res::Container_GetActivities
					(Container *cont,IDirect3DRMFrame3 **out_frameList,AnimClone **out_acList,
					char **out_nameList)
{
	HRESULT HVar1;
	char *_Str1;
	int iVar2;
	AnimClone *pAVar3;
	int unaff_EBX;
	uint uVar4;
	Container *pCVar5;
	int *unaff_ESI;
	uint uVar6;
	AnimClone **ppAVar7;
	Container *unaff_retaddr;
	GUID *pGStack76;
	undefined *puStack72;
	int *piStack68;
	uint uStack64;
	int local_24;
	IDirect3DRMFrameArray *local_18;
	IDirect3DRMFrame3 *local_14;
	uint local_10;
	uint local_c;
	DWORD local_8;
	
	if (cont->type == CONTAINER_FROMACTIVITY) {
		local_c = 0;
		pCVar5 = cont;
		do {
			uVar6 = local_c;
			if (local_c == 0) {
				local_14 = pCVar5->activityFrame;
			}
			if (local_c == 1) {
				local_14 = pCVar5->hiddenFrame;
			}
			uStack64 = 0x475d7d;
			HVar1 = (*local_14->lpVtbl->GetChildren)(local_14,&local_18);
			if (HVar1 == 0) {
				local_8 = (*local_18->lpVtbl->GetSize)();
				uVar4 = 0;
				if (local_8 != 0) {
					local_c = (int)out_acList - (int)out_frameList;
					ppAVar7 = (AnimClone **)out_frameList;
					pCVar5 = unaff_retaddr;
					do {
						piStack68 = NULL;
						puStack72 = (undefined *)0x475dc4;
						uStack64 = uVar4;
						(*ppcRam00000000[4])();
						puStack72 = &stack0xffffffcc;
						pGStack76 = &idl::IID_IDirect3DRMFrame3;
						(**ppcRam00000000)();
						(**(code **)(*unaff_ESI + 8))(unaff_ESI);
						(**(code **)(*piStack68 + 0x24))(piStack68,&uStack64,0);
						if (pGStack76 != NULL) {
							_Str1 = (char *)std::malloc((uint)pGStack76);
							(*ppcRam00000000[9])(0,&pGStack76,_Str1);
							iVar2 = std::_strnicmp(_Str1,"ActFrame",8);
							if (iVar2 == 0) {
								if (local_24 != 0) {
									*(undefined4 *)(((int)cont - (int)out_frameList) + (int)ppAVar7) = 0;
								}
								if (false) {
									pAVar3 = Container_Frame_GetAnimClone(NULL);
									*ppAVar7 = pAVar3;
								}
								if (false) {
									*(char **)(unaff_EBX + (int)ppAVar7) = _Str1;
								}
								ppAVar7 = ppAVar7 + 1;
								puStack72 = puStack72 + 1;
								if (false) goto LAB_00475e74;
							}
							std::free(_Str1);
						}
LAB_00475e74:
						(*ppcRam00000000[2])(0);
						uVar4 += 1;
						uVar6 = local_10;
						unaff_retaddr = pCVar5;
					} while (uVar4 < local_8);
				}
				uStack64 = 0x475ea1;
				(*ppcRam00000000[2])();
			}
			local_c = uVar6 + 1;
		} while (local_c < 2);
	}
	return 0;
}



// If non-null, `name` will be owned by this Resource.

void __cdecl
lego::res::Container_SetTypeData
					(Container *cont,char *name,IDirect3DRMLight *light,IDirect3DRMMesh *mesh,Mesh *transMesh)
{
	Container_TypeData *pCVar1;
	
	if (cont->typeData == NULL) {
		pCVar1 = (Container_TypeData *)std::malloc(0x10);
		cont->typeData = pCVar1;
		pCVar1->name = name;
		cont->typeData->light = light;
		cont->typeData->mesh = mesh;
		cont->typeData->transMesh = transMesh;
	}
	else {
		if (name != NULL) {
			cont->typeData->name = name;
		}
		if (light != NULL) {
			cont->typeData->light = light;
		}
		if (mesh != NULL) {
			cont->typeData->mesh = mesh;
		}
		if (transMesh != NULL) {
			cont->typeData->transMesh = transMesh;
			return;
		}
	}
	return;
}



void __cdecl lego::res::Container_FreeTypeData(Container *cont)
{
	Container_TypeData *pCVar1;
	Container_Type CVar2;
	IDirect3DRMMesh *This;
	
	pCVar1 = cont->typeData;
	if (pCVar1 != NULL) {
		CVar2 = cont->type;
		if (CVar2 == CONTAINER_FROMACTIVITY) {
			std::free(pCVar1->name);
		}
		else {
			if (CVar2 == CONTAINER_LIGHT) {
				(*pCVar1->light->lpVtbl->Release)((IUnknown *)pCVar1->light);
			}
			else {
				if (CVar2 == CONTAINER_MESH) {
					if (pCVar1->mesh != NULL) {
						(*cont->activityFrame->lpVtbl->DeleteVisual)
											(cont->activityFrame,(IDirect3DRMVisual *)pCVar1->mesh);
						This = cont->typeData->mesh;
						(*This->lpVtbl->Release)((IUnknown *)This);
					}
				}
				else {
					if ((CVar2 == CONTAINER_LWO) && (pCVar1->transMesh != NULL)) {
						Mesh_Remove(pCVar1->transMesh,cont->activityFrame);
					}
				}
			}
		}
		std::free(cont->typeData);
		cont->typeData = NULL;
	}
	return;
}



// ALSO: Container_AddActivity(<same args>)

BOOL __cdecl
lego::res::Container_AddActivity2
					(Container *cont,char *filename,char *actname,float transCo,uint trigger,char *sample,
					AnimClone *origClone,BOOL lws,BOOL looping)
{
	HRESULT HVar1;
	AnimClone *animClone;
	IDirect3DRMFrame3 *local_208;
	uint local_204;
	char local_200 [512];
	
	std::sprintf(local_200,"%s.%s",filename,globs::containerGlobs.extensionName[3]);
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
										(globs::mainGlobs.lpD3DRM,cont->hiddenFrame,&local_208);
	if (HVar1 == 0) {
		Container_Frame_FormatName(local_208,"%s_%s","ActFrame",actname);
		if (origClone == NULL) {
			animClone = Container_LoadAnimSet(local_200,local_208,&local_204,lws,looping);
		}
		else {
			animClone = AnimClone_Make(origClone,local_208,&local_204);
		}
		Container_Frame_SetAppData
							(local_208,cont,animClone,filename,&local_204,NULL,NULL,&transCo,sample,NULL,&trigger)
		;
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::res::Container_Frame_ReferenceDestroyCallback(IDirect3DRMFrame3 *lpD3DRMobj,void *lpArg)
{
	Container *pCVar1;
	
	pCVar1 = Container_Frame_GetOwner(lpD3DRMobj);
	if (pCVar1 != NULL) {
		pCVar1->flags = pCVar1->flags | CONTAINER_FLAG_DEADREFERENCE;
		Container_Frame_RemoveAppData(lpD3DRMobj);
	}
	return;
}



// WARNING: Exceeded maximum restarts with more pending

IDirect3DRMFrame3 * __cdecl
lego::res::Container_Frame_Find(Container *cont,char *findName,BOOL hidden)
{
	IDirect3DRMFrame3 *pIVar1;
	HRESULT HVar2;
	uint uVar3;
	char *lpName;
	int iVar4;
	IDirect3DRMFrame3 *unaff_EBP;
	IDirect3DRMFrame3 *pIVar5;
	uint uVar6;
	uint uVar7;
	IDirect3DRMFrame3 *pIVar8;
	IDirect3DRMFrame3 *rmFrame3;
	IDirect3DRMFrameArray *rmArray;
	IUnknown *rmFrameBase;
	uint dwNameSize;
	uint dwSize;
	char nameBuffer [512];
	
	pIVar5 = NULL;
	if (hidden == 0) {
		pIVar1 = cont->activityFrame;
	}
	else {
		pIVar1 = cont->hiddenFrame;
	}
						// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar2 = (*pIVar1->lpVtbl->GetChildren)(pIVar1,&rmArray);
	if (HVar2 == 0) {
						// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar3 = (*rmArray->lpVtbl->GetSize)();
		uVar6 = 0;
		if (uVar3 != 0) {
			do {
						// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
						// lplpD3DRMFrame)
				pIVar1 = rmFrame3;
				uVar7 = uVar6;
				(*rmFrame3->lpVtbl->AddDestroyCallback)();
						// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3, IDirect3DRMFrame3**
						// lplpOut)
				pIVar8 = unaff_EBP;
				(*unaff_EBP->lpVtbl->QueryInterface)
									((IUnknown *)unaff_EBP,(IID *)&idl::IID_IDirect3DRMFrame3,
									 (LPVOID *)&stack0xfffffddc);
						// IDirect3DRMFrame->Release(this)
				(*rmArray->lpVtbl->Release)((IUnknown *)rmArray);
						// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
				(*pIVar1->lpVtbl->GetName)((IUnknown *)pIVar1,(LPDWORD)&stack0xfffffdd8,NULL);
				if (pIVar1 != NULL) {
					lpName = (char *)std::malloc((int)&pIVar1->lpVtbl + 1);
						// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
					(*unaff_EBP->lpVtbl->GetName)((IUnknown *)unaff_EBP,(LPDWORD)&stack0xfffffdcc,lpName);
					std::sprintf(&stack0xfffffdd4,"%s_%s","ActFrame",cont);
					iVar4 = std::_stricmp(lpName,&stack0xfffffdd4);
					if (iVar4 == 0) {
						pIVar5 = unaff_EBP;
					}
					uVar3 = uVar7;
					std::free(lpName);
				}
						// IDirect3DRMFrame3->Release(this)
				(*unaff_EBP->lpVtbl->Release)((IUnknown *)unaff_EBP);
			} while ((pIVar5 == NULL) && (uVar6 += 1, unaff_EBP = pIVar8, uVar6 < uVar3));
		}
						// IDirect3DRMFrameArray->Release(this)
		(*rmFrame3->lpVtbl->Release)();
	}
	return pIVar5;
}



void __cdecl
lego::res::Container_Frame_SetAppData
					(IDirect3DRMFrame3 *frame,Container *owner,AnimClone *animClone,char *asfname,
					uint *frameCount,char *frameName,float *currTime,float *transCo,char *actSample,
					Sound3D_SoundFrameRecord *soundRecord,uint *trigger)
{
	char cVar1;
	Container_AppData *appData;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData == NULL) {
		appData = (Container_AppData *)std::malloc(0x28);
		appData->animClone = animClone;
		appData->ownerContainer = owner;
		appData->animSetFileName = NULL;
		if (frameCount == NULL) {
			appData->frameCount = 0;
		}
		else {
			appData->frameCount = *frameCount;
		}
		appData->frameName = frameName;
		if (currTime == NULL) {
			appData->currTime = 0.0;
		}
		else {
			appData->currTime = *currTime;
		}
		if (transCo == NULL) {
			appData->transCo = 0.0;
		}
		else {
			appData->transCo = *transCo;
		}
		if (trigger == NULL) {
			appData->trigger = 0;
		}
		else {
			appData->trigger = *trigger;
		}
		appData->activitySample = actSample;
		appData->soundList = soundRecord;
		(*frame->lpVtbl->SetAppData)(frame,appData);
	}
	else {
		if (owner != NULL) {
			appData->ownerContainer = owner;
		}
		if (animClone != NULL) {
			appData->animClone = animClone;
		}
		if ((asfname != NULL) && (appData->animSetFileName != NULL)) {
			std::free(appData->animSetFileName);
		}
		if (frameCount != NULL) {
			appData->frameCount = *frameCount;
		}
		if (frameName != NULL) {
			appData->frameName = frameName;
		}
		if (currTime != NULL) {
			appData->currTime = *currTime;
		}
		if (transCo != NULL) {
			appData->transCo = *transCo;
		}
		if (actSample != NULL) {
			appData->activitySample = actSample;
		}
		if (soundRecord != NULL) {
			appData->soundList = soundRecord;
		}
		if (trigger != NULL) {
			appData->trigger = *trigger;
		}
	}
	if (asfname != NULL) {
		uVar3 = 0xffffffff;
		pcVar6 = asfname;
		do {
			if (uVar3 == 0) break;
			uVar3 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		puVar2 = (undefined4 *)std::malloc(~uVar3);
		uVar3 = 0xffffffff;
		appData->animSetFileName = (char *)puVar2;
		do {
			pcVar6 = asfname;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar6 = asfname + 1;
			cVar1 = *asfname;
			asfname = pcVar6;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar6 + -uVar3);
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar2 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar2 = puVar2 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar2 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar2 = (undefined4 *)((int)puVar2 + 1);
		}
	}
	return;
}



void __cdecl lego::res::Container_Frame_RemoveAppData(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		if (appData->animSetFileName != NULL) {
			std::free(appData->animSetFileName);
		}
		std::free(appData);
	}
	(*frame->lpVtbl->SetAppData)(frame,NULL);
	return;
}



// ACCESSOR: ResourceAppData->resData (field_0)

Container * __cdecl lego::res::Container_Frame_GetOwner(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->ownerContainer;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->filename (field_4)

char * __cdecl lego::res::Container_Frame_GetAnimSetFileName(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->animSetFileName;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->actFrameRes (field_1c)

AnimClone * __cdecl lego::res::Container_Frame_GetAnimClone(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->animClone;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->field_c (field_c)

uint __cdecl lego::res::Container_Frame_GetFrameCount(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->frameCount;
	}
	return 0;
}



// ACCESSOR: ResourceAppData->float_10 (field_10)

float10 __cdecl lego::res::Container_Frame_GetCurrTime(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return (float10)appData->currTime;
	}
	return (float10)0.0;
}



// ACCESSOR: ResourceAppData->float_14 (field_14)

float10 __cdecl lego::res::Container_Frame_GetTransCo(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return (float10)appData->transCo;
	}
	return (float10)0.0;
}



// ACCESSOR: ResourceAppData->sampleName (field_18)

char * __cdecl lego::res::Container_Frame_GetSample(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->activitySample;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->field_20 (field_20)

uint __cdecl lego::res::Container_Frame_GetTrigger(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->trigger;
	}
	return 0;
}



void __cdecl
lego::res::Container_Frame_SafeAddChild(IDirect3DRMFrame3 *parent,IDirect3DRMFrame3 *child)
{
	IDirect3DRMFrame3 *lpD3DRMFrameChild;
	Matrix4F matrix;
	
	lpD3DRMFrameChild = child;
						// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
	(*child->lpVtbl->GetParent)(child,&child);
						// IDirect3DRMFrame3->GetTransform(this, IDirect3DRMFrame3* lpRefFrame, Matrix4F**
						// rmMatrix)
						// (this = frame2, lpRefFrame = GetParent)
	(*lpD3DRMFrameChild->lpVtbl->GetTransform)(lpD3DRMFrameChild,child,&matrix);
	if (child != NULL) {
						// IDirect3DRMFrame3->Release(this)
						//  (this = GetParent)
		(*child->lpVtbl->Release)(child);
	}
						// IDirect3DRMFrame3->AddChild(this, IDirect3DRMFrame3* lpD3DRMFrameChild)
						//  (this = frame1, lpChild = frame2)
	(*parent->lpVtbl->AddChild)(parent,lpD3DRMFrameChild);
						// IDirect3DRMFrame3->AddTransform(this, TD3DRMCombineType rctCombine, Matrix4F*
						// rmMatrix)
						//  (this = frame2)
	(*lpD3DRMFrameChild->lpVtbl->AddTransform)(lpD3DRMFrameChild,D3DRMCOMBINE_REPLACE,&matrix);
	return;
}



void __cdecl lego::res::Container_Frame_FormatName(IDirect3DRMFrame3 *frame,char *msg,...)
{
	int iVar1;
	char *buffer;
	char local_400 [1024];
	
	iVar1 = std::vsprintf(local_400,msg,&stack0x0000000c);
	buffer = (char *)std::malloc(iVar1 + 1);
	std::vsprintf(buffer,msg,&stack0x0000000c);
	(*frame->lpVtbl->SetName)((IUnknown *)frame,buffer);
	Container_Frame_SetAppData(frame,NULL,NULL,NULL,NULL,buffer,NULL,NULL,NULL,NULL,NULL);
	return;
}



void __cdecl lego::res::Container_Frame_FreeName(IDirect3DRMFrame3 *frame)
{
	char *buffer;
	
	buffer = Container_Frame_GetName(frame);
	if (buffer != NULL) {
		std::free(buffer);
	}
	return;
}



char * __cdecl lego::res::Container_Frame_GetName(IDirect3DRMFrame3 *frame)
{
	DWORD DVar1;
	
	DVar1 = (*frame->lpVtbl->GetAppData)((IUnknown *)frame);
	if (DVar1 != 0) {
		return *(char **)(DVar1 + 8);
	}
	return NULL;
}



BOOL __cdecl
lego::res::Container_Frame_WalkTree
					(IDirect3DRMFrame3 *frame,uint level,ContainerWalkTreeCallback Callback,void *data)
{
	IDirect3DRMFrame3 *This;
	ContainerWalkTreeCallback Callback_00;
	void *data_00;
	BOOL BVar1;
	uint uVar2;
	code **unaff_EBX;
	uint uVar3;
	IDirect3DRMFrame3 *unaff_EDI;
	int *local_8;
	int *local_4;
	
	data_00 = data;
	Callback_00 = Callback;
	This = frame;
	local_8 = NULL;
	BVar1 = (*Callback)(frame,data);
	if (BVar1 != 0) {
		return (BOOL)(IDirect3DRMFrame3 *)TRUE;
	}
	(*This->lpVtbl->GetChildren)(This,(IDirect3DRMFrameArray **)&frame);
	uVar2 = (**(code **)(*local_4 + 0xc))(local_4);
	uVar3 = 0;
	if (uVar2 != 0) {
		do {
			(**(code **)(*local_8 + 0x10))(local_8,uVar3,register0x00000010);
			(**(code **)*unaff_EBX)(unaff_EBX,&idl::IID_IDirect3DRMFrame3,&local_8);
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
			BVar1 = Container_Frame_WalkTree(unaff_EDI,(int)local_4 + 1,Callback_00,data_00);
			if (BVar1 != 0) {
				(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
				break;
			}
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
			uVar3 += 1;
		} while (uVar3 < uVar2);
	}
	(**(code **)(*local_8 + 8))(local_8);
	return (BOOL)unaff_EDI;
}



BOOL __cdecl
lego::res::Container_Frame_SearchCallback(IDirect3DRMFrame3 *frame,Container_SearchData *search)
{
	byte bVar1;
	Container_SearchMode CVar2;
	IDirect3DRMFrame3 *This;
	Container_SearchData *pCVar3;
	byte *lpName;
	uint uVar4;
	byte *pbVar5;
	int iVar6;
	uint unaff_EBP;
	byte *pbVar7;
	bool bVar8;
	
	This = frame;
	(*frame->lpVtbl->GetName)((IUnknown *)frame,(LPDWORD)&frame,NULL);
	pCVar3 = search;
	if ((int)&frame[-1].lpVtbl + 3U != search->stringLen) {
		return 0;
	}
	lpName = (byte *)std::malloc((uint)frame);
	*lpName = 0;
	(*This->lpVtbl->GetName)((IUnknown *)This,(LPDWORD)&frame,(LPSTR)lpName);
	uVar4 = 0;
	if (unaff_EBP != 0) {
		do {
			if (pCVar3->string[uVar4] == '?') {
				lpName[uVar4] = 0x3f;
			}
			uVar4 += 1;
		} while (uVar4 < unaff_EBP);
	}
	CVar2 = pCVar3->mode;
	if (CVar2 == CONTAINER_SEARCHMODE_FIRSTMATCH) {
		pCVar3->resultFrame = NULL;
		if (pCVar3->caseSensitive == 0) {
			iVar6 = std::_stricmp((char *)lpName,pCVar3->string);
		}
		else {
			pbVar7 = (byte *)pCVar3->string;
			pbVar5 = lpName;
			do {
				bVar1 = *pbVar5;
				bVar8 = bVar1 < *pbVar7;
				if (bVar1 != *pbVar7) {
LAB_0047676f:
					if (1 - bVar8 != (uint)(bVar8 != 0)) goto LAB_00476856;
					goto LAB_00476853;
				}
				if (bVar1 == 0) break;
				bVar1 = pbVar5[1];
				bVar8 = bVar1 < pbVar7[1];
				if (bVar1 != pbVar7[1]) goto LAB_0047676f;
				pbVar5 = pbVar5 + 2;
				pbVar7 = pbVar7 + 2;
			} while (bVar1 != 0);
			iVar6 = 0;
		}
		if (iVar6 != 0) goto LAB_00476856;
	}
	else {
		if (CVar2 == CONTAINER_SEARCHMODE_MATCHCOUNT) {
			if (pCVar3->caseSensitive == 0) {
				iVar6 = std::_stricmp((char *)lpName,pCVar3->string);
			}
			else {
				pbVar7 = (byte *)pCVar3->string;
				pbVar5 = lpName;
				do {
					bVar1 = *pbVar5;
					bVar8 = bVar1 < *pbVar7;
					if (bVar1 != *pbVar7) {
LAB_004767d0:
						if (1 - bVar8 == (uint)(bVar8 != 0)) {
							pCVar3->count = pCVar3->count + 1;
						}
						goto LAB_00476856;
					}
					if (bVar1 == 0) break;
					bVar1 = pbVar5[1];
					bVar8 = bVar1 < pbVar7[1];
					if (bVar1 != pbVar7[1]) goto LAB_004767d0;
					pbVar5 = pbVar5 + 2;
					pbVar7 = pbVar7 + 2;
				} while (bVar1 != 0);
				iVar6 = 0;
			}
			if (iVar6 == 0) {
				pCVar3->count = pCVar3->count + 1;
			}
			goto LAB_00476856;
		}
		if (CVar2 != CONTAINER_SEARCHMODE_NTHMATCH) goto LAB_00476856;
		pCVar3->resultFrame = NULL;
		if (pCVar3->caseSensitive == 0) {
			iVar6 = std::_stricmp((char *)lpName,pCVar3->string);
		}
		else {
			pbVar7 = (byte *)pCVar3->string;
			pbVar5 = lpName;
			do {
				bVar1 = *pbVar5;
				bVar8 = bVar1 < *pbVar7;
				if (bVar1 != *pbVar7) {
LAB_0047682a:
					iVar6 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
					goto joined_r0x00476843;
				}
				if (bVar1 == 0) break;
				bVar1 = pbVar5[1];
				bVar8 = bVar1 < pbVar7[1];
				if (bVar1 != pbVar7[1]) goto LAB_0047682a;
				pbVar5 = pbVar5 + 2;
				pbVar7 = pbVar7 + 2;
			} while (bVar1 != 0);
			iVar6 = 0;
		}
joined_r0x00476843:
		if (iVar6 == 0) {
			pCVar3->count = pCVar3->count + 1;
		}
		if (pCVar3->count != pCVar3->matchNumber + 1) goto LAB_00476856;
	}
LAB_00476853:
	pCVar3->resultFrame = This;
LAB_00476856:
	std::free(lpName);
	if (pCVar3->resultFrame == NULL) {
		return 0;
	}
	return TRUE;
}



AnimClone * __cdecl
lego::res::Container_LoadAnimSet
					(char *fname,IDirect3DRMFrame3 *frame,uint *out_frameCount,BOOL lws,BOOL looping)
{
	char cVar1;
	Lws_Info *scene;
	HRESULT HVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	IDirect3DRMFrame3 *unaff_EBX;
	AnimClone *pAVar6;
	IDirect3DRMAnimationSet2 *unaff_EBP;
	undefined4 *puVar7;
	undefined4 *puVar8;
	char *pcVar9;
	IDirect3DRMAnimationSet2 *local_11c;
	IDirect3DRMFrame3 *local_118;
	byte *local_114;
	uint local_110 [2];
	char acStack263 [3];
	char local_104 [260];
	
	pAVar6 = NULL;
	local_11c = NULL;
	if (lws == 0) {
		local_114 = lego::file::File_LoadBinary(fname,local_110);
		if (local_114 != NULL) {
						// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame, IDirect3DRMFrame3**
						// lplpD3DRMFrame)
			HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
												(globs::mainGlobs.lpD3DRM,frame,&local_118);
			if (HVar2 == 0) {
						// IDirect3DRM3->CreateAnimationSet(this, IDirect3DRMAnimationSet2**
						// lplpD3DRMAnimationSet)
				HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateAnimationSet)
													(globs::mainGlobs.lpD3DRM,&local_11c);
				if (HVar2 == 0) {
					local_114 = (byte *)fname;
					local_110[0] = 0;
						// IDirect3DRMAnimationSet2->Load(this, void* lpvObjSource, void* lpvObjID,
						// TD3DRMLoadOptions drd3mLOFlags, TD3DRMLoadTexture3Callback d3drmLoadTextureProc,
						// void* lpArgLTP, IDirect3DRMFrame3* lpParentFrame)
					iVar3 = (*(code *)unaff_EBP->lpVtbl->Load)
														(unaff_EBP,&local_11c,0,2,Container_TextureLoadCallback,&local_114,
														 unaff_EBX);
					if (iVar3 == 0) {
						// IDirect3DRMAnimationSet2->SetTime(this, float rvTime)
						(*(code *)unaff_EBP->lpVtbl->SetTime)(unaff_EBP,0);
						uVar4 = Container_GetAnimFileFrameCount((char *)local_11c);
						if (fname != NULL) {
							*(uint *)fname = uVar4;
						}
						pAVar6 = AnimClone_Register(unaff_EBP,unaff_EBX,uVar4);
					}
					std::free(local_11c);
				}
						// IDirect3DRMFrame3->Release(this)
				(*unaff_EBX->lpVtbl->Release)((IUnknown *)unaff_EBX);
			}
		}
	}
	else {
		uVar4 = 0xffffffff;
		do {
			pcVar9 = fname;
			if (uVar4 == 0) break;
			uVar4 -= 1;
			pcVar9 = fname + 1;
			cVar1 = *fname;
			fname = pcVar9;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar7 = (undefined4 *)(pcVar9 + -uVar4);
		puVar8 = (undefined4 *)local_104;
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
			*puVar8 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		uVar4 = 0xffffffff;
		pcVar9 = local_104;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar9;
			pcVar9 = pcVar9 + 1;
		} while (cVar1 != '\0');
		acStack263[~uVar4] = '\0';
		scene = Lws_Parse(local_104,looping);
		if (scene != NULL) {
			Lws_LoadMeshes(scene,frame);
			Lws_SetTime(scene,0.0);
			if (out_frameCount != NULL) {
				uVar4 = Lws_GetFrameCount(scene);
				*out_frameCount = uVar4;
			}
			pAVar6 = AnimClone_RegisterLws(scene,frame,*out_frameCount);
			return pAVar6;
		}
	}
	return pAVar6;
}



uint __cdecl lego::res::Container_GetAnimFileFrameCount(char *fileData)
{
	byte *str;
	uint uVar1;
	
	uVar1 = 0;
	str = (byte *)std::strstr(fileData,"DDiScene");
	if (str != NULL) {
		while( true ) {
						// int std::isdigit(int c)
			if (std::globals::_pcharwidth < 2) {
						// C1_DIGIT (0x4)
				uVar1 = *(byte *)(std::globals::_pctype + *str) & C1_DIGIT;
			}
			else {
						// C1_DIGIT (0x4)
				uVar1 = std::_isctype((uint)*str,C1_DIGIT);
			}
			if (uVar1 != 0) break;
			str = str + 1;
		}
		uVar1 = std::atoi((char *)str);
	}
	if (uVar1 == 0) {
		uVar1 = 1;
	}
	return uVar1;
}



BOOL __cdecl lego::res::Container_FrameLoad(char *fname,IDirect3DRMFrame3 *frame)
{
	int iVar1;
	uint uVar2;
	void *buffer;
	byte *local_10;
	uint fileSize;
	char *local_8;
	undefined4 local_4;
	
	uVar2 = 0;
	local_10 = lego::file::File_LoadBinary(fname,&fileSize);
	if (local_10 != NULL) {
		buffer = NULL;
		local_8 = fname;
		local_4 = 0;
		iVar1 = (*(code *)frame->lpVtbl->Load)
											(frame,&local_10,0,2,Container_TextureLoadCallback,&local_8);
		uVar2 = (uint)(iVar1 == 0);
		std::free(buffer);
	}
	return uVar2;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

IDirect3DRMMesh * __cdecl
lego::res::Container_MeshLoad
					(void *file_data,uint file_size,char *file_name,IDirect3DRMFrame3 *frame,BOOL noTexture)
{
	int iVar1;
	int *piVar2;
	IDirect3DRMMesh **ppIVar3;
	IDirect3DRMMesh *local_10;
	HRESULT local_c;
	IDirect3DRMMeshBuilder3 *local_8;
	uint local_4;
	
	local_8 = (IDirect3DRMMeshBuilder3 *)file_data;
	local_4 = file_size;
						// IDirect3DRM3->CreateMeshBuilder(this, IDirect3DRMMeshBuilder3** lplpD3DRMMeshBuilder)
	local_c = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMeshBuilder)
											(globs::mainGlobs.lpD3DRM,(IDirect3DRMMeshBuilder3 **)&file_data);
	ppIVar3 = &local_10;
	if (local_c == 0) {
		local_10 = (IDirect3DRMMesh *)file_name;
		if (noTexture != 0) {
			local_c = 1;
		}
						// WARNING: Load size is inaccurate
		piVar2 = (int *)0x2;
						// IDirect3DRMMeshBuilder3->Load(this, void* lpvObjSource, void* lpvObjID,
						// TD3DRMLoadOptions d3drmLOFlags, TD3DRMLoadTexture3Callback d3drmLoadTextureProc,
						// void* lpvArg)
						//   D3DRMLOAD_FROMMEMORY (0x2)
		iVar1 = (**(code **)((int)*file_data + 0x2c))
											(file_data,&local_8,0,2,Container_TextureLoadCallback);
		if (iVar1 == 0) {
						// IDirect3DRMMeshBuilder3->CreateMesh(this, IDirect3DRMMesh** lplpD3DRMMesh)
			(**(code **)((int)*ppIVar3 + 0xc0))(ppIVar3,&local_10);
			(**(code **)(*piVar2 + 8))(piVar2);
						// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
			iVar1 = (**(code **)((int)*ppIVar3 + 0x48))(ppIVar3,piVar2);
			if (iVar1 == 0) {
				return local_10;
			}
		}
		(**(code **)((int)*ppIVar3 + 8))(ppIVar3);
	}
	return NULL;
}



HRESULT __cdecl
lego::res::Container_TextureLoadCallback
					(char *name,Container_TextureData *textureData,IDirect3DRMTexture3 **texture)
{
	byte bVar1;
	IDirect3DRMTexture3 *pIVar2;
	char cVar3;
	byte *pbVar4;
	Container_Texture *pCVar5;
	undefined4 *puVar6;
	uint uVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	char *pcVar11;
	char *pcVar12;
	Container_TextureRef *pCVar13;
	byte *pbVar14;
	undefined4 *puVar15;
	char *pcVar16;
	char *pcVar17;
	char *pcVar18;
	char **ppcVar19;
	char **ppcVar20;
	bool bVar21;
	char *local_410;
	char *local_40c;
	int local_408;
	char *local_404;
	char local_400 [1024];
	
	if ((*(byte *)&textureData->flags & 1) == 0) {
		pcVar12 = textureData->xFileName;
		pcVar11 = local_400;
		local_410 = NULL;
		local_40c = pcVar12;
		local_404 = pcVar11;
		local_408 = 0;
		if ((globs::containerGlobs.sharedDir != NULL) != 0xffffffff) {
LAB_00476c0f:
			if (local_408 == 0) {
				cVar3 = *pcVar12;
				if (cVar3 != '\0') {
					do {
						if (cVar3 == '\\') {
							if (local_410 != NULL) {
								*local_410 = '\\';
							}
							*pcVar11 = '\0';
							local_410 = pcVar11;
						}
						else {
							*pcVar11 = cVar3;
						}
						cVar3 = pcVar12[1];
						pcVar12 = pcVar12 + 1;
						pcVar11 = pcVar11 + 1;
					} while (cVar3 != '\0');
					local_404 = pcVar11;
					local_40c = pcVar12;
				}
				if (local_410 == NULL) {
					uVar7 = 0xffffffff;
					pcVar17 = name;
					do {
						pcVar16 = pcVar17;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar16 = pcVar17 + 1;
						cVar3 = *pcVar17;
						pcVar17 = pcVar16;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					puVar6 = (undefined4 *)(pcVar16 + -uVar7);
					puVar15 = (undefined4 *)local_400;
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 -= 1) {
						*puVar15 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar15 = puVar15 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar15 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar15 = (undefined4 *)((int)puVar15 + 1);
					}
				}
				else {
					uVar7 = 0xffffffff;
					pcVar17 = "\\";
					do {
						pcVar16 = pcVar17;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar16 = pcVar17 + 1;
						cVar3 = *pcVar17;
						pcVar17 = pcVar16;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					iVar8 = -1;
					puVar6 = (undefined4 *)local_400;
					do {
						puVar15 = puVar6;
						if (iVar8 == 0) break;
						iVar8 += -1;
						puVar15 = (undefined4 *)((int)puVar6 + 1);
						cVar3 = *(char *)puVar6;
						puVar6 = puVar15;
					} while (cVar3 != '\0');
					puVar6 = (undefined4 *)(pcVar16 + -uVar7);
					puVar15 = (undefined4 *)((int)puVar15 + -1);
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 -= 1) {
						*puVar15 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar15 = puVar15 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar15 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar15 = (undefined4 *)((int)puVar15 + 1);
					}
					uVar7 = 0xffffffff;
					pcVar17 = name;
					do {
						pcVar16 = pcVar17;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar16 = pcVar17 + 1;
						cVar3 = *pcVar17;
						pcVar17 = pcVar16;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					iVar8 = -1;
					pcVar17 = local_400;
					do {
						pcVar18 = pcVar17;
						if (iVar8 == 0) break;
						iVar8 += -1;
						pcVar18 = pcVar17 + 1;
						cVar3 = *pcVar17;
						pcVar17 = pcVar18;
					} while (cVar3 != '\0');
					puVar6 = (undefined4 *)(pcVar16 + -uVar7);
					puVar15 = (undefined4 *)(pcVar18 + -1);
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 -= 1) {
						*puVar15 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar15 = puVar15 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar15 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar15 = (undefined4 *)((int)puVar15 + 1);
					}
				}
			}
			else {
				std::sprintf(local_400,"%s\\%s",globs::containerGlobs.sharedDir,name);
			}
			uVar7 = 0;
			*texture = NULL;
			if (globs::containerGlobs.textureCount != 0) {
				pCVar13 = globs::containerGlobs.textureSet;
				do {
					pbVar4 = (byte *)pCVar13->filename;
					if (pbVar4 != NULL) {
						pbVar14 = (byte *)local_400;
						do {
							bVar1 = *pbVar4;
							bVar21 = bVar1 < *pbVar14;
							if (bVar1 != *pbVar14) {
LAB_00476d3e:
								iVar8 = (1 - (uint)bVar21) - (uint)(bVar21 != 0);
								goto LAB_00476d43;
							}
							if (bVar1 == 0) break;
							bVar1 = pbVar4[1];
							bVar21 = bVar1 < pbVar14[1];
							if (bVar1 != pbVar14[1]) goto LAB_00476d3e;
							pbVar4 = pbVar4 + 2;
							pbVar14 = pbVar14 + 2;
						} while (bVar1 != 0);
						iVar8 = 0;
LAB_00476d43:
						pcVar11 = local_404;
						if (iVar8 == 0) {
							pIVar2 = globs::containerGlobs.textureSet[uVar7].texture;
							*texture = pIVar2;
							(*pIVar2->lpVtbl->AddRef)((IUnknown *)pIVar2);
							return 0;
						}
					}
					uVar7 += 1;
					pCVar13 = pCVar13 + 1;
					pcVar12 = local_40c;
				} while (uVar7 < globs::containerGlobs.textureCount);
			}
			pCVar5 = Container_LoadTexture2(local_400,0,NULL,NULL);
			if (pCVar5 == NULL) {
				local_408 += 1;
				if ((int)((globs::containerGlobs.sharedDir != NULL) + 1) <= local_408) {
					return -0x7789fcef;
				}
				goto LAB_00476c0f;
			}
			pIVar2 = pCVar5->texture;
			*texture = pIVar2;
			Container_YFlipTexture(pIVar2);
			if (((byte)globs::mainGlobs.flags & CMD_MIPMAP) != 0) {
				(*(code *)(*texture)->lpVtbl->GenerateMIPMap)(*texture,0);
			}
			if (globs::containerGlobs.textureCount == 1000) {
				std::qsort(globs::containerGlobs.textureSet,1000,8,Container_TextureSetSort);
				while (globs::containerGlobs.visualArray[globs::containerGlobs.textureCount * 2 + 2] == NULL
							) {
					globs::containerGlobs.textureCount -= 1;
				}
			}
			uVar7 = globs::containerGlobs.textureCount;
			if (globs::containerGlobs.textureCount < 1000) {
				pCVar13 = globs::containerGlobs.textureSet + globs::containerGlobs.textureCount;
				(*(*texture)->lpVtbl->AddDestroyCallback)
									((IUnknown *)*texture,Container_TextureDestroyCallback,pCVar13);
				uVar9 = 0xffffffff;
				ppcVar19 = &local_40c;
				do {
					if (uVar9 == 0) break;
					uVar9 -= 1;
					cVar3 = *(char *)ppcVar19;
					ppcVar19 = (char **)((int)ppcVar19 + 1);
				} while (cVar3 != '\0');
				puVar6 = (undefined4 *)std::malloc(~uVar9);
				uVar9 = 0xffffffff;
				pCVar13->filename = (char *)puVar6;
				ppcVar19 = &local_40c;
				do {
					ppcVar20 = ppcVar19;
					if (uVar9 == 0) break;
					uVar9 -= 1;
					ppcVar20 = (char **)((int)ppcVar19 + 1);
					cVar3 = *(char *)ppcVar19;
					ppcVar19 = ppcVar20;
				} while (cVar3 != '\0');
				uVar9 = ~uVar9;
				puVar15 = (undefined4 *)((int)ppcVar20 - uVar9);
				for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
					*puVar6 = *puVar15;
					puVar15 = puVar15 + 1;
					puVar6 = puVar6 + 1;
				}
				for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
					*(undefined *)puVar6 = *(undefined *)puVar15;
					puVar15 = (undefined4 *)((int)puVar15 + 1);
					puVar6 = (undefined4 *)((int)puVar6 + 1);
				}
				globs::containerGlobs.textureSet[uVar7].texture = *texture;
				globs::containerGlobs.textureCount += 1;
			}
			return 0;
		}
	}
	return -0x7789fcef;
}



void __cdecl lego::res::Container_YFlipTexture(IDirect3DRMTexture3 *texture)
{
	D3DRMImage *pDVar1;
	int iVar2;
	undefined4 *buffer;
	uint uVar3;
	undefined4 *puVar4;
	undefined4 *puVar5;
	uint size;
	undefined4 *puVar6;
	undefined4 *puVar7;
	int local_c;
	
	pDVar1 = (*texture->lpVtbl->GetImage)(texture);
	if (pDVar1 != NULL) {
		iVar2 = pDVar1->depth * pDVar1->width;
		size = (int)(iVar2 + (iVar2 >> 0x1f & 7U)) >> 3;
		buffer = (undefined4 *)std::malloc(size);
		if (buffer != NULL) {
			puVar4 = (undefined4 *)pDVar1->buffer1;
			local_c = 0;
			puVar5 = (undefined4 *)((pDVar1->height + -1) * pDVar1->bytes_per_line + (int)puVar4);
			if (0 < pDVar1->height / 2) {
				do {
					puVar6 = puVar5;
					puVar7 = buffer;
					for (uVar3 = size >> 2; uVar3 != 0; uVar3 -= 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = size & 3; uVar3 != 0; uVar3 -= 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar6 = puVar4;
					puVar7 = puVar5;
					for (uVar3 = size >> 2; uVar3 != 0; uVar3 -= 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = size & 3; uVar3 != 0; uVar3 -= 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar6 = buffer;
					puVar7 = puVar4;
					for (uVar3 = size >> 2; uVar3 != 0; uVar3 -= 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = size & 3; uVar3 != 0; uVar3 -= 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar4 = (undefined4 *)((int)puVar4 + pDVar1->bytes_per_line);
					puVar5 = (undefined4 *)((int)puVar5 - pDVar1->bytes_per_line);
					local_c += 1;
				} while (local_c < pDVar1->height / 2);
			}
			std::free(buffer);
		}
	}
	return;
}



// if (*param_1 && !*param_2) return -1;
// if (!*param_1 && *param_2) return  1;
// else                       return  0;

int __cdecl lego::res::Container_TextureSetSort(Container_TextureRef *a,Container_TextureRef *b)
{
	if ((a->filename != NULL) && (b->filename == NULL)) {
		return -1;
	}
	if ((a->filename == NULL) && (b->filename != NULL)) {
		return 1;
	}
	return 0;
}



void __cdecl
lego::res::Container_TextureDestroyCallback
					(IDirect3DRMTexture3 *lpD3DRMobj,Container_TextureRef *textRef)
{
	void *buffer;
	
	buffer = (*textRef->texture->lpVtbl->GetAppData)(textRef->texture);
	std::free(buffer);
	std::free(textRef->filename);
	textRef->filename = NULL;
	textRef->texture = NULL;
	return;
}



void __cdecl lego::view::Viewport_Initialise(void)
{
	int iVar1;
	Viewport_Globs *pVVar2;
	
	pVVar2 = &globs::viewportGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		pVVar2->listSet[0] = NULL;
		pVVar2 = (Viewport_Globs *)(pVVar2->listSet + 1);
	}
	globs::viewportGlobs.freeList = NULL;
	globs::viewportGlobs.listCount = 0;
	globs::viewportGlobs.flags = 1;
	return;
}



void __cdecl lego::view::Viewport_Shutdown(void)
{
	Viewport_Globs *pVVar1;
	
	Viewport_RemoveAll();
	pVVar1 = &globs::viewportGlobs;
	do {
		if (pVVar1->listSet[0] != NULL) {
			std::free(pVVar1->listSet[0]);
		}
		pVVar1 = (Viewport_Globs *)(pVVar1->listSet + 1);
	} while (pVVar1 < (Viewport_Globs *)&globs::viewportGlobs.freeList);
	globs::viewportGlobs.freeList = NULL;
	globs::viewportGlobs.flags = 0;
	return;
}



// Creates a viewport, where the float arguments are positions between 0.0 and 1.0
//  (rather than between 0,0 and rmWidth,rmHeight)

Viewport * __cdecl
lego::view::Viewport_Create(float xposf,float yposf,float widthf,float heightf,Container *resData)
{
	uint uVar1;
	uint uVar2;
	int yPos;
	Viewport *pVVar3;
	float10 extraout_ST0;
	longlong lVar4;
	float unaff_retaddr;
	float fVar5;
	float fStack4;
	
	uVar1 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetWidth)(globs::mainGlobs.device);
	uVar2 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetHeight)(globs::mainGlobs.device);
	fVar5 = (float)(ulonglong)uVar1;
	lVar4 = __ftol((float10)yposf * (float10)(ulonglong)uVar2);
	uVar1 = (uint)lVar4;
	lVar4 = __ftol((float10)xposf * (float10)fVar5);
	uVar2 = (uint)lVar4;
	lVar4 = __ftol((float10)unaff_retaddr * extraout_ST0);
	yPos = (int)lVar4;
	lVar4 = __ftol((float10)fStack4 * (float10)fVar5);
	pVVar3 = Viewport_CreatePixel((int)lVar4,yPos,uVar2,uVar1,(Container *)widthf);
	return pVVar3;
}



Viewport * __cdecl
lego::view::Viewport_CreatePixel(int xPos,int yPos,uint width,uint height,Container *resCamera)
{
	IDirect3DRMViewport2 **lplpD3DRMViewport;
	Viewport **ppVVar1;
	IDirect3DRMViewport2 *This;
	Viewport *appData;
	uint uVar2;
	uint uVar3;
	HRESULT HVar4;
	uint unaff_EBX;
	uint unaff_retaddr;
	
	uVar2 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetWidth)(globs::mainGlobs.device);
	uVar3 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetHeight)(globs::mainGlobs.device);
	if ((int)unaff_EBX < 0) {
		unaff_EBX += uVar2;
	}
	if ((int)unaff_retaddr < 0) {
		unaff_retaddr += uVar3;
	}
	if ((xPos + unaff_EBX <= uVar2) && (yPos + unaff_retaddr <= uVar3)) {
		if (globs::viewportGlobs.freeList == NULL) {
			Viewport_AddList();
		}
		appData = globs::viewportGlobs.freeList;
		lplpD3DRMViewport = &(globs::viewportGlobs.freeList)->lpVP;
		ppVVar1 = &(globs::viewportGlobs.freeList)->nextFree;
		globs::viewportGlobs.freeList = (globs::viewportGlobs.freeList)->nextFree;
		*ppVVar1 = NULL;
						// IDirect3DRM3->CreateViewport(this, IDirect3DRMDevice3* lpDev, IDirect3DRMFrame3*
						// lpCamera, DWORD dwXPos, DWORD dwYPos, DWORD dwWidth, DWORD dwHeight,
						// IDirect3DRMViewport2** lplpD3DRMViewport)
		HVar4 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateViewport)
											(globs::mainGlobs.lpD3DRM,globs::mainGlobs.device,*(IDirect3DRMFrame3 **)width
											 ,unaff_EBX,unaff_retaddr,xPos,yPos,lplpD3DRMViewport);
		if (HVar4 == 0) {
			This = *lplpD3DRMViewport;
						// IDirect3DRMViewport2->SetAppData(this, ViewportData* appData)
			(*This->lpVtbl->SetAppData)(This,appData);
			appData->smoothFOV = 0.0;
			return appData;
		}
	}
	return NULL;
}



void __cdecl lego::view::Viewport_GetSize(Viewport *view,uint *out_width,uint *out_height)
{
	DWORD DVar1;
	
	if (out_width != NULL) {
		DVar1 = (*view->lpVP->lpVtbl->GetWidth)(view->lpVP);
		*out_width = DVar1;
	}
	if (out_height != NULL) {
		DVar1 = (*view->lpVP->lpVtbl->GetHeight)(view->lpVP);
		*out_height = DVar1;
	}
	return;
}



void __cdecl lego::view::Viewport_SetCamera(Viewport *view,Container *resCamera)
{
	(*view->lpVP->lpVtbl->SetCamera)(view->lpVP,resCamera->masterFrame);
	return;
}



Container * __cdecl lego::view::Viewport_GetCamera(Viewport *view)
{
	HRESULT HVar1;
	Container *pCVar2;
	Container *pCVar3;
	
	pCVar3 = NULL;
						// IDirect3DRMViewport2->GetCamera(this, IDirect3DRMFrame3** lplpCamera)
	HVar1 = (*view->lpVP->lpVtbl->GetCamera)(view->lpVP,(IDirect3DRMFrame3 **)&view);
	if (HVar1 == 0) {
						// ResourceData* IDirect3DRMFrame3->GetAppData(this)
		pCVar2 = (**(code **)((int)view->xoffset + 0x1c))((IDirect3DRMFrame3 *)view);
		if (pCVar2 != NULL) {
			pCVar3 = (Container *)pCVar2->masterFrame;
		}
						// IDirect3DRMFrame3->Release(this)
		(**(code **)((int)view->xoffset + 8))(view);
	}
	return pCVar3;
}



void __cdecl lego::view::Viewport_SetBackClip(Viewport *view,float dist)
{
	(*view->lpVP->lpVtbl->SetBack)(view->lpVP,dist);
	return;
}



float10 __cdecl lego::view::Viewport_GetBackClip(Viewport *view)
{
	float10 fVar1;
	
						// float IDirect3DRMViewport2->GetBack(this)
	fVar1 = (*view->lpVP->lpVtbl->GetBack)(view->lpVP);
	return fVar1;
}



float10 __cdecl lego::view::Viewport_GetFrontClip(Viewport *view)
{
	float10 fVar1;
	
						// float IDirect3DRMViewport2->GetFront(this)
	fVar1 = (*view->lpVP->lpVtbl->GetFront)(view->lpVP);
	return fVar1;
}



void __cdecl lego::view::Viewport_Clear(Viewport *view,BOOL full)
{
	Viewport *pVVar1;
	IDirect3DRMFrame3 *pIVar2;
	DWORD DVar3;
	longlong lVar4;
	RECT local_20;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pVVar1 = view;
	if ((IDirect3DViewport3 *)full != NULL) {
		pIVar2 = Viewport_GetScene(view);
		DVar3 = 0;
		view = (Viewport *)(*pVVar1->lpVP->lpVtbl->GetX)(pVVar1->lpVP);
		local_10 = (float)(int)view;
		view = (Viewport *)(*pVVar1->lpVP->lpVtbl->GetY)(pVVar1->lpVP);
		local_c = (float)(int)view;
		local_20.left = (*pVVar1->lpVP->lpVtbl->GetWidth)(pVVar1->lpVP);
		local_20.top = 0;
		local_8 = (float)(ulonglong)(uint)local_20.left;
		local_20.left = (*pVVar1->lpVP->lpVtbl->GetHeight)(pVVar1->lpVP);
		local_20.top = 0;
		local_4 = (float)(ulonglong)(uint)local_20.left;
		if (pIVar2 != NULL) {
			DVar3 = (*pIVar2->lpVtbl->GetSceneBackground)(pIVar2);
		}
		lVar4 = __ftol((float10)local_10);
		local_20.left = (LONG)lVar4;
		lVar4 = __ftol((float10)local_c);
		local_20.top = (LONG)lVar4;
		lVar4 = __ftol((float10)local_10 + (float10)local_8);
		local_20.right = (LONG)lVar4;
		lVar4 = __ftol((float10)local_c + (float10)local_4);
		local_20.bottom = (LONG)lVar4;
		(*pVVar1->lpVP->lpVtbl->GetDirect3DViewport)(pVVar1->lpVP,(IDirect3DViewport **)&view);
		(**(code **)view->xoffset)
							((IDirect3DViewport *)view,&idl::IID_IDirect3DViewport3,(IDirect3DViewport3 **)&full);
		(**(code **)((int)view->xoffset + 8))((IDirect3DViewport *)view);
		(**(code **)((int)*(IDirect3DViewport3 *)full + 0x50))
							((IDirect3DViewport3 *)full,1,&local_20,3,DVar3,1.0,0);
		(**(code **)((int)*(IDirect3DViewport3 *)full + 8))((IDirect3DViewport3 *)full);
		return;
	}
	(*view->lpVP->lpVtbl->Clear)(view->lpVP,D3DRMCLEAR_ALL);
	return;
}



void __cdecl lego::view::Viewport_Render(Viewport *view,Container *resRoot,float delta)
{
	float fVar1;
	HRESULT err;
	float10 fVar2;
	
	view->rendering = 1;
	if (view->smoothFOV != 0.0) {
						// float IDirect3DRMViewport2->GetField(this)
		fVar2 = (*view->lpVP->lpVtbl->GetField)(view->lpVP);
		fVar1 = (1.0 / delta) * 4.0;
		fVar1 = (1.0 / (fVar1 - -1.0)) * (float)(fVar2 * (float10)fVar1 + (float10)view->smoothFOV);
						// IDirect3DRMViewport2->SetField(this, float rvField)
		(*view->lpVP->lpVtbl->SetField)(view->lpVP,fVar1);
		if (fVar1 == view->smoothFOV) {
			view->smoothFOV = 0.0;
		}
	}
						// IDirect3DRMViewport2->Render(this, IDirect3DRMFrame3* lpD3DRMFrame)
	err = (*view->lpVP->lpVtbl->Render)(view->lpVP,resRoot->masterFrame);
	if (err == 0) {
		res::Mesh_PostRenderAll(view);
		view->rendering = 0;
		return;
	}
	debug::Error_SetDXError(err,1,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Viewports.c",286);
	view->rendering = 0;
	return;
}



void __cdecl lego::view::Viewport_Remove(Viewport *view)
{
	view->nextFree = globs::viewportGlobs.freeList;
	globs::viewportGlobs.freeList = view;
	(*view->lpVP->lpVtbl->Release)(view->lpVP);
	return;
}



void __cdecl lego::view::Viewport_SmoothSetField(Viewport *view,float fov)
{
	view->smoothFOV = fov;
	return;
}



void __cdecl lego::view::Viewport_SetField(Viewport *view,float fov)
{
	(*view->lpVP->lpVtbl->SetField)(view->lpVP,fov);
	view->smoothFOV = 0.0;
	return;
}



float10 __cdecl lego::view::Viewport_GetField(Viewport *view)
{
	float10 fVar1;
	
	fVar1 = (*view->lpVP->lpVtbl->GetField)(view->lpVP);
	return fVar1;
}



void __cdecl
lego::view::Viewport_InverseTransform(Viewport *view,Vector3F *out_vector,Vector4F *transform4d)
{
						// IDirect3DRMViewport2->InverseTransform(this, Vector3F* out_lprvDst, const Vector4F*
						// lprvSrc)
	(*view->lpVP->lpVtbl->InverseTransform)(view->lpVP,out_vector,transform4d);
	return;
}



void __cdecl
lego::view::Viewport_Transform(Viewport *view,Vector4F *out_transform4d,Vector3F *vector)
{
						// IDirect3DRMViewport2->Transform(this, Vector4F** lplprvDst, Vector3F* lprvSrc)
	(*view->lpVP->lpVtbl->Transform)(view->lpVP,out_transform4d,vector);
	return;
}



Point2F * __cdecl
lego::view::Viewport_WorldToScreen(Viewport *view,Point2F *out_screenPt,Vector3F *in_worldVec)
{
	Vector4F transform4d;
	
						// IDirect3DRMViewport2->Transform(this, Vector4F** lplprvDst, Vector3F* lprvSrc)
	(*view->lpVP->lpVtbl->Transform)(view->lpVP,&transform4d,in_worldVec);
						// out_point.x = (transform4d.x / transform4d.w)
						// out_point.y = (transform4d.y / transform4d.w)
	out_screenPt->x = transform4d.x / transform4d.w;
	out_screenPt->y = transform4d.y / transform4d.w;
	return out_screenPt;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

IDirect3DRMFrame3 * __cdecl lego::view::Viewport_GetScene(Viewport *view)
{
	IDirect3DRMFrame3 *local_8;
	IDirect3DRMFrame3 *local_4;
	
	local_8 = NULL;
	local_4 = NULL;
	(*view->lpVP->lpVtbl->GetCamera)(view->lpVP,&local_8);
	if (local_8 != NULL) {
		(*local_8->lpVtbl->Release)((IUnknown *)local_8);
		(*local_8->lpVtbl->GetScene)((IDirect3DRMViewport2 *)local_8,(IDirect3DRMDevice3 **)&local_4);
		(*local_4->lpVtbl->Release)((IUnknown *)local_4);
	}
	return local_4;
}



void __cdecl lego::view::Viewport_AddList(void)
{
	Viewport *pVVar1;
	Viewport *pVVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::viewportGlobs.listCount & 0x1f);
	pVVar2 = (Viewport *)std::malloc(uVar4 * 0x20);
	globs::viewportGlobs.listSet[globs::viewportGlobs.listCount] = pVVar2;
	pVVar2 = globs::viewportGlobs.listSet[globs::viewportGlobs.listCount];
	if (pVVar2 != NULL) {
		globs::viewportGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pVVar1 = pVVar2;
			do {
				pVVar1->nextFree = pVVar1 + 1;
				iVar3 += -1;
				pVVar1 = pVVar1 + 1;
			} while (iVar3 != 0);
		}
		pVVar2[uVar4 - 1].nextFree = globs::viewportGlobs.freeList;
		globs::viewportGlobs.freeList = pVVar2;
	}
	return;
}



void __cdecl lego::view::Viewport_RemoveAll(void)
{
	int iVar1;
	int iVar2;
	Viewport_Globs *pVVar3;
	uint uVar4;
	int iVar5;
	
	uVar4 = 0;
	if (globs::viewportGlobs.listCount != 0) {
		pVVar3 = &globs::viewportGlobs;
		do {
			if ((pVVar3->listSet[0] != NULL) && (iVar1 = 1 << ((byte)uVar4 & 0x1f), iVar1 != 0)) {
				iVar5 = 0;
				do {
					iVar2 = (int)&pVVar3->listSet[0]->xoffset + iVar5;
					if ((iVar2 != 0) && (*(int *)(iVar2 + 0x1c) == iVar2)) {
						// IDirect3DRMViewport2->Release(this)
						(*(*(IDirect3DRMViewport2 **)(iVar2 + 0x10))->lpVtbl->Release)
											(*(IDirect3DRMViewport2 **)(iVar2 + 0x10));
					}
					iVar5 += 0x20;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			uVar4 += 1;
			pVVar3 = (Viewport_Globs *)(pVVar3->listSet + 1);
		} while (uVar4 < globs::viewportGlobs.listCount);
	}
	return;
}



int __cdecl lego::util::Util_Tokenise(char *input,char **out_parts,char *delimiter)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	int numParts;
	char *pcVar4;
	char **ppcVar5;
	
	uVar3 = 0xffffffff;
	pcVar4 = delimiter;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar4;
		pcVar4 = pcVar4 + 1;
	} while (cVar1 != '\0');
	if (*input == '\0') {
		return 0;
	}
	numParts = 1;
	*out_parts = input;
	if (*input != '\0') {
		ppcVar5 = out_parts + 1;
		do {
			iVar2 = std::strncmp(delimiter,input,~uVar3 - 1);
			if (iVar2 == 0) {
				*input = '\0';
				*ppcVar5 = input + (~uVar3 - 1);
				numParts += 1;
				ppcVar5 = ppcVar5 + 1;
			}
			pcVar4 = input + 1;
			input = input + 1;
		} while (*pcVar4 != '\0');
	}
	return numParts;
}



int __cdecl lego::util::Util_WSTokenise(char *input,char **out_parts)
{
	uint uVar1;
	int iVar2;
	byte **ppbVar3;
	
	if (*input != '\0') {
		*out_parts = input;
		iVar2 = 1;
		if (*input != '\0') {
			ppbVar3 = (byte **)(out_parts + 1);
			do {
						// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
						// C1_SPACE (0x8)
					uVar1 = *(byte *)(std::globals::_pctype + (byte)*input) & C1_SPACE;
				}
				else {
						// C1_SPACE (0x8)
					uVar1 = std::_isctype((uint)(byte)*input,C1_SPACE);
				}
				if (uVar1 == 0) {
					input = (char *)((byte *)input + 1);
				}
				else {
					*input = 0;
					do {
						input = (char *)((byte *)input + 1);
						// int std::isspace(int c)
						if (std::globals::_pcharwidth < 2) {
						// C1_SPACE (0x8)
							uVar1 = *(byte *)(std::globals::_pctype + (byte)*input) & C1_SPACE;
						}
						else {
						// C1_SPACE (0x8)
							uVar1 = std::_isctype((uint)(byte)*input,C1_SPACE);
						}
					} while (uVar1 != 0);
					*ppbVar3 = (byte *)input;
					iVar2 += 1;
					ppbVar3 = ppbVar3 + 1;
				}
			} while (*input != 0);
		}
		return iVar2;
	}
	return 0;
}



// OFFICIAL: Util_StrCpy
// C RUNTIME: ::_strdup

char * __cdecl lego::util::_strdup(char *strSource)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	uVar3 = 0xffffffff;
	pcVar6 = strSource;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	puVar2 = (undefined4 *)std::malloc(~uVar3);
	uVar3 = 0xffffffff;
	do {
		pcVar6 = strSource;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar6 = strSource + 1;
		cVar1 = *strSource;
		strSource = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



char * __cdecl lego::util::Util_RemoveUnderscores(char *text,...)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	char *pcVar4;
	char fmtBuffer [256];
	char replBuffer [256];
	
	std::vsprintf(fmtBuffer,text,&stack0x00000008);
	pcVar3 = fmtBuffer;
	pcVar4 = replBuffer;
	while (fmtBuffer[0] != '\0') {
		cVar2 = *pcVar3;
		if ((cVar2 == '\\') && (pcVar3[1] == 'n')) {
			*pcVar4 = '\n';
			pcVar3 = pcVar3 + 1;
		}
		else {
			if (cVar2 == '_') {
				*pcVar4 = ' ';
			}
			else {
				*pcVar4 = cVar2;
			}
		}
		pcVar1 = pcVar3 + 1;
		pcVar4 = pcVar4 + 1;
		pcVar3 = pcVar3 + 1;
		fmtBuffer[0] = *pcVar1;
	}
	*pcVar4 = '\0';
	pcVar4 = _strdup(replBuffer);
	return pcVar4;
}



char * __cdecl lego::util::Util_StrIStr(char *str,char *strSearch)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	uint uVar6;
	
	uVar3 = 0xffffffff;
	pcVar5 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	uVar4 = 0xffffffff;
	pcVar5 = strSearch;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	if (((uVar3 != 1) && (~uVar4 - 1 != 0)) && (uVar6 = 0, uVar3 != 1)) {
		do {
			iVar2 = std::_strnicmp(str,strSearch,~uVar4 - 1);
			if (iVar2 == 0) {
				return str;
			}
			uVar6 += 1;
			str = str + 1;
		} while (uVar6 < uVar3 - 1);
		return NULL;
	}
	return NULL;
}



// https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/begin/sdkdiff/utils.cpp
// 
// hash_string()

uint __cdecl lego::util::Util_HashString(char *str,BOOL bIgnoreBlanks,BOOL upperCase)
{
	byte bVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	byte *pbVar6;
	int iVar7;
	
	uVar5 = 0;
	iVar7 = 0x600937;
	iVar4 = 1;
	bVar1 = *str;
	pbVar6 = (byte *)str;
	while (bVar1 != 0) {
		if (bIgnoreBlanks != 0) {
			while( true ) {
						// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
						// C1_SPACE (0x8)
					uVar2 = *(byte *)(std::globals::_pctype + *pbVar6) & C1_SPACE;
				}
				else {
						// C1_SPACE (0x8)
					uVar2 = std::_isctype((uint)*pbVar6,C1_SPACE);
				}
				if (uVar2 == 0) break;
				pbVar6 = pbVar6 + 1;
			}
		}
		bVar1 = *pbVar6;
		pbVar6 = pbVar6 + 1;
		str = (char *)(uint)bVar1;
		if (upperCase != 0) {
			uVar2 = std::toupper((int)str);
			str = (char *)(uVar2 & 0xff);
		}
		iVar3 = iVar4 * iVar7;
		iVar7 *= 0x600937;
		uVar5 += iVar3 * (int)str;
		iVar4 += 1;
		bVar1 = *pbVar6;
	}
	return uVar5;
}



BoolTri __cdecl lego::util::Util_GetBoolFromString(char *str)
{
	int iVar1;
	
	iVar1 = std::_stricmp(str,"YES");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"TRUE");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"ON");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"NO");
	if (iVar1 == 0) {
		return BOOL3_FALSE;
	}
	iVar1 = std::_stricmp(str,"FALSE");
	if (iVar1 == 0) {
		return BOOL3_FALSE;
	}
	iVar1 = std::_stricmp(str,"OFF");
	return -(uint)(iVar1 != 0) & BOOL3_ERROR;
}



int lego::WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nShowCmd)
{
	char cVar1;
	DWORD DVar2;
	LPSTR pCVar3;
	char *pcVar4;
	BOOL BVar5;
	MainFlags MVar6;
	DWORD DVar7;
	uint uVar8;
	uint uVar9;
	int iVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	float fpsSync;
	BOOL insistOnCD;
	BOOL nosound;
	uint local_c88;
	undefined4 uStack3204;
	char mutexName [128];
	char fullCmdLine [1024];
	char errorMessage [1024];
	char standardParameters [1024];
	
	nosound = 0;
	insistOnCD = 0;
	if (true) {
		std::sprintf(mutexName,"%s Mutex","Lego Rock Raiders");
		CreateMutexA(NULL,TRUE,mutexName);
		DVar2 = GetLastError();
		if (DVar2 == ERROR_ALREADY_EXISTS) {
			return 0;
		}
	}
	pCVar3 = GetCommandLineA();
	cVar1 = *pCVar3;
	pcVar4 = pCVar3;
	while (cVar1 != '\0') {
		if (cVar1 == '\\') {
			pcVar4 = pCVar3 + 1;
		}
		pcVar12 = pCVar3 + 1;
		pCVar3 = pCVar3 + 1;
		cVar1 = *pcVar12;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar12 = pcVar4;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar12 = pcVar4 + 1;
		cVar1 = *pcVar4;
		pcVar4 = pcVar12;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar11 = (undefined4 *)(pcVar12 + -uVar8);
	puVar13 = (undefined4 *)globs::mainGlobs.programName;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar13 = *puVar11;
		puVar11 = puVar11 + 1;
		puVar13 = puVar13 + 1;
	}
	pcVar4 = globs::mainGlobs.programName;
	for (uVar8 &= 3; cVar1 = globs::mainGlobs.programName[0], uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar13 = *(undefined *)puVar11;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	}
	while (cVar1 != '\0') {
		if (*pcVar4 == '\"') {
			*pcVar4 = '\0';
		}
		pcVar12 = pcVar4 + 1;
		pcVar4 = pcVar4 + 1;
		cVar1 = *pcVar12;
	}
	iVar10 = 0x506814;
	pcVar4 = globs::mainGlobs.programName;
	cVar1 = globs::mainGlobs.programName[0];
	while (cVar1 != '\0') {
		if (cVar1 == '.') {
			pcVar4 = (char *)(iVar10 + 1);
		}
		pcVar12 = (char *)(iVar10 + 1);
		iVar10 += 1;
		cVar1 = *pcVar12;
	}
	if (pcVar4 != globs::mainGlobs.programName) {
						// to upper
		std::_strupr(pcVar4);
		pcVar4 = std::strstr(globs::mainGlobs.programName,".EXE");
		if (pcVar4 != NULL) {
			*pcVar4 = '\0';
		}
	}
	globs::mainGlobs.className = globs::mainGlobs.programName;
	globs::mainGlobs.active = 0;
	globs::mainGlobs.exit = 0;
	globs::mainGlobs.stateSet = 0;
	globs::mainGlobs.hInst = hInstance;
	globs::mainGlobs.fixedFrameTiming = 0.0;
	globs::mainGlobs.flags = CMD_NONE;
	BVar5 = registry::Registry_GetValue
										("SOFTWARE\\LEGO Media\\Games\\Rock Raiders","StandardParameters",
										 REGISTRY_STRING_VALUE,standardParameters,0x400);
	if (BVar5 == 0) {
		std::sprintf(fullCmdLine,"%s",lpCmdLine);
	}
	else {
		std::sprintf(fullCmdLine,"%s %s",lpCmdLine,standardParameters);
	}
	main::Main_ParseCommandLine(fullCmdLine,&nosound,&insistOnCD);
	BVar5 = registry::Registry_GetValue
										("SOFTWARE\\LEGO Media\\Games\\Rock Raiders","NoHALMessage",
										 REGISTRY_STRING_VALUE,errorMessage,0x400);
	if (BVar5 == 0) {
		std::sprintf(errorMessage,"No DirectX 3D accelerator could be found.");
	}
	debug::Error_Initialise();
	file::Mem_Initialise();
	file::File_Initialise
						(globs::mainGlobs.programName,insistOnCD,"SOFTWARE\\LEGO Media\\Games\\Rock Raiders");
	cfg::Config_Initialise();
	input::Input_InitKeysAndDI();
	BVar5 = main::Main_InitApp(hInstance);
	if (BVar5 != 0) {
		ddraw::DirectDraw_Initialise(globs::mainGlobs.hWnd);
		BVar5 = snd::Sound_Initialise(nosound);
		if ((BVar5 != 0) &&
			 (BVar5 = setup::Init_Initialise
													(TRUE,globs::mainGlobs.flags & CMD_DEBUG,globs::mainGlobs.flags & CMD_BEST
													 ,globs::mainGlobs.flags & CMD_WINDOW,errorMessage), BVar5 != 0)) {
			video::Animation_Initialise(globs::directDrawGlobs.lpDirectDraw);
			draw::Draw_Initialise(NULL);
			lrr::Gods_Go(globs::mainGlobs.programName);
			if (globs::mainGlobs.stateSet != 0) {
				if ((globs::mainGlobs.currState.Initialise != NULL) &&
					 (BVar5 = (*globs::mainGlobs.currState.Initialise)(), BVar5 == 0)) {
					globs::mainGlobs.currState.Initialise = NULL;
					globs::mainGlobs.currState.MainLoop = NULL;
					globs::mainGlobs.currState.Shutdown = NULL;
				}
				if (globs::mainGlobs.currState.MainLoop != NULL) {
					fpsSync = 1.0;
					DVar2 = timeGetTime();
					while (globs::mainGlobs.exit == 0) {
						globs::INPUT.lClicked = 0;
						globs::INPUT.rClicked = 0;
						globs::INPUT.lDoubleClicked = 0;
						globs::INPUT.rDoubleClicked = 0;
						main::Main_HandleIO();
						if ((globs::mainGlobs.flags & CMD_FULLSCREEN) != CMD_NONE) {
							globs::mainGlobs.active = TRUE;
						}
						input::Input_ReadKeys();
						input::Input_ReadMouse2();
						BVar5 = (*globs::mainGlobs.currState.MainLoop)(fpsSync);
						if (BVar5 == 0) {
							globs::mainGlobs.exit = TRUE;
						}
						main::Main_Finalise3D();
						ddraw::DirectDraw_Flip();
						MVar6 = globs::mainGlobs.flags & ~CMD_D3DRMUPDATED;
						if ((globs::mainGlobs.flags & CMD_FPSLOCK30) == CMD_NONE) {
							if ((globs::mainGlobs.flags & CMD_NOFPSLOCK) == CMD_NONE) {
								if (globs::mainGlobs.fixedFrameTiming != 0.0) {
									fpsSync = globs::mainGlobs.fixedFrameTiming;
									goto LAB_00477e2a;
								}
								globs::mainGlobs.flags = MVar6;
								DVar7 = timeGetTime();
								uStack3204 = 0;
								local_c88 = DVar7 - DVar2;
								fpsSync = (float)(ulonglong)local_c88 * 0.025;
								DVar2 = DVar7;
								if ((ushort)((ushort)(fpsSync < 3.0) << 8 | (ushort)(fpsSync == 3.0) << 0xe) == 0) {
									fpsSync = 3.0;
								}
							}
							else {
								fpsSync = 0.0;
LAB_00477e2a:
								globs::mainGlobs.flags = MVar6;
								DVar2 = timeGetTime();
							}
						}
						else {
							fpsSync = 0.8333333;
							globs::mainGlobs.flags = MVar6;
						}
					}
				}
				if (globs::mainGlobs.currState.Shutdown != NULL) {
					(*globs::mainGlobs.currState.Shutdown)();
				}
			}
		}
		ddraw::DirectDraw_Shutdown();
		DestroyWindow(globs::mainGlobs.hWnd);
	}
	input::Input_ReleaseKeysAndDI();
	cfg::Config_Shutdown();
	util::logf_removed(NULL);
	debug::Error_CloseLog();
	debug::Error_Shutdown();
	return 0;
}



// Sets the "-nm" commandline option only if the "-ftm" option is not set.
//  (The "-ftm" option is intended to be set when running on Voodoo2-based graphics cards, as is
// shown by CLGen.exe)
// This is called when Lego.cfg/Lego*::Main::TextureUsage (units in pixels) is valid and <=
// available video memory.

void __cdecl lego::main::Main_DisableTextureManagement(void)
{
	if ((globs::mainGlobs.flags & CMD_FTM) == CMD_NONE) {
		globs::mainGlobs.flags |= CMD_NM;
	}
	return;
}



void __cdecl
lego::main::Main_ParseCommandLine(char *lpszCmdLine,BOOL *out_nosound,BOOL *out_insistOnCD)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-insistOnCD");
	if (pcVar3 != NULL) {
		*out_insistOnCD = 1;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-nosound");
	if (pcVar3 != NULL) {
		*out_nosound = 1;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-debug");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_DEBUG;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-nm");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_NM;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-ftm");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_FTM;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-fvf");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_FVF;
	}
						// "best fit" for screen mode selection
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-best");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_BEST;
	}
						// Only used when "-best" is specified
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-window");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_WINDOW;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-dualmouse");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_DUALMOUSE;
	}
						// Automatically triggers "-debug" command line option as well
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-debugcomplete");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_DEBUGCOMPLETE;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-testercall");
	if (pcVar3 != NULL) {
		globs::mainGlobs.programmerLevel = PROGRAMMER_MODE_2;
		globs::mainGlobs.flags |= CMD_TESTERCALL;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-testlevels");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_TESTLEVELS;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reducesamples");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCESAMPLES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-showversion");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_SHOWVERSION;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceanimation");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEANIMATION;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reducepromeshes");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEPROMESHES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceflics");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEFLICS;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceimages");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEIMAGES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-startlevel");
	if (pcVar3 != NULL) {
		pcVar3 = pcVar3 + 0xb;
		iVar5 = 0;
		cVar2 = *pcVar3;
		while ((cVar2 != '\0' && (cVar2 == ' '))) {
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
		cVar2 = *pcVar3;
		while ((cVar2 != '\0' && (cVar2 != ' '))) {
			globs::mainGlobs.startLevel[iVar5] = cVar2;
			pcVar1 = pcVar3 + 1;
			iVar5 += 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
		globs::mainGlobs.startLevel[iVar5] = '\0';
		globs::mainGlobs.flags |= CMD_STARTLEVEL;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-flags");
	if (pcVar3 != NULL) {
		globs::mainGlobs.clFlags = std::atoi(pcVar3 + 6);
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-fpslock");
	if ((pcVar3 != NULL) && (uVar4 = std::atoi(pcVar3 + 8), uVar4 != 0)) {
		globs::mainGlobs.fixedFrameTiming = 25.0 / (float)(ulonglong)uVar4;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-programmer");
	if (pcVar3 == NULL) {
		globs::mainGlobs.programmerLevel = PROGRAMMER_OFF;
	}
	else {
		globs::mainGlobs.programmerLevel = std::atoi(pcVar3 + 0xb);
		if (globs::mainGlobs.programmerLevel == PROGRAMMER_OFF) {
			globs::mainGlobs.programmerLevel = PROGRAMMER_MODE_1;
		}
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-cleansaves");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_CLEANSAVES;
	}
	return;
}



void __cdecl lego::main::Main_LoopUpdate(BOOL clear)
{
	Main_HandleIO();
	input::Input_ReadKeys();
	input::Input_ReadMouse2();
	Main_Finalise3D();
	ddraw::DirectDraw_Flip();
	if (clear != 0) {
		ddraw::DirectDraw_Clear(NULL,0);
	}
	globs::mainGlobs.flags = globs::mainGlobs.flags & ~CMD_D3DRMUPDATED;
	return;
}



FeatureFlags __cdecl lego::main::Main_GetCLFlags(void)
{
	return globs::mainGlobs.clFlags;
}



int __cdecl lego::main::Main_GetWindowsBitDepth(void)
{
	HDC hdc;
	int iVar1;
	
	iVar1 = BITSPIXEL;
	hdc = GetDC(globs::mainGlobs.hWnd);
	iVar1 = GetDeviceCaps(hdc,iVar1);
	return iVar1;
}



void __cdecl lego::main::Main_Finalise3D(void)
{
	if ((globs::mainGlobs.flags & CMD_D3DRMUPDATED) == CMD_NONE) {
		(*(code *)(globs::mainGlobs.device)->lpVtbl->Update)(globs::mainGlobs.device);
		globs::mainGlobs.flags |= CMD_D3DRMUPDATED;
	}
	return;
}



BOOL __cdecl lego::main::Main_SetState(Main_State *state)
{
	if (state != NULL) {
		globs::mainGlobs.currState.Initialise = state->Initialise;
		globs::mainGlobs.currState.MainLoop = state->MainLoop;
		globs::mainGlobs.currState.Shutdown = state->Shutdown;
		globs::mainGlobs.stateSet = TRUE;
		return TRUE;
	}
	return 0;
}



uint __cdecl lego::main::Main_GetTime(void)
{
	DWORD DVar1;
	
						// WARNING: Could not recover jumptable at 0x004782c0. Too many branches
						// WARNING: Treating indirect jump as call
	DVar1 = timeGetTime();
	return DVar1;
}



BOOL __cdecl lego::main::Main_DispatchMessage(MSG *msg)
{
	UINT UVar1;
	
	if ((((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) != 0) &&
		 (((UVar1 = msg->message, UVar1 == WM_ACTIVATEAPP || (UVar1 == WM_SYSKEYDOWN)) ||
			(UVar1 == WM_SYSKEYUP)))) {
		return 0;
	}
	return 1;
}



void __cdecl lego::main::Main_HandleIO(void)
{
	int iVar1;
	BOOL BVar2;
	MSG msg;
	
	iVar1 = PeekMessageA((LPMSG)&msg,NULL,0,0,1);
	while (iVar1 != 0) {
		BVar2 = Main_DispatchMessage(&msg);
		if (BVar2 != 0) {
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
		iVar1 = PeekMessageA((LPMSG)&msg,NULL,0,0,1);
	}
	return;
}



void __cdecl
lego::main::Main_SetupDisplay(BOOL fullScreen,uint xPos,uint yPos,uint width,uint height)
{
	HWND hWnd;
	RECT rect;
	
	globs::mainGlobs.appWidth = width;
	globs::mainGlobs.appHeight = height;
	if (fullScreen != 0) {
		globs::mainGlobs.flags |= CMD_FULLSCREEN;
	}
	debug::Error_FullScreen(fullScreen);
	if (fullScreen == 0) {
		rect.left = xPos;
		rect.right = width + xPos;
		rect.bottom = height + yPos;
						// WS_POPUPWINDOW | WS_CAPTION (0x80880000 | 0xc00000)
						// WS_POPUP | WS_BORDER | WS_DLGFRAME | WS_SYSMENU (0x80000000 | 0x800000 | 0x400000 |
						// 0x80000)
		globs::mainGlobs.style = 0x80c80000;
		rect.top = yPos;
		Main_AdjustWindowRect((LPRECT)&rect);
		SetWindowLongA(globs::mainGlobs.hWnd,-0x10,globs::mainGlobs.style);
						// HWND_TOP (0x0) and SWP_NOZORDER (0x4)
						// Then hide system cursor since game draws its own
		SetWindowPos(globs::mainGlobs.hWnd,NULL,rect.left,rect.top,rect.right - rect.left,
								 rect.bottom - rect.top,SWP_NOZORDER);
		ShowCursor(0);
	}
	else {
		hWnd = GetDesktopWindow();
		GetWindowRect(hWnd,(LPRECT)&rect);
						// HWND_TOP (0x0) and SWP_NOZORDER (0x4)
						// Then hide system cursor since game draws its own
		SetWindowPos(globs::mainGlobs.hWnd,NULL,rect.left,rect.top,rect.right - rect.left,
								 rect.bottom - rect.top,SWP_NOZORDER);
		SetCursor(NULL);
	}
	ShowWindow(globs::mainGlobs.hWnd,SW_SHOW);
	SetActiveWindow(globs::mainGlobs.hWnd);
	return;
}



BOOL __cdecl
lego::main::Main_SetupDirect3D
					(DirectDraw_Device *dev,IDirectDraw *ddraw1,IDirectDrawSurface4 *backSurf,
					BOOL doubleBuffered)
{
	HRESULT HVar1;
	DirectDraw_Device *err;
	DirectDraw_Device *pDVar2;
	code ***ppvObj;
	DirectDraw_Device **ppDVar3;
	IUnknown *local_8;
	code **local_4;
	
	pDVar2 = NULL;
	if ((dev != NULL) &&
		 (pDVar2 = dev,
		 (dev->flags & DIRECTDRAW_FLAG_DEVICE_VIDEOTEXTURE) != DIRECTDRAW_FLAG_DEVICE_NONE)) {
		globs::mainGlobs.flags |= CMD_TEXTUREVIDEOMEMORY;
	}
						// Direct3DRMFrame3::SetSceneFogMethod
						// D3DRMFOGMETHOD_VERTEX = 0x1
						// D3DRMFOGMETHOD_TABLE  = 0x2
						// D3DRMFOGMETHOD_ANY    = 0x4
	if (((globs::mainGlobs.flags & CMD_FVF) != CMD_NONE) ||
		 (globs::mainGlobs.fogMethod = D3DRMFOGMETHOD_TABLE,
		 (dev->flags & DIRECTDRAW_FLAG_DEVICE_HARDWARE) == DIRECTDRAW_FLAG_DEVICE_NONE)) {
		globs::mainGlobs.fogMethod = D3DRMFOGMETHOD_VERTEX;
	}
	HVar1 = Direct3DRMCreate(&local_8);
	err = dev;
	if ((HVar1 == 0) &&
		 (HVar1 = (*local_8->lpVtbl->QueryInterface)
												(local_8,(IID *)&idl::IID_IDirect3DRM3,(void **)0x506914), err = dev,
		 HVar1 == 0)) {
		ppvObj = &local_4;
		(*backSurf->lpVtbl->QueryInterface)
							((IUnknown *)backSurf,(IID *)&idl::IID_IDirectDrawSurface,ppvObj);
		err = (DirectDraw_Device *)
					(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateDeviceFromSurface)
										(globs::mainGlobs.lpD3DRM,pDVar2,local_4,ppvObj,0,0x506918);
		if (err == NULL) {
			ppDVar3 = &dev;
			(*(code *)(globs::mainGlobs.device)->lpVtbl->GetDirect3DDevice2)(globs::mainGlobs.device);
			(**(code **)*local_4)(local_4,&idl::IID_IDirect3DDevice3,0x50691c);
			(**(code **)((*ppDVar3)->guid).Data4)(ppDVar3);
			if (local_8 != NULL) {
				(*(code *)(globs::mainGlobs.device)->lpVtbl->SetBufferCount)(globs::mainGlobs.device,2);
			}
			return TRUE;
		}
		debug::Error_SetDXError
							((HRESULT)err,3,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Main.c",568);
	}
	if (err != NULL) {
		debug::Error_SetDXError
							((HRESULT)err,1,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Main.c",576);
	}
	return 0;
}



void __cdecl lego::main::Main_AdjustWindowRect(LPRECT lpRect)
{
						// Adjust rectangle to client coordinates only in windowed mode
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) == 0) {
		AdjustWindowRect(lpRect,globs::mainGlobs.style,0);
	}
	return;
}



void __cdecl
lego::main::Main_Setup3D
					(GraphicsQuality renderQuality,BOOL dither,BOOL linearFilter,BOOL mipMap,BOOL mipMapLinear
					,BOOL blendTransparency,BOOL sortTransparency)
{
	char cVar1;
	DWORD quality;
	
						// D3DRMRENDER_WIREFRAME 0x40 (D3DRMSHADE_FLAT|D3DRMLIGHT_OFF|D3DRMFILL_WIREFRAME)
	quality = 0x40;
	if (renderQuality == QUALITY_FLAT) {
						// D3DRMRENDER_FLAT 0x88 (D3DRMSHADE_FLAT|D3DRMLIGHT_ON|D3DRMFILL_SOLID)
		quality = 0x88;
	}
	if (renderQuality == QUALITY_UNLITFLAT) {
						// D3DRMRENDER_UNLITFLAT 0x80 (D3DRMSHADE_FLAT|D3DRMLIGHT_OFF|D3DRMFILL_SOLID)
		quality = 0x80;
	}
	if (renderQuality == QUALITY_GOURAUD) {
						// D3DRMRENDER_GOURAUD 0x89 (D3DRMSHADE_GOURAUD|D3DRMLIGHT_ON|D3DRMFILL_SOLID)
		quality = 0x89;
	}
	if (linearFilter == 0) {
						// D3DRMTEXTURE_NEAREST 0
		cVar1 = '\0';
	}
	else {
		if (mipMap == 0) {
						// D3DRMTEXTURE_LINEAR 1
			cVar1 = '\x01';
		}
		else {
						// D3DRMTEXTURE_MIPLINEAR 3 (!linearmipmap), D3DRMTEXTURE_LINEARMIPLINEAR 5
			cVar1 = (-(mipMapLinear != 0) & 2U) + 3;
			globs::mainGlobs.flags |= CMD_MIPMAP;
		}
	}
	if (globs::mainGlobs.device != NULL) {
						// IDirect3DRMDevice3::SetDither(THIS_ BOOL)
		(*(globs::mainGlobs.device)->lpVtbl->SetDither)(globs::mainGlobs.device,dither);
						// IDirect3DRMDevice3::SetQuality(THIS_ D3DRMRENDERQUALITY)
		(*(globs::mainGlobs.device)->lpVtbl->SetQuality)(globs::mainGlobs.device,quality);
						// IDirect3DRMDevice3::SetTextureQuality(THIS_ D3DRMTEXTUREQUALITY)
		(*(globs::mainGlobs.device)->lpVtbl->SetTextureQuality)(globs::mainGlobs.device,(DWORD)cVar1);
	}
	return;
}



void __cdecl lego::main::Main_SetTitle(char *title)
{
	SetWindowTextA(globs::mainGlobs.hWnd,title);
	return;
}



BOOL __cdecl lego::main::Main_InitApp(HINSTANCE hInstance)
{
	ATOM AVar1;
	WNDCLASSA wndClass;
	
	wndClass.style = CS_DBLCLKS;
	wndClass.lpfnWndProc = Main_WndProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = hInstance;
	wndClass.hIcon = NULL;
	wndClass.hCursor = NULL;
	wndClass.hbrBackground = NULL;
	wndClass.lpszMenuName = NULL;
	wndClass.lpszClassName = globs::mainGlobs.className;
	AVar1 = RegisterClassA(&wndClass);
	if (AVar1 == 0) {
		MessageBoxA(NULL,"Unable to register window class","Fatal Error",0);
		return 0;
	}
						// WS_POPUP | WS_SYSMENU
	globs::mainGlobs.hWnd =
			 CreateWindowExA(WS_EX_APPWINDOW,globs::mainGlobs.className,____EMPTYSTR__,0x80080000,0,0,100,
											 100,NULL,NULL,hInstance,NULL);
	if (globs::mainGlobs.hWnd != NULL) {
		SetFocus(globs::mainGlobs.hWnd);
		return TRUE;
	}
	MessageBoxA(NULL,"Unable to Create Main Window","Fatal Error",0);
	return 0;
}



LRESULT __cdecl
lego::main::Main_WndProc_Fullscreen(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	LRESULT LVar1;
	
	if (message < 0x11) {
		if (message != 0x10) {
			if (true) {
				switch(message) {
				default:
					break;
				case 2:
					goto switchD_00478794_caseD_2;
				case 3:
				case 5:
				case 6:
					goto switchD_00478830_caseD_200;
				}
			}
			goto switchD_00478830_caseD_207;
		}
	}
	else {
		if (WM_ACTIVATEAPP < message) {
			if (message < WM_NCACTIVATE + 1) {
				if (message == WM_NCACTIVATE) {
switchD_00478830_caseD_200:
					return 0;
				}
				if (message == WM_WINDOWPOSCHANGING) {
					*(uint *)(lParam + 0x18) = *(uint *)(lParam + 0x18) & 0xfffffdff;
					return 0;
				}
			}
			else {
				if (message < WM_SYSKEYDOWN + 1) {
					if (message == WM_SYSKEYDOWN) {
						return 0;
					}
					if ((0xff < message) && (message < 0x102)) {
						return 0;
					}
				}
				else {
					if (true) {
						switch(message) {
						case 0x200:
						case 0x211:
						case 0x212:
							goto switchD_00478830_caseD_200;
						case 0x201:
						case 0x202:
						case 0x204:
						case 0x205:
							if ((globs::mainGlobs.flags & CMD_DUALMOUSE) == CMD_NONE) {
								if (true) {
									switch(message) {
									case 0x201:
									case 0x204:
										if (globs::INPUT.mslb == 0) {
											globs::INPUT.lClicked = 1;
											globs::INPUT.rClicked = 1;
										}
										globs::INPUT.mslb = 1;
										globs::INPUT.msrb = 1;
										globs::INPUT.lDoubleClicked = 1;
										return 0;
									case 0x202:
									case 0x205:
										globs::INPUT.lClicked = 0;
										globs::INPUT.rClicked = 0;
										globs::INPUT.msrb = 0;
										globs::INPUT.mslb = 0;
									}
								}
							}
							else {
								if (true) {
									switch(message) {
									case 0x201:
										globs::INPUT.mslb = 1;
										globs::INPUT.lClicked = 1;
										return 0;
									case 0x202:
										globs::INPUT.mslb = 0;
										globs::INPUT.lClicked = 0;
										return 0;
									case 0x204:
										globs::INPUT.msrb = 1;
										globs::INPUT.rClicked = 1;
										return 0;
									case 0x205:
										globs::INPUT.msrb = 0;
										globs::INPUT.rClicked = 0;
										return 0;
									}
								}
							}
						case 0x203:
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 0x206:
							globs::INPUT.rDoubleClicked = 1;
							return 0;
						}
					}
				}
			}
			goto switchD_00478830_caseD_207;
		}
		if (message == WM_ACTIVATEAPP) {
						// True if this window is being activated
			globs::mainGlobs.active = wParam;
			return 0;
		}
		if (message != WM_QUIT) goto switchD_00478830_caseD_207;
	}
switchD_00478794_caseD_2:
	globs::mainGlobs.exit = 1;
switchD_00478830_caseD_207:
	LVar1 = DefWindowProcA(hWnd,message,wParam,lParam);
	return LVar1;
}



LRESULT __cdecl
lego::main::Main_WndProc_Windowed(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	int iVar1;
	LRESULT LVar2;
	UINT UVar3;
	
	if (message < WM_ACTIVATE + 1) {
		UVar3 = message;
		if (message == WM_ACTIVATE) {
			return 0;
		}
	}
	else {
		if (WM_ACTIVATEAPP < message) {
						// Handle mouse button input (0x201 is WM_LBUTTONDOWN)
			iVar1 = message - 0x201;
			switch(iVar1) {
			case 0:
			case 1:
			case 3:
			case 4:
						// WM_LBUTTONDOWN (0x201) or WM_LBUTTONUP (0x202) or  WM_RBUTTONDOWN (0x204) or
						// WM_RBUTTONUP (0x205)
				if ((globs::mainGlobs.flags & CMD_DUALMOUSE) == CMD_NONE) {
					if (true) {
						switch(iVar1) {
						case 0:
						case 3:
						// WM_LBUTTONDOWN (0x201) or WM_RBUTTONDOWN (0x204)
							SetCapture(hWnd);
							if (globs::INPUT.mslb == 0) {
								globs::INPUT.lClicked = 1;
								globs::INPUT.rClicked = 1;
							}
							globs::INPUT.mslb = 1;
							globs::INPUT.msrb = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 1:
						case 4:
						// WM_LBUTTONUP (0x202) or WM_RBUTTONUP (0x205)
							ReleaseCapture();
							globs::INPUT.lClicked = 0;
							globs::INPUT.rClicked = 0;
							globs::INPUT.msrb = 0;
							globs::INPUT.mslb = 0;
						}
					}
				}
				else {
					if (true) {
						switch(iVar1) {
						case 0:
						// WM_LBUTTONDOWN (0x201)
							SetCapture(hWnd);
							globs::INPUT.mslb = 1;
							globs::INPUT.lClicked = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 1:
						// WM_LBUTTONUP (0x202)
							ReleaseCapture();
							globs::INPUT.mslb = 0;
							globs::INPUT.lClicked = 0;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 3:
							globs::INPUT.msrb = 1;
							globs::INPUT.rClicked = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 4:
						// WM_RBUTTONUP (0x205)
							globs::INPUT.msrb = 0;
							globs::INPUT.rClicked = 0;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						}
					}
				}
			case 2:
						// WM_LBUTTONDBLCLK (0x203)
				globs::INPUT.lDoubleClicked = 1;
						// WM_RBUTTONDBLCLK (0x206)
				return 0;
			case 5:
				globs::INPUT.rDoubleClicked = 1;
				return 0;
			}
			goto switchD_004789e8_caseD_6;
		}
		if (message == WM_ACTIVATEAPP) {
						// True if this window is being activated
			globs::mainGlobs.active = wParam;
			return 0;
		}
						// WM_CLOSE (0x10)  -0x10, is closing
		UVar3 = message - 0x10;
		if (message - 0x10 == 0) {
			globs::mainGlobs.exit = 1;
			return 0;
		}
	}
						// WM_QUIT (0x12)
	if (UVar3 == WM_DESTROY) {
		globs::mainGlobs.exit = 1;
		return 0;
	}
switchD_004789e8_caseD_6:
	LVar2 = DefWindowProcA(hWnd,message,wParam,lParam);
	return LVar2;
}



LRESULT lego::main::Main_WndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	LRESULT LVar1;
	
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) != 0) {
		LVar1 = Main_WndProc_Fullscreen(hWnd,message,wParam,lParam);
		return LVar1;
	}
	LVar1 = Main_WndProc_Windowed(hWnd,message,wParam,lParam);
	return LVar1;
}



void __cdecl
lego::main::Main_ChangeRenderState
					(D3DRenderStateType dwRenderStateType,D3DRenderStateType dwRenderState)
{
	D3DRenderStateType DVar1;
	
	DVar1 = dwRenderStateType;
						// IDirect3DDevice3->GetRenderState(this, D3DRenderStateType dwRenderStateType, DWORD*
						// lpdwRenderState)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
						(globs::mainGlobs.imDevice,dwRenderStateType,&dwRenderStateType);
	if (dwRenderStateType != dwRenderState) {
						// IDirect3DDevice3->SetRenderState(this, D3DRenderStateType dwRenderStateType, DWORD
						// dwRenderState)
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
							(globs::mainGlobs.imDevice,DVar1,dwRenderState);
		if (globs::mainGlobs.renderStateData[DVar1].changed == 0) {
			globs::mainGlobs.renderStateData[DVar1].changed = 1;
			globs::mainGlobs.renderStateData[DVar1].origValue = dwRenderStateType;
		}
		else {
			if (globs::mainGlobs.renderStateData[DVar1].origValue == dwRenderStateType) {
				globs::mainGlobs.renderStateData[DVar1].changed = 0;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::main::Main_RestoreStates(void)
{
	MainFlags *pMVar1;
	D3DRenderStateType DVar2;
	
	DVar2 = 0;
	pMVar1 = (MainFlags *)&globs::mainGlobs.renderStateData[0].changed;
	do {
		if (*pMVar1 != CMD_NONE) {
						// IDirect3DDevice3->SetRenderState(this, D3DRenderStateType dwRenderStateType, DWORD
						// dwRenderState)
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
								(globs::mainGlobs.imDevice,DVar2,pMVar1[-1]);
			*pMVar1 = CMD_NONE;
		}
		pMVar1 = pMVar1 + 2;
		DVar2 += D3DRENDERSTATE_TEXTUREHANDLE;
	} while (pMVar1 < &globs::mainGlobs.flags);
	return;
}



BOOL __cdecl lego::main::Main_SetCDVolume(float leftVolume,float rightVolume)
{
	BOOL BVar1;
	
	BVar1 = Main_CDVolume(&leftVolume,&rightVolume,1);
	return BVar1;
}



BOOL __cdecl lego::main::Main_GetCDVolume(float *out_leftVolume,float *out_rightVolume)
{
	BOOL BVar1;
	
	BVar1 = Main_CDVolume(out_leftVolume,out_rightVolume,0);
	return BVar1;
}



BOOL __cdecl lego::main::Main_CDVolume(float *ref_leftVolume,float *ref_rightVolume,BOOL set)
{
	UINT UVar1;
	MMRESULT MVar2;
	LPMIXERCONTROLA buffer;
	uint *buffer_00;
	uint uVar3;
	int iVar4;
	uint *puVar5;
	uint uVar6;
	uint uVar7;
	_union_1085 *p_Var8;
	UINT_PTR uMxId;
	tagMIXERCAPSA *ptVar9;
	tagMIXERLINEA *ptVar10;
	tagMIXERLINECONTROLSA *ptVar11;
	tMIXERCONTROLDETAILS *ptVar12;
	float10 extraout_ST0;
	longlong lVar13;
	HMIXEROBJ local_154;
	BOOL local_150;
	uint local_14c;
	uint local_148;
	uint local_144;
	uint local_140;
	UINT local_13c;
	uint local_138;
	LPMIXERCONTROLA local_134;
	uint local_130;
	undefined4 uStack300;
	int local_128;
	undefined4 local_124;
	tMIXERCONTROLDETAILS local_120;
	int local_108;
	undefined4 local_104;
	uint local_100;
	undefined4 uStack252;
	uint local_f8;
	undefined4 uStack244;
	tagMIXERLINECONTROLSA local_f0;
	tagMIXERLINEA local_d8;
	tagMIXERCAPSA local_30;
	
	UVar1 = mixerGetNumDevs();
	local_150 = 0;
	if (set != 0) {
		if ((ushort)((ushort)(*ref_leftVolume < 1.0) << 8 | (ushort)(*ref_leftVolume == 1.0) << 0xe) ==
				0) {
			*ref_leftVolume = 1.0;
		}
		if (*ref_leftVolume < 0.0) {
			*ref_leftVolume = 0.0;
		}
		if ((ushort)((ushort)(*ref_rightVolume < 1.0) << 8 | (ushort)(*ref_rightVolume == 1.0) << 0xe)
				== 0) {
			*ref_rightVolume = 1.0;
		}
		if (*ref_rightVolume < 0.0) {
			*ref_rightVolume = 0.0;
		}
	}
	local_140 = 0;
	local_13c = UVar1;
	if (UVar1 != 0) {
		do {
			uMxId = local_140;
			MVar2 = mixerOpen((LPHMIXER)&local_154,local_140,0,0,0);
			if (MVar2 == 0) {
				ptVar9 = &local_30;
				for (iVar4 = 0xc; iVar4 != 0; iVar4 += -1) {
					*(undefined4 *)ptVar9 = 0;
					ptVar9 = (tagMIXERCAPSA *)&ptVar9->vDriverVersion;
				}
				mixerGetDevCapsA(uMxId,(LPMIXERCAPSA)&local_30,0x30);
				local_148 = 0;
				if (local_30.cDestinations != 0) {
					do {
						uVar3 = local_148;
						ptVar10 = &local_d8;
						for (iVar4 = 0x2a; iVar4 != 0; iVar4 += -1) {
							ptVar10->cbStruct = 0;
							ptVar10 = (tagMIXERLINEA *)&ptVar10->dwDestination;
						}
						local_d8.cbStruct = 0xa8;
						local_d8.dwDestination = local_148;
						MVar2 = mixerGetLineInfoA(local_154,(LPMIXERLINEA)&local_d8,0);
						if (MVar2 == 0) {
							local_138 = local_d8.cConnections;
							local_144 = 0;
							uMxId = local_140;
							if (local_d8.cConnections != 0) {
								do {
									uVar7 = local_144;
									local_d8.cbStruct = 0xa8;
									local_d8.dwDestination = uVar3;
									local_d8.dwSource = local_144;
									MVar2 = mixerGetLineInfoA(local_154,(LPMIXERLINEA)&local_d8,1);
									if ((MVar2 == 0) && (local_d8.dwComponentType == 0x1005)) {
										ptVar11 = &local_f0;
										for (iVar4 = 6; iVar4 != 0; iVar4 += -1) {
											ptVar11->cbStruct = 0;
											ptVar11 = (tagMIXERLINECONTROLSA *)&ptVar11->dwLineID;
										}
										local_f0.cbStruct = 0x18;
										local_f0.dwLineID = local_d8.dwLineID;
										local_f0.cControls = local_d8.cControls;
										local_f0.cbmxctrl = 0x94;
										buffer = (LPMIXERCONTROLA)std::malloc(local_d8.cControls * 0x94);
										local_134 = buffer;
										local_f0.pamxctrl = buffer;
										MVar2 = mixerGetLineControlsA(local_154,(LPMIXERLINECONTROLSA)&local_f0,0);
										if ((MVar2 == 0) && (local_14c = 0, local_d8.cControls != 0)) {
											p_Var8 = &buffer->Bounds;
											do {
												if (((*(uint *)&p_Var8[-4].field_0x4 & 0x50000000) != 0) &&
													 ((*(uint *)&p_Var8[-4].field_0x4 & 0x50030001) != 0)) {
													local_120.dwControlID = *(DWORD *)(p_Var8 + -4);
													ptVar12 = &local_120;
													for (iVar4 = 6; iVar4 != 0; iVar4 += -1) {
														ptVar12->cbStruct = 0;
														ptVar12 = (tMIXERCONTROLDETAILS *)&ptVar12->dwControlID;
													}
													local_120.cbStruct = 0x18;
													local_120.cChannels = local_d8.cChannels;
													local_120.cbDetails = 4;
													local_120.u = 0;
													buffer_00 = (uint *)std::malloc(local_d8.cChannels << 2);
													local_120.paDetails = buffer_00;
													if (set == 0) {
														MVar2 = mixerGetControlDetailsA
																							(local_154,(LPMIXERCONTROLDETAILS)&local_120,0);
														if (MVar2 == 0) {
															local_100 = *buffer_00 - *(int *)p_Var8;
															uStack252 = 0;
															local_108 = *(int *)&p_Var8->field_0x4 - *(int *)p_Var8;
															local_104 = 0;
															*ref_leftVolume = (float)(ulonglong)local_100 / (float)local_108;
															if (local_d8.cChannels == 2) {
																local_130 = buffer_00[1] - *(int *)p_Var8;
																uStack300 = 0;
																local_128 = *(int *)&p_Var8->field_0x4 - *(int *)p_Var8;
																local_124 = 0;
																local_150 = 1;
																*ref_rightVolume = (float)(ulonglong)local_130 / (float)local_128;
															}
															else {
																local_150 = 1;
																*ref_rightVolume = (float)(ulonglong)local_100 / (float)local_108;
															}
														}
													}
													else {
														iVar4 = *(int *)p_Var8;
														local_f8 = *(int *)&p_Var8->field_0x4 - iVar4;
														uStack244 = 0;
														lVar13 = __ftol((float10)*ref_leftVolume * (float10)(ulonglong)local_f8)
														;
														uVar7 = (int)lVar13 + iVar4;
														lVar13 = __ftol((float10)*ref_rightVolume * extraout_ST0);
														uVar3 = (int)lVar13 + iVar4;
														if (local_d8.cChannels == 2) {
															*buffer_00 = uVar7;
															buffer_00[1] = uVar3;
														}
														else {
															uVar6 = 0;
															if (local_d8.cChannels != 0) {
																puVar5 = buffer_00;
																do {
																	*puVar5 = uVar3 + uVar7 >> 1;
																	uVar6 += 1;
																	puVar5 = puVar5 + 1;
																} while (uVar6 < local_d8.cChannels);
															}
														}
														MVar2 = mixerSetControlDetails
																							(local_154,(LPMIXERCONTROLDETAILS)&local_120,0);
														if (MVar2 == 0) {
															local_150 = 1;
														}
													}
													std::free(buffer_00);
													buffer = local_134;
												}
												local_14c += 1;
												p_Var8 = (_union_1085 *)&p_Var8[6].field_0x4;
												uVar3 = local_148;
												uVar7 = local_144;
											} while (local_14c < local_d8.cControls);
										}
										std::free(buffer);
									}
									local_144 = uVar7 + 1;
									uMxId = local_140;
								} while (local_144 < local_138);
							}
						}
						local_148 = uVar3 + 1;
					} while (local_148 < local_30.cDestinations);
				}
				mixerClose((HMIXER)local_154);
				UVar1 = local_13c;
			}
			local_140 = uMxId + 1;
		} while (local_140 < UVar1);
	}
	return local_150;
}



void __cdecl lego::cfg::Config_Initialise(void)
{
	int iVar1;
	CFGProperty **ppCVar2;
	
	ppCVar2 = globs::configGlobs.listSet;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		*ppCVar2 = NULL;
		ppCVar2 = ppCVar2 + 1;
	}
	globs::configGlobs.freeList = NULL;
	globs::configGlobs.listCount = 0;
	globs::configGlobs.flags = 1;
	return;
}



void __cdecl lego::cfg::Config_Shutdown(void)
{
	CFGProperty **ppCVar1;
	
	ppCVar1 = globs::configGlobs.listSet;
	do {
		if (*ppCVar1 != NULL) {
			std::free(*ppCVar1);
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &globs::configGlobs.freeList);
	globs::configGlobs.freeList = NULL;
	globs::configGlobs.flags = 0;
	return;
}



CFGProperty * __cdecl lego::cfg::CFG_Open(char *filename)
{
	char cVar1;
	CFGProperty *current;
	uint uVar2;
	char *pcVar3;
	CFGProperty *root;
	char *text;
	char *pcVar4;
	char *pcVar5;
	bool isComment;
	char c;
	
	root = NULL;
	isComment = false;
	text = (char *)lego::file::File_LoadBinary(filename,(uint *)&filename);
	if ((byte *)text != NULL) {
		root = Config_Create(NULL);
		pcVar4 = NULL;
		root->fileData = text;
		if (filename != NULL) {
			do {
				c = *text;
				if (c == ';') {
					isComment = true;
				}
				else {
					if (c == '\n') {
						isComment = false;
					}
				}
				if ((((isComment) || (c == '\t')) || (c == '\n')) || ((c == '\r' || (c == ' ')))) {
					*text = 0;
				}
				text = (char *)((byte *)text + 1);
				pcVar4 = pcVar4 + 1;
			} while (pcVar4 < filename);
		}
		pcVar4 = root->fileData;
		pcVar5 = NULL;
		current = root;
		pcVar3 = filename;
		if (filename != NULL) {
			do {
				if (*pcVar4 == '\0') {
					pcVar4 = pcVar4 + 1;
				}
				else {
					if ((*pcVar4 == '}') && (pcVar4[1] == '\0')) {
						uVar2 = current->depth - 1;
LAB_004791e1:
						current->depth = uVar2;
					}
					else {
						if (current->key == NULL) {
							current->key = pcVar4;
						}
						else {
							current->value = pcVar4;
							current = Config_Create(current);
							if ((*pcVar4 == '{') && (pcVar4[1] == '\0')) {
								uVar2 = current->depth + 1;
								goto LAB_004791e1;
							}
						}
					}
					while ((pcVar3 = filename, pcVar5 < filename &&
								 (cVar1 = *pcVar4, pcVar4 = pcVar4 + 1, cVar1 != '\0'))) {
						pcVar5 = pcVar5 + 1;
					}
				}
				pcVar5 = pcVar5 + 1;
			} while (pcVar5 < pcVar3);
		}
	}
	return root;
}



// Variadic function to join a path used for all CFGProperty lookup functions
// NULL must be specified as the final argument, to signal the end of path arguments.
// The returned buffer is TEMPORARY, and must be used immediately before the next
// call to this function.

char * __cdecl lego::cfg::CFG_JoinPath(char *keyPath1,...)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	char **ppcVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	Config_Globs *pCVar9;
	Config_Globs *pCVar10;
	undefined4 *puVar11;
	char *in_stack_00000008;
	
	uVar2 = 0xffffffff;
	do {
		pcVar8 = keyPath1;
		if (uVar2 == 0) break;
		uVar2 -= 1;
		pcVar8 = keyPath1 + 1;
		cVar1 = *keyPath1;
		keyPath1 = pcVar8;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	ppcVar5 = (char **)&stack0x0000000c;
	puVar6 = (undefined4 *)(pcVar8 + -uVar2);
	pCVar9 = &globs::configGlobs;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
		*(undefined4 *)pCVar9->s_JoinPath_string = *puVar6;
		puVar6 = puVar6 + 1;
		pCVar9 = (Config_Globs *)(pCVar9->s_JoinPath_string + 4);
	}
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		pCVar9->s_JoinPath_string[0] = *(char *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		pCVar9 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
	}
	if (in_stack_00000008 != NULL) {
		do {
			uVar2 = 0xffffffff;
			pcVar8 = "::";
			do {
				pcVar7 = pcVar8;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar7 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar7;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			iVar4 = -1;
			pCVar9 = &globs::configGlobs;
			do {
				pCVar10 = pCVar9;
				if (iVar4 == 0) break;
				iVar4 += -1;
				pCVar10 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
				pcVar8 = pCVar9->s_JoinPath_string;
				pCVar9 = pCVar10;
			} while (*pcVar8 != '\0');
			puVar6 = (undefined4 *)(pcVar7 + -uVar2);
			puVar11 = (undefined4 *)((int)&pCVar10[-1].flags + 3);
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*puVar11 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar11 = puVar11 + 1;
			}
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar11 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			uVar2 = 0xffffffff;
			do {
				pcVar8 = in_stack_00000008;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar8 = in_stack_00000008 + 1;
				cVar1 = *in_stack_00000008;
				in_stack_00000008 = pcVar8;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			iVar4 = -1;
			pCVar9 = &globs::configGlobs;
			do {
				pCVar10 = pCVar9;
				if (iVar4 == 0) break;
				iVar4 += -1;
				pCVar10 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
				pcVar7 = pCVar9->s_JoinPath_string;
				pCVar9 = pCVar10;
			} while (*pcVar7 != '\0');
			puVar6 = (undefined4 *)(pcVar8 + -uVar2);
			puVar11 = (undefined4 *)((int)&pCVar10[-1].flags + 3);
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*puVar11 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar11 = puVar11 + 1;
			}
			in_stack_00000008 = *ppcVar5;
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar11 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			ppcVar5 = ppcVar5 + 1;
		} while (in_stack_00000008 != NULL);
	}
	return globs::configGlobs.s_JoinPath_string;
}



CFGProperty * __cdecl lego::cfg::CFG_GetChildren(CFGProperty *prop,char *keyPath)
{
	CFGProperty *getProp;
	
	getProp = CFG_GetProperty(prop,keyPath);
	if ((getProp != NULL) && (getProp->depth < getProp->linkNext->depth)) {
		return getProp->linkNext;
	}
	return NULL;
}



// Returns the next CFGProperty in the same block, and at the same depth
// Returns NULL if there are no more properties, or if prop is NULL

CFGProperty * __cdecl lego::cfg::CFG_NextFlat(CFGProperty *prop)
{
	uint nextDepth;
	uint currentDepth;
	
	currentDepth = prop->depth;
	nextDepth = currentDepth;
	if (prop != NULL) {
		do {
			if (nextDepth < currentDepth) {
				return NULL;
			}
			prop = prop->linkNext;
			if (prop->depth == currentDepth) {
				return prop;
			}
			nextDepth = prop->depth;
		} while (prop != NULL);
	}
	return NULL;
}



char * __cdecl lego::cfg::CFG_CopyString(CFGProperty *prop,char *keyPath)
{
	char cVar1;
	CFGProperty *pCVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	undefined4 *puVar9;
	
	pCVar2 = CFG_GetProperty(prop,keyPath);
	if ((pCVar2 == NULL) || (pCVar2->value == NULL)) {
		return (char *)NULL;
	}
	uVar4 = 0xffffffff;
	pcVar7 = pCVar2->value;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (cVar1 != '\0');
	puVar3 = (undefined4 *)std::malloc(~uVar4);
	uVar4 = 0xffffffff;
	pcVar7 = pCVar2->value;
	do {
		pcVar8 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar8 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar8;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar8 + -uVar4);
	puVar9 = puVar3;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	return (char *)puVar3;
}



char * __cdecl lego::cfg::CFG_ReadString(CFGProperty *prop,char *keyPath)
{
	CFGProperty *getProp;
	
	getProp = CFG_GetProperty(prop,keyPath);
	if (getProp != NULL) {
		return getProp->value;
	}
	return NULL;
}



BoolTri __cdecl lego::cfg::CFG_ReadBool(CFGProperty *prop,char *keyPath)
{
	char *str;
	BoolTri BVar1;
	
	BVar1 = BOOL3_ERROR;
	str = CFG_CopyString(prop,keyPath);
	if (str != NULL) {
		BVar1 = util::Util_GetBoolFromString(str);
		std::free(str);
	}
	return BVar1;
}



// Reads a CFG float property specified in degrees, and returns the value in radians

float10 __cdecl lego::cfg::CFG_ReadRadians(CFGProperty *prop,char *keyPath)
{
	char *pcVar1;
	float10 fVar2;
	
	pcVar1 = CFG_ReadString(prop,keyPath);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = CFG_ReadString(prop,keyPath);
	}
	fVar2 = std::atof(pcVar1);
	if (fVar2 != (float10)0.0) {
						// value / 360.0 * (M_PI * 2.0)
		return fVar2 * (float10)0.002777778 * (float10)6.283185;
	}
	return (float10)0.0;
}



BOOL __cdecl
lego::cfg::CFG_ReadRGBF(CFGProperty *prop,char *keyPath,float *out_r,float *out_g,float *out_b)
{
	char *input;
	int numParts;
	int channel;
	uint result;
	char *parts_0;
	char *parts_1;
	char *parts_2;
	
	result = 0;
	input = CFG_CopyString(prop,keyPath);
	if (input != NULL) {
		numParts = util::Util_Tokenise(input,&parts_0,":");
		if (numParts == 3) {
			channel = std::atoi(parts_0);
						// channel / 255.0
			*out_r = (float)channel * 0.003921569;
			channel = std::atoi(parts_1);
			*out_g = (float)channel * 0.003921569;
			channel = std::atoi(parts_2);
			*out_b = (float)channel * 0.003921569;
		}
		result = (uint)(numParts == 3);
		std::free(input);
	}
	return result;
}



void __cdecl lego::cfg::CFG_Close(CFGProperty *root)
{
	CFGProperty *prop;
	
	std::free(root->fileData);
	if (root != NULL) {
		do {
			prop = root->linkNext;
			Config_Remove(root);
			root = prop;
		} while (prop != NULL);
	}
	return;
}



CFGProperty * __cdecl lego::cfg::Config_Create(CFGProperty *prev)
{
	uint uVar1;
	CFGProperty *pCVar2;
	CFGProperty *pCVar3;
	CFGProperty *next;
	
	if (globs::configGlobs.freeList == NULL) {
		Config_AddList();
	}
	pCVar2 = globs::configGlobs.freeList;
	next = globs::configGlobs.freeList;
	pCVar3 = (globs::configGlobs.freeList)->nextFree;
	(globs::configGlobs.freeList)->nextFree = globs::configGlobs.freeList;
	globs::configGlobs.freeList = pCVar3;
	pCVar2->key = NULL;
	pCVar2->value = NULL;
	pCVar2->linkNext = NULL;
	if (prev != NULL) {
		prev->linkNext = pCVar2;
		pCVar2->linkPrev = prev;
		uVar1 = prev->depth;
		pCVar2->fileData = NULL;
		pCVar2->depth = uVar1;
		return next;
	}
	pCVar2->depth = 0;
	pCVar2->linkPrev = NULL;
	return next;
}



void __cdecl lego::cfg::Config_Remove(CFGProperty *prop)
{
	prop->nextFree = globs::configGlobs.freeList;
	globs::configGlobs.freeList = prop;
	return;
}



CFGProperty * __cdecl lego::cfg::CFG_GetProperty(CFGProperty *prop,char *keyPath)
{
	char *pcVar1;
	int numParts;
	int tmpCmp;
	uint uVar2;
	char *pcVar3;
	uint uVar4;
	undefined4 *puVar5;
	size_t sVar6;
	char *pcVar7;
	undefined4 *puVar8;
	bool isWildcard;
	CFGProperty *result;
	char *input_parts [101];
	char c;
	uint depth;
	CFGProperty *previous;
	
	depth = 0xffffffff;
	pcVar7 = keyPath;
	do {
		if (depth == 0) break;
		depth -= 1;
		c = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (c != '\0');
	result = NULL;
	input_parts[0] = (char *)std::malloc(~depth);
	depth = 0xffffffff;
	do {
		pcVar7 = keyPath;
		if (depth == 0) break;
		depth -= 1;
		pcVar7 = keyPath + 1;
		c = *keyPath;
		keyPath = pcVar7;
	} while (c != '\0');
	depth = ~depth;
	puVar5 = (undefined4 *)(pcVar7 + -depth);
	puVar8 = (undefined4 *)input_parts[0];
	for (uVar2 = depth >> 2; uVar2 != 0; uVar2 -= 1) {
		*puVar8 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar8 = puVar8 + 1;
	}
	for (depth &= 3; depth != 0; depth -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	numParts = util::Util_Tokenise(input_parts[0],input_parts + 1,"::");
	if (prop != NULL) {
		do {
			if (prop->depth == numParts - 1U) {
						// CFG_IsKeyMatch
				isWildcard = false;
				if (numParts == 1) {
					pcVar7 = prop->key;
					sVar6 = 0;
					c = *pcVar7;
					pcVar3 = pcVar7;
					while ((c != '\0' && (c != '*'))) {
						pcVar1 = pcVar3 + 1;
						sVar6 += 1;
						pcVar3 = pcVar3 + 1;
						c = *pcVar1;
					}
					if (*pcVar3 == '*') {
						tmpCmp = std::_strnicmp(input_parts[1],pcVar7,sVar6);
						isWildcard = tmpCmp == 0;
					}
				}
				if ((isWildcard) || (tmpCmp = std::_stricmp(input_parts[numParts],prop->key), tmpCmp == 0))
				{
					isWildcard = false;
					depth = numParts - 1U;
					for (previous = prop; previous != NULL; previous = previous->linkPrev) {
						// CFG_IsKeyMatch
						uVar2 = depth - 1;
						uVar4 = depth;
						if (previous->depth == uVar2) {
							if (depth == 1) {
								pcVar7 = previous->key;
								sVar6 = 0;
								c = *pcVar7;
								pcVar3 = pcVar7;
								while ((c != '\0' && (c != '*'))) {
									pcVar1 = pcVar3 + 1;
									sVar6 += 1;
									pcVar3 = pcVar3 + 1;
									c = *pcVar1;
								}
								if (*pcVar3 == '*') {
									tmpCmp = std::_strnicmp(input_parts[1],pcVar7,sVar6);
									isWildcard = tmpCmp == 0;
								}
							}
							uVar4 = uVar2;
							if ((!isWildcard) &&
								 (tmpCmp = std::_stricmp(input_parts[depth],previous->key), tmpCmp != 0)) break;
						}
						depth = uVar4;
					}
					if ((depth == 0) && (result = prop, !isWildcard)) break;
				}
			}
			prop = prop->linkNext;
		} while (prop != NULL);
	}
	std::free(input_parts[0]);
	return result;
}



void __cdecl lego::cfg::Config_AddList(void)
{
	CFGProperty *pCVar1;
	CFGProperty *pCVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::configGlobs.listCount & 0x1f);
	pCVar2 = (CFGProperty *)std::malloc(uVar4 * 0x20);
	globs::configGlobs.listSet[globs::configGlobs.listCount] = pCVar2;
	pCVar2 = globs::configGlobs.listSet[globs::configGlobs.listCount];
	if (pCVar2 != NULL) {
		globs::configGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pCVar1 = pCVar2;
			do {
				pCVar1->nextFree = pCVar1 + 1;
				iVar3 += -1;
				pCVar1 = pCVar1 + 1;
			} while (iVar3 != 0);
		}
		pCVar2[uVar4 - 1].nextFree = globs::configGlobs.freeList;
		globs::configGlobs.freeList = pCVar2;
	}
	return;
}



// out_vector = norm({ rand(), rand(), rand() })

Vector3F * __cdecl lego::math::Maths_Vector3DRandom(Vector3F *out_vector)
{
	Vector3F *pVVar1;
	
	pVVar1 = D3DRMVectorRandom(out_vector);
	return pVVar1;
}



// out_vector = ::D3DRMVectorRotate(out_vector, v, axis, theta)

Vector3F * __cdecl
lego::math::Maths_Vector3DRotate(Vector3F *out_vector,Vector3F *v,Vector3F *axis,float theta)
{
	Vector3F *pVVar1;
	
	pVVar1 = D3DRMVectorRotate(out_vector,v,axis,theta);
	return pVVar1;
}



// out_vector = norm(cross_product((c - b), (b - a)))

Vector3F * __cdecl
lego::math::Maths_PlaneNormal(Vector3F *out_vector,Vector3F *p1,Vector3F *p2,Vector3F *p3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	
	fVar1 = p3->x - p2->x;
	fVar4 = p2->x - p1->x;
	fVar3 = p3->y - p2->y;
	fVar5 = p3->z - p2->z;
	fVar6 = p2->y - p1->y;
	fVar7 = p2->z - p1->z;
	fVar2 = fVar1 * fVar7 - fVar5 * fVar4;
	fVar4 = fVar3 * fVar4 - fVar1 * fVar6;
	fVar3 = fVar5 * fVar6 - fVar3 * fVar7;
	fVar1 = 1.0 / SQRT(fVar3 * fVar3 + fVar4 * fVar4 + fVar2 * fVar2);
	out_vector->x = fVar1 * fVar3;
	out_vector->y = fVar1 * fVar2;
	out_vector->z = fVar1 * fVar4;
	return out_vector;
}



float10 __cdecl lego::math::Maths_TriangleAreaZ(Vector3F *p1,Vector3F *p2,Vector3F *p3,BOOL bfc)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F *pVVar5;
	Vector3F *pVVar6;
	int iVar7;
	float *pfVar8;
	Vector3F *pVVar9;
	Vector3F **ppVVar10;
	uint uVar11;
	float10 fVar12;
	float local_8c;
	uint local_88;
	float local_7c;
	Vector3F local_78;
	Vector3F local_6c;
	Vector3F local_60;
	Vector3F *local_54 [5];
	Vector3F *local_40;
	Vector3F local_3c;
	Vector3F local_30 [3];
	
	local_54[0] = &local_78;
	local_54[1] = &local_6c;
	local_54[3] = &local_60;
	local_54[2] = &local_6c;
	local_54[4] = &local_60;
	local_78.x = p1->x;
	local_40 = &local_78;
	local_78.y = p1->y;
	local_6c.x = p2->x;
	local_6c.y = p2->y;
	local_60.x = p3->x;
	local_60.y = p3->y;
	local_7c = 0.0;
	local_8c = 0.0;
	local_78.z = 0.0;
	local_6c.z = 0.0;
	local_60.z = 0.0;
	if (bfc == 0) {
		local_3c.z = -1.0;
	}
	else {
		Maths_PlaneNormal(&local_3c,&local_78,&local_6c,&local_60);
	}
	if (local_3c.z < 0.0) {
		uVar11 = 0;
		pVVar9 = local_30;
		ppVVar10 = local_54 + 1;
		pfVar8 = &local_30[1].z;
		do {
			pVVar5 = *ppVVar10;
			pVVar6 = ppVVar10[-1];
			fVar1 = pVVar5->y;
			fVar2 = pVVar5->z;
			fVar3 = pVVar6->y;
			fVar4 = pVVar6->z;
			pfVar8[-2] = pVVar5->x - pVVar6->x;
			pfVar8[-1] = fVar1 - fVar3;
			*pfVar8 = fVar2 - fVar4;
			fVar2 = SQRT(pfVar8[-2] * pfVar8[-2] + *pfVar8 * *pfVar8 + pfVar8[-1] * pfVar8[-1]);
			fVar3 = 1.0 / fVar2;
			fVar1 = pfVar8[-2];
			pVVar9->x = fVar2;
			fVar2 = pVVar9->x;
			pfVar8[-2] = fVar3 * fVar1;
			pfVar8[-1] = fVar3 * pfVar8[-1];
			*pfVar8 = fVar3 * *pfVar8;
			if ((ushort)((ushort)(fVar2 < local_8c) << 8 | (ushort)(fVar2 == local_8c) << 0xe) == 0) {
				local_8c = pVVar9->x;
				local_88 = uVar11;
			}
			uVar11 += 1;
			ppVVar10 = ppVVar10 + 2;
			pfVar8 = pfVar8 + 3;
			pVVar9 = (Vector3F *)&pVVar9->y;
		} while (uVar11 < 3);
		uVar11 = (local_88 + 1) % 3;
		local_30[local_88 + 1].x = local_30[local_88 + 1].x * -1.0;
		local_30[local_88 + 1].y = local_30[local_88 + 1].y * -1.0;
		local_30[local_88 + 1].z = local_30[local_88 + 1].z * -1.0;
						// Standard library math functions have some nasty ASM in them.
						// I believe the second function is testing against FPU control word results(?)
		fVar12 = std::acos((float10)local_30[uVar11 + 1].x * (float10)local_30[local_88 + 1].x +
											 (float10)local_30[local_88 + 1].z * (float10)local_30[uVar11 + 1].z +
											 (float10)local_30[local_88 + 1].y * (float10)local_30[uVar11 + 1].y);
		iVar7 = std::_finite((double)fVar12);
		if (iVar7 != 0) {
			fVar12 = (float10)fsin((float10)(float)fVar12);
			local_7c = (float)((float10)(&local_30[0].x)[local_88] * (float10)0.5 *
												fVar12 * (float10)(&local_30[0].x)[uVar11]);
		}
	}
	return (float10)local_7c;
}



short __cdecl lego::math::Maths_Rand(void)
{
	std::globals::g_rand = std::globals::g_rand * 0x343fd + 0x269ec3;
	return (short)((ushort)(std::globals::g_rand >> 0x10) & 0x7fff);
}



float10 __cdecl lego::math::Maths_RandRange(float low,float high)
{
	short sVar1;
	
	sVar1 = Maths_Rand();
	return (float10)(int)sVar1 * (float10)3.051851e-05 * ((float10)high - (float10)low) + (float10)low
	;
}



// out_vector = a + (norm(b) * (dot_product((c - a), norm(d)) / dot_product(norm(b), norm(d)))
// CONDITION: dot_product(norm(b), norm(d)) != 0.0

BOOL __cdecl
lego::math::Maths_RayPlaneIntersection
					(Vector3F *out_endPoint,Vector3F *rayOrigin,Vector3F *ray,Vector3F *planePoint,
					Vector3F *planeNormal)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	BOOL BVar8;
	Vector3F norm_b;
	Vector3F norm_d;
	
	fVar1 = planeNormal->x;
	fVar2 = ray->x;
	fVar3 = planeNormal->y;
	fVar4 = ray->y;
	fVar5 = ray->z;
	fVar6 = planeNormal->z;
	fVar7 = 1.0 / SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar2 * fVar2);
	ray = (Vector3F *)(1.0 / SQRT(fVar6 * fVar6 + fVar3 * fVar3 + fVar1 * fVar1));
	norm_b.x = fVar7 * fVar2;
	norm_b.y = fVar7 * fVar4;
	norm_b.z = fVar7 * fVar5;
	norm_d.x = (float)ray * fVar1;
	norm_d.y = (float)ray * fVar3;
	norm_d.z = (float)ray * fVar6;
	BVar8 = Maths_RayPlaneDistance((float *)&ray,rayOrigin,&norm_b,planePoint,&norm_d);
	if (BVar8 != 0) {
		Maths_RayEndPoint(out_endPoint,rayOrigin,&norm_b,(float)ray);
		return TRUE;
	}
	return 0;
}



// out_value = dot_product((c - a), d) / dot_product(b, d)
// CONDITION: dot_product(b, d) != 0.0

BOOL __cdecl
lego::math::Maths_RayPlaneDistance
					(float *out_dist,Vector3F *rayOrigin,Vector3F *ray,Vector3F *planePoint,
					Vector3F *planeNormal)
{
	float dot_product;
	
						// Vector3_DotProduct(b, d)
	dot_product = planeNormal->x * ray->x + ray->z * planeNormal->z + ray->y * planeNormal->y;
	if (dot_product != 0.0) {
						// Vector3_Multiply((Vector3_Subtract(c, a), d)
		*out_dist = ((planePoint->x - rayOrigin->x) * planeNormal->x +
								(planePoint->y - rayOrigin->y) * planeNormal->y +
								(planePoint->z - rayOrigin->z) * planeNormal->z) / dot_product;
		return TRUE;
	}
	return 0;
}



// out_vector = a + (b * scalar)

Vector3F * __cdecl
lego::math::Maths_RayEndPoint(Vector3F *out_endPoint,Vector3F *rayOrigin,Vector3F *ray,float dist)
{
	float fVar1;
	float fVar2;
	
	fVar1 = ray->y;
	fVar2 = ray->z;
	out_endPoint->x = dist * ray->x + rayOrigin->x;
	out_endPoint->y = rayOrigin->y + fVar1 * dist;
	out_endPoint->z = rayOrigin->z + fVar2 * dist;
	return out_endPoint;
}



// out_point = a + (b * dot_product((a - c), (perpendicular(d) / dot_product(perpendicular(b), d))))
// CONDITION: dot_product(perpendicular(b), d) != 0.0

Point2F * __cdecl
lego::math::Maths_Vector2DIntersection
					(Point2F *out_intersection,Point2F *start1,Point2F *vector1,Point2F *start2,
					Point2F *vector2)
{
	float fVar1;
	
	fVar1 = -vector1->y * vector2->x - -vector1->x * vector2->y;
	if (fVar1 != 0.0) {
		fVar1 = (start1->x - start2->x) * -(vector2->y / fVar1) +
						(vector2->x / fVar1) * (start1->y - start2->y);
		out_intersection->x = fVar1 * vector1->x;
		out_intersection->y = fVar1 * vector1->y;
		out_intersection->x = start1->x + out_intersection->x;
		out_intersection->y = out_intersection->y + start1->y;
		return out_intersection;
	}
	return NULL;
}



BOOL __cdecl
lego::math::Maths_PointInsidePoly(Point2F *point,Point2F *fromList,Point2F *toList,uint count)
{
	float fVar1;
	float *pfVar2;
	uint uVar3;
	int iVar4;
	
	uVar3 = 0;
	if (count != 0) {
		pfVar2 = &fromList->y;
		iVar4 = (int)toList - (int)fromList;
		do {
			if (((((ushort)((ushort)(*pfVar2 < point->y) << 8 | (ushort)(*pfVar2 == point->y) << 0xe) != 0
						) && (point->y <= *(float *)(iVar4 + (int)pfVar2))) ||
					((point->y <= *pfVar2 &&
					 ((ushort)((ushort)(*(float *)(iVar4 + (int)pfVar2) < point->y) << 8 |
										(ushort)(*(float *)(iVar4 + (int)pfVar2) == point->y) << 0xe) != 0)))) &&
				 (fVar1 = (toList->x - pfVar2[-1]) *
									((*(float *)(iVar4 + (int)pfVar2) - *pfVar2) / (point->y - *pfVar2)) + pfVar2[-1],
				 (ushort)((ushort)(fVar1 < point->x) << 8 | (ushort)(fVar1 == point->x) << 0xe) == 0)) {
				uVar3 += 1;
			}
			toList = toList + 1;
			pfVar2 = pfVar2 + 2;
			count -= 1;
		} while (count != 0);
	}
	return uVar3 & 1;
}



BOOL __cdecl
lego::math::Maths_RaySphereIntersection
					(Vector3F *center,float radius,Vector3F *camera,Vector3F *line)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	
	fVar1 = camera->y - center->y;
	fVar4 = camera->z - center->z;
	fVar3 = camera->x - center->x;
	fVar2 = (line->z + line->z) * fVar4 + (line->y + line->y) * fVar1 + (line->x + line->x) * fVar3;
	fVar1 = fVar2 * fVar2 - ((fVar3 * fVar3 + fVar4 * fVar4 + fVar1 * fVar1) * 4.0 - radius * radius);
	if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
		return TRUE;
	}
	return 0;
}



// out_matrix = { {
//                  l[0,0]*r[0,0] + l[0,1]*r[1,0] + l[0,2]*r[2,0] + l[0,3]*r[3,0],
//                  l[0,0]*r[0,1] + l[0,1]*r[1,1] + l[0,2]*r[2,1] + l[0,3]*r[3,1],
//                  l[0,0]*r[0,2] + l[0,1]*r[1,2] + l[0,2]*r[2,2] + l[0,3]*r[3,2],
//                  l[0,0]*r[0,3] + l[0,1]*r[1,3] + l[0,2]*r[2,3] + l[0,3]*r[3,3]
//                },{
//                  l[1,0]*r[0,0] + l[1,1]*r[1,0] + l[1,2]*r[2,0] + l[1,3]*r[3,0],
//                  l[1,0]*r[0,1] + l[1,1]*r[1,1] + l[1,2]*r[2,1] + l[1,3]*r[3,1],
//                  l[1,0]*r[0,2] + l[1,1]*r[1,2] + l[1,2]*r[2,2] + l[1,3]*r[3,2],
//                  l[1,0]*r[0,3] + l[1,1]*r[1,3] + l[1,2]*r[2,3] + l[1,3]*r[3,3]
//                },{
//                  l[2,0]*r[0,0] + l[2,1]*r[1,0] + l[2,2]*r[2,0] + l[2,3]*r[3,0],
//                  l[2,0]*r[0,1] + l[2,1]*r[1,1] + l[2,2]*r[2,1] + l[2,3]*r[3,1],
//                  l[2,0]*r[0,2] + l[2,1]*r[1,2] + l[2,2]*r[2,2] + l[2,3]*r[3,2],
//                  l[2,0]*r[0,3] + l[2,1]*r[1,3] + l[2,2]*r[2,3] + l[2,3]*r[3,3]
//                },{
//                  l[3,0]*r[0,0] + l[3,1]*r[1,0] + l[3,2]*r[2,0] + l[3,3]*r[3,0],
//                  l[3,0]*r[0,1] + l[3,1]*r[1,1] + l[3,2]*r[2,1] + l[3,3]*r[3,1],
//                  l[3,0]*r[0,2] + l[3,1]*r[1,2] + l[3,2]*r[2,2] + l[3,3]*r[3,2],
//                  l[3,0]*r[0,3] + l[3,1]*r[1,3] + l[3,2]*r[2,3] + l[3,3]*r[3,3]
//              } }
// NOTE: right and left operands are ordered in reverse in the parameter list.

void __cdecl lego::math::Matrix_Mult(Matrix4F *out_matrix,Matrix4F *right,Matrix4F *left)
{
	float (*pafVar1) [4];
	float (*pafVar2) [4];
	Matrix4F *pMVar3;
	Matrix4F *pMVar4;
	int iVar5;
	float *pfVar6;
	int iVar7;
	int iVar8;
	Matrix4F *pMVar9;
	
	Matrix_Zero(out_matrix);
	iVar5 = (int)out_matrix - (int)left;
	out_matrix = (Matrix4F *)&DAT_00000004;
	do {
		pfVar6 = (float *)(iVar5 + (int)left);
		iVar7 = 4;
		pMVar9 = right;
		do {
			iVar8 = 4;
			pMVar3 = pMVar9;
			pMVar4 = left;
			do {
				pafVar1 = pMVar4->values;
				pafVar2 = pMVar3->values;
				pMVar3 = (Matrix4F *)pMVar3->values[1];
				pMVar4 = (Matrix4F *)(pMVar4->values + 1);
				iVar8 += -1;
				*pfVar6 = (*pafVar1)[0] * (*pafVar2)[0] + *pfVar6;
			} while (iVar8 != 0);
			pfVar6 = pfVar6 + 1;
			pMVar9 = (Matrix4F *)(pMVar9->values + 1);
			iVar7 += -1;
		} while (iVar7 != 0);
		left = (Matrix4F *)left->values[1];
		out_matrix = (Matrix4F *)((int)out_matrix[-1].values[3] + 0xf);
	} while (out_matrix != NULL);
	return;
}



// out_matrix = { { 1,      0,       0, 0 },
//                { 0, cos(t), -sin(t), 0 },
//                { 0, sin(t),  cos(t), 0 },
//                { 0,      0,       0, 1 } }

void __cdecl lego::math::Matrix_RotX(Matrix4F *out_matrix,float rot)
{
	float10 cosine;
	float10 sine;
	
	cosine = (float10)fcos((float10)rot);
	sine = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[1][2] = -(float)sine;
	out_matrix->values[1][1] = (float)cosine;
	out_matrix->values[2][2] = (float)cosine;
	out_matrix->values[2][1] = (float)sine;
	return;
}



// out_matrix = { {  cos(t), 0, sin(t), 0 },
//                {       0, 1,      0, 0 },
//                { -sin(t), 0, cos(t), 0 },
//                {       0, 0,      0, 1 } }

void __cdecl lego::math::Matrix_RotY(Matrix4F *out_matrix,float rot)
{
	float10 cosine;
	float10 sine;
	
	cosine = (float10)fcos((float10)rot);
	sine = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[2][0] = -(float)sine;
	out_matrix->values[0] = (float)cosine;
	out_matrix->values[2][2] = (float)cosine;
	out_matrix->values[2] = (float)sine;
	return;
}



// out_matrix = { { cos(t), -sin(t), 0, 0 },
//                { sin(t),  cos(t), 0, 0 },
//                {      0,       0, 1, 0 },
//                {      0,       0, 0, 1 } }

void __cdecl lego::math::Matrix_RotZ(Matrix4F *out_matrix,float rot)
{
	float10 cosine;
	float10 sine;
	
	cosine = (float10)fcos((float10)rot);
	sine = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[1] = -(float)sine;
	out_matrix->values[0] = (float)cosine;
	out_matrix->values[1][1] = (float)cosine;
	out_matrix->values[1][0] = (float)sine;
	return;
}



// out_matrix = { { 1, 0, 0, 0 },
//                { 0, 1, 0, 0 },
//                { 0, 0, 1, 0 },
//                { x, y, z, 1 } }

void __cdecl lego::math::Matrix_Translate(Matrix4F *out_matrix,Vector3F *trans)
{
	Matrix_Identity(out_matrix);
	out_matrix->values[3][0] = trans->x;
	out_matrix->values[3][1] = trans->y;
	out_matrix->values[3][2] = trans->z;
	return;
}



// out_matrix = { { 1, 0, 0, 0 },
//                { 0, 1, 0, 0 },
//                { 0, 0, 1, 0 },
//                { 0, 0, 0, 1 } }

void __cdecl lego::math::Matrix_Identity(Matrix4F *out_matrix)
{
	float fVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 0;
	do {
		iVar2 = 0;
		do {
			if (iVar3 == iVar2) {
				fVar1 = 1.0;
			}
			else {
				fVar1 = 0.0;
			}
			out_matrix->values[0] = fVar1;
			iVar2 += 1;
			out_matrix = (Matrix4F *)(out_matrix->values + 1);
		} while (iVar2 < 4);
		iVar3 += 1;
	} while (iVar3 < 4);
	return;
}



// out_matrix = { { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 } }

void __cdecl lego::math::Matrix_Zero(Matrix4F *out_matrix)
{
	int iVar1;
	
	for (iVar1 = 0x10; iVar1 != 0; iVar1 += -1) {
		out_matrix->values[0] = 0.0;
		out_matrix = (Matrix4F *)(out_matrix->values + 1);
	}
	return;
}



// out_matrix = a

void __cdecl lego::math::Matrix_Copy(Matrix4F *out_matrix,Matrix4F *src)
{
	Matrix4F *pMVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 4;
	pMVar1 = out_matrix;
	do {
		iVar2 = 4;
		do {
			pMVar1->values[0] = *(float *)(((int)src - (int)out_matrix) + (int)pMVar1);
			pMVar1 = (Matrix4F *)(pMVar1->values + 1);
			iVar2 += -1;
		} while (iVar2 != 0);
		iVar3 += -1;
	} while (iVar3 != 0);
	return;
}



Font * __cdecl lego::image::Font_Load(char *fname)
{
	uint uVar1;
	uint uVar2;
	Image *image;
	Font *font;
	void *pvVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	float10 fVar10;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar11;
	longlong lVar12;
	int local_58;
	uint local_50;
	int local_48;
	uint local_38;
	uint local_34;
	uint local_30;
	uint local_2c;
	uint local_28;
	float *local_24;
	undefined4 uStack32;
	Image *local_1c;
	uint local_18;
	undefined4 uStack20;
	char *local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	image = Image_LoadBMPScaled(fname,0,0);
	if (image != NULL) {
		local_1c = image;
		font = Font_Create(image);
		if (font != NULL) {
			Image_SetPenZeroTrans(image);
			uVar5 = (int)image->width / 10;
			uVar2 = (int)image->height / 0x13;
			local_28 = uVar5;
			local_2c = Image_GetPen255(image);
			local_30 = Image_GetPixelMask(image);
			pvVar3 = Image_LockSurface(image,&local_34,&local_38);
			if (pvVar3 != NULL) {
				fVar9 = (float10)(ulonglong)uVar5;
				uStack32 = 0;
				uVar1 = uVar5 - 1;
				pfVar7 = &font->posSet[0].width;
				local_50 = 0;
				local_48 = 0x13;
				local_24 = pfVar7;
				do {
					uStack20 = 0;
					fVar10 = (float10)(ulonglong)local_50;
					fname = NULL;
					local_58 = 10;
					pfVar8 = pfVar7;
					local_18 = local_50;
					do {
						uStack12 = 0;
						local_10 = fname;
						pfVar8[-2] = (float)ZEXT48(fname);
						pfVar8[-1] = (float)fVar10;
						*pfVar8 = (float)fVar9;
						pfVar8[1] = (float)(ulonglong)uVar2;
						if (uVar1 != 0) {
							lVar11 = __ftol(fVar10);
							uVar6 = uVar1;
							do {
								uStack4 = 0;
								local_8 = uVar6;
								lVar12 = __ftol((float10)(ulonglong)uVar6 + (float10)ZEXT48(fname));
								iVar4 = (int)lVar12 * (local_38 >> 3) + local_34 * (int)lVar11;
								uVar5 = local_28;
								fVar10 = extraout_ST0;
								fVar9 = extraout_ST1;
								if ((CONCAT31(CONCAT21(CONCAT11(*(undefined *)(iVar4 + (int)pvVar3),
																								*(undefined *)(iVar4 + 1 + (int)pvVar3)),
																			 *(undefined *)(iVar4 + 2 + (int)pvVar3)),
															*(undefined *)(iVar4 + 3 + (int)pvVar3)) & local_30) != local_2c)
								break;
								uVar6 -= 1;
								*pfVar8 = *pfVar8 - 1.0;
							} while (uVar6 != 0);
						}
						pfVar8 = pfVar8 + 0x4c;
						fname = fname + uVar5;
						local_58 += -1;
					} while (local_58 != 0);
					local_50 += uVar2;
					pfVar7 = pfVar7 + 4;
					local_48 += -1;
					if (local_48 == 0) {
						lVar11 = __ftol((float10)font->posSet[0].height);
						font->fontHeight = (uint)lVar11;
						lVar11 = __ftol((float10)*local_24);
						font->tabWidth = (int)lVar11 << 3;
						Image_UnlockSurface(local_1c);
						return font;
					}
				} while( true );
			}
			Font_Remove(font);
		}
		Image_Remove(image);
	}
	return NULL;
}



void __cdecl
lego::image::Font_VGetStringInfo
					(Font *font,uint *out_width,uint *out_lineCount,char *msg,va_list argptr)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,0,0,FALSE,out_lineCount,msg,argptr);
	if (out_width != NULL) {
		*out_width = uVar1;
	}
	return;
}



uint __cdecl lego::image::Font_PrintF(Font *font,int x,int y,char *msg,...)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,x,y,TRUE,NULL,msg,&stack0x00000014);
	return uVar1;
}



uint __cdecl lego::image::Font_VPrintF(Font *font,int x,int y,char *msg,va_list argptr)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,x,y,TRUE,NULL,msg,argptr);
	return uVar1;
}



uint __cdecl
lego::image::Font_VPrintF2
					(Font *font,int x,int y,BOOL render,uint *out_lineCount,char *msg,va_list argptr)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	Image *image;
	byte bVar7;
	uint local_828;
	uint local_824;
	uint local_820;
	uint local_81c;
	uint local_818;
	Point2F local_808;
	char local_800 [12];
	char acStack2036 [1012];
	char local_400 [1024];
	
	cVar2 = *msg;
	local_824 = font->fontHeight;
	local_818 = 1;
	local_828 = 0;
	local_81c = 0;
	pcVar3 = local_400;
	while (cVar2 != '\0') {
		if ((*msg == '%') && (msg[1] == 'b')) {
			*pcVar3 = '@';
			pcVar3[1] = '[';
			pcVar3[2] = '0';
			pcVar3[3] = 'x';
			pcVar3[4] = '%';
			pcVar3[5] = '0';
			pcVar3[6] = '.';
			pcVar3[7] = '8';
			pcVar3[8] = 'x';
			pcVar3 = pcVar3 + 9;
			msg = msg + 1;
			*pcVar3 = ']';
		}
		else {
			*pcVar3 = *msg;
		}
		pcVar1 = msg + 1;
		msg = msg + 1;
		pcVar3 = pcVar3 + 1;
		cVar2 = *pcVar1;
	}
	*pcVar3 = '\0';
	uVar4 = std::vsprintf(local_800,local_400,argptr);
	local_820 = 0;
	uVar6 = 0;
	if (uVar4 != 0) {
		do {
			cVar2 = local_800[local_820];
			if (cVar2 == '\n') {
				if (local_81c < local_828) {
					local_81c = local_828;
				}
				y += local_824;
				local_824 = font->fontHeight;
				local_828 = 0;
				local_818 += 1;
			}
			else {
				if (cVar2 == '\t') {
					uVar6 = font->tabWidth - local_828 % font->tabWidth;
				}
				else {
					if ((((local_820 < uVar4 - 0xc) && (cVar2 == '@')) && (local_800[local_820 + 1] == '['))
						 && (((local_800[local_820 + 2] == '0' && (local_800[local_820 + 3] == 'x')) &&
								 (acStack2036[local_820] == ']')))) {
						image = NULL;
						uVar6 = 0;
						pcVar3 = local_800 + local_820 + 4;
						bVar7 = 0x1c;
						do {
						// int std::isdigit(int c)
							if (std::globals::_pcharwidth < 2) {
								uVar5 = *(byte *)(std::globals::_pctype + (byte)pcVar3[uVar6]) & C1_DIGIT;
							}
							else {
						// C1_DIGIT (0x4)
								uVar5 = std::_isctype((uint)(byte)pcVar3[uVar6],C1_DIGIT);
							}
							image = (Image *)((uint)image |
															 (uint)(byte)pcVar3[uVar6] -
															 ((-(uint)(uVar5 != 0) & 0xffffffd9) + 0x57) << (bVar7 & 0x1f));
							uVar6 += 1;
							bVar7 = bVar7 - 4;
						} while (uVar6 < 8);
						if (image != NULL) {
							local_808.x = (float)(ulonglong)(local_828 + x);
							local_808.y = (float)y;
							local_828 += image->width;
							if (local_824 < image->height) {
								local_824 = image->height;
							}
							Image_DisplayScaled(image,NULL,&local_808,NULL);
						}
						local_820 += 0xc;
						goto LAB_0047a6f3;
					}
					uVar6 = Font_OutputChar(font,local_828 + x,y,cVar2,render);
				}
				local_828 += uVar6;
			}
LAB_0047a6f3:
			local_820 += 1;
			uVar6 = local_828;
		} while (local_820 < uVar4);
	}
	if (out_lineCount != NULL) {
		*out_lineCount = local_818;
	}
	if (local_81c < uVar6) {
		local_81c = uVar6;
	}
	return local_81c;
}



uint __cdecl lego::image::Font_OutputChar(Font *font,int x,int y,char c,BOOL render)
{
	uint uVar1;
	uint uVar2;
	longlong lVar3;
	Point2F local_8;
	
	local_8.x = (float)x;
	local_8.y = (float)y;
	uVar1 = (byte)(c - 0x20) / 10;
	uVar2 = (uint)(byte)(c - 0x20) % 10;
	if (uVar1 < 0x13) {
		if (render != 0) {
			Image_DisplayScaled(font->image,font->posSet[uVar2] + uVar1,&local_8,NULL);
		}
		lVar3 = __ftol((float10)font->posSet[uVar2][uVar1].width);
		return (uint)lVar3;
	}
	return 0;
}



uint __cdecl lego::image::Font_GetCharWidth(Font *font,char c)
{
	uint uVar1;
	
	uVar1 = Font_OutputChar(font,0,0,c,FALSE);
	return uVar1;
}



uint __cdecl lego::image::Font_GetHeight(Font *font)
{
	return font->fontHeight;
}



void __cdecl lego::image::Font_Remove(Font *font)
{
	Image_Remove(font->image);
	font->nextFree = globs::fontGlobs.freeList;
	globs::fontGlobs.freeList = font;
	return;
}



Font * __cdecl lego::image::Font_Create(Image *image)
{
	int iVar1;
	Font *pFVar2;
	Font *pFVar3;
	
	pFVar2 = globs::fontGlobs.freeList;
	if (globs::fontGlobs.freeList == NULL) {
		Font_AddList();
		pFVar2 = globs::fontGlobs.freeList;
	}
	globs::fontGlobs.freeList = pFVar2->nextFree;
	pFVar3 = pFVar2;
	for (iVar1 = 0x2fd; iVar1 != 0; iVar1 += -1) {
		pFVar3->image = NULL;
		pFVar3 = (Font *)pFVar3->posSet;
	}
	pFVar2->nextFree = pFVar2;
	pFVar2->image = image;
	return pFVar2;
}



void __cdecl lego::image::Font_AddList(void)
{
	Font *pFVar1;
	Font *pFVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::fontGlobs.listCount & 0x1f);
	pFVar2 = (Font *)std::malloc(uVar4 * 0xbf4);
	globs::fontGlobs.listSet[globs::fontGlobs.listCount] = pFVar2;
	pFVar2 = globs::fontGlobs.listSet[globs::fontGlobs.listCount];
	if (pFVar2 != NULL) {
		globs::fontGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pFVar1 = pFVar2;
			do {
				pFVar1->nextFree = pFVar1 + 1;
				iVar3 += -1;
				pFVar1 = pFVar1 + 1;
			} while (iVar3 != 0);
		}
		pFVar2[uVar4 - 1].nextFree = globs::fontGlobs.freeList;
		globs::fontGlobs.freeList = pFVar2;
	}
	return;
}



BOOL __cdecl lego::snd::Sound3D_Initialise(HWND hWnd)
{
	HRESULT HVar1;
	WAVEFORMATEX *pWVar2;
	int iVar3;
	WAVEFORMATEX wfx;
	DSBUFFERDESC dsbd;
	
	globs::sound3DGlobs.intialised = 0;
	globs::sound3DGlobs.listenerFrame = NULL;
	do {
		HVar1 = DirectSoundCreate(NULL,&globs::sound3DGlobs.lpDSnd,NULL);
		if (HVar1 == 0) {
						// DSSCL_PRIORITY (0x2)
			pWVar2 = (WAVEFORMATEX *)
							 (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->SetCooperativeLevel)
												 (globs::sound3DGlobs.lpDSnd,hWnd,2);
			if (pWVar2 == NULL) {
				dsbd.dwSize = 0x14;
						// DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME
				dsbd.dwFlags = 0x91;
				dsbd.dwBufferBytes = (DWORD)pWVar2;
				dsbd.dwReserved = (DWORD)pWVar2;
				dsbd.lpwfxFormat = pWVar2;
				HVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
													(globs::sound3DGlobs.lpDSnd,&dsbd,
													 (IDirectSoundBuffer *)&globs::sound3DGlobs.lpDSBuff,NULL);
				if (HVar1 == 0) {
					wfx.wFormatTag = 1;
					wfx.nChannels = 2;
					wfx.wBitsPerSample = 0x10;
					wfx.nSamplesPerSec = 22050;
						// wfx.wBitsPerSample / 8 * wfx.nChannels
					wfx.nBlockAlign = 4;
						// wfx.nSamplesPerSec * wfx.nBlockAlign
					wfx.nAvgBytesPerSec = 88200;
					wfx.cbSize = 0;
					(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetFormat)
										(globs::sound3DGlobs.lpDSBuff,&wfx);
					HVar1 = (*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->QueryInterface)
														(globs::sound3DGlobs.lpDSBuff,&idl::IID_IDirectSound3DListener,
														 &globs::sound3DGlobs.lp3DListenerInfo);
					if (HVar1 == 0) {
						(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetDopplerFactor)
											(globs::sound3DGlobs.lp3DListenerInfo,(float)&DAT_42c80000,0);
						goto LAB_0047aa15;
					}
					(*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Release)(globs::sound3DGlobs.lpDSBuff);
					goto LAB_0047aa04;
				}
				(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)(globs::sound3DGlobs.lpDSnd);
			}
			else {
LAB_0047aa04:
				(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)(globs::sound3DGlobs.lpDSnd);
			}
			globs::sound3DGlobs.lpDSnd = NULL;
		}
LAB_0047aa15:
		if (globs::sound3DGlobs.lpDSnd == NULL) {
			iVar3 = 5;
		}
		else {
			iVar3 = 1;
			globs::sound3DGlobs.intialised = 1;
		}
		if (iVar3 != 4) {
			if (globs::sound3DGlobs.intialised != 0) {
						// SET THE PRIMARY BUFFER TO CONTINUOUSLY PLAY - OPTIMISATION FOR FREQUENT STARTING AND
						// STOPPING OF PLAYBACK
						// 
						// DSBPLAY_LOOPING (0x1)
				(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Play)(globs::sound3DGlobs.lpDSBuff,0,0,1);
						// DEFAULT VALUES
						// 
						// DS3D_DEFERRED (0x1)
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetRolloffFactor)
									(globs::sound3DGlobs.lp3DListenerInfo,1.0,1);
						// DISABLE DOPPLER - DONT NEED TO SET VELOCITY ON SOUNDS
						// 
						// DS3D_DEFERRED (0x1)
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetDopplerFactor)
									(globs::sound3DGlobs.lp3DListenerInfo,0.0,1);
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
									(globs::sound3DGlobs.lp3DListenerInfo);
				globs::sound3DGlobs.minDistanceForAttentuation = 1.0;
				globs::sound3DGlobs.maxDistance = 800.0;
				(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->GetVolume)
									(globs::sound3DGlobs.lpDSBuff,&globs::sound3DGlobs.windowsVolume);
				Sound3D_SetVolumeToDefault();
			}
			return 1;
		}
	} while( true );
}



void __cdecl lego::snd::Sound3D_ShutDown(void)
{
	if (globs::sound3DGlobs.intialised != 0) {
		Sound3D_SetGlobalVolume(globs::sound3DGlobs.windowsVolume);
		(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Stop)(globs::sound3DGlobs.lpDSBuff);
		(*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Release)((IUnknown *)globs::sound3DGlobs.lpDSBuff);
		(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)((IUnknown *)globs::sound3DGlobs.lpDSnd);
		globs::sound3DGlobs.lpDSnd = NULL;
		globs::sound3DGlobs.intialised = 0;
	}
	return;
}



BOOL __cdecl lego::snd::Sound3D_CheckVolumeLimits(int vol)
{
						// is volume in range [-10000 to 0], inclusive
	if ((vol < 1) && (-10001 < vol)) {
		return 1;
	}
	return 0;
}



int __cdecl lego::snd::Sound3D_Load(char *fName,BOOL stream,BOOL simultaneous,int volume)
{
	char cVar1;
	BOOL BVar2;
	char *pcVar3;
	FILE *pFVar4;
	uint uVar5;
	uint uVar6;
	LPCSTR finalFilename;
	SampleFlags SVar7;
	undefined4 *puVar8;
	char *pcVar9;
	Sound3D_SoundData *pSVar10;
	uint sfxIndex;
	char wavFilename [260];
	char cdromFilename [260];
	bool success;
	
	success = false;
	if ((globs::sound3DGlobs.intialised != 0) &&
		 (BVar2 = Sound3D_GetFreeSoundIndex(&sfxIndex), BVar2 != 0)) {
		globs::sound3DGlobs.soundTable[sfxIndex].flags = SAMPLE_NONE;
		std::sprintf(wavFilename,"%s.wav",fName);
		if (stream == 0) {
			BVar2 = Sound3D_LoadSample(globs::sound3DGlobs.soundTable + sfxIndex,wavFilename,simultaneous)
			;
			if (BVar2 != 0) {
				SVar7 = globs::sound3DGlobs.soundTable[sfxIndex].flags & ~SAMPLE_STREAMED;
				globs::sound3DGlobs.soundTable[sfxIndex].flags = SVar7;
				if (simultaneous != 0) {
					globs::sound3DGlobs.soundTable[sfxIndex].flags = SVar7 | SAMPLE_MULTIPLE;
				}
				success = true;
			}
		}
		else {
			pcVar3 = lego::file::File_VerifyFilename(wavFilename);
			finalFilename = NULL;
			pFVar4 = std::fopen(pcVar3,"r");
			if (pFVar4 == NULL) {
				BVar2 = lego::file::File_GetCDFilePath(cdromFilename,wavFilename);
				if (BVar2 != 0) {
					finalFilename = cdromFilename;
				}
			}
			else {
				std::fclose(pFVar4);
				finalFilename = pcVar3;
			}
			if ((finalFilename != NULL) && (pFVar4 = std::fopen(finalFilename,"r"), pFVar4 != NULL)) {
				std::fseek(pFVar4,0,2);
				uVar5 = std::ftell(pFVar4);
				uVar6 = sfxIndex;
				globs::sound3DGlobs.soundTable[sfxIndex].size = uVar5;
				uVar5 = GetWaveAvgBytesPerSec(finalFilename);
				globs::sound3DGlobs.soundTable[uVar6].avgBytesPerSec = uVar5;
				globs::sound3DGlobs.soundTable[uVar6].flags =
						 globs::sound3DGlobs.soundTable[uVar6].flags | SAMPLE_STREAMED;
				std::fclose(pFVar4);
				success = true;
			}
		}
		if (success) {
			uVar6 = 0xffffffff;
			pcVar3 = wavFilename;
			do {
				pcVar9 = pcVar3;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar9 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar9;
			} while (cVar1 != '\0');
			uVar6 = ~uVar6;
			puVar8 = (undefined4 *)(pcVar9 + -uVar6);
			pSVar10 = globs::sound3DGlobs.soundTable + sfxIndex;
			for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 -= 1) {
				*(undefined4 *)pSVar10->filename = *puVar8;
				puVar8 = puVar8 + 1;
				pSVar10 = (Sound3D_SoundData *)(pSVar10->filename + 4);
			}
			for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
				pSVar10->filename[0] = *(char *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				pSVar10 = (Sound3D_SoundData *)(pSVar10->filename + 1);
			}
			BVar2 = Sound3D_CheckVolumeLimits(volume);
			if (BVar2 == 0) {
				globs::sound3DGlobs.soundTable[sfxIndex].volume = 0;
				globs::sound3DGlobs.soundTable[sfxIndex].flags =
						 globs::sound3DGlobs.soundTable[sfxIndex].flags | (SAMPLE_ISUSED|SAMPLE_VOLUME);
				return sfxIndex;
			}
			globs::sound3DGlobs.soundTable[sfxIndex].volume = volume;
			globs::sound3DGlobs.soundTable[sfxIndex].flags =
					 globs::sound3DGlobs.soundTable[sfxIndex].flags | (SAMPLE_ISUSED|SAMPLE_VOLUME);
			return sfxIndex;
		}
	}
	return -1;
}



BOOL __cdecl lego::snd::Sound3D_GetFreeSoundIndex(uint *out_soundTableIndex)
{
	SampleFlags *pSVar1;
	uint uVar2;
	
	uVar2 = 0;
	pSVar1 = &globs::sound3DGlobs.soundTable[0].flags;
	do {
		if ((*(byte *)pSVar1 & 1) == 0) {
			*out_soundTableIndex = uVar2;
			return 1;
		}
		pSVar1 = pSVar1 + 0x4d;
		uVar2 += 1;
	} while (pSVar1 < globs::fileGlobs.wadBasePath + 8);
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Remove(int soundTableIndex)
{
	WAVEFORMATEX *hMem;
	IDirectSoundBuffer *This;
	IDirectSoundBuffer **ppIVar1;
	int iVar2;
	
	if ((globs::sound3DGlobs.intialised != 0) && (soundTableIndex != -1)) {
		hMem = globs::sound3DGlobs.soundTable[soundTableIndex].waveFormat;
		globs::sound3DGlobs.soundTable[soundTableIndex].flags =
				 globs::sound3DGlobs.soundTable[soundTableIndex].flags & ~SAMPLE_ISUSED;
		if (hMem != NULL) {
			GlobalFree(hMem);
			globs::sound3DGlobs.soundTable[soundTableIndex].waveFormat = NULL;
		}
		ppIVar1 = globs::sound3DGlobs.soundTable[soundTableIndex].dSoundBuffers;
		iVar2 = 3;
		do {
			This = *ppIVar1;
			if (This != NULL) {
				(*This->lpVtbl->Release)((IUnknown *)This);
				*ppIVar1 = NULL;
			}
			ppIVar1 = ppIVar1 + 1;
			iVar2 += -1;
		} while (iVar2 != 0);
		return 1;
	}
	return 0;
}



void __cdecl lego::snd::Sound3D_MakeListener(IDirect3DRMFrame3 *frame)
{
	if (globs::sound3DGlobs.intialised != 0) {
		globs::sound3DGlobs.listenerFrame = frame;
	}
	return;
}



void __cdecl lego::snd::Sound3D_UpdateListener(void)
{
	if ((globs::sound3DGlobs.intialised != 0) && (globs::sound3DGlobs.listenerFrame != NULL)) {
		Sound3D_ListenerCallback(globs::sound3DGlobs.listenerFrame,NULL,0.0);
	}
	return;
}



void __cdecl lego::snd::Sound3D_ListenerCallback(IDirect3DRMFrame3 *obj,void *arg,float delta)
{
	IDirect3DRMFrame3 *This;
	BOOL BVar1;
	bool bVar2;
	Vector3F local_18;
	Vector3F local_c;
	
	This = obj;
	(*obj->lpVtbl->GetScene)(obj,&obj);
	(*This->lpVtbl->GetPosition)(This,obj,&local_18);
	BVar1 = Sound3D_D3DVectorEqual(&local_18,&globs::sound3DGlobs.s_ListenerCallback_oldPos);
	bVar2 = BVar1 == 0;
	if (bVar2) {
						// IDirectSound3DListener->SetPosition(float x, float y, float z, DWORD dwApply)
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetPosition)
							(globs::sound3DGlobs.lp3DListenerInfo,local_18.x,local_18.y,local_18.z,1);
		globs::sound3DGlobs.s_ListenerCallback_oldPos.x = local_18.x;
		globs::sound3DGlobs.s_ListenerCallback_oldPos.y = local_18.y;
		globs::sound3DGlobs.s_ListenerCallback_oldPos.z = local_18.z;
	}
	(*This->lpVtbl->GetOrientation)(This,obj,&local_18,&local_c);
	BVar1 = Sound3D_D3DVectorEqual(&local_18,&globs::sound3DGlobs.s_ListenerCallback_oldOrien);
	if (BVar1 != 0) {
		BVar1 = Sound3D_D3DVectorEqual(&local_c,&globs::sound3DGlobs.s_ListenerCallback_oldOrienUp);
		if (BVar1 != 0) goto LAB_0047afa5;
	}
	(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetOrientation)
						(globs::sound3DGlobs.lp3DListenerInfo,local_18.x,local_18.y,local_18.z,local_c.x,
						 local_c.y,local_c.z,1);
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.x = local_18.x;
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.y = local_18.y;
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.z = local_18.z;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.x = local_c.x;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.y = local_c.y;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.z = local_c.z;
	bVar2 = true;
LAB_0047afa5:
	if (bVar2) {
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
							(globs::sound3DGlobs.lp3DListenerInfo);
	}
	(*obj->lpVtbl->Release)(obj);
	return;
}



void __cdecl
lego::snd::Sound3D_SetWorldPos(IDirectSound3DBuffer *sound3DBuff,Vector3F *wPos,Vector3F *vel)
{
						// IDirectSound3DBuffer->SetPosition(float x, float y, float z, DWORD dwApply)
	(*(code *)sound3DBuff->lpVtbl->SetPosition)(sound3DBuff,wPos->x,wPos->y,wPos->z,0);
	return;
}



BOOL __cdecl
lego::snd::Sound3D_CheckAlreadyExists(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord == NULL) {
		return (BOOL)NULL;
	}
	do {
		if (sound3DBuff == pSVar1->sound3DBuff) {
			Sound3D_RemoveSound(pSVar1->frame,pSVar1->sound3DBuff);
			return (BOOL)(Sound3D_SoundRecord *)0x1;
		}
		pSVar1 = pSVar1->next;
	} while (pSVar1 != NULL);
	return (BOOL)pSVar1;
}



int __cdecl
lego::snd::Sound3D_Play2
					(Sound3DPlayMode mode,IDirect3DRMFrame3 *frame,int soundTableIndex,BOOL loop,
					Vector3F *opt_wPos)
{
	SampleFlags SVar1;
	char *filename;
	FILE *stream;
	BOOL BVar2;
	IDirect3DRMFrame3 *This;
	uint uVar3;
	int *unaff_EBP;
	IDirectSound3DBuffer *unaff_ESI;
	char *fName;
	IDirectSound3DBuffer *soundBuff;
	float rvZ;
	undefined4 uVar4;
	IDirectSound3DBuffer *sound3DBuff;
	IDirectSound3DBuffer *local_118;
	IDirect3DRMFrame3 *local_114;
	Vector3F local_110;
	char local_104 [244];
	IDirect3DRMFrame3 *pIStack16;
	int iStack8;
	
	fName = NULL;
	if ((globs::sound3DGlobs.intialised != 0) && (soundTableIndex != -1)) {
		SVar1 = globs::sound3DGlobs.soundTable[soundTableIndex].flags;
		if ((SVar1 & SAMPLE_VOLUME) != SAMPLE_NONE) {
			if ((SVar1 & SAMPLE_STREAMED) == SAMPLE_NONE) {
				if ((SVar1 & SAMPLE_MULTIPLE) == SAMPLE_NONE) {
					soundBuff = (IDirectSound3DBuffer *)
											globs::sound3DGlobs.soundTable[soundTableIndex].dSoundBuffers[0];
				}
				else {
					uVar3 = globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex + 1;
					globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex = uVar3;
					if (2 < uVar3) {
						globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex = 0;
					}
					soundBuff = *(IDirectSound3DBuffer **)
											 (soundTableIndex * 0x134 + 0x5077b8 +
											 globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex * 4);
				}
				(*soundBuff->lpVtbl->QueryInterface)
									((IUnknown *)soundBuff,(IID *)&idl::IID_IDirectSound3DBuffer,&local_118);
				This = (IDirect3DRMFrame3 *)globs::sound3DGlobs.soundTable[soundTableIndex].volume;
				if (mode == SOUND3D_PLAY_NORMAL) {
					This = This + -200;
				}
				sound3DBuff = soundBuff;
				(*(code *)soundBuff->lpVtbl->SetConeOutsideVolume)();
				uVar4 = 1;
						// IDirectSound3DBuffer->SetMinDistance(float flMinDistance, DWORD dwApply)
				rvZ = globs::sound3DGlobs.minDistanceForAttentuation;
				(**(code **)(*unaff_EBP + 0x44))(unaff_EBP,globs::sound3DGlobs.minDistanceForAttentuation,1)
				;
						// IDirectSound3DBuffer->SetMaxDistance(float flMaxDistance, DWORD dwApply)
				(*This->lpVtbl->AddScale)
									(This,(D3DRMCombineType)globs::sound3DGlobs.maxDistance,1.401298e-45,
									 (float)unaff_EBP,rvZ);
				if (mode == SOUND3D_PLAY_ONFRAME) {
						// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
						//  (dwMode = DS3DMODE_NORMAL (0x0), dwApply = TRUE (0x1))
					(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,0,1);
						// IDirect3DRMFrame3->GetScene(this, IDirect3DRMFrame3** lplpRoot)
						//  (this = param_2 (rmFrame3), lplpRoot => local_114)
					(*pIStack16->lpVtbl->GetScene)(pIStack16,(IDirect3DRMFrame3 **)&stack0xfffffed4);
					Sound3D_CheckAlreadyExists(pIStack16,sound3DBuff);
					res::Sound3D_AttachSound(pIStack16,sound3DBuff);
					Sound3D_AddSoundRecord(pIStack16,(IDirectSoundBuffer *)soundBuff,sound3DBuff);
						// IDirect3DRMFrame3->GetPosition(this, IDirect3DRMFrame3* lpRef, Vector3F* lprvPos)
						//  (this = param_2 (rmFrame3), lpRef = GetScene)
					(*pIStack16->lpVtbl->GetPosition)(pIStack16,This,(Vector3F *)&stack0xfffffed8);
						// IDirectSound3DBuffer->SetPosition(float x, float y, float z, DWORD dwApply)
					(**(code **)(*(int *)mode + 0x4c))(mode,uVar4,sound3DBuff,This,1);
						// IDirect3DRMFrame3->Release(this)
						//  (this = GetScene)
					(*pIStack16->lpVtbl->Release)((IUnknown *)pIStack16);
				}
				else {
					if (mode == SOUND3D_PLAY_ONPOS) {
						// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
						//  (dwMode = DS3DMODE_NORMAL (0x0), dwApply = TRUE (0x1))
						(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,0,1);
						Sound3D_SetWorldPos(unaff_ESI,(Vector3F *)frame,NULL);
						Sound3D_CheckAlreadyExists(NULL,unaff_ESI);
					}
					else {
						if (mode != SOUND3D_PLAY_NORMAL) goto LAB_0047b26d;
						// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
						//  (dwMode = DS3DMODE_DISABLE (0x2), dwApply = TRUE (0x1))
						(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,2,1);
						Sound3D_CheckAlreadyExists(NULL,unaff_ESI);
					}
					Sound3D_AddSoundRecord(NULL,(IDirectSoundBuffer *)soundBuff,unaff_ESI);
				}
LAB_0047b26d:
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
									(globs::sound3DGlobs.lp3DListenerInfo);
				(*(code *)soundBuff->lpVtbl->SetConeAngles)(soundBuff,0);
				if (iStack8 != 0) {
					(*(code *)soundBuff->lpVtbl->SetAllParameters)(soundBuff,0,0,1);
					return soundTableIndex * 3 + globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex;
				}
				(*(code *)soundBuff->lpVtbl->SetAllParameters)(soundBuff,0,0,0);
				return soundTableIndex * 3 + globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex;
			}
			filename = lego::file::File_VerifyFilename
													 (globs::sound3DGlobs.soundTable[soundTableIndex].filename);
			stream = std::fopen(filename,"r");
			if (stream == NULL) {
				BVar2 = lego::file::File_GetCDFilePath
													(local_104,globs::sound3DGlobs.soundTable[soundTableIndex].filename);
				if (BVar2 != 0) {
					fName = local_104;
				}
			}
			else {
				std::fclose(stream);
				fName = filename;
			}
			if (fName != NULL) {
				Sound3D_Stream_Play(fName,loop,globs::sound3DGlobs.soundTable[soundTableIndex].volume);
				return soundTableIndex * 3;
			}
		}
	}
	return -1;
}



void __cdecl
lego::snd::Sound3D_AddSoundRecord
					(IDirect3DRMFrame3 *frame,IDirectSoundBuffer *soundBuff,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = (Sound3D_SoundRecord *)std::malloc(0x10);
	pSVar1->next = globs::sound3DGlobs.soundRecord;
	pSVar1->frame = frame;
	pSVar1->sound3DBuff = sound3DBuff;
	pSVar1->soundBuff = soundBuff;
	globs::sound3DGlobs.soundRecord = pSVar1;
	return;
}



void __cdecl lego::snd::Sound3D_SetBufferVolume(int handle,int newvolume)
{
	byte bVar1;
	IDirectSoundBuffer *pIVar2;
	BOOL BVar3;
	uint uVar4;
	int iVar5;
	IDirectSoundBuffer **ppIVar6;
	
	BVar3 = Sound3D_CheckVolumeLimits(newvolume);
	bVar1 = *(byte *)&globs::sound3DGlobs.soundTable[handle].flags;
	uVar4 = -(uint)(BVar3 != 0) & newvolume;
	globs::sound3DGlobs.soundTable[handle].volume = uVar4;
	if ((bVar1 & 4) != 0) {
		ppIVar6 = globs::sound3DGlobs.soundTable[handle].dSoundBuffers;
		iVar5 = 3;
		do {
			pIVar2 = *ppIVar6;
			if (pIVar2 != NULL) {
				(*(code *)pIVar2->lpVtbl->SetVolume)(pIVar2,globs::sound3DGlobs.soundTable[handle].volume);
			}
			ppIVar6 = ppIVar6 + 1;
			iVar5 += -1;
		} while (iVar5 != 0);
		return;
	}
	pIVar2 = globs::sound3DGlobs.soundTable[handle].dSoundBuffers[0];
	if (pIVar2 != NULL) {
		(*(code *)pIVar2->lpVtbl->SetVolume)(pIVar2,uVar4);
	}
	return;
}



int __cdecl lego::snd::Sound3D_GetBufferVolume(int handle)
{
	return globs::sound3DGlobs.soundTable[handle].volume;
}



IDirectSoundBuffer * __cdecl lego::snd::Sound3D_GetSoundBuffer(int handle)
{
	if (handle == -1) {
		return NULL;
	}
						// globals::g_SampleDatas_TABLE[sfxType / 3].dSoundBuffers[sfxType % 3]
	return *(IDirectSoundBuffer **)
					((handle % 3) * 4 + 0x5077b8 + ((uint)(handle - handle % 3) / 3) * 0x134);
}



void __cdecl lego::snd::Sound3D_StopSound(int handle)
{
	IDirectSoundBuffer *dSoundBuffer;
	
	dSoundBuffer = Sound3D_GetSoundBuffer(handle);
	if (((globs::sound3DGlobs.intialised != 0) && (handle != -1)) && (dSoundBuffer != NULL)) {
		(*(code *)dSoundBuffer->lpVtbl->Stop)(dSoundBuffer);
	}
	return;
}



void __cdecl lego::snd::Sound3D_StopAllSounds(void)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != NULL) {
		do {
			(*(code *)pSVar1->soundBuff->lpVtbl->Stop)(pSVar1->soundBuff);
			pSVar1 = pSVar1->next;
		} while (pSVar1 != NULL);
	}
	Sound3D_Stream_Stop(FALSE);
	Sound3D_Stream_Stop(TRUE);
	return;
}



void __cdecl
lego::res::Sound3D_AttachSound(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Container_AppData *appData;
	Sound3D_SoundFrameRecord *soundRecord;
	IDirect3DRMFrame3 **ppIVar1;
	int iVar2;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	soundRecord = (Sound3D_SoundFrameRecord *)std::malloc(0x14);
	if (appData == NULL) {
		soundRecord->next = NULL;
	}
	else {
		soundRecord->next = appData->soundList;
	}
	soundRecord->sound3DBuff = sound3DBuff;
	(soundRecord->pos).x = 0.0;
	(soundRecord->pos).y = 0.0;
	(soundRecord->pos).z = 0.0;
	Container_Frame_SetAppData(frame,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,soundRecord,NULL);
	iVar2 = 0;
	ppIVar1 = globs::sound3DGlobs.updateFrameList;
	do {
		if (*ppIVar1 == NULL) {
			globs::sound3DGlobs.updateFrameList[iVar2] = frame;
			return;
		}
		ppIVar1 = ppIVar1 + 1;
		iVar2 += 1;
	} while (ppIVar1 < &globs::sound3DGlobs.reserved1);
	return;
}



void __cdecl
lego::snd::Sound3D_RemoveSound(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundFrameRecord *buffer;
	Container_AppData *appData;
	BOOL BVar1;
	IDirect3DRMFrame3 **ppIVar2;
	
	(*sound3DBuff->lpVtbl->Release)(sound3DBuff);
	if (frame == NULL) {
		Sound3D_RemoveSoundRecord(NULL,sound3DBuff);
		return;
	}
	appData = (*frame->lpVtbl->GetAppData)(frame);
	BVar1 = Sound3D_RecurseRemoveSound(frame,sound3DBuff,appData->soundList);
	if (BVar1 != 0) {
		Sound3D_RemoveSoundRecord(frame,sound3DBuff);
		buffer = appData->soundList;
		appData->soundList = buffer->next;
		std::free(buffer);
	}
	ppIVar2 = globs::sound3DGlobs.updateFrameList;
	do {
		if (frame == *ppIVar2) {
			*ppIVar2 = NULL;
		}
		ppIVar2 = ppIVar2 + 1;
	} while (ppIVar2 < &globs::sound3DGlobs.reserved1);
	return;
}



void __cdecl
lego::snd::Sound3D_RemoveSoundRecord(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *buffer;
	BOOL BVar1;
	
	BVar1 = Sound3D_RecurseRemoveSoundRecord(frame,sound3DBuff,globs::sound3DGlobs.soundRecord);
	buffer = globs::sound3DGlobs.soundRecord;
	if (BVar1 != 0) {
		globs::sound3DGlobs.soundRecord = (globs::sound3DGlobs.soundRecord)->next;
		std::free(buffer);
	}
	return;
}



BOOL __cdecl
lego::snd::Sound3D_RecurseRemoveSoundRecord
					(IDirect3DRMFrame3 *owner,IDirectSound3DBuffer *sound3DBuff,Sound3D_SoundRecord *record)
{
	Sound3D_SoundRecord *buffer;
	BOOL BVar1;
	
	if (record == NULL) {
		return 0;
	}
	BVar1 = Sound3D_RecurseRemoveSoundRecord(owner,sound3DBuff,record->next);
	if (BVar1 != 0) {
		buffer = record->next;
		record->next = buffer->next;
		std::free(buffer);
	}
	return (uint)(sound3DBuff == record->sound3DBuff);
}



BOOL __cdecl
lego::snd::Sound3D_RecurseRemoveSound
					(IDirect3DRMFrame3 *owner,IDirectSound3DBuffer *sound3DBuff,
					Sound3D_SoundFrameRecord *record)
{
	Sound3D_SoundFrameRecord *buffer;
	BOOL BVar1;
	
	if (record == NULL) {
		return 0;
	}
	BVar1 = Sound3D_RecurseRemoveSound(owner,sound3DBuff,record->next);
	if (BVar1 != 0) {
		Sound3D_RemoveSoundRecord(owner,sound3DBuff);
		buffer = record->next;
		record->next = buffer->next;
		std::free(buffer);
	}
	return (uint)(sound3DBuff == record->sound3DBuff);
}



void __cdecl lego::snd::Sound3D_Update(void)
{
	Sound3D_SoundRecord *pSVar1;
	uint in_ECX;
	Sound3D_SoundRecord *pSVar2;
	IDirect3DRMFrame3 **lpSndBufFrame;
	uint local_4;
	
	pSVar2 = globs::sound3DGlobs.soundRecord;
	lpSndBufFrame = globs::sound3DGlobs.updateFrameList;
	local_4 = in_ECX;
	do {
						// (inlined) Sound3D_UpdateFrames();
		if (*lpSndBufFrame != NULL) {
			Sound3D_SoundCallback(*lpSndBufFrame,NULL,0.0);
		}
		lpSndBufFrame = lpSndBufFrame + 1;
	} while (lpSndBufFrame < &globs::sound3DGlobs.reserved1);
	if (pSVar2 != NULL) {
		do {
			pSVar1 = pSVar2->next;
			(*(code *)pSVar2->soundBuff->lpVtbl->GetStatus)(pSVar2->soundBuff,&local_4);
			if ((local_4 & 1) == 0) {
				Sound3D_RemoveSound(pSVar2->frame,pSVar2->sound3DBuff);
			}
			pSVar2 = pSVar1;
		} while (pSVar1 != NULL);
	}
	Sound3D_Stream_CheckPosition(FALSE);
	Sound3D_Stream_CheckPosition(1);
	return;
}



void __cdecl lego::snd::Sound3D_SoundCallback(IDirect3DRMFrame3 *tFrame,void *arg,float delay)
{
	Container_AppData *appData;
	BOOL BVar1;
	Vector3F position;
	IDirect3DRMFrame3 *rmFrame3_00;
	Sound3D_SoundFrameRecord *sndRes;
	
	rmFrame3_00 = tFrame;
	appData = (*tFrame->lpVtbl->GetAppData)(tFrame);
	sndRes = appData->soundList;
	(*rmFrame3_00->lpVtbl->GetScene)(rmFrame3_00,&tFrame);
	for (; sndRes != NULL; sndRes = sndRes->next) {
		(*rmFrame3_00->lpVtbl->GetPosition)(rmFrame3_00,tFrame,&position);
		BVar1 = Sound3D_D3DVectorEqual(&position,&sndRes->pos);
		if (BVar1 == 0) {
						// IDirectSound3DBuffer->SetPosition(this, float x, float y, float z, DWORD dwApply)
			(*(code *)sndRes->sound3DBuff->lpVtbl->SetPosition)
								(sndRes->sound3DBuff,position.x,position.y,position.z,0);
			(sndRes->pos).x = position.x;
			(sndRes->pos).y = position.y;
			(sndRes->pos).z = position.z;
		}
	}
	(*tFrame->lpVtbl->Release)(tFrame);
	return;
}



void __cdecl lego::snd::Sound3D_SetMinDistForAtten(float dist)
{
	Sound3D_SoundRecord **ppSVar1;
	Sound3D_SoundRecord *pSVar2;
	
	globs::sound3DGlobs.minDistanceForAttentuation = dist;
	pSVar2 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != NULL) {
		do {
			(*(code *)pSVar2->sound3DBuff->lpVtbl->SetMinDistance)(pSVar2->sound3DBuff,dist,0);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != NULL);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetMaxDist(float dist)
{
	Sound3D_SoundRecord **ppSVar1;
	Sound3D_SoundRecord *pSVar2;
	
	globs::sound3DGlobs.maxDistance = dist;
	pSVar2 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != NULL) {
		do {
			(*(code *)pSVar2->sound3DBuff->lpVtbl->SetMaxDistance)(pSVar2->sound3DBuff,dist,0);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != NULL);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetGlobalVolume(int vol)
{
	BOOL BVar1;
	
	if (globs::sound3DGlobs.intialised != 0) {
		BVar1 = Sound3D_CheckVolumeLimits(vol);
		if (BVar1 != 0) {
			globs::sound3DGlobs.volume = vol;
			(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetVolume)(globs::sound3DGlobs.lpDSBuff,vol)
			;
		}
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetGlobalVolumePrescaled(int vol_0_10)
{
	if ((-1 < vol_0_10) && (vol_0_10 < 0xb)) {
		Sound3D_SetGlobalVolume(globs::constant::c_SetGlobalVolumePrescaled_realVol[vol_0_10]);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetVolumeToDefault(void)
{
	if (globs::sound3DGlobs.intialised != 0) {
		globs::sound3DGlobs.volume = -300;
		(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetVolume)(globs::sound3DGlobs.lpDSBuff,-NAN);
	}
	return;
}



BOOL __cdecl
lego::snd::Sound3D_LoadSample(Sound3D_SoundData *out_sound,char *fName,BOOL simultaneous)
{
	Sound3D_SoundData *sound;
	byte *fileData;
	byte *pbDest;
	BOOL BVar1;
	int iVar2;
	Sound3D_SoundData *pSVar3;
	uint local_2c;
	MMCKINFO local_28;
	MMCKINFO local_14;
	
	sound = out_sound;
	pSVar3 = out_sound;
	for (iVar2 = 0x4d; iVar2 != 0; iVar2 += -1) {
		*(undefined4 *)pSVar3->filename = 0;
		pSVar3 = (Sound3D_SoundData *)(pSVar3->filename + 4);
	}
	fileData = lego::file::File_LoadBinary(fName,(uint *)&fName);
	if (fileData != NULL) {
		iVar2 = WaveOpenFile(fileData,(uint)fName,(HMMIO *)&out_sound,&sound->waveFormat,&local_14);
		if (iVar2 == 0) {
			iVar2 = WaveStartDataRead((HMMIO *)&out_sound,&local_28,&local_14);
			if (iVar2 == 0) {
				pbDest = (byte *)GlobalAlloc(0,local_28.cksize);
				sound->data = pbDest;
				if (pbDest != NULL) {
					iVar2 = WaveReadFile((HMMIO)out_sound,local_28.cksize,pbDest,&local_28,&local_2c);
					if (iVar2 == 0) {
						sound->size = local_2c;
						if (out_sound != NULL) {
							mmioClose((HMMIO)out_sound,0);
							out_sound = NULL;
						}
						BVar1 = Sound3D_CreateSoundBuffer(sound);
						if (BVar1 != 0) {
							BVar1 = Sound3D_SendSoundToBuffer(sound);
							if (BVar1 != 0) {
								if (sound->data != NULL) {
									GlobalFree(sound->data);
									sound->data = NULL;
								}
								std::free(fileData);
								return 1;
							}
						}
					}
				}
			}
		}
	}
	if (sound->data != NULL) {
		GlobalFree(sound->data);
		sound->data = NULL;
	}
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_CreateSoundBuffer(Sound3D_SoundData *sound)
{
	int iVar1;
	IDirectSoundBuffer **ppIVar2;
	uint uVar3;
	undefined4 local_14;
	undefined4 local_10;
	uint local_c;
	int local_8;
	WAVEFORMATEX *local_4;
	
	local_4 = sound->waveFormat;
	local_c = sound->size;
	local_8 = 0;
	local_14 = 0x14;
	local_10 = 0x200f2;
	iVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
										(globs::sound3DGlobs.lpDSnd,&local_14,sound->dSoundBuffers,0);
	if (iVar1 != 0) {
		return 0;
	}
	sound->bufferIndex = 0;
	if (local_8 != 0) {
		uVar3 = 1;
		ppIVar2 = sound->dSoundBuffers;
		do {
			ppIVar2 = ppIVar2 + 1;
			iVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->DuplicateSoundBuffer)
												(globs::sound3DGlobs.lpDSnd,sound->dSoundBuffers[0],ppIVar2);
			if (iVar1 != 0) {
				return 0;
			}
			uVar3 += 1;
		} while (uVar3 < 3);
		return TRUE;
	}
	return TRUE;
}



BOOL __cdecl lego::snd::Sound3D_SendSoundToBuffer(Sound3D_SoundData *sound)
{
	Sound3D_SoundData *pSVar1;
	int iVar2;
	uint uVar3;
	Sound3D_SoundData *pSVar4;
	undefined4 *puVar5;
	Sound3D_SoundData **ppSVar6;
	undefined4 *puVar7;
	uint uStack48;
	undefined *puStack44;
	undefined4 *puStack40;
	Sound3D_SoundData **ppSStack36;
	undefined4 *puStack32;
	undefined4 *puStack28;
	undefined4 local_c;
	undefined4 local_8;
	undefined local_4 [4];
	
	pSVar1 = sound;
	puStack32 = &local_8;
	puStack28 = NULL;
	ppSStack36 = &sound;
	puStack40 = &local_c;
	local_c = 0;
	puStack44 = local_4;
	uStack48 = sound->size;
	local_8 = 0;
	iVar2 = (*(code *)sound->dSoundBuffers[0]->lpVtbl->Lock)(sound->dSoundBuffers[0],sound->offset);
	if (iVar2 == -0x7787ff6a) {
		(*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Restore)(pSVar1->dSoundBuffers[0]);
		(*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Lock)
							(pSVar1->dSoundBuffers[0],pSVar1->offset,pSVar1->size,&puStack40,&uStack48,&puStack32,
							 &puStack44,0);
	}
	else {
		if (iVar2 != 0) {
			return 0;
		}
	}
	pSVar4 = (Sound3D_SoundData *)pSVar1->data;
	ppSVar6 = ppSStack36;
	for (uVar3 = (uint)puStack44 >> 2; uVar3 != 0; uVar3 -= 1) {
		*ppSVar6 = *(Sound3D_SoundData **)pSVar4;
		pSVar4 = (Sound3D_SoundData *)((int)pSVar4 + 4);
		ppSVar6 = ppSVar6 + 1;
	}
	for (uVar3 = (uint)puStack44 & 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)ppSVar6 = pSVar4->filename[0];
		pSVar4 = (Sound3D_SoundData *)((int)pSVar4 + 1);
		ppSVar6 = (Sound3D_SoundData **)((int)ppSVar6 + 1);
	}
	if (puStack28 != NULL) {
		puVar5 = (undefined4 *)(puStack44 + (int)pSVar1->data);
		puVar7 = puStack28;
		for (uVar3 = (uint)puStack40 >> 2; uVar3 != 0; uVar3 -= 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar3 = (uint)puStack40 & 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
	}
	iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Unlock)
										(pSVar1->dSoundBuffers[0],ppSStack36,puStack44,puStack28,puStack40);
	if (iVar2 == 0) {
		iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->GetFrequency)
											(pSVar1->dSoundBuffers[0],&pSVar1->frequency);
		if (iVar2 == 0) {
			iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->GetVolume)
												(pSVar1->dSoundBuffers[0],&pSVar1->volume);
			return (uint)(iVar2 == 0);
		}
		return 0;
	}
	return 0;
}



float10 __cdecl lego::snd::Sound3D_GetSamplePlayTime(int handle)
{
	uint uVar1;
	
	if (handle == -1) {
		return (float10)0.0;
	}
	uVar1 = globs::sound3DGlobs.soundTable[handle].size;
	if ((*(byte *)&globs::sound3DGlobs.soundTable[handle].flags & 8) != 0) {
		return (float10)(ulonglong)uVar1 /
					 (float10)globs::sound3DGlobs.soundTable[handle].avgBytesPerSec;
	}
	return (float10)(ulonglong)uVar1 /
				 (float10)(globs::sound3DGlobs.soundTable[handle].waveFormat)->nAvgBytesPerSec;
}



BOOL __cdecl lego::snd::Sound3D_Stream_Play(char *fName,BOOL loop,int volume)
{
	BOOL BVar1;
	IDirectSoundBuffer *pIVar2;
	Sound3D_StreamData *pSVar3;
	
	pSVar3 = &globs::sound3DGlobs.loopStreamData;
	if (loop == 0) {
		pSVar3 = &globs::sound3DGlobs.streamData;
	}
	if ((pSVar3->playing != 0) || (pSVar3->fileOpen != 0)) {
		Sound3D_Stream_Stop(loop);
	}
	BVar1 = Sound3D_Stream_BufferSetup(fName,loop,volume);
	if (BVar1 != 0) {
		pIVar2 = globs::sound3DGlobs.lpDSStreamBuff;
		if (loop != 0) {
			pIVar2 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*(code *)pIVar2->lpVtbl->SetCurrentPosition)(pIVar2,0);
		pIVar2 = globs::sound3DGlobs.lpDSStreamBuff;
		if (loop != 0) {
			pIVar2 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
						// DSBPLAY_LOOPING (0x1)
		(*(code *)pIVar2->lpVtbl->Play)(pIVar2,0,0,1);
		pSVar3->playing = 1;
		return TRUE;
	}
	pSVar3->playing = 0;
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Stream_Stop(BOOL looping)
{
	IDirectSoundBuffer *pIVar1;
	Sound3D_StreamData *pSVar2;
	
	pSVar2 = &globs::sound3DGlobs.loopStreamData;
	if (looping == 0) {
		pSVar2 = &globs::sound3DGlobs.streamData;
	}
	pSVar2->playing = 0;
	if (pSVar2->fileOpen != 0) {
		pIVar1 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar1 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*(code *)pIVar1->lpVtbl->Stop)(pIVar1);
		WaveCloseReadFile(&(pSVar2->wiWave).hmmio,&(pSVar2->wiWave).waveFormat);
		pIVar1 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar1 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*pIVar1->lpVtbl->Release)((IUnknown *)pIVar1);
		pSVar2->fileOpen = 0;
	}
	return TRUE;
}



BOOL __cdecl lego::snd::Sound3D_Stream_BufferSetup(char *waveFName,BOOL loop,int volume)
{
	MMCKINFO *out_pckInRIFF;
	Sound3D_WaveData *out_ppwfxInfo;
	HMMIO *out_phmmioIn;
	WAVEFORMATEX *pWVar1;
	DWORD looping;
	int iVar2;
	uint uVar3;
	Sound3D_StreamData *pSVar4;
	DSBUFFERDESC sndBuffer;
	
	pSVar4 = &globs::sound3DGlobs.loopStreamData;
	if (loop == 0) {
		pSVar4 = &globs::sound3DGlobs.streamData;
	}
	out_pckInRIFF = &(pSVar4->wiWave).mmckInRIFF;
	out_ppwfxInfo = &pSVar4->wiWave;
	out_phmmioIn = &(pSVar4->wiWave).hmmio;
	iVar2 = WaveOpenFile2(waveFName,out_phmmioIn,&out_ppwfxInfo->waveFormat,out_pckInRIFF);
	if (iVar2 != 0) {
		return 0;
	}
	if (out_ppwfxInfo->waveFormat->wFormatTag != WAVE_FORMAT_PCM) {
		WaveCloseReadFile(out_phmmioIn,&out_ppwfxInfo->waveFormat);
		return 0;
	}
	iVar2 = WaveStartDataRead(out_phmmioIn,&(pSVar4->wiWave).mmck,out_pckInRIFF);
	if (iVar2 == 0) {
		pWVar1 = out_ppwfxInfo->waveFormat;
		uVar3 = pWVar1->nSamplesPerSec * (uint)pWVar1->nBlockAlign * 3 >> 2;
		(pSVar4->wiWave).dwNotifySize = uVar3;
		uVar3 %= (uint)pWVar1->nBlockAlign;
		if (uVar3 != 0) {
			(pSVar4->wiWave).dwNotifySize = (pSVar4->wiWave).dwNotifySize + (pWVar1->nBlockAlign - uVar3);
		}
		sndBuffer.dwSize = 0x14;
		sndBuffer.dwFlags = 0x100e0;
		sndBuffer.dwBufferBytes = (pSVar4->wiWave).dwNotifySize << 2;
		sndBuffer.dwReserved = 0;
		(pSVar4->wiWave).dwBufferSize = sndBuffer.dwBufferBytes;
		sndBuffer.lpwfxFormat = out_ppwfxInfo->waveFormat;
		iVar2 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
											(globs::sound3DGlobs.lpDSnd,&sndBuffer,&waveFName,0);
		looping = sndBuffer.dwReserved;
		if (iVar2 == 0) {
			if (sndBuffer.dwReserved == 0) {
				globs::sound3DGlobs.lpDSStreamBuff = (IDirectSoundBuffer *)sndBuffer.dwBufferBytes;
			}
			else {
				globs::sound3DGlobs.lpDSLoopStreamBuff = (IDirectSoundBuffer *)sndBuffer.dwBufferBytes;
			}
			(**(code **)(*(int *)sndBuffer.dwBufferBytes + 0x3c))
								(sndBuffer.dwBufferBytes,sndBuffer.lpwfxFormat);
			(pSVar4->wiWave).bFoundEnd = 0;
			(pSVar4->wiWave).dwNextWriteOffset = 0;
			(pSVar4->wiWave).dwNextProgressCheck = (pSVar4->wiWave).dwNotifySize << 1;
			(pSVar4->wiWave).bLoopFile = looping;
			Sound3D_Stream_FillDataBuffer(looping);
			(pSVar4->wiWave).bDonePlaying = 0;
			pSVar4->fileOpen = 1;
			return 1;
		}
		return 0;
	}
	WaveCloseReadFile(out_phmmioIn,&out_ppwfxInfo->waveFormat);
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Stream_FillDataBuffer(BOOL looping)
{
	MMCKINFO *pckIn;
	HMMIO *phmmioIn;
	undefined2 uVar1;
	int iVar2;
	uint uVar3;
	IDirectSoundBuffer *pIVar4;
	uint uVar5;
	uint uVar6;
	char cVar7;
	int unaff_EBP;
	int iVar8;
	undefined *puVar9;
	uint *puVar10;
	undefined *puStack44;
	undefined4 uStack40;
	undefined local_14 [4];
	undefined local_10 [8];
	undefined local_8 [4];
	uint local_4;
	
	iVar8 = 0x507628;
	if (looping == 0) {
		iVar8 = 0x5075cc;
	}
	pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
	if (looping != 0) {
		pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
	}
	puStack44 = local_8;
	uStack40 = 0;
	iVar2 = (*(code *)pIVar4->lpVtbl->Lock)(pIVar4,0,*(undefined4 *)(iVar8 + 0x34),local_10);
	if (iVar2 != 0) {
		return 0;
	}
	pckIn = (MMCKINFO *)(iVar8 + 0xc);
	phmmioIn = (HMMIO *)(iVar8 + 8);
	WaveReadFile(*phmmioIn,(uint)local_14,(byte *)&local_4,pckIn,(uint *)&puStack44);
	if (puStack44 < local_14) {
		puVar9 = puStack44;
		iVar2 = unaff_EBP;
		if (*(int *)(iVar8 + 0x50) == 0) {
			if (puStack44 < *(undefined **)(iVar8 + 0x38)) {
				*(undefined4 *)(iVar8 + 0x54) = 1;
			}
			uVar5 = (int)local_14 - (int)puStack44;
			cVar7 = (*(short *)(*(int *)(iVar8 + 4) + 0xe) != 8) + -1;
			uVar1 = CONCAT11(cVar7,cVar7);
			uVar3 = CONCAT22(uVar1,uVar1) & 0x80808080;
			puVar10 = (uint *)((int)&local_4 + (int)puStack44);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar10 = uVar3;
				puVar10 = puVar10 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(byte *)puVar10 = (byte)uVar3;
				puVar10 = (uint *)((int)puVar10 + 1);
			}
		}
		else {
			do {
				looping = iVar2;
				WaveStartDataRead(phmmioIn,pckIn,(MMCKINFO *)(iVar8 + 0x20));
				WaveReadFile(*phmmioIn,(int)local_14 - (int)puVar9,puVar9 + (int)&local_4,pckIn,
										 (uint *)&puStack44);
				puVar9 = puVar9 + (int)puStack44;
				iVar2 = looping;
			} while (puVar9 < local_14);
		}
	}
	pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
	if (looping != 0) {
		pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
	}
	iVar2 = 0;
	(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,&local_4,local_14,0);
	uVar3 = *(uint *)(iVar8 + 0x34);
	uVar6 = *(int *)(iVar8 + 0x3c) + iVar2;
	*(uint *)(iVar8 + 0x3c) = uVar6;
	if (uVar3 <= uVar6) {
		*(uint *)(iVar8 + 0x3c) = uVar6 - uVar3;
		uVar6 = uVar3;
	}
	*(undefined4 *)(iVar8 + 0x40) = 0;
	*(undefined4 *)(iVar8 + 0x48) = 0;
	return uVar6;
}



void __cdecl lego::snd::Sound3D_Stream_CheckPosition(BOOL looping)
{
	MMCKINFO *pckIn;
	HMMIO *phmmioIn;
	byte bVar1;
	void *pvVar2;
	HRESULT HVar3;
	IDirectSoundBuffer *pIVar4;
	uint uVar5;
	uint unaff_EBX;
	uint *unaff_EBP;
	uint unaff_ESI;
	Sound3D_StreamData *pSVar6;
	uint uVar7;
	uint *puVar8;
	DWORD local_18;
	void *local_14;
	undefined4 local_10;
	uint local_c;
	int local_8;
	DWORD local_4;
	
	pSVar6 = &globs::sound3DGlobs.loopStreamData;
	if (looping == 0) {
		pSVar6 = &globs::sound3DGlobs.streamData;
	}
	if ((pSVar6->playing != 0) && (pSVar6->fileOpen != 0)) {
		pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
						// IDirectSoundBuffer->GetCurrentPosition(this, DWORD* pdwCurrentPlayCursor, DWORD*
						// pdwCurrentWriteCursor)
		(*(code *)pIVar4->lpVtbl->GetCurrentPosition)(pIVar4,&local_c,&local_4);
		uVar7 = (pSVar6->wiWave).dwLastPos;
		uVar5 = local_c;
		if (local_c < uVar7) {
			uVar5 = (pSVar6->wiWave).dwBufferSize + local_c;
		}
		uVar7 = (pSVar6->wiWave).dwProgress + (uVar5 - uVar7);
		(pSVar6->wiWave).dwLastPos = local_c;
		(pSVar6->wiWave).dwProgress = uVar7;
		pvVar2 = NULL;
		if ((pSVar6->wiWave).dwNextProgressCheck < uVar7) {
			while ((local_10 = 0, (pSVar6->wiWave).bDonePlaying == 0 || (pvVar2 != NULL))) {
				local_8 = 1;
				if ((pSVar6->wiWave).bFoundEnd == 0) {
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
						// IDirectSoundBuffer->Lock(this, DWORD dwOffset, DWORD dwBytes, void** ppvAudioPtr1,
						// DWORD* pdwAudioBytes1)
					HVar3 = (*(code *)pIVar4->lpVtbl->Lock)
														(pIVar4,(pSVar6->wiWave).dwNextWriteOffset,(pSVar6->wiWave).dwNotifySize
														 ,&local_14,&local_18);
					if (HVar3 != 0) {
						return;
					}
					pckIn = &(pSVar6->wiWave).mmck;
					phmmioIn = &(pSVar6->wiWave).hmmio;
					WaveReadFile(*phmmioIn,unaff_ESI,(byte *)unaff_EBP,pckIn,(uint *)&stack0xffffffe4);
					uVar7 = unaff_EBX;
					if (unaff_EBX < unaff_ESI) {
						if ((pSVar6->wiWave).bLoopFile == 0) {
							(pSVar6->wiWave).bFoundEnd = 1;
							bVar1 = (((pSVar6->wiWave).waveFormat)->wBitsPerSample != 8) - 1;
							puVar8 = (uint *)(unaff_EBX + (int)unaff_EBP);
							for (uVar5 = unaff_ESI - unaff_EBX >> 2; uVar5 != 0; uVar5 -= 1) {
								*puVar8 = CONCAT22(CONCAT11(bVar1,bVar1),CONCAT11(bVar1,bVar1)) & 0x80808080;
								puVar8 = puVar8 + 1;
							}
							for (uVar5 = unaff_ESI - unaff_EBX & 3; uVar5 != 0; uVar5 -= 1) {
								*(byte *)puVar8 = bVar1 & 0x80;
								puVar8 = (uint *)((int)puVar8 + 1);
							}
						}
						else {
							do {
								WaveStartDataRead(phmmioIn,pckIn,&(pSVar6->wiWave).mmckInRIFF);
								WaveReadFile(*phmmioIn,unaff_ESI - unaff_EBX,(byte *)(unaff_EBX + (int)unaff_EBP),
														 pckIn,(uint *)&stack0xffffffe4);
								unaff_EBX += uVar7;
							} while (unaff_EBX < unaff_ESI);
						}
					}
					unaff_EBX = uVar7;
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (local_8 != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
						// IDirectSoundBuffer->Unlock(this, void* pvAudioPtr1, DWORD dwAudioBytes1, void*
						// pvAudioPtr2, DWORD dwAudioBytes2)
					(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,unaff_EBP,unaff_ESI,NULL,0);
					uVar5 = (pSVar6->wiWave).dwNextWriteOffset + unaff_ESI;
					uVar7 = (pSVar6->wiWave).dwBufferSize;
					(pSVar6->wiWave).dwNextWriteOffset = uVar5;
					(pSVar6->wiWave).dwNextProgressCheck = (pSVar6->wiWave).dwNextProgressCheck + unaff_ESI;
					looping = local_8;
					if (uVar7 <= uVar5) {
						(pSVar6->wiWave).dwNextWriteOffset = uVar5 - uVar7;
					}
				}
				else {
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
					(*(code *)pIVar4->lpVtbl->Lock)
										(pIVar4,(pSVar6->wiWave).dwNextWriteOffset,(pSVar6->wiWave).dwNotifySize,
										 &local_14,&local_18);
					bVar1 = (((pSVar6->wiWave).waveFormat)->wBitsPerSample != 8) - 1;
					puVar8 = unaff_EBP;
					for (uVar7 = unaff_ESI >> 2; uVar7 != 0; uVar7 -= 1) {
						*puVar8 = CONCAT22(CONCAT11(bVar1,bVar1),CONCAT11(bVar1,bVar1)) & 0x80808080;
						puVar8 = puVar8 + 1;
					}
					for (uVar7 = unaff_ESI & 3; uVar7 != 0; uVar7 -= 1) {
						*(byte *)puVar8 = bVar1 & 0x80;
						puVar8 = (uint *)((int)puVar8 + 1);
					}
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
					(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,unaff_EBP,unaff_ESI,NULL,0);
					uVar7 = (pSVar6->wiWave).mmckInRIFF.cksize;
					uVar5 = (pSVar6->wiWave).dwNotifySize;
					if (((uVar5 < uVar7) && (uVar7 - uVar5 <= (pSVar6->wiWave).dwProgress)) ||
						 (uVar7 <= (pSVar6->wiWave).dwProgress)) {
						(pSVar6->wiWave).bDonePlaying = 1;
					}
					(pSVar6->wiWave).dwNextProgressCheck = (pSVar6->wiWave).dwNextProgressCheck + unaff_ESI;
				}
				pvVar2 = local_14;
				if ((pSVar6->wiWave).dwProgress <= (pSVar6->wiWave).dwNextProgressCheck) {
					return;
				}
			}
			Sound3D_Stream_Stop(looping);
		}
	}
	return;
}



// return (a.x == b.x) && (a.y == b.y) && (a.z == b.z)

BOOL __cdecl lego::snd::Sound3D_D3DVectorEqual(Vector3F *a,Vector3F *b)
{
	if (((a->x == b->x) && (a->y == b->y)) && (a->z == b->z)) {
		return 1;
	}
	return 0;
}



float10 __cdecl lego::snd::Sound3D_SetRollOffFactor(float rollOff)
{
	if (globs::sound3DGlobs.intialised != 0) {
		if (rollOff < 0.0) {
			rollOff = 0.0;
		}
		if ((ushort)((ushort)(rollOff < 10.0) << 8 | (ushort)(rollOff == 10.0) << 0xe) == 0) {
			rollOff = 10.0;
		}
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetRolloffFactor)
							(globs::sound3DGlobs.lp3DListenerInfo,rollOff,0);
	}
	return (float10)rollOff;
}



int __cdecl lego::snd::Sound3D_MinVolume(void)
{
	return -10000;
}



void __cdecl lego::ddraw::DirectDraw_Initialise(HWND hWnd)
{
	globs::directDrawGlobs.hWnd = hWnd;
	globs::directDrawGlobs.lpDirectDraw = NULL;
	globs::directDrawGlobs.fSurf = NULL;
	globs::directDrawGlobs.bSurf = NULL;
	globs::directDrawGlobs.zSurf = NULL;
	globs::directDrawGlobs.lpFrontClipper = NULL;
	globs::directDrawGlobs.driverList = NULL;
	globs::directDrawGlobs.deviceList = NULL;
	globs::directDrawGlobs.modeList = NULL;
	globs::directDrawGlobs.driverCount = 0;
	globs::directDrawGlobs.deviceCount = 0;
	globs::directDrawGlobs.modeCount = 0;
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_EnumDrivers(DirectDraw_Driver *ref_list,uint *out_count)
{
	globs::directDrawGlobs.driverList = ref_list;
	DirectDrawEnumerateA(DirectDraw_EnumDriverCallback,NULL);
	*out_count = globs::directDrawGlobs.driverCount;
	return 1;
}



BOOL lego::ddraw::DirectDraw_EnumDriverCallback
							 (LPGUID lpGUID,LPSTR lpDriverDescription,LPSTR lpDriverName,LPVOID lpContext)
{
	DirectDraw_Driver *pDVar1;
	
	globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
			 DIRECTDRAW_FLAG_DRIVER_VALID;
	if (lpGUID == NULL) {
		globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
				 globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags |
				 DIRECTDRAW_FLAG_DRIVER_PRIMARY;
		globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
				 globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags |
				 DIRECTDRAW_FLAG_DRIVER_WINDOWOK;
	}
	else {
		pDVar1 = globs::directDrawGlobs.driverList + globs::directDrawGlobs.driverCount;
		(pDVar1->guid).Data1 = lpGUID->Data1;
		*(undefined4 *)&(pDVar1->guid).Data2 = *(undefined4 *)&lpGUID->Data2;
		*(undefined4 *)(pDVar1->guid).Data4 = *(undefined4 *)lpGUID->Data4;
		*(undefined4 *)((pDVar1->guid).Data4 + 4) = *(undefined4 *)(lpGUID->Data4 + 4);
	}
	std::sprintf(globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].desc,"%s (%s)",
							 lpDriverDescription,lpDriverName);
	globs::directDrawGlobs.driverCount = globs::directDrawGlobs.driverCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_EnumDevices
					(DirectDraw_Driver *driver,DirectDraw_Device *ref_list,uint *out_count)
{
	HRESULT HVar1;
	uint uVar2;
	GUID *pGVar3;
	IUnknown *local_8;
	DirectDraw_Device *local_4;
	
	uVar2 = 0;
	globs::directDrawGlobs.deviceCount = 0;
	HVar1 = DirectDrawCreate(&driver->guid,(IDirectDraw **)&local_4,NULL);
	if (HVar1 == 0) {
		HVar1 = (**(code **)(local_4->guid).Data1)
											((IUnknown *)local_4,(IID *)&idl::IID_IDirectDraw4,&local_8);
		if (HVar1 == 0) {
			pGVar3 = &idl::IID_IDirect3D3;
			HVar1 = (*local_8->lpVtbl->QueryInterface)(local_8,(IID *)&idl::IID_IDirect3D3,&driver);
			if (HVar1 == 0) {
				globs::directDrawGlobs.deviceList = local_4;
				(*local_8->lpVtbl[1].QueryInterface)(local_8,(IID *)DirectDraw_EnumDeviceCallback,NULL);
				(**(code **)(*(int *)pGVar3 + 8))(pGVar3);
			}
			uVar2 = (uint)(HVar1 == 0);
			(**(code **)(*(int *)pGVar3 + 8))(pGVar3);
		}
		(**(code **)((local_4->guid).Data1 + 8))(local_4);
	}
	*out_count = globs::directDrawGlobs.deviceCount;
	return uVar2;
}



HRESULT lego::ddraw::DirectDraw_EnumDeviceCallback
									(LPGUID lpGuid,LPSTR lpDeviceDescription,LPSTR lpDeviceName,
									D3DDEVICEDESC_V1 *lpHWDesc,D3DDEVICEDESC_V1 *lpHELDesc,LPVOID lpContext)
{
	DirectDraw_Device *pDVar1;
	DirectDraw_DeviceFlags DVar2;
	
	pDVar1 = globs::directDrawGlobs.deviceList + globs::directDrawGlobs.deviceCount;
	pDVar1->flags = DIRECTDRAW_FLAG_DEVICE_VALID;
	if (lpHWDesc->dcmColorModel != 0) {
		pDVar1->flags = DIRECTDRAW_FLAG_DEVICE_VALID|DIRECTDRAW_FLAG_DEVICE_HARDWARE;
		lpHELDesc = lpHWDesc;
	}
						// D3DDD_COLORMODEL (0x1) and D3DCOLOR_RGB (0x2)
	if (((*(byte *)&lpHELDesc->dwFlags & 1) != 0) && (lpHELDesc->dcmColorModel == 2)) {
		pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_COLOUR;
	}
						// D3DDD_DEVICERENDERBITDEPTH (0x80)
	if ((*(byte *)&lpHELDesc->dwFlags & 0x80) != 0) {
						// <https://github.com/github/VisualStudio/blob/263aac11f57d53c5f9fe64ba9916f77c058974d7/tools/Debugging%20Tools%20for%20Windows/winext/manifest/ddraw.h#L1421>
						// DDBD_8 (0x800) 8 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x800) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH8;
		}
						// DDBD_16 (0x400) 16 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x400) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH16;
		}
						// DDBD_24 (0x200) 24 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x200) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH24;
		}
						// DDBD_32 (0x100) 32 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x100) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH32;
		}
	}
						// D3DDD_DEVCAPS (0x2)
	if ((*(byte *)&lpHELDesc->dwFlags & 2) != 0) {
						// D3DDEVCAPS_TEXTUREVIDEOMEMORY (0x200)
		if ((lpHELDesc->dwDevCaps & 0x200) == 0) {
						// D3DDEVCAPS_TEXTURESYSTEMMEMORY (0x100)
			if ((lpHELDesc->dwDevCaps & 0x100) == 0) goto LAB_0047c71d;
			DVar2 = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_SYSTEMTEXTURE;
		}
		else {
			DVar2 = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_VIDEOTEXTURE;
		}
		pDVar1->flags = DVar2;
	}
LAB_0047c71d:
	(pDVar1->guid).Data1 = lpGuid->Data1;
	*(undefined4 *)&(pDVar1->guid).Data2 = *(undefined4 *)&lpGuid->Data2;
	*(undefined4 *)(pDVar1->guid).Data4 = *(undefined4 *)lpGuid->Data4;
	*(undefined4 *)((pDVar1->guid).Data4 + 4) = *(undefined4 *)(lpGuid->Data4 + 4);
	std::sprintf(pDVar1->desc,"%s (%s)",lpDeviceName,lpDeviceDescription);
						// DIENUM_CONTINUE (0x1)
	globs::directDrawGlobs.deviceCount = globs::directDrawGlobs.deviceCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_EnumModes
					(DirectDraw_Driver *driver,BOOL fullScreen,DirectDraw_Mode *ref_list,uint *out_count)
{
	HRESULT HVar1;
	uint uVar2;
	IDirectDraw *ddraw1;
	
	uVar2 = 0;
	globs::directDrawGlobs.modeCount = 0;
	if ((driver != NULL) &&
		 ((driver->flags & DIRECTDRAW_FLAG_DRIVER_VALID) != DIRECTDRAW_FLAG_DRIVER_NONE)) {
		HVar1 = DirectDrawCreate((LPGUID)(~-(uint)((driver->flags & DIRECTDRAW_FLAG_DRIVER_PRIMARY) !=
																							DIRECTDRAW_FLAG_DRIVER_NONE) & (uint)driver),&ddraw1,
														 NULL);
		if (HVar1 == 0) {
			HVar1 = (*ddraw1->lpVtbl->QueryInterface)
												(ddraw1,&idl::IID_IDirectDraw4,(IDirectDraw4 **)&driver);
			if (HVar1 == 0) {
				globs::directDrawGlobs.modeList = ref_list;
						// IDirectDraw4->EnumDisplayModes(this, DWORD dwFlags, DDSURFACEDESC2* lpDDSurfaceDesc,
						// void* lpContext, DDENUMMODESCALLBACK2* lpEnumModesCallback)
				(**(code **)((driver->guid).Data1 + 0x20))
									((IDirectDraw4 *)driver,0,NULL,&fullScreen,DirectDraw_EnumModeCallback);
				(**(code **)((driver->guid).Data1 + 8))((IDirectDraw4 *)driver);
			}
			uVar2 = (uint)(HVar1 == 0);
			(*ddraw1->lpVtbl->Release)(ddraw1);
		}
	}
	*out_count = globs::directDrawGlobs.modeCount;
	return uVar2;
}



HRESULT lego::ddraw::DirectDraw_EnumModeCallback(DDSURFACEDESC2 *lpDDSurfaceDesc,LPVOID lpContext)
{
	uint uVar1;
	DirectDraw_Mode *pDVar2;
	
	pDVar2 = globs::directDrawGlobs.modeList + globs::directDrawGlobs.modeCount;
	pDVar2->flags = DIRECTDRAW_FLAG_MODE_VALID;
	pDVar2->width = lpDDSurfaceDesc->dwWidth;
	pDVar2->height = lpDDSurfaceDesc->dwHeight;
	pDVar2->bitDepth = (lpDDSurfaceDesc->ddpfPixelFormat).dwRGBBitCount;
						// WARNING: Load size is inaccurate
						// lpContext (BOOL* isFullScreen)
	if (*lpContext == 0) {
		std::sprintf(pDVar2->desc,"%ix%i",lpDDSurfaceDesc->dwWidth,lpDDSurfaceDesc->dwHeight);
	}
	else {
		std::sprintf(pDVar2->desc,"%ix%i (%i bit)",lpDDSurfaceDesc->dwWidth,lpDDSurfaceDesc->dwHeight,
								 (lpDDSurfaceDesc->ddpfPixelFormat).dwRGBBitCount);
	}
						// WARNING: Load size is inaccurate
						// lpContext (BOOL* isFullScreen)
	if ((*lpContext == 0) && (globs::directDrawGlobs.modeCount != 0)) {
		uVar1 = main::Main_GetWindowsBitDepth();
		if (pDVar2->bitDepth != uVar1) {
						// Bit depth doesn't match system, we can't use this in windowed
			pDVar2->flags = pDVar2->flags & 0xfffffffe;
						// DDENUMRET_OK (0x1)
						// skip incrementing COUNT and return
			return 1;
		}
	}
						// DDENUMRET_OK (0x1)
	globs::directDrawGlobs.modeCount = globs::directDrawGlobs.modeCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_Setup
					(BOOL fullscreen,DirectDraw_Driver *driver,DirectDraw_Device *device,
					DirectDraw_Mode *screen,uint xPos,uint yPos,uint width,uint height)
{
	HRESULT HVar1;
	int iVar2;
	BOOL BVar3;
	LPGUID lpGUID;
	DDSURFACEDESC2 *pDVar4;
	IDirectDraw *ddraw1;
	uint dwBPP;
	DDSCAPS2 caps;
	DDSURFACEDESC2 surf;
	
	lpGUID = NULL;
	dwBPP = 0x10;
	if ((driver != NULL) && ((*(byte *)&driver->flags & DIRECTDRAW_FLAG_DRIVER_VALID) == 0)) {
		driver = NULL;
	}
	if ((device != NULL) && ((*(byte *)&device->flags & DIRECTDRAW_FLAG_DEVICE_VALID) == 0)) {
		device = NULL;
	}
	if (screen != NULL) {
		if ((*(byte *)&screen->flags & DIRECTDRAW_FLAG_MODE_VALID) == 0) {
			screen = NULL;
		}
		if (screen != NULL) {
			width = screen->width;
			height = screen->height;
			dwBPP = screen->bitDepth;
		}
	}
	globs::directDrawGlobs.fullScreen = fullscreen;
	if (driver != NULL) {
		lpGUID = (LPGUID)(~-(uint)((driver->flags & DIRECTDRAW_FLAG_DRIVER_PRIMARY) !=
															DIRECTDRAW_FLAG_DRIVER_NONE) & (uint)driver);
	}
	globs::directDrawGlobs.width = width;
	globs::directDrawGlobs.height = height;
	main::Main_SetupDisplay(fullscreen,xPos,yPos,width,height);
	HVar1 = DirectDrawCreate(lpGUID,&ddraw1,NULL);
	if (HVar1 == 0) {
		HVar1 = (*ddraw1->lpVtbl->QueryInterface)
											(ddraw1,&idl::IID_IDirectDraw4,&globs::directDrawGlobs.lpDirectDraw);
		if (HVar1 == 0) {
						// IDirectDraw4->SetCooperativeLevel(this, HWND hWnd, DWORD dwFlags)
						// 
						// FullScreen = DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN (0x11)
						// Windowed   = DDSCL_NORMAL (0x8)
			HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->SetCooperativeLevel)
												(globs::directDrawGlobs.lpDirectDraw,globs::directDrawGlobs.hWnd,
												 (-(uint)(fullscreen != 0) & 9) + 8);
			if (HVar1 == 0) {
				if (fullscreen == 0) {
					iVar2 = 0;
				}
				else {
						// IDirectDraw4->SetDisplayMode(this, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD
						// dwRefreshRate, DWORD dwFlags)
					iVar2 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->SetDisplayMode)
														(globs::directDrawGlobs.lpDirectDraw,width,height,dwBPP,0,0);
				}
				if (iVar2 == 0) {
					pDVar4 = &surf;
					for (iVar2 = 0x1f; iVar2 != 0; iVar2 += -1) {
						pDVar4->dwSize = 0;
						pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
					}
					surf.dwSize = 0x7c;
					surf.dwFlags = 1;
					surf.ddsCaps.dwCaps = 0x2200;
					if (fullscreen != 0) {
						surf.dwFlags = 0x21;
						surf.dwBackBufferCount_Depth = 1;
						surf.ddsCaps.dwCaps = 0x2218;
					}
						// IDirectDraw4->CreateSurface(this, DDSURFACEDESC2* lpDDSurfaceDesc,
						// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
					HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
														(globs::directDrawGlobs.lpDirectDraw,&surf,&globs::directDrawGlobs.fSurf
														 ,NULL);
					if (HVar1 == 0) {
						if (fullscreen == 0) {
							surf.ddsCaps.dwCaps = surf.ddsCaps.dwCaps & 0xfffffdff | 0x40;
							surf.dwFlags |= 6;
						// IDirectDraw4->CreateSurface(this, DDSURFACEDESC2* lpDDSurfaceDesc,
						// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
							surf.dwHeight = height;
							surf.dwWidth = width;
							iVar2 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
																(globs::directDrawGlobs.lpDirectDraw,&surf,
																 &globs::directDrawGlobs.bSurf,NULL);
						}
						else {
							caps.dwCaps = 4;
							caps.dwCaps2 = 0;
							caps.dwCaps3 = 0;
							caps.dwCaps4_VolumeDepth = 0;
						// IDirectDrawSurface4->GetAttachedSurface(this, DDSCAPS2* lpDDSCaps,
						// IDirectDrawSurface4** lplpDDAttachedSurface)
							iVar2 = (*(globs::directDrawGlobs.fSurf)->lpVtbl->GetAttachedSurface)
																(globs::directDrawGlobs.fSurf,&caps,&globs::directDrawGlobs.bSurf);
						}
						if (iVar2 == 0) {
							BVar3 = DirectDraw_CreateClipper(fullscreen,width,height);
							if ((BVar3 != 0) &&
								 (BVar3 = main::Main_SetupDirect3D
																		(device,ddraw1,globs::directDrawGlobs.bSurf,fullscreen),
								 BVar3 != 0)) {
								(*ddraw1->lpVtbl->Release)(ddraw1);
								if (fullscreen != 0) {
									ShowCursor(0);
								}
								return 1;
							}
							(*(globs::directDrawGlobs.bSurf)->lpVtbl->Release)(globs::directDrawGlobs.bSurf);
							globs::directDrawGlobs.bSurf = NULL;
						}
						(*(globs::directDrawGlobs.fSurf)->lpVtbl->Release)(globs::directDrawGlobs.fSurf);
						globs::directDrawGlobs.fSurf = NULL;
					}
				}
			}
			(*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->Release)(globs::directDrawGlobs.lpDirectDraw)
			;
			globs::directDrawGlobs.lpDirectDraw = NULL;
		}
		(*ddraw1->lpVtbl->Release)(ddraw1);
	}
	return 0;
}



void __cdecl lego::ddraw::DirectDraw_Flip(void)
{
	if (globs::directDrawGlobs.fullScreen != 0) {
						// DDFLIP_WAIT (0x1)
		(*(globs::directDrawGlobs.fSurf)->lpVtbl->Flip)(globs::directDrawGlobs.fSurf,NULL,1);
		return;
	}
	DirectDraw_BlitBuffers();
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_SaveBMP(IDirectDrawSurface4 *surface,char *fname)
{
	uint uVar1;
	char cVar2;
	char cVar3;
	File *f;
	HRESULT HVar4;
	undefined4 *puVar5;
	int iVar6;
	uint uVar7;
	int iVar8;
	byte bVar9;
	BOOL BVar10;
	DDSURFACEDESC2 *pDVar11;
	uint size;
	undefined4 *puVar12;
	int local_e8;
	uint local_d8;
	undefined uStack180;
	undefined auStack179 [9];
	undefined4 local_aa;
	undefined4 local_a6;
	uint local_a2;
	uint local_9e;
	undefined2 local_9a;
	undefined2 uStack152;
	undefined4 local_96;
	undefined4 local_92;
	undefined4 local_8e;
	undefined4 local_8a;
	undefined4 local_86;
	undefined4 uStack130;
	DDSURFACEDESC2 local_7c;
	
	bVar9 = 0;
	uStack180 = 0;
	BVar10 = 0;
	puVar5 = (undefined4 *)auStack179;
	for (iVar6 = 0xd; iVar6 != 0; iVar6 += -1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	*(undefined *)puVar5 = 0;
	cVar3 = '\0';
	cVar2 = '\0';
	f = lego::file::File_Open(fname,"wb");
	if (f != NULL) {
		pDVar11 = &local_7c;
		for (iVar6 = 0x1f; iVar6 != 0; iVar6 += -1) {
			pDVar11->dwSize = 0;
			pDVar11 = (DDSURFACEDESC2 *)&pDVar11->dwFlags;
		}
		local_7c.dwSize = 0x7c;
		HVar4 = (*surface->lpVtbl->Lock)(surface,NULL,&local_7c,1,NULL);
		if (HVar4 == 0) {
			iVar6 = (-(uint)((local_7c.dwWidth * 3 & 3) != 0) & 4) + (local_7c.dwWidth * 3 & 0xfffffffc);
			size = iVar6 * local_7c.dwHeight;
			puVar5 = (undefined4 *)std::malloc(size);
			if (puVar5 != NULL) {
				puVar12 = puVar5;
				for (uVar7 = size >> 2; uVar7 != 0; uVar7 -= 1) {
					*puVar12 = 0;
					puVar12 = puVar12 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 += -1) {
					*(undefined *)puVar12 = 0;
					puVar12 = (undefined4 *)((int)puVar12 + 1);
				}
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwRBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						cVar3 += '\x01';
					}
					uVar7 += 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwGBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						cVar2 += '\x01';
					}
					uVar7 += 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwBBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						bVar9 += 1;
					}
					uVar7 += 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				if (local_7c.dwHeight != 0) {
					do {
						iVar8 = 0;
						local_d8 = 0;
						if (local_7c.dwWidth != 0) {
							local_e8 = 0;
							do {
								iVar8 += 3;
								uVar1 = *(uint *)((int)local_7c.lpSurface + local_e8 + uVar7 * local_7c.lPitch);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -1) =
										 (char)(uVar1 >> (bVar9 + cVar2 & 0x1f)) << (8U - cVar3 & 0x1f);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -2) =
										 (char)(uVar1 >> (bVar9 & 0x1f)) << (8U - cVar2 & 0x1f);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -3) =
										 (char)uVar1 << (8 - bVar9 & 0x1f);
								local_e8 += local_7c.ddpfPixelFormat.dwRGBBitCount >> 3;
								local_d8 += 1;
							} while (local_d8 < local_7c.dwWidth);
						}
						uVar7 += 1;
					} while (uVar7 < local_7c.dwHeight);
				}
				BVar10 = 1;
			}
			(*surface->lpVtbl->Unlock)(surface,NULL);
			auStack179._1_4_ = size + 0x36;
			uStack180 = 0x42;
			auStack179[0] = 0x4d;
			local_aa = 0x36;
			local_a6 = 0x28;
			local_a2 = local_7c.dwWidth;
			local_9e = local_7c.dwHeight;
			local_9a = 1;
			uStack152 = 0x18;
			local_96 = 0;
			local_92 = 0;
			local_8e = 1;
			local_8a = 1;
			local_86 = 0;
			uStack130 = 0;
			if (BVar10 != 0) {
				lego::file::File_Write(&uStack180,0x36,1,f);
				lego::file::File_Write(puVar5,size,1,f);
			}
			std::free(puVar5);
		}
		lego::file::File_Close(f);
	}
	return BVar10;
}



void __cdecl lego::ddraw::DirectDraw_ReturnFrontBuffer(void)
{
	if (globs::directDrawGlobs.fullScreen != 0) {
						// DDBLT_WAIT (0x1000000)
		(*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
							(globs::directDrawGlobs.bSurf,NULL,globs::directDrawGlobs.fSurf,NULL,0x1000000,NULL);
	}
	return;
}



void __cdecl lego::ddraw::DirectDraw_BlitBuffers(void)
{
	POINT ptClient;
	RECT dstRect;
	RECT srcRect;
	
	dstRect.right = globs::directDrawGlobs.width;
	ptClient.y = 0;
	ptClient.x = 0;
	dstRect.left = 0;
	dstRect.top = 0;
	dstRect.bottom = globs::directDrawGlobs.height;
	ClientToScreen(globs::directDrawGlobs.hWnd,(LPPOINT)&ptClient);
	OffsetRect((LPRECT)&dstRect,ptClient.x,ptClient.y);
	srcRect.bottom = globs::directDrawGlobs.height;
	srcRect.left = 0;
	srcRect.top = 0;
	srcRect.right = globs::directDrawGlobs.width;
						// DDBLT_WAIT (0x1000000)
	(*(globs::directDrawGlobs.fSurf)->lpVtbl->Blt)
						(globs::directDrawGlobs.fSurf,(LPRECT)&dstRect,globs::directDrawGlobs.bSurf,
						 (LPRECT)&srcRect,0x1000000,NULL);
	return;
}



void __cdecl lego::ddraw::DirectDraw_Shutdown(void)
{
	if (globs::directDrawGlobs.fSurf != NULL) {
		(*(globs::directDrawGlobs.fSurf)->lpVtbl->Release)((IUnknown *)globs::directDrawGlobs.fSurf);
	}
	if (globs::directDrawGlobs.lpFrontClipper != NULL) {
		(*(globs::directDrawGlobs.lpFrontClipper)->lpVtbl->Release)
							((IUnknown *)globs::directDrawGlobs.lpFrontClipper);
	}
	if (globs::directDrawGlobs.lpBackClipper != NULL) {
		(*(globs::directDrawGlobs.lpBackClipper)->lpVtbl->Release)
							((IUnknown *)globs::directDrawGlobs.lpBackClipper);
	}
	if (globs::directDrawGlobs.lpDirectDraw != NULL) {
		if (globs::directDrawGlobs.fullScreen != 0) {
			(*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->RestoreDisplayMode)
								(globs::directDrawGlobs.lpDirectDraw);
		}
		if (globs::directDrawGlobs.lpDirectDraw != NULL) {
			(*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->Release)
								((IUnknown *)globs::directDrawGlobs.lpDirectDraw);
		}
	}
	return;
}



void __cdecl lego::ddraw::DirectDraw_AdjustTextureUsage(uint *ref_textureUsage)
{
	HRESULT HVar1;
	int iVar2;
	uint unaff_EDI;
	DDPIXELFORMAT *pDVar3;
	DDPIXELFORMAT pixFmt;
	
	pDVar3 = &pixFmt;
	for (iVar2 = 8; iVar2 != 0; iVar2 += -1) {
		pDVar3->dwSize = 0;
		pDVar3 = (DDPIXELFORMAT *)((int)pDVar3 + 4);
	}
	pixFmt.dwSize = 0x20;
						// DDBD_8 (0x800), D3DRMFPTF_PALETTIZED (0x4)
	HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
										(globs::mainGlobs.device,0x800,4,&pixFmt);
	if (HVar1 != 0) {
		pDVar3 = &pixFmt;
		for (iVar2 = 8; iVar2 != 0; iVar2 += -1) {
			pDVar3->dwSize = 0;
			pDVar3 = (DDPIXELFORMAT *)&pDVar3->dwFlags;
		}
		pixFmt.dwSize = 0x20;
						// DDBD_16 (0x400), <no flags> (0x0)
		HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
											(globs::mainGlobs.device,0x400,0,&pixFmt);
		if (HVar1 == 0) {
			*(uint *)pixFmt.dwGBitMask = (unaff_EDI >> 3) * *(int *)pixFmt.dwGBitMask;
		}
	}
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_GetAvailTextureMem(uint *out_total,uint *out_avil)
{
	int iVar1;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_c = 0;
	local_8 = 0;
						// DDSCAPS_TEXTURE (0x1000)
	local_10 = 0x1000;
	local_4 = 0;
	*out_total = 0;
	*out_avil = 0;
	iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->GetAvailableVidMem)
										(globs::directDrawGlobs.lpDirectDraw,&local_10,out_total,out_avil);
	return (uint)(iVar1 == 0);
}



HRESULT __cdecl lego::ddraw::DirectDraw_Clear(Area2F *window,uint colour)
{
	HRESULT HVar1;
	int iVar2;
	undefined4 *puVar3;
	longlong lVar4;
	tagRECT local_74;
	undefined4 local_64 [20];
	uint local_14;
	
	puVar3 = local_64;
	for (iVar2 = 0x19; iVar2 != 0; iVar2 += -1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	local_64[0] = 100;
	local_14 = DirectDraw_GetColour(globs::directDrawGlobs.bSurf,colour);
	if (window != NULL) {
		lVar4 = __ftol((float10)window->x);
		local_74.left = (LONG)lVar4;
		lVar4 = __ftol((float10)window->y);
		local_74.top = (LONG)lVar4;
		lVar4 = __ftol((float10)window->width + (float10)window->x);
		local_74.right = (LONG)lVar4;
		lVar4 = __ftol((float10)window->height + (float10)window->y);
		local_74.bottom = (LONG)lVar4;
						// DDBLT_WAIT | DDBLT_COLORFILL (0x1000000 | 0x400)
		HVar1 = (*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
											(globs::directDrawGlobs.bSurf,(LPRECT)&local_74,NULL,NULL,0x1000400,local_64);
		return HVar1;
	}
						// DDBLT_WAIT | DDBLT_COLORFILL (0x1000000 | 0x400)
	HVar1 = (*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
										(globs::directDrawGlobs.bSurf,NULL,NULL,NULL,0x1000400,local_64);
	return HVar1;
}



BOOL __cdecl lego::ddraw::DirectDraw_CreateClipper(BOOL fullscreen,uint width,uint height)
{
	int iVar1;
	HRGN hrgn;
	DWORD size;
	LPRGNDATA lpRgnData;
	int unaff_EBX;
	int unaff_EBP;
	IDirectDraw4 *pIVar2;
	
	pIVar2 = globs::directDrawGlobs.lpDirectDraw;
	iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateClipper)
										(globs::directDrawGlobs.lpDirectDraw,0,0x76bc98,0);
	if (iVar1 == 0) {
		hrgn = CreateRectRgn(0,0,unaff_EBP,unaff_EBX);
		size = GetRegionData(hrgn,0,NULL);
		lpRgnData = (LPRGNDATA)std::malloc(size);
		GetRegionData(hrgn,size,lpRgnData);
		iVar1 = (*(code *)(globs::directDrawGlobs.lpBackClipper)->lpVtbl->SetClipList)
											(globs::directDrawGlobs.lpBackClipper,lpRgnData,0);
		if (iVar1 == 0) {
			std::free(lpRgnData);
			iVar1 = (*(code *)(globs::directDrawGlobs.bSurf)->lpVtbl->SetClipper)
												(globs::directDrawGlobs.bSurf,globs::directDrawGlobs.lpBackClipper);
			if (iVar1 == 0) {
				if (pIVar2 != NULL) {
					return 1;
				}
				iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateClipper)
													(globs::directDrawGlobs.lpDirectDraw,0,0x76bc94,0);
				if (iVar1 == 0) {
					iVar1 = (*(code *)(globs::directDrawGlobs.lpFrontClipper)->lpVtbl->SetHWnd)
														(globs::directDrawGlobs.lpFrontClipper,0,globs::directDrawGlobs.hWnd);
					if (iVar1 == 0) {
						iVar1 = (*(code *)(globs::directDrawGlobs.fSurf)->lpVtbl->SetClipper)
															(globs::directDrawGlobs.fSurf,globs::directDrawGlobs.lpFrontClipper);
						if (iVar1 == 0) {
							return 1;
						}
					}
				}
			}
			(*(globs::directDrawGlobs.lpBackClipper)->lpVtbl->Release)
								((IUnknown *)globs::directDrawGlobs.lpBackClipper);
			globs::directDrawGlobs.lpBackClipper = NULL;
		}
		std::free(lpRgnData);
	}
	return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl
lego::ddraw::DirectDraw_Blt8To16
					(IDirectDrawSurface4 *target,IDirectDrawSurface4 *source,D3DRMPaletteEntry *palette)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	bool bVar5;
	HRESULT HVar6;
	int iVar7;
	char cVar8;
	uint uVar9;
	uint uVar10;
	char cVar11;
	byte bVar12;
	DDSURFACEDESC2 *pDVar13;
	uint uStack296;
	int iStack288;
	uint uStack272;
	byte bStack256;
	byte bStack252;
	DDSURFACEDESC2 local_f8;
	DDSURFACEDESC2 local_7c;
	
	pDVar13 = &local_7c;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 += -1) {
		pDVar13->dwSize = 0;
		pDVar13 = (DDSURFACEDESC2 *)&pDVar13->dwFlags;
	}
	pDVar13 = &local_f8;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 += -1) {
		pDVar13->dwSize = 0;
		pDVar13 = (DDSURFACEDESC2 *)&pDVar13->dwFlags;
	}
	local_7c.dwSize = 0x7c;
	local_f8.dwSize = 0x7c;
	HVar6 = (*source->lpVtbl->Lock)(source,NULL,&local_f8,1,NULL);
	if (HVar6 == 0) {
		if ((local_f8.ddpfPixelFormat.dwRGBBitCount == 8) &&
			 (HVar6 = (*target->lpVtbl->Lock)(target,NULL,&local_7c,1,NULL), HVar6 == 0)) {
			if ((local_7c.ddpfPixelFormat.dwRGBBitCount == 0x10) &&
				 ((local_7c.dwWidth == local_f8.dwWidth && (local_7c.dwHeight == local_f8.dwHeight)))) {
				iVar7 = 0;
				cVar8 = '\0';
				do {
					if ((local_7c.ddpfPixelFormat.dwRBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						cVar8 += '\x01';
					}
					iVar7 += 1;
				} while (iVar7 < 0x20);
				iVar7 = 0;
				cVar11 = '\0';
				do {
					if ((local_7c.ddpfPixelFormat.dwGBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						cVar11 += '\x01';
					}
					iVar7 += 1;
				} while (iVar7 < 0x20);
				iVar7 = 0;
				bVar12 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwBBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						bVar12 += 1;
					}
					iVar7 += 1;
				} while (iVar7 < 0x20);
				uStack296 = 0;
				if (local_f8.dwHeight != 0) {
					do {
						uVar10 = 0;
						if (local_f8.dwWidth != 0) {
							bStack256 = 8 - cVar8;
							bStack252 = 8 - cVar11;
							uStack272._0_1_ = 8 - bVar12;
							do {
								iStack288 = 0x18;
								uVar1 = *(uint *)(uStack296 * local_f8.lPitch + uVar10 + (int)local_f8.lpSurface);
								uVar9 = 3;
								bVar5 = true;
								do {
									uVar2 = uVar1 >> ((byte)iStack288 & 0x1f) & 0xff;
									uVar3 = (uint)(palette[uVar2].red >> (bStack256 & 0x1f));
									uVar4 = (uint)(palette[uVar2].green >> (bStack252 & 0x1f));
									uVar2 = (uint)(palette[uVar2].blue >> ((byte)uStack272 & 0x1f));
									if (bVar5) {
										uStack272 = (uVar3 << (bVar12 + cVar11 & 0x1f) | uVar4 << (bVar12 & 0x1f) |
																uVar2) << 0x10;
									}
									else {
										uStack272 |= uVar3 << (cVar11 + bVar12 & 0x1f) | uVar4 << (bVar12 & 0x1f) |
																 uVar2;
										*(uint *)((int)local_7c.lpSurface +
														 (uVar10 + (uVar9 >> 1 & 1) * 2) * 2 + uStack296 * local_7c.lPitch) =
												 uStack272;
									}
									uVar9 -= 1;
									bVar5 = (bool)(bVar5 ^ 1);
									iStack288 += -8;
								} while (-1 < iStack288);
								uVar10 += 4;
							} while (uVar10 < local_f8.dwWidth);
						}
						uStack296 += 1;
					} while (uStack296 < local_f8.dwHeight);
				}
			}
			(*target->lpVtbl->Unlock)(target,NULL);
		}
		(*source->lpVtbl->Unlock)(source,NULL);
	}
	return;
}



uint __cdecl lego::ddraw::DirectDraw_GetColour(IDirectDrawSurface4 *surf,uint colour)
{
	IDirectDrawSurface4Vtbl *pIVar1;
	byte bVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	byte *pbVar8;
	uint unaff_EBP;
	int *unaff_ESI;
	DDPIXELFORMAT *pDVar9;
	IDirectDrawPalette *ddPal;
	DDPIXELFORMAT pixFmt;
	D3DRMPaletteEntry palEntries [256];
	
	uVar6 = colour >> 8 & 0xff;
	pIVar1 = surf->lpVtbl;
	pDVar9 = &pixFmt;
	for (iVar7 = 8; iVar7 != 0; iVar7 += -1) {
		pDVar9->dwSize = 0;
		pDVar9 = (DDPIXELFORMAT *)&pDVar9->dwFlags;
	}
	pixFmt.dwSize = 0x20;
	(*pIVar1->GetPixelFormat)(surf,&pixFmt);
	if (((byte)ddPal & 0x40) == 0) {
		(*surf->lpVtbl->GetPalette)(surf,(IDirectDrawPalette **)&stack0xfffffbd4);
		(**(code **)(*unaff_ESI + 0x10))(unaff_ESI,0,0,0x100);
		uVar3 = 0;
		pbVar8 = (byte *)((int)&ddPal + 1);
		while ((((DWORD *)(uint)pbVar8[-1] != &pixFmt.dwRBitMask || (*pbVar8 != uVar6)) ||
					 ((uint)pbVar8[1] != (colour & 0xff)))) {
			uVar3 += 1;
			pbVar8 = pbVar8 + 4;
			if (0xff < uVar3) {
				return 0;
			}
		}
		return uVar3;
	}
	uVar3 = DirectDraw_GetNumberOfBits(pixFmt.dwFourCC);
	uVar4 = DirectDraw_GetNumberOfBits(pixFmt.dwRGBBitCount);
	uVar5 = DirectDraw_GetNumberOfBits(pixFmt.dwRBitMask);
	bVar2 = (byte)uVar5;
	return (unaff_EBP >> (8U - (char)uVar3 & 0x1f)) << (bVar2 + (char)uVar4 & 0x1f) |
				 (uVar6 >> (8U - (char)uVar4 & 0x1f)) << (bVar2 & 0x1f) |
				 (colour & 0xff) >> (8 - bVar2 & 0x1f);
}



uint __cdecl lego::ddraw::DirectDraw_GetNumberOfBits(uint mask)
{
	uint uVar1;
	
	uVar1 = 0;
	if (mask != 0) {
		do {
			mask &= mask - 1;
			uVar1 += 1;
		} while (mask != 0);
	}
	return uVar1;
}



void __cdecl lego::image::Image_Initialise(void)
{
	int iVar1;
	Image_Globs *pIVar2;
	
	pIVar2 = &globs::imageGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		pIVar2->listSet[0] = NULL;
		pIVar2 = (Image_Globs *)(pIVar2->listSet + 1);
	}
	globs::imageGlobs.flags = 1;
	return;
}



void __cdecl lego::image::Image_Shutdown(void)
{
	Image_Globs *pIVar1;
	
	Image_RemoveAll();
	pIVar1 = &globs::imageGlobs;
	do {
		if (pIVar1->listSet[0] != NULL) {
			std::free(pIVar1->listSet[0]);
		}
		pIVar1 = (Image_Globs *)(pIVar1->listSet + 1);
	} while (pIVar1 < (Image_Globs *)&globs::imageGlobs.freeList);
	globs::imageGlobs.freeList = NULL;
	globs::imageGlobs.flags = 0;
	return;
}



void __cdecl lego::image::Image_Remove(Image *image)
{
	(*image->surface->lpVtbl->Release)((IUnknown *)image->surface);
	image->nextFree = globs::imageGlobs.freeList;
	globs::imageGlobs.freeList = image;
	return;
}



BOOL __cdecl lego::image::Image_CopyToDataToSurface(IDirectDrawSurface4 *surface,D3DRMImage *image)
{
	HRESULT HVar1;
	int iVar2;
	DWORD *pDVar3;
	DDSURFACEDESC2 local_7c;
	
	pDVar3 = &local_7c.dwFlags;
	for (iVar2 = 0x1e; iVar2 != 0; iVar2 += -1) {
		*pDVar3 = 0;
		pDVar3 = pDVar3 + 1;
	}
						// IDirectDrawSurface4::Lock(IDirectDrawSurface4* This, RECT* a, DDSURFACEDESC2* b,
						// DWORD c, HANDLE d)
						// DDLOCK_WRITEONLY | DDLOCK_WAIT (0x20 | 0x1)
	local_7c.dwSize = 0x7c;
	HVar1 = (*surface->lpVtbl->Lock)(surface,NULL,&local_7c,0x21,NULL);
	if (HVar1 == 0) {
		iVar2 = image->depth;
		if (7 < iVar2) {
			if (iVar2 == 8) {
				Image_8BitSourceCopy(&local_7c,image);
			}
			else {
				if ((iVar2 != 0x10) && (iVar2 == 0x18)) {
					Image_24BitSourceCopy(&local_7c,image);
				}
			}
		}
						// IDirectDrawSurface4::Unock(IDirectDrawSurface4* This, RECT* a)
		(*surface->lpVtbl->Unlock)(surface,NULL);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::image::Image_8BitSourceCopy(DDSURFACEDESC2 *desc,D3DRMImage *image)
{
	DWORD DVar1;
	int iVar2;
	D3DRMPaletteEntry *pDVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	int iVar14;
	undefined2 *puVar15;
	undefined2 *puVar16;
	byte *pbVar17;
	int local_30;
	byte local_2c;
	byte local_18;
	byte local_10;
	
	DVar1 = (desc->ddpfPixelFormat).dwRGBBitCount;
	if (DVar1 == 8) {
		return 0;
	}
	if (DVar1 == 0x10) {
		uVar9 = (desc->ddpfPixelFormat).dwGBitMask;
		puVar16 = (undefined2 *)desc->lpSurface;
		iVar2 = image->bytes_per_line;
		pDVar3 = image->palette;
		uVar4 = desc->lPitch;
		pbVar17 = image->buffer1;
		uVar10 = (desc->ddpfPixelFormat).dwBBitMask;
		uVar8 = (desc->ddpfPixelFormat).dwRBitMask;
		uVar5 = Image_CountMaskBits(uVar8);
		uVar6 = Image_CountMaskBits(uVar9);
		uVar7 = Image_CountMaskBits(uVar10);
		uVar8 = Image_CountMaskBitShift(uVar8);
		uVar9 = Image_CountMaskBitShift(uVar9);
		uVar10 = Image_CountMaskBitShift(uVar10);
		local_30 = 0;
		if (0 < image->height) {
			do {
				iVar14 = 0;
				if (0 < image->width) {
					local_2c = 8 - (char)uVar7;
					local_10 = 8 - (char)uVar6;
					uVar11 = 8 - uVar5;
					uVar13 = uVar7;
					puVar15 = puVar16;
					do {
						uVar12 = (uint)*pbVar17;
						pbVar17 = pbVar17 + 1;
						puVar16 = puVar15 + 1;
						local_18 = (byte)(8 - uVar5);
						uVar13 = (uVar13 & 0xffff0000 | (uint)(pDVar3[uVar12].blue >> (local_2c & 0x1f))) <<
										 ((byte)uVar10 & 0x1f) |
										 ((uint)pDVar3 & 0xffff0000 | (uint)(pDVar3[uVar12].red >> (local_18 & 0x1f)))
										 << ((byte)uVar8 & 0x1f) |
										 (uVar11 & 0xffff0000 | (uint)(pDVar3[uVar12].green >> (local_10 & 0x1f))) <<
										 ((byte)uVar9 & 0x1f);
						iVar14 += 1;
						*puVar15 = (short)uVar13;
						uVar11 = image->width;
						puVar15 = puVar16;
					} while (iVar14 < (int)uVar11);
				}
				pbVar17 = pbVar17 + (iVar2 - image->width);
				puVar16 = puVar16 + ((uVar4 >> 1) - image->width);
				local_30 += 1;
			} while (local_30 < image->height);
		}
		Image_FlipSurface(desc);
		return 1;
	}
	if (DVar1 == 0x18) {
		return 0;
	}
	if (DVar1 != 0x20) {
		return 1;
	}
	return 0;
}



uint __cdecl lego::image::Image_CountMaskBits(uint mask)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = 0;
	uVar2 = 0;
	do {
		if ((mask & 1 << ((byte)uVar2 & 0x1f)) != 0) {
			uVar1 += 1;
		}
		uVar2 += 1;
	} while (uVar2 < 0x20);
	return uVar1;
}



uint __cdecl lego::image::Image_CountMaskBitShift(uint mask)
{
	uint uVar1;
	
	uVar1 = 0;
	do {
		if ((mask & 1 << ((byte)uVar1 & 0x1f)) != 0) {
			return uVar1;
		}
		uVar1 += 1;
	} while (uVar1 < 0x20);
	return 0xffffffff;
}



void __cdecl lego::image::Image_FlipSurface(DDSURFACEDESC2 *desc)
{
	uint size;
	int iVar1;
	undefined4 *buffer;
	uint uVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	undefined4 *puVar5;
	undefined4 *local_8;
	uint local_4;
	
	puVar3 = (undefined4 *)desc->lpSurface;
	iVar1 = (int)desc->lPitch / 2;
	size = iVar1 * 2;
	local_8 = (undefined4 *)((int)puVar3 + (desc->dwHeight - 1) * iVar1 * 2);
	buffer = (undefined4 *)std::malloc(size);
	local_4 = 0;
	if ((desc->dwHeight & 0xfffffffe) != 0) {
		do {
			puVar4 = puVar3;
			puVar5 = buffer;
			for (uVar2 = size >> 2; uVar2 != 0; uVar2 -= 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = size & 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			puVar4 = local_8;
			puVar5 = puVar3;
			for (uVar2 = size >> 2; uVar2 != 0; uVar2 -= 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = size & 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			puVar4 = buffer;
			puVar5 = local_8;
			for (uVar2 = size >> 2; uVar2 != 0; uVar2 -= 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = size & 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			local_4 += 1;
			puVar3 = (undefined4 *)((int)puVar3 + size);
			local_8 = (undefined4 *)((int)local_8 + iVar1 * -2);
		} while (local_4 < desc->dwHeight >> 1);
	}
	std::free(buffer);
	return;
}



BOOL __cdecl lego::image::Image_24BitSourceCopy(DDSURFACEDESC2 *desc,D3DRMImage *image)
{
	byte *pbVar1;
	byte *pbVar2;
	byte bVar3;
	DWORD DVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	uint uVar14;
	D3DRMImage *pDVar15;
	int iVar16;
	byte *pbVar17;
	undefined2 *puVar18;
	undefined2 *puVar19;
	int local_2c;
	byte local_18;
	byte local_10;
	
	DVar4 = (desc->ddpfPixelFormat).dwRGBBitCount;
	if (DVar4 == 8) {
		return 0;
	}
	if (DVar4 == 0x10) {
		uVar11 = (desc->ddpfPixelFormat).dwGBitMask;
		uVar12 = (desc->ddpfPixelFormat).dwBBitMask;
		puVar19 = (undefined2 *)desc->lpSurface;
		iVar5 = image->bytes_per_line;
		pbVar17 = image->buffer1;
		uVar6 = desc->lPitch;
		uVar10 = (desc->ddpfPixelFormat).dwRBitMask;
		uVar7 = Image_CountMaskBits(uVar10);
		uVar8 = Image_CountMaskBits(uVar11);
		uVar9 = Image_CountMaskBits(uVar12);
		uVar10 = Image_CountMaskBitShift(uVar10);
		uVar11 = Image_CountMaskBitShift(uVar11);
		uVar12 = Image_CountMaskBitShift(uVar12);
		local_2c = 0;
		if (0 < image->height) {
			do {
				iVar16 = 0;
				if (0 < image->width) {
					local_10 = 8 - (char)uVar7;
					local_18 = 8 - (char)uVar9;
					uVar13 = uVar8;
					uVar14 = uVar7;
					pDVar15 = image;
					puVar18 = puVar19;
					do {
						bVar3 = *pbVar17;
						pbVar1 = pbVar17 + 1;
						puVar19 = puVar18 + 1;
						pbVar2 = pbVar17 + 2;
						pbVar17 = pbVar17 + 3;
						uVar14 = (uVar14 & 0xffff0000 | (uint)(bVar3 >> (local_18 & 0x1f))) <<
										 ((byte)uVar12 & 0x1f);
						pDVar15 = (D3DRMImage *)
											(((uint)pDVar15 & 0xffff0000 | (uint)(*pbVar1 >> (8U - (char)uVar8 & 0x1f)))
											 << ((byte)uVar11 & 0x1f) | uVar14 |
											(uVar13 & 0xffff0000 | (uint)(*pbVar2 >> (local_10 & 0x1f))) <<
											((byte)uVar10 & 0x1f));
						iVar16 += 1;
						*puVar18 = (short)pDVar15;
						uVar13 = image->width;
						puVar18 = puVar19;
					} while (iVar16 < (int)uVar13);
				}
				pbVar17 = pbVar17 + iVar5 + image->width * -3;
				local_2c += 1;
				puVar19 = puVar19 + ((uVar6 >> 1) - image->width);
			} while (local_2c < image->height);
		}
		Image_FlipSurface(desc);
		return 1;
	}
	if (DVar4 == 0x18) {
		return 0;
	}
	if (DVar4 != 0x20) {
		return 1;
	}
	return 0;
}



Image * __cdecl lego::image::Image_LoadBMPScaled(char *fileName,uint width,uint height)
{
	COLORREF pen255;
	BITMAP_FILE_INFO_STRUCT *data;
	HRESULT HVar1;
	BOOL BVar2;
	Image *pIVar3;
	int iVar4;
	uint unaff_EBX;
	COLORREF unaff_ESI;
	IDirectDrawSurface4 *unaff_EDI;
	int *piVar5;
	DWORD *pDVar6;
	DDSURFACEDESC2 *pDVar7;
	IDirectDrawSurface4 *local_4c4;
	COLORREF local_4c0;
	uint length;
	D3DRMImage local_4b8;
	DDSURFACEDESC2 surfaceDesc;
	char local_400 [1024];
	
	local_4b8.width = 0;
	piVar5 = &local_4b8.height;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 += -1) {
		*piVar5 = 0;
		piVar5 = piVar5 + 1;
	}
	surfaceDesc.dwSize = 0;
	pDVar6 = &surfaceDesc.dwFlags;
	for (iVar4 = 0x1e; iVar4 != 0; iVar4 += -1) {
		*pDVar6 = 0;
		pDVar6 = pDVar6 + 1;
	}
	length = 0;
	local_4c4 = NULL;
	pen255 = Image_RGB2CR(0,0,0);
	local_4c0 = pen255;
	data = (BITMAP_FILE_INFO_STRUCT *)lego::file::File_LoadBinary(fileName,&length);
	if (data != NULL) {
		BMP_Parse(data,length,&local_4b8);
		if (local_4b8.rgb == 0) {
			local_4c0 = Image_RGB2CR((local_4b8.palette)->red,(local_4b8.palette)->green,
															 (local_4b8.palette)->blue);
			if (local_4b8.rgb == 0) {
				pen255 = Image_RGB2CR(local_4b8.palette[0xff].red,local_4b8.palette[0xff].green,
															local_4b8.palette[0xff].blue);
			}
		}
		std::sprintf(local_400,"Data\\%s",fileName);
		pDVar7 = &surfaceDesc;
		for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
			pDVar7->dwSize = 0;
			pDVar7 = (DDSURFACEDESC2 *)&pDVar7->dwFlags;
		}
		surfaceDesc.dwWidth = local_4b8.width;
		surfaceDesc.dwHeight = local_4b8.height;
		surfaceDesc.dwSize = 0x7c;
		surfaceDesc.dwFlags = 7;
		surfaceDesc.ddsCaps.dwCaps = 0x840;
						// IDirectDraw4::CreateSurface(IDirectDraw4* This, DDSURFACEDESC2* lpDDSurfaceDesc,
						// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
		HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
											(globs::directDrawGlobs.lpDirectDraw,&surfaceDesc,&local_4c4,NULL);
		if (HVar1 == 0) {
			BVar2 = Image_CopyToDataToSurface(unaff_EDI,(D3DRMImage *)&stack0xfffffb38);
			if (BVar2 != 0) {
				pIVar3 = Image_Create(unaff_EDI,unaff_EBX,(uint)local_4c4,unaff_ESI,pen255);
				if (pIVar3 != NULL) {
					BMP_Cleanup((D3DRMImage *)&stack0xfffffb38);
					std::free(data);
					return pIVar3;
				}
			}
		}
		if (unaff_EDI != NULL) {
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
		}
		BMP_Cleanup((D3DRMImage *)&stack0xfffffb38);
		std::free(data);
	}
	return NULL;
}



COLORREF __cdecl lego::image::Image_RGB2CR(byte red,byte green,byte blue)
{
	_red = (uint)CONCAT12(blue,CONCAT11(green,red));
	return _red;
}



void __cdecl lego::image::Image_SetPenZeroTrans(Image *image)
{
	DDCOLORKEY colorKey;
	
	colorKey.dwColorSpaceLowValue = image->penZero;
	colorKey.dwColorSpaceHighValue = colorKey.dwColorSpaceLowValue;
	(*image->surface->lpVtbl->SetColorKey)(image->surface,8,&colorKey);
	image->flags = image->flags | IMAGE_FLAG_TRANS;
	return;
}



void __cdecl
lego::image::Image_SetupTrans
					(Image *image,float red_low,float green_low,float blue_low,float red_high,float green_high
					,float blue_high)
{
	byte bVar1;
	COLORREF rgb;
	COLORREF rgb_00;
	longlong lVar2;
	byte bVar3;
	DDCOLORKEY colorKey;
	
	lVar2 = __ftol((float10)blue_low * (float10)255.0);
	bVar3 = (byte)lVar2;
	lVar2 = __ftol((float10)green_low * (float10)255.0);
	bVar1 = (byte)lVar2;
	lVar2 = __ftol((float10)red_low * (float10)255.0);
	rgb = Image_RGB2CR((byte)lVar2,bVar1,bVar3);
	lVar2 = __ftol((float10)blue_high * (float10)255.0);
	bVar3 = (byte)lVar2;
	lVar2 = __ftol((float10)green_high * (float10)255.0);
	bVar1 = (byte)lVar2;
	lVar2 = __ftol((float10)red_high * (float10)255.0);
	rgb_00 = Image_RGB2CR((byte)lVar2,bVar1,bVar3);
	colorKey.dwColorSpaceLowValue = Image_DDColorMatch(image->surface,rgb);
	colorKey.dwColorSpaceHighValue = Image_DDColorMatch(image->surface,rgb_00);
						// IDirectDrawSurface4::SetColorKey(DWORD a, LPDDCOLORKEY b)
	(*image->surface->lpVtbl->SetColorKey)(image->surface,8,&colorKey);
	image->flags = image->flags | IMAGE_FLAG_TRANS;
	return;
}



// Image_Blt

void __cdecl
lego::image::Image_DisplayScaled(Image *image,Area2F *src,Point2F *destPos,Size2F *destSize)
{
	float fVar1;
	float10 fVar2;
	longlong lVar3;
	DWORD DVar4;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (src != NULL) {
		fVar2 = std::floor((double)src->x);
		lVar3 = __ftol(fVar2);
		local_10 = (undefined4)lVar3;
		fVar2 = std::floor((double)src->y);
		lVar3 = __ftol(fVar2);
		local_c = (undefined4)lVar3;
		fVar2 = std::floor((double)(src->width + src->x));
		lVar3 = __ftol(fVar2);
		local_8 = (undefined4)lVar3;
		fVar2 = std::floor((double)(src->height + src->y));
		lVar3 = __ftol(fVar2);
		local_4 = (undefined4)lVar3;
	}
	if (destPos != NULL) {
		fVar2 = std::floor((double)destPos->x);
		lVar3 = __ftol(fVar2);
		local_20 = (undefined4)lVar3;
		fVar2 = std::floor((double)destPos->y);
		lVar3 = __ftol(fVar2);
		local_1c = (undefined4)lVar3;
		if (destSize == NULL) {
			if (src == NULL) {
				fVar2 = std::floor((double)((float)(ulonglong)image->width + destPos->x));
				lVar3 = __ftol(fVar2);
				local_18 = (undefined4)lVar3;
				fVar1 = (float)(ulonglong)image->height;
			}
			else {
				fVar2 = std::floor((double)(src->width + destPos->x));
				lVar3 = __ftol(fVar2);
				local_18 = (undefined4)lVar3;
				fVar1 = src->height;
			}
		}
		else {
			fVar2 = std::floor((double)(destSize->width + destPos->x));
			lVar3 = __ftol(fVar2);
			local_18 = (undefined4)lVar3;
			fVar1 = destSize->height;
		}
		fVar2 = std::floor((double)(fVar1 + destPos->y));
		lVar3 = __ftol(fVar2);
		local_14 = (undefined4)lVar3;
	}
	if ((*(byte *)&image->flags & 2) == 0) {
		DVar4 = 0x1000000;
	}
	else {
		DVar4 = 0x1008000;
	}
	(*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
						(globs::directDrawGlobs.bSurf,(LPRECT)(-(uint)(destPos != NULL) & (uint)&local_20),
						 image->surface,(LPRECT)(-(uint)(src != NULL) & (uint)&local_10),DVar4,NULL);
	return;
}



void * __cdecl lego::image::Image_LockSurface(Image *image,uint *out_pitch,uint *out_bpp)
{
	DDSURFACEDESC2 *pDVar1;
	HRESULT HVar2;
	int iVar3;
	DDSURFACEDESC2 s;
	
	pDVar1 = &s;
	for (iVar3 = 0x1f; iVar3 != 0; iVar3 += -1) {
		pDVar1->dwSize = 0;
		pDVar1 = (DDSURFACEDESC2 *)((int)pDVar1 + 4);
	}
	s.dwSize = 0x7c;
	HVar2 = (*image->surface->lpVtbl->Lock)(image->surface,NULL,&s,1,NULL);
	if (HVar2 == 0) {
		*out_pitch = s.lPitch;
		*out_bpp = s.ddpfPixelFormat.dwRGBBitCount;
		return s.lpSurface;
	}
	return NULL;
}



void __cdecl lego::image::Image_UnlockSurface(Image *image)
{
	(*image->surface->lpVtbl->Unlock)(image->surface,NULL);
	return;
}



// WARNING: Could not reconcile some variable overlaps

uint __cdecl lego::image::Image_GetPen255(Image *image)
{
	int iVar1;
	DDPIXELFORMAT *pDVar2;
	uint local_24;
	DDPIXELFORMAT pixelFmt;
	
	pDVar2 = &pixelFmt;
	for (iVar1 = 8; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDPIXELFORMAT *)&pDVar2->dwFlags;
	}
	pixelFmt.dwSize = 0x20;
	local_24 = (*image->surface->lpVtbl->GetPixelFormat)(image->surface,&pixelFmt);
	if (local_24 == 0) {
		local_24 = CONCAT13(*(undefined *)&image->pen255,
												CONCAT12(*(undefined *)((int)&image->pen255 + 1),
																 CONCAT11(*(undefined *)((int)&image->pen255 + 2),
																					*(undefined *)((int)&image->pen255 + 3))));
	}
	return local_24;
}



uint __cdecl lego::image::Image_GetPixelMask(Image *image)
{
	DDPIXELFORMAT *pDVar1;
	HRESULT HVar2;
	int iVar3;
	DDPIXELFORMAT pixelFmt;
	
	pDVar1 = &pixelFmt;
	for (iVar3 = 8; iVar3 != 0; iVar3 += -1) {
		pDVar1->dwSize = 0;
		pDVar1 = (DDPIXELFORMAT *)((int)pDVar1 + 4);
	}
	pixelFmt.dwSize = 0x20;
	HVar2 = (*image->surface->lpVtbl->GetPixelFormat)(image->surface,&pixelFmt);
	if (HVar2 == 0) {
		return -1 << (0x20U - (char)pixelFmt.dwRGBBitCount & 0x1f);
	}
	return 0;
}



BOOL __cdecl lego::image::Image_GetPixel(Image *image,uint x,uint y,uint *out_colour)
{
	HRESULT HVar1;
	int iVar2;
	DDSURFACEDESC2 *pDVar3;
	DDSURFACEDESC2 local_7c;
	
	pDVar3 = &local_7c;
	for (iVar2 = 0x1f; iVar2 != 0; iVar2 += -1) {
		pDVar3->dwSize = 0;
		pDVar3 = (DDSURFACEDESC2 *)&pDVar3->dwFlags;
	}
	local_7c.dwSize = 0x7c;
	if ((x < image->width) && (y < image->height)) {
		HVar1 = (*image->surface->lpVtbl->Lock)(image->surface,NULL,&local_7c,0x11,NULL);
		if (HVar1 == 0) {
			*out_colour = *(uint *)((int)local_7c.lpSurface +
														 (local_7c.ddpfPixelFormat.dwRGBBitCount >> 3) * x + local_7c.lPitch * y
														 ) >> (0x20U - (char)local_7c.ddpfPixelFormat.dwRGBBitCount & 0x1f);
			(*image->surface->lpVtbl->Unlock)(image->surface,NULL);
			return TRUE;
		}
	}
	return 0;
}



Image * __cdecl
lego::image::Image_Create
					(IDirectDrawSurface4 *surface,uint width,uint height,COLORREF penZero,COLORREF pen255)
{
	Image *pIVar1;
	Image *pIVar2;
	DWORD DVar3;
	
	if (globs::imageGlobs.freeList == NULL) {
		Image_AddList();
	}
	pIVar1 = globs::imageGlobs.freeList;
	pIVar2 = (globs::imageGlobs.freeList)->nextFree;
	(globs::imageGlobs.freeList)->nextFree = globs::imageGlobs.freeList;
	globs::imageGlobs.freeList = pIVar2;
	pIVar1->flags = IMAGE_FLAG_NONE;
	pIVar1->width = width;
	pIVar1->height = height;
	pIVar1->surface = surface;
	pIVar1->penZeroRGB = penZero;
	DVar3 = Image_DDColorMatch(surface,penZero);
	pIVar1->penZero = DVar3;
	DVar3 = Image_DDColorMatch(surface,pen255);
	pIVar1->pen255 = DVar3;
	return pIVar1;
}



void __cdecl lego::image::Image_AddList(void)
{
	Image *pIVar1;
	Image *pIVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::imageGlobs.listCount & 0x1f);
	pIVar2 = (Image *)std::malloc(uVar4 * 0x20);
	globs::imageGlobs.listSet[globs::imageGlobs.listCount] = pIVar2;
	pIVar2 = globs::imageGlobs.listSet[globs::imageGlobs.listCount];
	if (pIVar2 != NULL) {
		globs::imageGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pIVar1 = pIVar2;
			do {
				pIVar1->nextFree = pIVar1 + 1;
				iVar3 += -1;
				pIVar1 = pIVar1 + 1;
			} while (iVar3 != 0);
		}
		pIVar2[uVar4 - 1].nextFree = globs::imageGlobs.freeList;
		globs::imageGlobs.freeList = pIVar2;
	}
	return;
}



void __cdecl lego::image::Image_RemoveAll(void)
{
	int iVar1;
	Image *image;
	Image_Globs *pIVar2;
	uint uVar3;
	int iVar4;
	
	uVar3 = 0;
	if (globs::imageGlobs.listCount != 0) {
		pIVar2 = &globs::imageGlobs;
		do {
			if ((pIVar2->listSet[0] != NULL) && (iVar1 = 1 << ((byte)uVar3 & 0x1f), iVar1 != 0)) {
				iVar4 = 0;
				do {
					image = (Image *)((int)&pIVar2->listSet[0]->surface + iVar4);
					if ((image != NULL) && (image->nextFree == image)) {
						Image_Remove(image);
					}
					iVar4 += 0x20;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			uVar3 += 1;
			pIVar2 = (Image_Globs *)(pIVar2->listSet + 1);
		} while (uVar3 < globs::imageGlobs.listCount);
	}
	return;
}



DWORD __cdecl lego::image::Image_DDColorMatch(IDirectDrawSurface4 *pdds,DWORD rgb)
{
	byte bVar1;
	HRESULT HVar2;
	uint uVar3;
	uint uVar4;
	int iVar6;
	uint unaff_ESI;
	DWORD DVar7;
	DWORD *pDVar8;
	DDSURFACEDESC2 *lpDDSurfaceDesc;
	char cVar9;
	char cVar10;
	byte out_red;
	byte out_blue;
	byte out_green;
	DDSURFACEDESC2 s;
	uint uVar5;
	
	pDVar8 = &s.dwFlags;
	for (iVar6 = 0x1e; iVar6 != 0; iVar6 += -1) {
		*pDVar8 = 0;
		pDVar8 = pDVar8 + 1;
	}
	DVar7 = 0;
	s.dwSize = 0x7c;
	Image_CR2RGB(rgb,&out_red,&out_green,&out_blue);
	lpDDSurfaceDesc = &s;
	HVar2 = (*pdds->lpVtbl->Lock)(pdds,NULL,lpDDSurfaceDesc,1,NULL);
	if (HVar2 == 0) {
		uVar3 = Image_CountMaskBits(s.ddckCKSrcBlt.dwColorSpaceHighValue);
		uVar4 = Image_CountMaskBits(s.ddpfPixelFormat.dwSize);
		cVar9 = (char)uVar4;
		uVar4 = Image_CountMaskBits(s.ddpfPixelFormat.dwFlags);
		cVar10 = (char)uVar4;
		uVar4 = Image_CountMaskBitShift(s.ddckCKSrcBlt.dwColorSpaceHighValue);
		uVar5 = Image_CountMaskBitShift(s.ddpfPixelFormat.dwSize);
		bVar1 = (byte)uVar5;
		uVar5 = Image_CountMaskBitShift(s.ddpfPixelFormat.dwFlags);
		DVar7 = ((_out_red & 0xff) >> (8U - cVar9 & 0x1f)) << (bVar1 & 0x1f) |
						(((uint)lpDDSurfaceDesc & 0xff) >> (8U - (char)uVar3 & 0x1f)) << ((byte)uVar4 & 0x1f) |
						((unaff_ESI & 0xff) >> (8U - cVar10 & 0x1f)) << ((byte)uVar5 & 0x1f);
		if (s.ddckCKSrcBlt.dwColorSpaceLowValue < 0x20) {
			DVar7 &= (1 << ((byte)s.ddckCKSrcBlt.dwColorSpaceLowValue & 0x1f)) - 1U;
		}
		(**(code **)(*(int *)s.ddsCaps.dwCaps2 + 0x80))(s.ddsCaps.dwCaps2,0);
	}
	return DVar7;
}



void __cdecl lego::image::Image_CR2RGB(COLORREF cr,byte *out_r,byte *out_g,byte *out_b)
{
	if (out_r != NULL) {
		*out_r = (byte)cr;
	}
	if (out_g != NULL) {
		*out_g = (byte)(cr >> 8);
	}
	if (out_b != NULL) {
		*out_b = cr._2_1_;
	}
	return;
}



void __cdecl lego::image::Image_GetScreenshot(Image *ref_image,uint xsize,uint ysize)
{
	HRESULT err;
	int iVar1;
	DDSURFACEDESC2 *pDVar2;
	IDirectDrawSurface4 *ddSurface4;
	RECT dstRect;
	DDSURFACEDESC2 surfDesc;
	
	pDVar2 = &surfDesc;
	for (iVar1 = 0x1f; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDSURFACEDESC2 *)&pDVar2->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	surfDesc.dwWidth = xsize;
	surfDesc.dwHeight = ysize;
	surfDesc.ddsCaps.dwCaps = 0x840;
	surfDesc.dwFlags = 7;
	err = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
									(globs::directDrawGlobs.lpDirectDraw,&surfDesc,&ddSurface4,NULL);
	if (err != 0) {
		debug::Error_SetDXError(err,3,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Images.c",1140);
		return;
	}
	dstRect.left = 0;
	dstRect.top = 0;
	dstRect.right = xsize;
	dstRect.bottom = ysize;
	(*ddSurface4->lpVtbl->Blt)(ddSurface4,&dstRect,globs::directDrawGlobs.bSurf,NULL,0,NULL);
	Image_InitFromSurface(ref_image,ddSurface4,xsize,ysize,0,0);
	return;
}



void __cdecl
lego::image::Image_InitFromSurface
					(Image *ref_newImage,IDirectDrawSurface4 *surface,uint width,uint height,COLORREF penZero,
					COLORREF pen255)
{
	DWORD DVar1;
	
	if (globs::imageGlobs.freeList == NULL) {
		Image_AddList();
	}
	ref_newImage->width = width;
	ref_newImage->nextFree = ref_newImage;
	ref_newImage->flags = IMAGE_FLAG_NONE;
	ref_newImage->height = height;
	ref_newImage->surface = surface;
	ref_newImage->penZeroRGB = penZero;
	DVar1 = Image_DDColorMatch(surface,penZero);
	ref_newImage->penZero = DVar1;
	DVar1 = Image_DDColorMatch(surface,pen255);
	ref_newImage->pen255 = DVar1;
	return;
}



BOOL __cdecl lego::image::Image_SaveBMP(Image *image,char *fname)
{
	BOOL BVar1;
	
	BVar1 = ddraw::DirectDraw_SaveBMP(image->surface,fname);
	return BVar1;
}



G98CSurface * __thiscall lego::video::G98CSurface___deletor(void *this,G98CSurface *This,byte flag)
{
	G98CSurface___dtor((G98CSurface *)this);
	if (((uint)This & 1) != 0) {
						// Function shared between multiple uses that just calls std::free(void* ptr)
		game::RadarMap_Free_UnwindMultiUse((RadarMap *)this);
	}
	return (G98CSurface *)this;
}



void __thiscall lego::video::G98CSurface___dtor(G98CSurface *this)
{
	IDirectDrawSurface4 *ddSurface4;
	IDirectDrawPalette *This;
	
	this->vftable = &G98CSurface___vftable;
	ddSurface4 = this->m_surf;
	if (ddSurface4 != NULL) {
		(*ddSurface4->lpVtbl->Release)(ddSurface4);
		this->m_surf = NULL;
	}
	This = this->m_palette;
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
		this->m_palette = NULL;
	}
	return;
}



G98CSurface * __thiscall
lego::video::G98CSurface___ctor
					(G98CSurface *this,int width,int height,int bpp,bool vram,bool fullScreen)
{
	bool bVar1;
	
	this->m_clipper = NULL;
	this->m_squashToEdge = false;
	this->m_15bit = false;
	this->m_surf = NULL;
	this->m_surfaceInited = false;
	this->vftable = &G98CSurface___vftable;
	G98CSurface__PreInit(this,fullScreen);
	bVar1 = G98CSurface__Init(this,width,height,bpp,vram);
	if (bVar1 != false) {
		this->m_surfaceInited = true;
	}
	return this;
}



bool __thiscall
lego::video::G98CSurface__Init(G98CSurface *this,int width,int height,int bpp,bool vram)
{
	IDirectDrawSurface4 *This;
	HRESULT HVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	DWORD DVar5;
	int iVar6;
	uint uVar7;
	D3DRMPaletteEntry palette [256];
	
						// (dwFlags should initially be 0)
						// dwFlags = DDSD_CAPS (0x1)
						// if (width  != 0) dwFlags |= DDSD_WIDTH (0x4)
						// if (height != 0) dwFlags |= DDSD_HEIGHT (0x2)
	uVar7 = (this->m_desc).dwFlags | -(uint)(height != 0) & 2 | -(uint)(width != 0) & 4 | 1;
	(this->m_desc).dwFlags = uVar7;
	this->m_bpp = bpp;
	if (width != 0) {
		(this->m_desc).dwWidth = width;
	}
	if (height != 0) {
		(this->m_desc).dwHeight = height;
	}
	if ((width == 0) && (height == 0)) {
						// DDSCAPS_PRIMARYSURFACE (0x200)
		(this->m_desc).ddsCaps.dwCaps = 0x200;
	}
	else {
						// DDSCAPS_OFFSCREENPLAIN (0x40)
		(this->m_desc).ddsCaps.dwCaps = 0x40;
						// if (useVideoMemory)
						//   DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN (0x4000 | 0x40)
						// else
						//   DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN (0x800 | 0x40)
		(this->m_desc).ddsCaps.dwCaps = (-(uint)(vram != false) & 0x3800) + 0x840;
	}
	if (bpp != 0) {
						// DDSD_PIXELFORMAT (0x1000)
		(this->m_desc).dwFlags = uVar7 | 0x1000;
		(this->m_desc).ddpfPixelFormat.dwSize = 0x20;
						// specify as 16-bpp when proper depth is 15-bpp
		DVar5 = 0x10;
		if (bpp != 0xf) {
			DVar5 = bpp;
		}
		(this->m_desc).ddpfPixelFormat.dwRGBBitCount = DVar5;
		if (bpp == 24) {
						// 24-bpp
			(this->m_desc).ddpfPixelFormat.dwRBitMask = 0xff0000;
			(this->m_desc).ddpfPixelFormat.dwGBitMask = 0xff00;
			(this->m_desc).ddpfPixelFormat.dwBBitMask = 0xff;
						// DDPF_RGB (0x40)
			(this->m_desc).ddpfPixelFormat.dwFlags = 0x40;
		}
		else {
			if (bpp == 0x10) {
						// 16-bpp (proper)
				(this->m_desc).ddpfPixelFormat.dwRBitMask = 0xf800;
				(this->m_desc).ddpfPixelFormat.dwGBitMask = 0x7e0;
				(this->m_desc).ddpfPixelFormat.dwBBitMask = 0x1f;
						// DDPF_RGB (0x40)
				(this->m_desc).ddpfPixelFormat.dwFlags = 0x40;
			}
			else {
				if (bpp == 0xf) {
						// 15-bpp (treated as 16-bpp)
					(this->m_desc).ddpfPixelFormat.dwRBitMask = 0x7c00;
					(this->m_desc).ddpfPixelFormat.dwGBitMask = 0x3e0;
					(this->m_desc).ddpfPixelFormat.dwBBitMask = 0x1f;
						// DDPF_RGB (0x40)
					(this->m_desc).ddpfPixelFormat.dwFlags = 0x40;
				}
				else {
					if (bpp == 8) {
						// 8-bpp (indexed)
						(this->m_desc).ddpfPixelFormat.dwRBitMask = 0xff0000;
						(this->m_desc).ddpfPixelFormat.dwGBitMask = 0xff00;
						(this->m_desc).ddpfPixelFormat.dwBBitMask = 0xff;
						// DDPF_RGB | DDPF_PALETTEINDEXED8 (0x40 | 0x20)
						(this->m_desc).ddpfPixelFormat.dwFlags = 0x60;
					}
				}
			}
		}
	}
	HVar1 = (*(globs::animationGlobs.ddraw)->lpVtbl->CreateSurface)
										(globs::animationGlobs.ddraw,&this->m_desc,&this->m_surf,NULL);
	if (HVar1 == 0) {
		G98CSurface__Lock(this);
		G98CSurface__Unlock(this);
		if ((this->m_desc).ddpfPixelFormat.dwRGBBitCount != 8) {
LAB_0047e975:
			if ((this->m_desc).ddpfPixelFormat.dwRGBBitCount == 0x10) {
						// Count number of bits to check if we're actually using 15-bpp handling (when surface
						// considers it as 16-bpp)
				iVar6 = G98CSurface__CountMaskBits(this,(this->m_desc).ddpfPixelFormat.dwGBitMask);
				iVar3 = G98CSurface__CountMaskBits(this,(this->m_desc).ddpfPixelFormat.dwBBitMask);
				iVar4 = G98CSurface__CountMaskBits(this,(this->m_desc).ddpfPixelFormat.dwRBitMask);
				if (iVar6 + iVar3 + iVar4 == 0xf) {
					this->m_15bit = true;
				}
			}
			return true;
		}
		pbVar2 = &palette[0].green;
		iVar6 = 0x100;
		do {
			pbVar2[-1] = 0;
			*pbVar2 = 0;
			pbVar2[1] = 0;
			pbVar2[2] = 0;
			pbVar2 = pbVar2 + 4;
			iVar6 += -1;
		} while (iVar6 != 0);
						// DDPCAPS_8BIT (0x4)
		HVar1 = (*(globs::animationGlobs.ddraw)->lpVtbl->CreatePalette)
											(globs::animationGlobs.ddraw,4,palette,&this->m_palette,NULL);
		if (HVar1 == 0) {
			This = this->m_surf;
			HVar1 = (*This->lpVtbl->SetPalette)(This,this->m_palette);
			if (HVar1 == 0) goto LAB_0047e975;
		}
	}
	return false;
}



void __thiscall lego::video::G98CSurface__PreInit(G98CSurface *this,bool fullscreen)
{
	int iVar1;
	DDSURFACEDESC2 *pDVar2;
	
	pDVar2 = &this->m_desc;
	for (iVar1 = 0x1f; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDSURFACEDESC2 *)&pDVar2->dwFlags;
	}
	(this->m_desc).dwSize = 0x7c;
	this->m_surf = NULL;
	this->m_palette = NULL;
	this->m_surfaceLocked = false;
	this->m_colourKeyed = false;
	return;
}



int __thiscall lego::video::G98CSurface__Width(void *this,G98CSurface *This)
{
	return *(int *)((int)this + 0x28);
}



int __thiscall lego::video::G98CSurface__Height(void *this,G98CSurface *This)
{
	return *(int *)((int)this + 0x24);
}



bool __thiscall lego::video::G98CSurface__Lock(G98CSurface *this)
{
	DDSURFACEDESC2 *pDVar1;
	IDirectDrawSurface4 *pIVar2;
	IDirectDrawSurface4Vtbl *pIVar3;
	HRESULT HVar4;
	int iVar5;
	DDSURFACEDESC2 *pDVar6;
	
	if (this->m_surfaceLocked == false) {
		pDVar1 = &this->m_desc;
		pDVar6 = pDVar1;
		for (iVar5 = 0x1f; iVar5 != 0; iVar5 += -1) {
			pDVar6->dwSize = 0;
			pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
		}
		pIVar2 = this->m_surf;
		pIVar3 = pIVar2->lpVtbl;
		pDVar1->dwSize = 0x7c;
		HVar4 = (*pIVar3->Lock)(pIVar2,NULL,pDVar1,0x801,NULL);
		if (HVar4 == 0) {
			this->m_surfaceLocked = true;
			return true;
		}
	}
	return false;
}



bool __thiscall lego::video::G98CSurface__Unlock(G98CSurface *this)
{
	HRESULT HVar1;
	
	if (this->m_surfaceLocked != false) {
		HVar1 = (*this->m_surf->lpVtbl->Unlock)(this->m_surf,NULL);
		if (HVar1 == 0) {
			this->m_surfaceLocked = false;
			return true;
		}
	}
	return false;
}



int __thiscall lego::video::G98CSurface__CountMaskBits(G98CSurface *this,uint mask)
{
	int count;
	uint i;
	
	count = 0;
	i = 0;
	do {
		if ((mask & 1 << ((byte)i & 0x1f)) != 0) {
			count += 1;
		}
		i += 1;
	} while (i < 32);
	return count;
}



G98CAnimation * __thiscall lego::video::G98CAnimation___ctor(G98CAnimation *this,char *filename)
{
	IAVIStream **lplpIAVIStream;
	LONG LVar1;
	LONG LVar2;
	LONG LVar3;
	char *szFile;
	HRESULT HVar4;
	IGetFrame *pIVar5;
	DWORD DVar6;
	G98CSurface *pGVar7;
	int iVar8;
	AVISTREAMINFOA *pAVar9;
	undefined4 *in_FS_OFFSET;
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
	local_c = *in_FS_OFFSET;
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e08b;
	*in_FS_OFFSET = &local_c;
	this->m_colourKeySet = false;
	this->m_init = false;
	this->m_movieSurf = NULL;
	this->vftable = &G98CAnimation___vftable;
	szFile = lego::file::File_VerifyFilename(filename);
	lplpIAVIStream = &this->m_aviStream;
	this->m_decompressFn = NULL;
	*lplpIAVIStream = NULL;
	pAVar9 = &this->m_aviStreamInfo;
	for (iVar8 = 0x23; iVar8 != 0; iVar8 += -1) {
		pAVar9->fccType = 0;
		pAVar9 = (AVISTREAMINFOA *)&pAVar9->fccHandler;
	}
	(this->m_movieRect).top = 0;
	(this->m_movieRect).bottom = 0;
	(this->m_movieRect).left = 0;
	(this->m_movieRect).right = 0;
	if (globs::animationGlobs.g98NoAvis == false) {
						// fccType "sdiv" (as DWORD)
		HVar4 = AVIStreamOpenFromFileA(lplpIAVIStream,szFile,L'\x73646976',0,0,NULL);
		if (HVar4 == 0) {
						// AVIGETFRAMEF_BESTDISPLAYFMT (0x1)
			pIVar5 = AVIStreamGetFrameOpen(*lplpIAVIStream,(BITMAPINFOHEADER *)0x1);
			this->m_decompressFn = pIVar5;
			if (pIVar5 != NULL) {
				HVar4 = AVIStreamInfoA(*lplpIAVIStream,&this->m_aviStreamInfo,0x8c);
				if (HVar4 == 0) {
					DVar6 = timeGetTime();
					LVar1 = (this->m_aviStreamInfo).rcFrame.bottom;
					LVar2 = (this->m_aviStreamInfo).rcFrame.left;
					(this->m_movieRect).top = (this->m_aviStreamInfo).rcFrame.top;
					LVar3 = (this->m_aviStreamInfo).rcFrame.right;
					this->m_init = true;
					this->m_currFrame = 0;
					(this->m_movieRect).bottom = LVar1;
					(this->m_movieRect).left = LVar2;
					(this->m_movieRect).right = LVar3;
					this->m_startTime = (float)(ulonglong)DVar6 * 0.001;
					pGVar7 = (G98CSurface *)std::operator_new(0x98);
					local_4 = 0;
					if (pGVar7 == NULL) {
						pGVar7 = NULL;
					}
					else {
						pGVar7 = G98CSurface___ctor(pGVar7,(this->m_movieRect).right - (this->m_movieRect).left,
																				(this->m_movieRect).bottom - (this->m_movieRect).top,0,false
																				,false);
					}
					this->m_movieSurf = pGVar7;
				}
			}
		}
	}
	*in_FS_OFFSET = local_c;
	return this;
}



G98CAnimation * __thiscall
lego::video::G98CAnimation___deletor(void *this,G98CAnimation *This,byte flag)
{
	G98CAnimation___dtor((G98CAnimation *)this);
	if (((uint)This & 1) != 0) {
		game::RadarMap_Free_UnwindMultiUse((RadarMap *)this);
	}
	return (G98CAnimation *)this;
}



void __thiscall lego::video::G98CAnimation___dtor(G98CAnimation *this)
{
	G98CSurface *This;
	
	this->vftable = &G98CAnimation___vftable;
	if (globs::animationGlobs.g98NoAvis == false) {
		if (this->m_aviStream != NULL) {
			AVIStreamRelease(this->m_aviStream);
		}
		This = this->m_movieSurf;
		if (This != NULL) {
			(*This->vftable->deletor)(This,1);
		}
	}
	return;
}



void __thiscall lego::video::G98CAnimation__BMICopy(G98CAnimation *this,BITMAPINFO *bmi)
{
	G98CSurface *this_00;
	G98CSurface *pGVar1;
	uint uVar2;
	bool bVar3;
	bool bVar4;
	int stride;
	int height;
	uint uVar5;
	DWORD depth;
	undefined4 *puVar6;
	int width;
	undefined4 *puVar7;
	undefined4 *puVar8;
	BYTE *pBVar9;
	undefined4 *puVar10;
	bool local_8;
	
	bVar3 = false;
	this_00 = this->m_movieSurf;
	if ((this_00->m_surfaceLocked == false) && (bVar4 = G98CSurface__Lock(this_00), bVar4 != false)) {
		bVar3 = true;
	}
	puVar7 = (undefined4 *)(this_00->m_desc).lpSurface;
	width = (this->m_movieRect).right - (this->m_movieRect).left;
	pGVar1 = this->m_movieSurf;
	height = (this->m_movieRect).bottom - (this->m_movieRect).top;
	pBVar9 = &bmi->bmiColors[-10].rgbBlue + (bmi->bmiHeader).biSize;
	stride = (int)(pGVar1->m_desc).lPitch / 2;
	depth = 0xf;
	if (pGVar1->m_15bit == false) {
		depth = (pGVar1->m_desc).ddpfPixelFormat.dwRGBBitCount;
	}
	if (depth == 0xf) {
		puVar6 = (undefined4 *)(pBVar9 + (height + -1) * stride * 2);
		if (0 < height) {
			uVar2 = width * 2;
			do {
				puVar8 = puVar6;
				puVar10 = puVar7;
				for (uVar5 = uVar2 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar10 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar10 = puVar10 + 1;
				}
				for (uVar5 = uVar2 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar10 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar10 = (undefined4 *)((int)puVar10 + 1);
				}
				puVar6 = (undefined4 *)((int)puVar6 + stride * -2);
				puVar7 = (undefined4 *)((int)puVar7 + stride * 2);
				height += -1;
			} while (height != 0);
		}
	}
	else {
						// "Corporate needs you to find the differences between these two code blocks."
						// 
						// (swap out the first `depth == 0xf` confition for `depth == 15 || depth == 16`)
		if (pGVar1->m_15bit == false) {
			depth = (pGVar1->m_desc).ddpfPixelFormat.dwRGBBitCount;
		}
		else {
			depth = 0xf;
		}
		if ((depth == 0x10) &&
			 (puVar6 = (undefined4 *)(pBVar9 + (height + -1) * stride * 2), 0 < height)) {
			uVar2 = width * 2;
			do {
				puVar8 = puVar6;
				puVar10 = puVar7;
				for (uVar5 = uVar2 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar10 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar10 = puVar10 + 1;
				}
				for (uVar5 = uVar2 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar10 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar10 = (undefined4 *)((int)puVar10 + 1);
				}
				puVar6 = (undefined4 *)((int)puVar6 + stride * -2);
				puVar7 = (undefined4 *)((int)puVar7 + stride * 2);
				height += -1;
			} while (height != 0);
		}
	}
	if (bVar3) {
		G98CSurface__Unlock(this_00);
	}
	return;
}



bool __thiscall lego::video::G98CAnimation__Update(G98CAnimation *this)
{
	BITMAPINFO *bmi;
	DWORD DVar1;
	float10 fVar2;
	longlong lVar3;
	
	if (this->m_init == false) {
		return false;
	}
	if (globs::animationGlobs.g98NoAvis != false) {
		return false;
	}
	bmi = (BITMAPINFO *)AVIStreamGetFrame(this->m_decompressFn,this->m_currFrame);
	if (bmi != NULL) {
		G98CAnimation__BMICopy(this,bmi);
		DVar1 = timeGetTime();
		fVar2 = (float10)(ulonglong)(this->m_aviStreamInfo).dwRate /
						(float10)(ulonglong)(this->m_aviStreamInfo).dwScale;
		this->m_aviTimeScale = (float)fVar2;
		this->m_currTime = (float)((float10)(ulonglong)DVar1 * (float10)0.001);
		lVar3 = __ftol(((float10)(ulonglong)DVar1 * (float10)0.001 - (float10)this->m_startTime) * fVar2
									);
		this->m_currFrame = (uint)lVar3;
	}
	return true;
}



uint __thiscall lego::video::G98CAnimation__Length(G98CAnimation *this)
{
	if (globs::animationGlobs.g98NoAvis != false) {
		return 0;
	}
	return (this->m_aviStreamInfo).dwLength;
}



void __thiscall lego::video::G98CAnimation__SetTime(G98CAnimation *this,uint time)
{
	DWORD DVar1;
	
	if (globs::animationGlobs.g98NoAvis == false) {
		this->m_currFrame = time;
		DVar1 = timeGetTime();
		this->m_currTime = (float)(ulonglong)DVar1 * 0.001;
		this->m_startTime =
				 (float)(ulonglong)DVar1 * 0.001 -
				 (float)(ulonglong)this->m_currFrame / this->m_aviTimeScale;
	}
	return;
}



uint __thiscall lego::video::G98CAnimation__GetTime(G98CAnimation *this)
{
	return ~-(uint)(globs::animationGlobs.g98NoAvis != false) & this->m_currFrame;
}



void __cdecl lego::video::Animation_Initialise(IDirectDraw4 *directDraw)
{
	globs::animationGlobs.ddraw = directDraw;
	AVIFileInit();
	return;
}



Animation_t * __cdecl lego::video::Animation_Load(char *fName)
{
	G98CAnimation *pGVar1;
	undefined4 *in_FS_OFFSET;
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e0ab;
	local_c = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_c;
	pGVar1 = (G98CAnimation *)std::operator_new(0xc4);
	local_4 = 0;
	if (pGVar1 != NULL) {
		pGVar1 = G98CAnimation___ctor(pGVar1,fName);
		*in_FS_OFFSET = local_c;
		return (Animation_t *)pGVar1;
	}
	*in_FS_OFFSET = local_c;
	return (Animation_t *)NULL;
}



BOOL __cdecl lego::video::Animation_Update(Animation_t *anim)
{
	bool bVar1;
	
	bVar1 = G98CAnimation__Update((G98CAnimation *)anim);
	return (uint)bVar1;
}



void __cdecl lego::video::Animation_BlitToBackBuffer(Animation_t *anim,RECT *destRect)
{
	IDirectDrawSurface4 *lpDDSrcSurface;
	IDirectDrawSurface4 *This;
	
	if (anim->m_init != false) {
		lpDDSrcSurface = anim->m_movieSurf->m_surf;
		This = ddraw::DirectDraw_bSurf();
						// DDBLT_WAIT (0x1000000)
		(*This->lpVtbl->Blt)(This,(LPRECT)destRect,lpDDSrcSurface,NULL,0x1000000,NULL);
	}
	return;
}



void __cdecl lego::video::Animation_SetTime(Animation_t *anim,uint time)
{
	G98CAnimation__SetTime((G98CAnimation *)anim,time);
	return;
}



uint __cdecl lego::video::Animation_GetTime(Animation_t *anim)
{
	uint uVar1;
	
	uVar1 = G98CAnimation__GetTime((G98CAnimation *)anim);
	return uVar1;
}



uint __cdecl lego::video::Animation_GetLength(Animation_t *anim)
{
	uint uVar1;
	
	uVar1 = G98CAnimation__Length((G98CAnimation *)anim);
	return uVar1;
}



void __cdecl lego::video::Animation_Free(Animation_t *anim)
{
	if (anim != NULL) {
		(*anim->vftable->deletor)((G98CAnimation *)anim,1);
	}
	return;
}



BOOL __cdecl lego::video::Animation_IsOk(Animation_t *anim)
{
	return (uint)anim->m_init;
}



BOOL __cdecl lego::input::Input_InitKeysAndDI(void)
{
	HRESULT HVar1;
	int iVar2;
	char *pcVar3;
	int iVar4;
	GUID guidSysKeyboard;
	
						// GUID_SysKeyboard {6F1D2B61-D5A0-11CF-BFC7-444553540000}
	HVar1 = DirectInputCreateA(globs::mainGlobs.hInst,0x500,(IUnknown **)&globs::INPUT.lpdi,NULL);
	if (HVar1 != 0) {
		iVar4 = 118;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = DirectInputCreateA(globs::mainGlobs.hInst,0x500,(IUnknown **)&globs::INPUT.lpdi,NULL);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdi)->lpVtbl->CreateDevice)
										(globs::INPUT.lpdi,(LPGUID)&guidSysKeyboard,&globs::INPUT.lpdiKeyboard,NULL);
	if (HVar1 != 0) {
		iVar4 = 121;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = (*(globs::INPUT.lpdi)->lpVtbl->CreateDevice)
											(globs::INPUT.lpdi,(LPGUID)&guidSysKeyboard,&globs::INPUT.lpdiKeyboard,NULL);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetDataFormat)
										(globs::INPUT.lpdiKeyboard,&idl::c_dfDIKeyboard);
	if (HVar1 != 0) {
		iVar4 = 124;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetDataFormat)
											(globs::INPUT.lpdiKeyboard,&idl::c_dfDIKeyboard);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
						// DISCL_FOREGROUND | DISCL_NONEXCLUSIVE (0x4 | 0x2)
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetCooperativeLevel)
										(globs::INPUT.lpdiKeyboard,globs::mainGlobs.hWnd,6);
	if (HVar1 != 0) {
		iVar4 = 127;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
						// DISCL_FOREGROUND | DISCL_NONEXCLUSIVE (0x4 | 0x2)
		HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetCooperativeLevel)
											(globs::INPUT.lpdiKeyboard,globs::mainGlobs.hWnd,6);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->Acquire)(globs::INPUT.lpdiKeyboard);
	globs::INPUT.fKeybdAcquired = (uint)(HVar1 == 0);
	return 1;
}



void __cdecl lego::input::Input_ReadKeys(void)
{
	IDirectInputDeviceA *This;
	HRESULT HVar1;
	int iVar2;
	undefined4 *puVar3;
	Input_Globs *pIVar4;
	
	This = globs::INPUT.lpdiKeyboard;
	iVar2 = 1;
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) == 0) {
		iVar2 = globs::mainGlobs.active;
	}
	if (iVar2 == 0) {
		puVar3 = (undefined4 *)globs::INPUT.Key_Map;
		for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
			*puVar3 = 0;
			puVar3 = puVar3 + 1;
		}
		pIVar4 = &globs::INPUT;
		for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
			*(undefined4 *)pIVar4->prevKey_Map = 0;
			pIVar4 = (Input_Globs *)(pIVar4->prevKey_Map + 4);
		}
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Unacquire)(globs::INPUT.lpdiKeyboard);
		return;
	}
	if (globs::INPUT.lpdiKeyboard != NULL) {
		if (globs::INPUT.fKeybdAcquired == 0) {
			iVar2 = -0x7ff8ffe2;
		}
		else {
			puVar3 = (undefined4 *)globs::INPUT.Key_Map;
			pIVar4 = &globs::INPUT;
			for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
				*(undefined4 *)pIVar4->prevKey_Map = *puVar3;
				puVar3 = puVar3 + 1;
				pIVar4 = (Input_Globs *)(pIVar4->prevKey_Map + 4);
			}
			puVar3 = (undefined4 *)globs::INPUT.Key_Map;
			for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
				*puVar3 = 0;
				puVar3 = puVar3 + 1;
			}
			iVar2 = (*This->lpVtbl->GetDeviceState)(This,0x100,(LPVOID)0x76bb80);
		}
		if (iVar2 != 0) {
			globs::INPUT.fKeybdAcquired = 0;
			HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->Acquire)(globs::INPUT.lpdiKeyboard);
			if (HVar1 == 0) {
				globs::INPUT.fKeybdAcquired = 1;
			}
		}
	}
	return;
}



uint __cdecl lego::input::Input_AnyKeyPressed(void)
{
	uint uVar1;
	bool *pbVar2;
	int iVar3;
	
	uVar1 = 0;
	pbVar2 = globs::INPUT.Key_Map;
	iVar3 = 0x100;
	do {
		if (*pbVar2 != false) {
			uVar1 += 1;
		}
		pbVar2 = pbVar2 + 1;
		iVar3 += -1;
	} while (iVar3 != 0);
	return uVar1;
}



void __cdecl lego::input::Input_ReleaseKeysAndDI(void)
{
	if (globs::INPUT.fKeybdAcquired != 0) {
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Unacquire)(globs::INPUT.lpdiKeyboard);
		globs::INPUT.fKeybdAcquired = 0;
	}
	if (globs::INPUT.lpdiKeyboard != NULL) {
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Release)((IUnknown *)globs::INPUT.lpdiKeyboard);
	}
	if (globs::INPUT.lpdi != NULL) {
		(*(globs::INPUT.lpdi)->lpVtbl->Release)((IUnknown *)globs::INPUT.lpdi);
	}
	return;
}



void __cdecl lego::input::Input_ReadMouse2(void)
{
	BOOL BVar1;
	tagPOINT clientPos;
	tagPOINT mousePos;
	tagRECT clientRect;
	
	BVar1 = GetClientRect(globs::mainGlobs.hWnd,(LPRECT)&clientRect);
	if (BVar1 != 0) {
		clientPos.y = 0;
		clientPos.x = 0;
		ClientToScreen(globs::mainGlobs.hWnd,(LPPOINT)&clientPos);
		GetCursorPos((LPPOINT)&mousePos);
		mousePos.x -= clientPos.x;
		mousePos.y -= clientPos.y;
		if ((int)globs::mainGlobs.appWidth <= mousePos.x) {
			mousePos.x = globs::mainGlobs.appWidth - 1;
		}
		if ((int)globs::mainGlobs.appHeight <= mousePos.y) {
			mousePos.y = globs::mainGlobs.appHeight - 1;
		}
		if (mousePos.x < 0) {
			mousePos.x = 0;
		}
		if (mousePos.y < 0) {
			mousePos.y = 0;
		}
		globs::INPUT.diffx = mousePos.x - globs::INPUT.msx;
		globs::INPUT.diffy = mousePos.y - globs::INPUT.msy;
		globs::INPUT.msx = mousePos.x;
		globs::INPUT.msy = mousePos.y;
	}
	return;
}



BOOL __cdecl lego::input::Input_SetCursorPos(int x,int y)
{
	BOOL BVar1;
	tagPOINT client;
	
	client.y = 0;
	client.x = 0;
	ClientToScreen(globs::mainGlobs.hWnd,(LPPOINT)&client);
	globs::INPUT.msy = y;
	globs::INPUT.msx = x;
	globs::INPUT.diffx = 0;
	globs::INPUT.diffy = 0;
	BVar1 = SetCursorPos(client.x + x,client.y + y);
	return BVar1;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::file::File_Initialise(char *programName,BOOL insistOnCD,char *registryLocation)
{
	char cVar1;
	bool bVar2;
	int iVar3;
	BOOL BVar4;
	HANDLE handle;
	FILE *pFVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	char *pcVar11;
	undefined4 *puVar12;
	BOOL failed;
	char cwd [260];
	_finddata32_t fileinfo;
	char dataDir [260];
	char msgError [1024];
	char fname [1024];
	char msgNoCD [1024];
	
	bVar2 = false;
	failed = 0;
	std::_getcwd(cwd,MAX_PATH);
	uVar6 = 0xffffffff;
	pcVar10 = cwd;
	do {
		if (uVar6 == 0) break;
		uVar6 -= 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar10 + 1;
	} while (cVar1 != '\0');
	if (cwd[~uVar6 - 2] == '\\') {
		uVar6 = 0xffffffff;
		pcVar10 = cwd;
		do {
			if (uVar6 == 0) break;
			uVar6 -= 1;
			cVar1 = *pcVar10;
			pcVar10 = pcVar10 + 1;
		} while (cVar1 != '\0');
		cwd[~uVar6 - 2] = '\0';
	}
	std::sprintf(globs::fileGlobs.dataDir,"%s\\%s",cwd,"Data");
	uVar6 = 0;
	do {
		std::sprintf((char *)&fileinfo,"%s%i.wad",programName,uVar6);
		iVar3 = File_LoadWad((char *)&fileinfo);
		if (iVar3 != -1) {
			bVar2 = true;
		}
		uVar6 += 1;
	} while (uVar6 < 10);
	std::_getcwd(dataDir,MAX_PATH);
	uVar6 = 0xffffffff;
	pcVar10 = "\\Data";
	do {
		pcVar9 = pcVar10;
		if (uVar6 == 0) break;
		uVar6 -= 1;
		pcVar9 = pcVar10 + 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar9;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	iVar3 = -1;
	pcVar10 = dataDir;
	do {
		pcVar11 = pcVar10;
		if (iVar3 == 0) break;
		iVar3 += -1;
		pcVar11 = pcVar10 + 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar11;
	} while (cVar1 != '\0');
	puVar8 = (undefined4 *)(pcVar9 + -uVar6);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
		*puVar12 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	File_SetBaseSearchPath(dataDir);
	iVar3 = File_FindDataCD();
	while ((iVar3 == 0 && (insistOnCD != 0))) {
		msgError._0_4_ = 0x6f727245;
		msgError._4_2_ = 0x72;
		puVar8 = (undefined4 *)(msgError + 6);
		for (iVar3 = 0xfe; iVar3 != 0; iVar3 += -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		*(undefined2 *)puVar8 = 0;
		BVar4 = registry::Registry_GetValue
											(registryLocation,"CDMissing",REGISTRY_STRING_VALUE,msgNoCD,0x400);
		if (BVar4 == 0) {
LAB_0047f59b:
			std::exit(0);
		}
		else {
			registry::Registry_GetValue
								(registryLocation,"SetupError",REGISTRY_STRING_VALUE,msgError,0x400);
			iVar3 = MessageBoxA(NULL,msgNoCD,msgError,1);
			if (iVar3 == 2) goto LAB_0047f59b;
		}
		iVar3 = File_FindDataCD();
	}
	if ((iVar3 == 0) && (!bVar2)) {
		failed = 1;
		handle = std::_findfirst32("*.*",&fileinfo);
		if (handle != (HANDLE)0xffffffff) {
			do {
				if ((((byte)fileinfo.attrib & 0x10) != 0) &&
					 (iVar3 = std::_stricmp(fileinfo.name,"Data"), iVar3 == 0)) {
					failed = 0;
					break;
				}
				iVar3 = std::_findnext32(handle,&fileinfo);
			} while (iVar3 == 0);
			std::_findclose(handle);
		}
	}
	if (insistOnCD != 0) {
		std::sprintf(fname,"%s\\%s","Data","cd.key");
		pFVar5 = std::fopen(fname,"r");
		if (pFVar5 != NULL) {
			std::fclose(pFVar5);
			failed = 1;
		}
	}
	if (failed == 0) {
		std::_mkdir("Data");
		std::sprintf(fname,"%s\\%s","Data","delme.dat");
		pFVar5 = std::fopen(fname,"r");
		if (pFVar5 != NULL) {
			std::fclose(pFVar5);
			std::_chmod(fname,FILE_ATTRIBUTE_NORMAL);
			std::remove(fname);
			return;
		}
	}
	else {
		msgError._0_4_ = 0x6f727245;
		msgError._4_2_ = 0x72;
		puVar8 = (undefined4 *)(msgError + 6);
		for (iVar3 = 0xfe; iVar3 != 0; iVar3 += -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		*(undefined2 *)puVar8 = 0;
		BVar4 = registry::Registry_GetValue
											(registryLocation,"DataMissing",REGISTRY_STRING_VALUE,msgNoCD,0x400);
		if (BVar4 != 0) {
			registry::Registry_GetValue
								(registryLocation,"SetupError",REGISTRY_STRING_VALUE,msgError,0x400);
			MessageBoxA(NULL,msgNoCD,msgError,0);
		}
		std::exit(0);
	}
	return;
}



BOOL __cdecl lego::file::File_FindDataCD(void)
{
	UINT driveType;
	FILE *stream;
	char letter;
	uint rootName;
	char buffer [260];
	
	letter = 0x43;
	rootName = 0x5c3a41;
	do {
		rootName = rootName & 0xffffff00 | (uint)(byte)letter;
		driveType = GetDriveTypeA((LPCSTR)&rootName);
		if (driveType == DRIVE_CDROM) {
			std::sprintf(buffer,"%c:\\%s\\%s",letter,"Data","cd.key");
			stream = std::fopen(buffer,"r");
			if (stream != NULL) {
				std::fclose(stream);
				globs::fileGlobs.cdLetter = letter;
				return TRUE;
			}
		}
		letter += 1;
	} while ((byte)letter < 0x5b);
	return 0;
}



// This allows the translation from File paths into Wad names.

BOOL __cdecl lego::file::File_SetBaseSearchPath(char *basePath)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	undefined4 *puVar5;
	char *pcVar6;
	File_Globs *pFVar7;
	
	if (basePath != NULL) {
		uVar2 = 0xffffffff;
		pcVar6 = basePath;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
						// if (std::strlen(dirname) != 0 && std::strlen(dirname) < 0x400)
		if (((int)(~uVar2 - 1) < 0x401) && (~uVar2 != 1)) {
						// std::strcpy(globals::g_FILEPATH_DATADIR_STRIP, dirname);
			uVar2 = 0xffffffff;
			do {
				pcVar6 = basePath;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar6 = basePath + 1;
				cVar1 = *basePath;
				basePath = pcVar6;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			puVar5 = (undefined4 *)(pcVar6 + -uVar2);
			pFVar7 = &globs::fileGlobs;
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*(undefined4 *)pFVar7->wadBasePath = *puVar5;
				puVar5 = puVar5 + 1;
				pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 4);
			}
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				pFVar7->wadBasePath[0] = *(char *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 1);
			}
			globs::fileGlobs.basePathSet = TRUE;
			return TRUE;
		}
	}
	globs::fileGlobs.basePathSet = 0;
	pFVar7 = &globs::fileGlobs;
	for (iVar4 = 0x100; iVar4 != 0; iVar4 += -1) {
		*(undefined4 *)pFVar7->wadBasePath = 0;
		pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 4);
	}
	return 0;
}



void __cdecl lego::file::File_Error(char *msg,...)
{
	char buffer [1024];
	
	std::vsprintf(buffer,msg,&stack0x00000008);
	OutputDebugStringA(buffer);
	return;
}



int __cdecl lego::file::File_LoadWad(char *fName)
{
	int iVar1;
	
						// File_ErrorFile(0); // Open the wad error log
	util::logf_removed(NULL);
	iVar1 = wad::Wad_Load(fName);
	return iVar1;
}



BOOL __cdecl lego::file::File_GetCDFilePath(char *out_path,char *fname)
{
	if ((char)globs::fileGlobs._2580_4_ != '\0') {
		std::sprintf(out_path,"%c:\\%s\\%s",globs::fileGlobs._2580_4_ & 0xff,"Data",fname);
		return TRUE;
	}
	return 0;
}



int __cdecl lego::file::File_MakeDir(char *path)
{
	int iVar1;
	char buffer [260];
	
	std::sprintf(buffer,"%s\\%s","Data",path);
	iVar1 = std::_mkdir(buffer);
	return iVar1;
}



File * __cdecl lego::file::File_Open(char *fName,char *mode)
{
	char *pcVar1;
	FileSystemType FVar2;
	File *file;
	FILE *pFVar3;
	char *pcVar4;
	BOOL BVar5;
	char buffer [160];
	
	pcVar1 = File_VerifyFilename(fName);
	FVar2 = _File_CheckSystem(pcVar1,mode);
	if (FVar2 == FILESYSTEM_WAD) {
		file = _File_Alloc(FILESYSTEM_WAD);
		if (file == NULL) {
			return NULL;
		}
		pcVar4 = _File_GetWadName(pcVar1);
		BVar5 = _File_OpenWad((WADFILE *)file->stream,pcVar4);
		if (BVar5 != 0) {
			pcVar1 = _File_GetWadName(pcVar1);
			util::logf_removed("WAD Load %s\n",pcVar1);
			return file;
		}
		pcVar1 = _File_GetWadName(pcVar1);
		pcVar4 = "WAD Fail %s\n";
	}
	else {
		if (FVar2 != FILESYSTEM_STD) {
			File_Error("%s(%i) : Error in call to %s\n",
								 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",330,"File_Open");
			return NULL;
		}
		file = _File_Alloc(FILESYSTEM_STD);
		if (file == NULL) {
			return NULL;
		}
		pFVar3 = std::fopen(pcVar1,mode);
		file->stream = pFVar3;
		if (pFVar3 != NULL) {
			util::logf_removed("STD Load %s\n",pcVar1);
			return file;
		}
		pcVar4 = util::Util_StrIStr(mode,"w");
		if ((pcVar4 == NULL) && (BVar5 = File_GetCDFilePath(buffer,fName), BVar5 != 0)) {
			pFVar3 = std::fopen(buffer,mode);
			file->stream = pFVar3;
			if (pFVar3 != NULL) {
				return file;
			}
		}
		pcVar4 = "STD Fail %s\n";
	}
	util::logf_removed(pcVar4,pcVar1);
	_File_Dealloc(file);
	return NULL;
}



int __cdecl lego::file::File_Seek(File *f,int pos,int origin)
{
	int *piVar1;
	FileSystemType FVar2;
	int iVar3;
	
	FVar2 = _File_GetSystem(f);
	if (FVar2 != FILESYSTEM_WAD) {
		if (FVar2 != FILESYSTEM_STD) {
			File_Error("%s(%i) : Unknown file system in call to %s",
								 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",368,"File_Seek");
			return 0;
		}
		iVar3 = std::fseek((FILE *)f->stream,pos,origin);
		return iVar3;
	}
	if (origin == 0) {
		*(int *)(f->stream + 4) = pos;
		piVar1 = (int *)f->stream;
		iVar3 = wad::Wad_hLength(*piVar1);
		if (iVar3 < piVar1[1]) {
			iVar3 = wad::Wad_hLength(*piVar1);
			*(int *)(f->stream + 4) = iVar3;
		}
		if (*(int *)(f->stream + 4) < 0) {
			*(undefined4 *)(f->stream + 4) = 0;
		}
	}
	else {
		if (origin != 1) {
			if (origin != 2) {
				File_Error("Uknown seek mode (%i)",origin);
				return 0;
			}
			iVar3 = wad::Wad_hLength(*(int *)f->stream);
			*(int *)(f->stream + 4) = iVar3 + pos;
			return 0;
		}
		*(int *)(f->stream + 4) = *(int *)(f->stream + 4) + pos;
		piVar1 = (int *)f->stream;
		iVar3 = wad::Wad_hLength(*piVar1);
		if (iVar3 < piVar1[1]) {
			iVar3 = wad::Wad_hLength(*piVar1);
			*(int *)(f->stream + 4) = iVar3;
		}
		if (*(int *)(f->stream + 4) < 0) {
			*(undefined4 *)(f->stream + 4) = 0;
			return 0;
		}
	}
	return 0;
}



int __cdecl lego::file::File_Read(void *out_buffer,int size,int count,File *f)
{
	int iVar1;
	FileSystemType FVar2;
	size_t sVar3;
	int iVar4;
	void *pvVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	
	FVar2 = _File_GetSystem(f);
	if (FVar2 == FILESYSTEM_WAD) {
		iVar4 = wad::Wad_hLength(*(int *)f->stream);
		uVar6 = count * size;
		iVar1 = ((int *)f->stream)[1];
		if (iVar4 < (int)(iVar1 + uVar6)) {
			uVar6 = iVar4 - iVar1;
		}
		pvVar5 = wad::Wad_hData(*(int *)f->stream);
		puVar8 = (undefined4 *)((int)pvVar5 + *(int *)(f->stream + 4));
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*(undefined4 *)out_buffer = *puVar8;
			puVar8 = puVar8 + 1;
			out_buffer = (undefined4 *)((int)out_buffer + 4);
		}
		for (uVar7 = uVar6 & 3; uVar7 != 0; uVar7 -= 1) {
			*(undefined *)out_buffer = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			out_buffer = (undefined4 *)((int)out_buffer + 1);
		}
		*(uint *)(f->stream + 4) = *(int *)(f->stream + 4) + uVar6;
		return (int)uVar6 / size;
	}
	if (FVar2 == FILESYSTEM_STD) {
		sVar3 = std::fread(out_buffer,size,count,(FILE *)f->stream);
		return sVar3;
	}
	File_Error("%s(%i) : Unknown file system in call to %s",
						 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",395,____EMPTYSTR__);
	return 0;
}



int __cdecl lego::file::File_Write(void *buffer,int size,int count,File *f)
{
	FileSystemType FVar1;
	size_t sVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		File_Error("Cannot write to a file stored in a Wad!");
		return 0;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",414,"File_Write");
		return 0;
	}
	sVar2 = std::fwrite(buffer,size,count,(FILE *)f->stream);
	return sVar2;
}



int __cdecl lego::file::File_Close(File *f)
{
	FileSystemType FVar1;
	
	FVar1 = _File_GetSystem(f);
	if ((-1 < (int)FVar1) && ((int)FVar1 < 2)) {
		_File_Dealloc(f);
		return 0;
	}
	File_Error("%s(%i) : Unknown file system in call to %s",
						 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",431,"File_Close");
	return 0;
}



int __cdecl lego::file::File_Tell(File *f)
{
	FileSystemType FVar1;
	int iVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		return *(int *)(f->stream + 4);
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",469,"File_Tell");
		return 0;
	}
	iVar2 = std::ftell((FILE *)f->stream);
	return iVar2;
}



BOOL __cdecl lego::file::File_Exists(char *fName)
{
	char *fName_00;
	FileSystemType FVar1;
	FILE *pFVar2;
	BOOL BVar3;
	char cdName [260];
	
	fName_00 = File_VerifyFilename(fName);
	FVar1 = _File_CheckSystem(fName_00,"r");
	if (FVar1 == FILESYSTEM_STD) {
		pFVar2 = std::fopen(fName_00,"r");
		if (pFVar2 != NULL) {
			std::fclose(pFVar2);
			return TRUE;
		}
		BVar3 = File_GetCDFilePath(cdName,fName);
		if (BVar3 != 0) {
			pFVar2 = std::fopen(cdName,"r");
			if (pFVar2 != NULL) {
				std::fclose(pFVar2);
				return TRUE;
			}
		}
	}
	else {
		if (FVar1 == FILESYSTEM_WAD) {
			BVar3 = wad::Wad_IsFileInWad(fName_00,globs::currWadHandle);
			return BVar3;
		}
	}
	return 0;
}



int __cdecl lego::file::File_GetC(File *f)
{
	int iVar1;
	int iVar2;
	FileSystemType FVar3;
	int iVar4;
	void *pvVar5;
	
	FVar3 = _File_GetSystem(f);
	if (FVar3 == FILESYSTEM_WAD) {
		iVar4 = wad::Wad_hLength(*(int *)f->stream);
		if (iVar4 + -1 <= ((int *)f->stream)[1]) {
			return -1;
		}
		iVar4 = f->stream;
		iVar1 = *(int *)(iVar4 + 4);
		pvVar5 = wad::Wad_hData(*(int *)f->stream);
		iVar2 = *(int *)((int)pvVar5 + iVar1);
		*(int *)(iVar4 + 4) = iVar1 + 1;
		return iVar2;
	}
	if (FVar3 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",545,"File_GetC");
		return 0;
	}
	iVar4 = std::fgetc((FILE *)f->stream);
	return iVar4;
}



int __cdecl lego::file::File_Length(File *f)
{
	int pos;
	int iVar1;
	
	pos = File_Tell(f);
	File_Seek(f,0,SEEK_END);
	iVar1 = File_Tell(f);
	File_Seek(f,pos,SEEK_SET);
	return iVar1;
}



char * __cdecl lego::file::File_InternalFGetS(char *out_str,int num,File *f)
{
	char cVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 0;
	iVar2 = File_GetC(f);
	cVar1 = (char)iVar2;
	*out_str = cVar1;
	while ((((cVar1 != '\0' && (out_str[iVar3] != '\n')) && (out_str[iVar3] != -1)) && (iVar3 != num))
				) {
		iVar3 += 1;
		iVar2 = File_GetC(f);
		cVar1 = (char)iVar2;
		out_str[iVar3] = cVar1;
	}
	out_str[iVar3 + 1] = '\0';
	return (char *)(-(uint)(iVar3 != 0) & (uint)out_str);
}



char * __cdecl lego::file::File_GetS(char *out_str,int num,File *f)
{
	FileSystemType FVar1;
	char *pcVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		pcVar2 = File_InternalFGetS(out_str,num,f);
		return pcVar2;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",587,"File_GetS");
		return NULL;
	}
	pcVar2 = std::fgets(out_str,num,(FILE *)f->stream);
	return pcVar2;
}



int __cdecl lego::file::File_PrintF(File *f,char *msg,...)
{
	FileSystemType FVar1;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		File_Error("\"fprintf\" is unsupprted for wad files");
		return 0;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",612,"File_PrintF");
		return 0;
	}
	std::vfprintf((FILE *)f->stream,msg,&stack0x0000000c);
	return 0;
}



FileSystemType __cdecl lego::file::_File_GetSystem(File *f)
{
	return f->type;
}



FileSystemType __cdecl lego::file::_File_CheckSystem(char *fName,char *mode)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	
	if ((fName != NULL) && (mode != NULL)) {
		iVar3 = -1;
		pcVar2 = fName;
		do {
			if (iVar3 == 0) break;
			iVar3 += -1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar2 + 1;
		} while (cVar1 != '\0');
		if (iVar3 != -2) {
			iVar3 = -1;
			pcVar2 = mode;
			do {
				if (iVar3 == 0) break;
				iVar3 += -1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			if (iVar3 != -2) {
				if ((*mode != 'w') && (*mode != 'W')) {
					iVar3 = globs::currWadHandle;
					pcVar2 = _File_GetWadName(fName);
					iVar3 = wad::Wad_IsFileInWad(pcVar2,iVar3);
					return (uint)(iVar3 == -1);
				}
				return FILESYSTEM_STD;
			}
		}
	}
	return FILESYSTEM_ERR;
}



BOOL __cdecl lego::file::_File_OpenWad(WADFILE *wad,char *fName)
{
	int iVar1;
	
	wad->eof = 0;
	wad->streamPos = 0;
	iVar1 = lego::wad::Wad_FileOpen(fName,globs::currWadHandle);
	wad->hFile = iVar1;
	return (uint)(iVar1 != -1);
}



File * __cdecl lego::file::_File_Alloc(FileSystemType fType)
{
	File *pFVar1;
	File *file;
	WADFILE *wadStream;
	
	if (fType == FILESYSTEM_STD) {
		pFVar1 = (File *)_File_Malloc(8);
		pFVar1->type = FILESYSTEM_STD;
		return pFVar1;
	}
	if (fType == FILESYSTEM_WAD) {
		file = (File *)_File_Malloc(8);
		if (file != NULL) {
			file->type = FILESYSTEM_WAD;
			wadStream = (WADFILE *)_File_Malloc(0xc);
			file->stream = wadStream;
			if (wadStream != NULL) {
				return file;
			}
			_File_Free(file);
		}
	}
	return NULL;
}



// (Change to whatever is required)

void * __cdecl lego::file::_File_Malloc(int size)
{
	void *pvVar1;
	
	pvVar1 = std::malloc(size);
	return pvVar1;
}



// (Change to whatever is required)

void __cdecl lego::file::_File_Free(void *ptr)
{
	std::free(ptr);
	return;
}



void __cdecl lego::file::_File_Dealloc(File *file)
{
	FileSystemType FVar1;
	
	if (file != NULL) {
		FVar1 = _File_GetSystem(file);
		if (FVar1 == FILESYSTEM_STD) {
			if ((FILE *)file->stream != NULL) {
				std::fclose((FILE *)file->stream);
				_File_Free(file);
				return;
			}
		}
		else {
			FVar1 = _File_GetSystem(file);
			if (FVar1 != FILESYSTEM_WAD) {
				return;
			}
			if ((int *)file->stream != NULL) {
				wad::Wad_FileClose(*(int *)file->stream);
				_File_Free((void *)file->stream);
			}
		}
		_File_Free(file);
	}
	return;
}



char * __cdecl lego::file::_File_GetWadName(char *fName)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	char *pcVar6;
	File_Globs *pFVar7;
	
	if (globs::fileGlobs.basePathSet == 0) {
		return fName;
	}
	uVar3 = 0xffffffff;
	pcVar6 = fName;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	uVar4 = 0xffffffff;
	pFVar7 = &globs::fileGlobs;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar6 = pFVar7->wadBasePath;
		pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 1);
	} while (*pcVar6 != '\0');
	iVar5 = ~uVar4 - 1;
	if ((int)(~uVar3 - 1) <= iVar5) {
		return fName;
	}
	cVar1 = fName[iVar5];
	fName[iVar5] = '\0';
	iVar2 = std::_stricmp(fName,globs::fileGlobs.wadBasePath);
	if (iVar2 == 0) {
		std::sprintf(globs::fileGlobs.s_GetWadName_wadedName,"%s",fName + ~uVar4);
		fName[iVar5] = cVar1;
		return globs::fileGlobs.s_GetWadName_wadedName;
	}
	fName[iVar5] = cVar1;
	return fName;
}



char * __cdecl lego::file::File_GetLine(char *out_str,uint size,File *file)
{
	char cVar1;
	char *pcVar2;
	uint uVar3;
	int iVar4;
	char *pcVar5;
	
	pcVar2 = File_GetS(out_str,size,file);
	uVar3 = 0xffffffff;
	pcVar5 = out_str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar4 = uVar3 - 2;
	if (out_str[iVar4] == '\n') {
		out_str[iVar4] = '\0';
	}
	if ((iVar4 != 0) && (out_str[uVar3 - 3] == '\r')) {
		out_str[uVar3 - 3] = '\0';
	}
	return pcVar2;
}



byte * __cdecl lego::file::File_LoadBinary(char *filename,uint *out_size)
{
	byte *buffer;
	
	buffer = (byte *)File_Load(filename,out_size,TRUE);
	return buffer;
}



void * __cdecl lego::file::File_Load(char *filename,uint *out_size,BOOL binary)
{
	char *mode;
	File *file;
	uint length;
	void *out_buffer;
	
	mode = "rb";
	if (binary == 0) {
		mode = "r";
	}
	file = File_Open(filename,mode);
	if (file != NULL) {
		File_Seek(file,0,SEEK_END);
		length = File_Tell(file);
		if (globs::fileGlobs.loadCallback != NULL) {
			(*globs::fileGlobs.loadCallback)(filename,length,globs::fileGlobs.loadCallbackData);
		}
		out_buffer = std::malloc(length);
		if (out_buffer != NULL) {
			File_Seek(file,0,SEEK_SET);
			File_Read(out_buffer,1,length,file);
			if (out_size != NULL) {
				*out_size = length;
			}
			File_Close(file);
			return out_buffer;
		}
		File_Close(file);
	}
	return NULL;
}



uint __cdecl lego::file::File_LoadBinaryHandle(char *filename,uint *out_size)
{
	File *f;
	uint fileSize;
	int bufferIndex;
	void *out_buffer;
	
	f = File_Open(filename,"rb");
	if (f != NULL) {
		File_Seek(f,0,SEEK_END);
		fileSize = File_Tell(f);
		if (globs::fileGlobs.loadCallback != NULL) {
			(*globs::fileGlobs.loadCallback)(filename,fileSize,globs::fileGlobs.loadCallbackData);
		}
		bufferIndex = Mem_AllocHandle(fileSize);
		if (bufferIndex != -1) {
			out_buffer = Mem_AddressHandle(bufferIndex);
			File_Seek(f,0,SEEK_SET);
			File_Read(out_buffer,1,fileSize,f);
			if (out_size != NULL) {
				*out_size = fileSize;
			}
			File_Close(f);
			return bufferIndex;
		}
		File_Close(f);
	}
	return 0xffffffff;
}



char * __cdecl lego::file::File_VerifyFilename(char *filename)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	uint uVar4;
	char part [260];
	
	if (filename != NULL) {
		if (*filename == '\\') {
			filename = filename + 1;
		}
		std::sprintf(part,"%s\\%s",0x5352a8,filename);
		pcVar2 = std::_fullpath(globs::fileGlobs.s_VerifyFilename_full,part,MAX_PATH);
		if (pcVar2 != NULL) {
			uVar4 = 0xffffffff;
			pcVar2 = globs::fileGlobs.dataDir;
			do {
				if (uVar4 == 0) break;
				uVar4 -= 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			iVar3 = std::strncmp(globs::fileGlobs.s_VerifyFilename_full,globs::fileGlobs.dataDir,
													 ~uVar4 - 1);
			if (iVar3 == 0) {
				return globs::fileGlobs.s_VerifyFilename_full;
			}
		}
	}
	return NULL;
}



void __cdecl lego::file::File_SetLoadCallback(FileLoadCallback callback,void *data)
{
	globs::fileGlobs.loadCallback = callback;
	globs::fileGlobs.loadCallbackData = data;
	return;
}



void __cdecl lego::file::File_CheckRedundantFiles(char *logName)
{
	char cVar1;
	FILE *stream;
	int iVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	char (*pacVar8) [1024];
	char buffer [1024];
	
	stream = (FILE *)File_Open(logName,"r");
	if (stream != NULL) {
		globs::checkGlobs.numInList = 0;
		iVar2 = std::fscanf(stream,"%s",buffer);
		while (iVar2 != -1) {
			uVar3 = 0xffffffff;
			pacVar8 = globs::checkGlobs.loadedList[globs::checkGlobs.numInList];
			globs::checkGlobs.numInList += 1;
			pcVar6 = buffer;
			do {
				pcVar7 = pcVar6;
				if (uVar3 == 0) break;
				uVar3 -= 1;
				pcVar7 = pcVar6 + 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar7;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar7 + -uVar3);
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
				*(undefined4 *)*pacVar8 = *puVar5;
				puVar5 = puVar5 + 1;
				pacVar8 = (char (*) [1024])(*pacVar8 + 4);
			}
			for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
				(*pacVar8)[0] = *(char *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				pacVar8 = (char (*) [1024])(*pacVar8 + 1);
			}
			iVar2 = std::fscanf(stream,"%s",buffer);
		}
		File_CheckDirectory(globs::fileGlobs.dataDir);
		std::fclose(stream);
	}
	return;
}



void __cdecl lego::file::File_CheckDirectory(char *dirName)
{
	char cVar1;
	byte bVar2;
	HANDLE handle;
	byte *pbVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	undefined4 *puVar11;
	bool bVar12;
	byte local_518;
	char local_504 [260];
	char name [1024];
	
	uVar4 = 0xffffffff;
	pcVar7 = dirName;
	do {
		pcVar9 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar9 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar9;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar8 = (undefined4 *)(pcVar9 + -uVar4);
	puVar11 = (undefined4 *)name;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar11 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar11 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	uVar4 = 0xffffffff;
	pcVar7 = "\\*.*";
	do {
		pcVar9 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar9 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar9;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	iVar6 = -1;
	pcVar7 = name;
	do {
		pcVar10 = pcVar7;
		if (iVar6 == 0) break;
		iVar6 += -1;
		pcVar10 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar10;
	} while (cVar1 != '\0');
	puVar8 = (undefined4 *)(pcVar9 + -uVar4);
	puVar11 = (undefined4 *)(pcVar10 + -1);
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar11 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar11 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	handle = std::_findfirst32(name,(_finddata32_t *)&local_518);
	if (handle != (HANDLE)0xffffffff) {
		do {
			pcVar7 = ".";
			pbVar3 = (byte *)local_504;
			do {
				bVar2 = *pbVar3;
				bVar12 = bVar2 < (byte)*pcVar7;
				if (bVar2 != *pcVar7) {
LAB_00480709:
					iVar6 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
					goto LAB_0048070e;
				}
				if (bVar2 == 0) break;
				bVar2 = pbVar3[1];
				bVar12 = bVar2 < ((byte *)pcVar7)[1];
				if (bVar2 != ((byte *)pcVar7)[1]) goto LAB_00480709;
				pbVar3 = pbVar3 + 2;
				pcVar7 = (char *)((byte *)pcVar7 + 2);
			} while (bVar2 != 0);
			iVar6 = 0;
LAB_0048070e:
			if (iVar6 != 0) {
				pcVar7 = "..";
				pbVar3 = (byte *)local_504;
				do {
					bVar2 = *pbVar3;
					bVar12 = bVar2 < (byte)*pcVar7;
					if (bVar2 != *pcVar7) {
LAB_00480743:
						iVar6 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
						goto LAB_00480748;
					}
					if (bVar2 == 0) break;
					bVar2 = pbVar3[1];
					bVar12 = bVar2 < ((byte *)pcVar7)[1];
					if (bVar2 != ((byte *)pcVar7)[1]) goto LAB_00480743;
					pbVar3 = pbVar3 + 2;
					pcVar7 = (char *)((byte *)pcVar7 + 2);
				} while (bVar2 != 0);
				iVar6 = 0;
LAB_00480748:
				if (iVar6 != 0) {
					uVar4 = 0xffffffff;
					pcVar7 = dirName;
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)name;
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					uVar4 = 0xffffffff;
					pcVar7 = "\\";
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar6 = -1;
					pcVar7 = name;
					do {
						pcVar10 = pcVar7;
						if (iVar6 == 0) break;
						iVar6 += -1;
						pcVar10 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar10;
					} while (cVar1 != '\0');
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)(pcVar10 + -1);
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					uVar4 = 0xffffffff;
					pcVar7 = local_504;
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar6 = -1;
					pcVar7 = name;
					do {
						pcVar10 = pcVar7;
						if (iVar6 == 0) break;
						iVar6 += -1;
						pcVar10 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar10;
					} while (cVar1 != '\0');
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)(pcVar10 + -1);
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					if ((local_518 & 0x10) == 0) {
						File_CheckFile(name);
					}
					else {
						File_CheckDirectory(name);
					}
				}
			}
			iVar6 = std::_findnext32(handle,(_finddata32_t *)&local_518);
		} while (iVar6 == 0);
		std::_findclose(handle);
	}
	return;
}



void __cdecl lego::file::File_CheckFile(char *fileName)
{
	int iVar1;
	uint uVar2;
	FileCheck_Globs *_Str2;
	
	uVar2 = 0;
	if (globs::checkGlobs.numInList != 0) {
		_Str2 = &globs::checkGlobs;
		do {
			iVar1 = std::_stricmp(fileName,(char *)_Str2);
			if (iVar1 == 0) {
				return;
			}
			uVar2 += 1;
			_Str2 = (FileCheck_Globs *)_Str2->loadedList[1];
		} while (uVar2 < globs::checkGlobs.numInList);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_Initialise(char *sharedTextureDir)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	Mesh **ppMVar9;
	
	globs::meshGlobs.postRenderMeshList = NULL;
	Mesh_ClearPostRenderList();
	if (sharedTextureDir != NULL) {
		uVar2 = 0xffffffff;
		pcVar7 = sharedTextureDir;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		uVar5 = uVar2 - 1;
		if (sharedTextureDir[uVar2 - 2] != '\\') {
			uVar5 = uVar2;
		}
		globs::meshGlobs.sharedTextureDir = (char *)std::malloc(uVar5 + 1);
		uVar2 = 0xffffffff;
		do {
			pcVar7 = sharedTextureDir;
			if (uVar2 == 0) break;
			uVar2 -= 1;
			pcVar7 = sharedTextureDir + 1;
			cVar1 = *sharedTextureDir;
			sharedTextureDir = pcVar7;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		puVar6 = (undefined4 *)(pcVar7 + -uVar2);
		puVar8 = (undefined4 *)globs::meshGlobs.sharedTextureDir;
		for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
			*puVar8 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		globs::meshGlobs.sharedTextureDir[uVar5 - 1] = '\\';
		globs::meshGlobs.sharedTextureDir[uVar5] = '\0';
	}
	ppMVar9 = globs::meshGlobs.listSet;
	for (iVar4 = 0x14; iVar4 != 0; iVar4 += -1) {
		*ppMVar9 = NULL;
		ppMVar9 = ppMVar9 + 1;
	}
	globs::meshGlobs.freeList = NULL;
	globs::meshGlobs.listCount = 0;
	Mesh_CreateGlobalMaterial();
	return 1;
}



BOOL __cdecl lego::res::Mesh_CreateGlobalMaterial(void)
{
	HRESULT HVar1;
	IDirect3D3 *d3d3;
	D3DMaterial material;
	
	material.dwSize = 0x50;
	material.diffuse.red = 1.0;
	material.diffuse.green = 1.0;
	material.diffuse.blue = 1.0;
	material.diffuse.alpha = 1.0;
	material.ambient.red = 0.0;
	material.ambient.green = 0.0;
	material.ambient.blue = 0.0;
	material.ambient.alpha = 0.0;
	material.specular.red = 0.0;
	material.specular.green = 0.0;
	material.specular.blue = 0.0;
	material.specular.alpha = 0.0;
	material.emissive.red = 0.0;
	material.emissive.green = 0.0;
	material.emissive.blue = 0.0;
	material.emissive.alpha = 0.0;
	material.power = 0.0;
	material.hTexture = 0;
	material.dwRampSize = 0;
						// IDirect3DDevice3->GetDirect3D(this, IDirect3D3** lplpD3D)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetDirect3D)(globs::mainGlobs.imDevice,&d3d3);
						// IDirect3D3->CreateMaterial(this, IDirect3DMaterial3** lplpDirect3DMaterial3,
						// IUnknown* pUnkOuter)
	HVar1 = (**(code **)((int)*d3d3 + 0x14))(d3d3,&globs::meshGlobs.imMat,NULL);
	if (HVar1 == 0) {
						// IDirect3DMaterial3->GetHandle(this, IDirect3DDevice3* lpDirect3DDevice, DWORD*
						// lpHandle)
		HVar1 = (*(code *)(globs::meshGlobs.imMat)->lpVtbl->GetHandle)
											(globs::meshGlobs.imMat,globs::mainGlobs.imDevice,&globs::meshGlobs.matHandle)
		;
		if (HVar1 == 0) {
			Mesh_SetMaterial(&material);
			if (d3d3 != NULL) {
				(**(code **)((int)*d3d3 + 8))(d3d3);
			}
			return 1;
		}
		if (d3d3 != NULL) {
			(**(code **)((int)*d3d3 + 8))(d3d3);
		}
	}
	else {
		if (d3d3 != NULL) {
			(**(code **)((int)*d3d3 + 8))(d3d3);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::res::Mesh_SetMaterial(D3DMaterial *newMaterial)
{
	HRESULT HVar1;
	
	HVar1 = (*(code *)(globs::meshGlobs.imMat)->lpVtbl->SetMaterial)
										(globs::meshGlobs.imMat,newMaterial);
	return (uint)(HVar1 == 0);
}



Mesh * __cdecl lego::res::Mesh_ObtainFromList(void)
{
	Mesh *pMVar1;
	int iVar2;
	Mesh *pMVar3;
	
	if (globs::meshGlobs.freeList == NULL) {
		Mesh_AddList();
	}
	pMVar1 = globs::meshGlobs.freeList;
	pMVar3 = globs::meshGlobs.freeList;
	globs::meshGlobs.freeList = (globs::meshGlobs.freeList)->nextFree;
	for (iVar2 = 0xd; iVar2 != 0; iVar2 += -1) {
		pMVar3->groupCount = 0;
		pMVar3 = (Mesh *)&pMVar3->listSize;
	}
	pMVar1->nextFree = pMVar1;
	return pMVar1;
}



void __cdecl lego::res::Mesh_ReturnToList(Mesh *mesh)
{
	mesh->nextFree = globs::meshGlobs.freeList;
	globs::meshGlobs.freeList = mesh;
	return;
}



void __cdecl lego::res::Mesh_AddList(void)
{
	Mesh *pMVar1;
	Mesh *pMVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::meshGlobs.listCount & 0x1f);
	pMVar2 = (Mesh *)std::malloc(uVar4 * 0x34);
	globs::meshGlobs.listSet[globs::meshGlobs.listCount] = pMVar2;
	pMVar2 = globs::meshGlobs.listSet[globs::meshGlobs.listCount];
	if (pMVar2 != NULL) {
		globs::meshGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pMVar1 = pMVar2;
			do {
				pMVar1->nextFree = pMVar1 + 1;
				iVar3 += -1;
				pMVar1 = pMVar1 + 1;
			} while (iVar3 != 0);
		}
		pMVar2[uVar4 - 1].nextFree = globs::meshGlobs.freeList;
		globs::meshGlobs.freeList = pMVar2;
	}
	return;
}



Mesh * __cdecl
lego::res::Mesh_CreateOnFrame
					(IDirect3DRMFrame3 *frame,MeshRenderCallback renderFunc,uint renderFlags,void *data,
					MeshType type)
{
	IDirect3DRMUserVisual **ppIVar1;
	Mesh *meshData;
	
	meshData = Mesh_ObtainFromList();
	GetRoot();
	ppIVar1 = &meshData->uv;
						// IDirect3DRM3->CreateUserVisual(this, TD3DRMUserVisualCallback fn, void* lpArg,
						// IDirect3DRMUserVisual** lplpD3DRMUV)
	(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateUserVisual)
						(globs::mainGlobs.lpD3DRM,Mesh_RenderCallback,meshData,ppIVar1);
						// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
	(*frame->lpVtbl->AddVisual)(frame,(IDirect3DRMVisual *)*ppIVar1);
						// IDirect3DRMUserVisual->SetAppData(this, Struct_34* ulData)
	(*(*ppIVar1)->lpVtbl->SetAppData)((IDirect3DRMVisual *)*ppIVar1,meshData);
	(meshData->renderDesc).renderCallbackData = data;
	meshData->frameCreatedOn = frame;
	(meshData->renderDesc).renderCallback = renderFunc;
	(meshData->renderDesc).renderFlags = renderFlags;
	if (type == MESH_TYPE_POSTEFFECT) {
		meshData->numOfRefs = 1;
		meshData->flags = meshData->flags | 2;
		return meshData;
	}
	if (type == MESH_TYPE_LIGHTWAVEOBJECT) {
		meshData->flags = meshData->flags | 4;
	}
	meshData->numOfRefs = 1;
	return meshData;
}



Mesh * __cdecl lego::res::Mesh_Clone(Mesh *mesh,IDirect3DRMFrame3 *frame)
{
	IDirect3DRMUserVisual **ppIVar1;
	Mesh *mesh_00;
	Mesh_Group *pMVar2;
	int iVar3;
	uint uVar4;
	IDirect3DRMFrame3 *unaff_EBP;
	Mesh *pMVar5;
	Mesh_Group *pMVar6;
	D3DRMGroupIndex groupID;
	Mesh *pMVar7;
	
	mesh_00 = Mesh_ObtainFromList();
	if (mesh->clonedFrom != NULL) {
		mesh = mesh->clonedFrom;
	}
	pMVar5 = mesh;
	pMVar7 = mesh_00;
	for (iVar3 = 0xd; iVar3 != 0; iVar3 += -1) {
		pMVar7->groupCount = pMVar5->groupCount;
		pMVar5 = (Mesh *)&pMVar5->listSize;
		pMVar7 = (Mesh *)&pMVar7->listSize;
	}
	mesh_00->clonedFrom = mesh;
	mesh_00->listSize = mesh_00->groupCount;
	pMVar2 = (Mesh_Group *)std::malloc(mesh_00->groupCount * 0x70);
	mesh_00->groupList = pMVar2;
	pMVar6 = mesh->groupList;
	for (uVar4 = mesh_00->groupCount * 0x70 >> 2; uVar4 != 0; uVar4 -= 1) {
		pMVar2->faceDataSize = pMVar6->faceDataSize;
		pMVar6 = (Mesh_Group *)&pMVar6->vertexCount;
		pMVar2 = (Mesh_Group *)&pMVar2->vertexCount;
	}
	for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
		*(undefined *)&pMVar2->faceDataSize = *(undefined *)&pMVar6->faceDataSize;
		pMVar6 = (Mesh_Group *)((int)&pMVar6->faceDataSize + 1);
		pMVar2 = (Mesh_Group *)((int)&pMVar2->faceDataSize + 1);
	}
	groupID = D3DRMGROUP_0;
	if (mesh_00->groupCount != 0) {
		iVar3 = 0;
		do {
			Mesh_CreateGroupMaterial(mesh_00,groupID);
			Mesh_SetGroupMaterial
								(mesh_00,groupID,(D3DMaterial *)((int)&(mesh->groupList->material).dwSize + iVar3));
			groupID += 1;
			iVar3 += 0x70;
		} while (groupID < mesh_00->groupCount);
	}
	ppIVar1 = &mesh_00->uv;
						// IDirect3DRM3->CreateUserVisual(this, TD3DRMUserVisualCallback fn, void* lpArg,
						// IDirect3DRMUserVisual** lplpD3DRMUV)
	(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateUserVisual)
						(globs::mainGlobs.lpD3DRM,Mesh_RenderCallback,mesh_00,ppIVar1);
						// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
	(*unaff_EBP->lpVtbl->AddVisual)(unaff_EBP,(IDirect3DRMVisual *)*ppIVar1);
						// IDirect3DRMUserVisual->SetAppData(this, Struct_3c* ulData)
	(*(*ppIVar1)->lpVtbl->SetAppData)((IUnknown *)*ppIVar1,(DWORD)mesh_00);
	mesh_00->frameCreatedOn = unaff_EBP;
	mesh->numOfRefs = mesh->numOfRefs + 1;
	mesh->flags = mesh->flags | 0x200000;
	mesh_00->numOfRefs = 0;
	return mesh_00;
}



Mesh * __cdecl lego::res::Mesh_Load(char *filename,IDirect3DRMFrame3 *frame,BOOL noTextures)
{
	char *pcVar1;
	char cVar2;
	BOOL BVar3;
	Mesh *mesh;
	uint uVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	void *struct20;
	char filenameBuffer [260];
	
	uVar4 = 0xffffffff;
	pcVar7 = filename;
	do {
		pcVar6 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar6 = pcVar7 + 1;
		cVar2 = *pcVar7;
		pcVar7 = pcVar6;
	} while (cVar2 != '\0');
	uVar4 = ~uVar4;
	pcVar7 = filenameBuffer;
	puVar8 = (undefined4 *)(pcVar6 + -uVar4);
	puVar9 = (undefined4 *)filenameBuffer;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar9 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	pcVar6 = filenameBuffer;
	while (filenameBuffer[0] != '\0') {
		if (filenameBuffer[0] == '\\') {
			pcVar7 = pcVar6;
		}
		pcVar1 = pcVar6 + 1;
		pcVar6 = pcVar6 + 1;
		filenameBuffer[0] = *pcVar1;
	}
	pcVar7[pcVar7 != filenameBuffer] = '\0';
	BVar3 = lw::LoadAppObj(filename,(APPOBJ **)&struct20,0);
	if (BVar3 == 0) {
		return NULL;
	}
	mesh = Mesh_CreateOnFrame(frame,NULL,0x3000,NULL,MESH_TYPE_LIGHTWAVEOBJECT);
	Mesh_ParseLWO(filenameBuffer,mesh,(APPOBJ *)struct20,noTextures);
	lw::FreeLWOB((APPOBJ *)struct20);
	return mesh;
}



// WARNING: Type propagation algorithm not settling

BOOL __cdecl
lego::res::Mesh_ParseLWO(char *basePath,Mesh *mesh,APPOBJ *lightWaveObject,BOOL noTextures)
{
	float r;
	uint uVar1;
	LWPOLY *pLVar2;
	Vector3F *buffer;
	Vector3F **buffer_00;
	uint *buffer_01;
	undefined4 *buffer_02;
	uint *buffer_03;
	uint *buffer_04;
	void *buffer_05;
	undefined4 *buffer_06;
	Mesh_LightWave_Surface *pMVar3;
	D3DRMGroupIndex groupID;
	char *pcVar4;
	Container_Texture *pCVar5;
	uint uVar6;
	int iVar7;
	float *pfVar8;
	int iVar9;
	float *pfVar10;
	uint *puVar11;
	int iVar12;
	int iVar13;
	int iVar14;
	int iVar15;
	uint uVar16;
	undefined4 *puVar17;
	int iVar18;
	float g;
	float fVar19;
	Point2F *textCoords;
	Point2F *local_ac;
	uint local_a8;
	uint local_a4;
	uint *local_a0;
	int *local_9c;
	Vector3F *local_98;
	uint *local_8c;
	Vector3F **local_88;
	Point2F *local_78;
	Point2F *local_74;
	int local_3c [4];
	undefined4 local_2c;
	undefined4 local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	uVar6 = (lightWaveObject->aoSize).lwVertCount;
	local_3c[2] = 2;
	local_2c = 2;
	uVar1 = (lightWaveObject->aoSize).lwPolyCount;
	iVar12 = uVar6 * 2;
	iVar15 = uVar1 * 6;
	local_3c[0] = 0;
	local_3c[1] = 1;
	local_3c[3] = 0;
	local_28 = 3;
	local_74 = NULL;
	if (lightWaveObject->aoFileUV == NULL) {
		local_78 = (Point2F *)std::malloc(uVar6 * 0x10);
	}
	else {
		local_74 = (Point2F *)std::malloc(uVar6 * 0x140);
		Mesh_UViewMesh(lightWaveObject,local_74);
		iVar12 = (lightWaveObject->aoSize).lwVertCount * 2;
		local_78 = (Point2F *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount * iVar12 * 8);
	}
	uVar16 = iVar12 * (lightWaveObject->aoSize).lwSurfaceCount;
	buffer = (Vector3F *)std::malloc(uVar16 * 0xc);
	buffer_00 = (Vector3F **)std::malloc(uVar16 * 4);
	buffer_01 = (uint *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount << 2);
	buffer_02 = (undefined4 *)std::malloc(uVar16 * 4);
	buffer_03 = (uint *)std::malloc(iVar15 * (lightWaveObject->aoSize).lwSurfaceCount * 4);
	buffer_04 = (uint *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount << 2);
	buffer_05 = std::malloc((lightWaveObject->aoSize).lwPolyCount * 0xc);
	buffer_06 = (undefined4 *)std::malloc(iVar12 * 0xc);
	puVar11 = buffer_01;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (uint *)((int)puVar11 + 1);
	}
	puVar17 = buffer_02;
	for (uVar16 &= 0x3fffffff; uVar16 != 0; uVar16 -= 1) {
		*puVar17 = 0xffffffff;
		puVar17 = puVar17 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar17 = 0xff;
		puVar17 = (undefined4 *)((int)puVar17 + 1);
	}
	puVar11 = buffer_04;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (uint *)((int)puVar11 + 1);
	}
	puVar17 = buffer_06;
	for (uVar6 = iVar12 * 3 & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
		*puVar17 = 0;
		puVar17 = puVar17 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar17 = 0;
		puVar17 = (undefined4 *)((int)puVar17 + 1);
	}
	pMVar3 = (Mesh_LightWave_Surface *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount * 0x3c);
	mesh->lightWaveSurf = pMVar3;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount * 0xf & 0x3fffffff; uVar6 != 0; uVar6 -= 1)
	{
		pMVar3->textureSeq = NULL;
		pMVar3 = (Mesh_LightWave_Surface *)&pMVar3->texture;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)&pMVar3->textureSeq = 0;
		pMVar3 = (Mesh_LightWave_Surface *)((int)&pMVar3->textureSeq + 1);
	}
	local_8c = NULL;
	if ((lightWaveObject->aoSize).lwPolyCount != 0) {
		local_9c = NULL;
		do {
			pLVar2 = lightWaveObject->aoPoly;
			pfVar10 = lightWaveObject->aoVerts;
			pfVar8 = &local_24.y;
			uVar6 = 0;
			do {
				uVar16 = uVar6 + 2;
				uVar6 = (uint)*(ushort *)(uVar6 + *(int *)((int)&pLVar2->plyData + (int)local_9c));
				pfVar8[-1] = pfVar10[uVar6 * 3];
				*pfVar8 = pfVar10[uVar6 * 3 + 1];
				pfVar8[1] = pfVar10[uVar6 * 3 + 2];
				pfVar8 = pfVar8 + 3;
				uVar6 = uVar16;
			} while (uVar16 < 6);
			math::Maths_PlaneNormal
								((Vector3F *)((int)buffer_05 + (int)local_9c),&local_24,&local_18,&local_c);
			local_8c = (uint *)((int)local_8c + 1);
			local_9c = (int *)((int)local_9c + 0xc);
		} while (local_8c < (lightWaveObject->aoSize).lwPolyCount);
	}
	Mesh_GetSurfInfo(basePath,lightWaveObject,mesh->lightWaveSurf,noTextures);
	iVar7 = 0;
	local_8c = NULL;
	if ((lightWaveObject->aoSize).lwPolyCount != 0) {
		pfVar10 = (float *)((int)buffer_05 + 8);
		do {
			iVar9 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
			iVar13 = iVar15 * iVar9;
			iVar9 = iVar12 * iVar9;
			if (*(int *)((int)&lightWaveObject->aoPoly->plyCount + iVar7) == 3) {
				local_a4 = 0;
				do {
					iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
					uVar6 = (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4);
					if (buffer_02[uVar6 + iVar9] == -1) {
						buffer[buffer_01[*(int *)(iVar14 + 4)] + iVar9].x = lightWaveObject->aoVerts[uVar6 * 3];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].y
								 = lightWaveObject->aoVerts[uVar6 * 3 + 1];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].z
								 = lightWaveObject->aoVerts[uVar6 * 3 + 2];
						if (lightWaveObject->aoFileUV != NULL) {
							iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
							uVar16 = (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4);
							uVar6 = buffer_01[*(int *)(iVar14 + 4)];
							local_78[uVar6 + iVar9].x = local_74[uVar16].x;
							local_78[uVar6 + iVar9].y = local_74[uVar16].y;
						}
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + local_a4);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + local_a4);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 +
																pfVar8[2] * pfVar8[2] +
																(float)buffer_06[uVar6 * 3 + 1] * (float)buffer_06[uVar6 * 3 + 1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_00[buffer_01[*(int *)(iVar14 + 4)] + iVar9] =
								 (Vector3F *)(buffer_06 + (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) * 3);
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						buffer_03[buffer_04[iVar14] + iVar13] = buffer_01[iVar14];
						buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
								 buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_02[(uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) + iVar9] =
								 buffer_01[*(int *)(iVar14 + 4)];
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						puVar11 = buffer_01;
					}
					else {
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						pfVar8 = (float *)(buffer_06 +
															(uint)*(ushort *)
																		 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) +
																		 local_a4) * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 + pfVar8[2] * pfVar8[2] + pfVar8[1] * pfVar8[1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_03[buffer_04[*(int *)(iVar14 + 4)] + iVar13] =
								 buffer_02[(uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) + iVar9];
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						puVar11 = buffer_04;
					}
					local_a4 += 2;
					puVar11[iVar14] = puVar11[iVar14] + 1;
				} while (local_a4 < 6);
			}
			else {
				local_9c = local_3c;
				local_a8 = 6;
				do {
					iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
					iVar14 = *local_9c * 2;
					uVar6 = (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14);
					if (buffer_02[iVar9 + uVar6] == -1) {
						buffer[buffer_01[*(int *)(iVar18 + 4)] + iVar9].x = lightWaveObject->aoVerts[uVar6 * 3];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].y
								 = lightWaveObject->aoVerts[uVar6 * 3 + 1];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].z
								 = lightWaveObject->aoVerts[uVar6 * 3 + 2];
						if (lightWaveObject->aoFileUV != NULL) {
							iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
							uVar16 = (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14);
							uVar6 = buffer_01[*(int *)(iVar18 + 4)];
							local_78[uVar6 + iVar9].x = local_74[uVar16].x;
							local_78[uVar6 + iVar9].y = local_74[uVar16].y;
						}
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + iVar14);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + iVar14);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 +
																(float)buffer_06[uVar6 * 3 + 2] * (float)buffer_06[uVar6 * 3 + 2] +
																(float)buffer_06[uVar6 * 3 + 1] * (float)buffer_06[uVar6 * 3 + 1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_00[buffer_01[*(int *)(iVar18 + 4)] + iVar9] =
								 (Vector3F *)(buffer_06 + (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) * 3);
						iVar18 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						buffer_03[buffer_04[iVar18] + iVar13] = buffer_01[iVar18];
						buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
								 buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_02[(uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) + iVar9] =
								 buffer_01[*(int *)(iVar18 + 4)];
						puVar11 = buffer_01;
					}
					else {
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						pfVar8 = (float *)(buffer_06 +
															(uint)*(ushort *)
																		 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) +
																		 iVar14) * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 + pfVar8[2] * pfVar8[2] + pfVar8[1] * pfVar8[1]);
						*pfVar8 = *pfVar8 * fVar19;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_03[buffer_04[*(int *)(iVar18 + 4)] + iVar13] =
								 buffer_02[(uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) + iVar9];
						puVar11 = buffer_04;
					}
					puVar11[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
							 puVar11[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
					local_9c = local_9c + 1;
					local_a8 += -1;
				} while (local_a8 != 0);
			}
			local_8c = (uint *)((int)local_8c + 1);
			iVar7 += 0xc;
			pfVar10 = pfVar10 + 3;
		} while (local_8c < (lightWaveObject->aoSize).lwPolyCount);
	}
	iVar15 = 0;
	local_a8 = 0;
	if ((lightWaveObject->aoSize).lwSurfaceCount != 0) {
		local_a4 = 0;
		local_ac = local_78;
		local_a0 = buffer_01;
		local_98 = buffer;
		local_8c = buffer_03;
		local_88 = buffer_00;
		do {
			uVar6 = *(uint *)(((int)buffer_04 - (int)buffer_01) + (int)local_a0);
			groupID = Mesh_AddGroup(mesh,uVar6,uVar6 / 3,3,local_8c);
			if (lightWaveObject->aoFileUV == NULL) {
				pcVar4 = lightWaveObject->aoSurface->srfTCLR + local_a4 + -0x10;
				Mesh_GetTextureUVsWrap
									(*local_a0,local_98,local_78,*(float *)(pcVar4 + 0x24),*(float *)(pcVar4 + 0x28),
									 *(float *)(pcVar4 + 0x2c),*(float *)(pcVar4 + 0x30),*(float *)(pcVar4 + 0x34),
									 *(float *)(pcVar4 + 0x38),*(LWTEXFLAGS *)(pcVar4 + 0x14));
				uVar6 = *local_a0;
				textCoords = local_78;
			}
			else {
				uVar6 = *local_a0;
				textCoords = local_ac;
			}
			Mesh_SetVertices_VNT(mesh,groupID,0,uVar6,local_98,local_88,(Point2I *)textCoords);
			if ((*(uint *)((int)&mesh->lightWaveSurf->flags + iVar15) & 0x200) == 0) {
				uVar6 = 0x3000;
			}
			else {
				Mesh_AlterGroupRenderFlags(mesh,groupID,0x2800);
				uVar6 = 0x2800;
			}
			if ((*(uint *)((int)&mesh->lightWaveSurf->flags + iVar15) & 0x100) != 0) {
				uVar6 |= 0x4000000;
				Mesh_AlterGroupRenderFlags(mesh,groupID,uVar6);
			}
			if ((*(byte *)((int)&mesh->lightWaveSurf->texFlags + iVar15) & 0x20) == 0) {
				Mesh_AlterGroupRenderFlags(mesh,groupID,uVar6 | 0x800000);
			}
			if ((lightWaveObject->aoSurface->srfTCLR[local_a4 + 4] & 0x80U) == 0) {
				pCVar5 = *(Container_Texture **)((int)&mesh->lightWaveSurf->texture + iVar15);
				if (pCVar5 != NULL) goto LAB_004818c5;
			}
			else {
				pCVar5 = *(Container_Texture **)((int)&mesh->lightWaveSurf->textureSeq + iVar15);
				if (pCVar5 != NULL) {
					pCVar5 = (Container_Texture *)pCVar5->surface;
LAB_004818c5:
					Mesh_SetGroupTexture(mesh,groupID,pCVar5);
				}
			}
			pMVar3 = mesh->lightWaveSurf;
			iVar7 = (int)&pMVar3->textureSeq + iVar15;
			Mesh_SetGroupColour(mesh,groupID,*(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x1c),
													*(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x1c),
													*(float *)((int)&(pMVar3->colour).blue + iVar15) *
													*(float *)((int)&pMVar3->diffuse + iVar15),MATERIAL_DIFFUSE);
			iVar7 = (int)&mesh->lightWaveSurf->textureSeq + iVar15;
			Mesh_SetGroupColour(mesh,groupID,*(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x20),
													*(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x20),
													*(float *)(iVar7 + 0x14) * *(float *)(iVar7 + 0x20),MATERIAL_EMISSIVE);
			iVar7 = (int)&mesh->lightWaveSurf->textureSeq + iVar15;
			if ((*(byte *)((int)&mesh->lightWaveSurf->flags + iVar15) & 8) == 0) {
				fVar19 = *(float *)(iVar7 + 0x24);
				g = *(float *)(iVar7 + 0x24);
				r = *(float *)(iVar7 + 0x24);
			}
			else {
				fVar19 = *(float *)(iVar7 + 0x14) * *(float *)(iVar7 + 0x24);
				g = *(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x24);
				r = *(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x24);
			}
			Mesh_SetGroupColour(mesh,groupID,r,g,fVar19,MATERIAL_SPECULAR);
			Mesh_SetGroupMaterialValues
								(mesh,groupID,*(float *)((int)&mesh->lightWaveSurf->power + iVar15) * 10.0,
								 MATERIAL_POWER);
			Mesh_SetGroupMaterialValues
								(mesh,groupID,1.0 - *(float *)((int)&mesh->lightWaveSurf->transparency + iVar15),
								 MATERIAL_ALPHA);
			pMVar3 = (Mesh_LightWave_Surface *)((int)&mesh->lightWaveSurf->textureSeq + iVar15);
			iVar15 += 0x3c;
			mesh->groupList[groupID].lightWaveSurfaceInfo = pMVar3;
			local_ac = local_ac + iVar12;
			local_88 = local_88 + iVar12;
			local_98 = local_98 + iVar12;
			local_8c = local_8c + uVar1 * 6;
			local_a0 = local_a0 + 1;
			local_a8 += 1;
			local_a4 += 0x54;
		} while (local_a8 < (lightWaveObject->aoSize).lwSurfaceCount);
	}
	std::free(buffer);
	std::free(buffer_00);
	std::free(local_78);
	std::free(buffer_01);
	std::free(buffer_02);
	std::free(buffer_03);
	std::free(buffer_04);
	std::free(buffer_05);
	std::free(buffer_06);
	if (local_74 != NULL) {
		std::free(local_74);
	}
	return 1;
}



void __cdecl
lego::res::Mesh_GetSurfInfo
					(char *basePath,APPOBJ *param_2,Mesh_LightWave_Surface *lightWaveSurf,BOOL noTextures)
{
	byte bVar1;
	char *path;
	BOOL BVar2;
	void *pvVar3;
	Container_Texture *pCVar4;
	float fVar5;
	ColourRGBAF *pCVar6;
	int iVar7;
	uint local_618;
	uint local_614;
	uint local_610;
	uint local_60c;
	char local_608 [4];
	char local_604 [260];
	char local_500 [256];
	char local_400 [256];
	char local_300 [256];
	char local_200 [256];
	char local_100 [256];
	
	local_614 = 0;
	if ((param_2->aoSize).lwSurfaceCount != 0) {
		pCVar6 = &lightWaveSurf->colour;
		iVar7 = 0;
		do {
			path = *(char **)(param_2->aoSurface->srfTCLR + iVar7 + -8);
			if ((path == NULL) || (noTextures != 0)) {
				pCVar6->red = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -4] * 0.00390625;
				pCVar6->green = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -3] * 0.00390625;
				bVar1 = param_2->aoSurface->srfTCLR[iVar7 + -2];
LAB_00481d09:
				local_618 = (uint)bVar1;
				pCVar6->blue = (float)local_618 * 0.00390625;
			}
			else {
				std::_splitpath(path,local_608,local_100,local_400,local_500);
				if ((param_2->aoSurface->srfTCLR[iVar7 + 4] & 0x80U) == 0) {
					std::sprintf(local_604,"%s%s",local_400,local_500);
					pCVar4 = Mesh_LoadTexture(basePath,local_604,0,0);
					pCVar6[-1].blue = (float)pCVar4;
				}
				else {
					BVar2 = Mesh_GetTextureSeqInfo(local_400,local_200,(int *)&local_60c,(int *)&local_610);
					if (BVar2 != 0) {
						pvVar3 = std::malloc(400);
						pCVar6[-1].green = (float)pvVar3;
						fVar5 = 0.0;
						do {
							Mesh_GetNextInSequence(local_200,local_300,&local_60c,local_610);
							std::sprintf(local_604,"%s%s",local_300,local_500);
							pCVar4 = Mesh_LoadTexture(basePath,local_604,0,0);
							*(Container_Texture **)((int)pCVar6[-1].green + (int)fVar5 * 4) = pCVar4;
							if (*(int *)((int)pCVar6[-1].green + (int)fVar5 * 4) == 0) break;
							fVar5 = (float)((int)fVar5 + 1);
						} while ((uint)fVar5 < 100);
						pCVar6[-1].alpha = fVar5;
						pvVar3 = std::realloc((void *)pCVar6[-1].green,(int)fVar5 * 4);
						pCVar6[-1].green = (float)pvVar3;
					}
				}
				if ((param_2->aoSurface->srfTCLR[iVar7 + 8] & 0x80U) != 0) {
					pCVar6->red = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -4] * 0.00390625;
					pCVar6->green = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -3] * 0.00390625;
					bVar1 = param_2->aoSurface->srfTCLR[iVar7 + -2];
					goto LAB_00481d09;
				}
				pCVar6->red = 1.0;
				pCVar6->green = 1.0;
				pCVar6->blue = 1.0;
			}
			pCVar6[1].green = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x2c);
			pCVar6[2].red = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x30);
			pCVar6[1].red = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x34);
			pCVar6[1].blue = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x3c);
			pCVar6[1].alpha = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x40);
			pCVar6[2].green = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 8);
			pCVar6[2].blue = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 4);
			local_614 += 1;
			pCVar6 = (ColourRGBAF *)&pCVar6[3].alpha;
			iVar7 = iVar7 + 0x54;
		} while (local_614 < (param_2->aoSize).lwSurfaceCount);
	}
	return;
}



BOOL __cdecl
lego::res::Mesh_GetTextureSeqInfo(char *tname,char *out_tfname,int *out_tstart,int *out_tnumlen)
{
	char cVar1;
	byte bVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	undefined4 *puVar11;
	bool bVar12;
	int local_4;
	
	pcVar9 = tname;
	uVar3 = 0xffffffff;
	pcVar10 = tname;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar10 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar6 = 1;
	local_4 = 0;
	if ((0x2f < (byte)tname[uVar3 - 2]) && ((byte)tname[uVar3 - 2] < 0x3a)) {
		iVar7 = uVar3 - 2;
		bVar12 = iVar7 == 0;
		if (!bVar12) {
			do {
				bVar2 = pcVar9[iVar7];
				tname = (char *)(uint)bVar2;
				if ((bVar2 < 0x30) || (0x39 < bVar2)) break;
				local_4 += (int)(tname + -0x30) * iVar6;
				iVar6 *= 10;
				iVar7 += -1;
			} while (iVar7 != 0);
			bVar12 = iVar7 == 0;
		}
		if (!bVar12) {
			uVar4 = 0xffffffff;
			do {
				pcVar10 = pcVar9;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pcVar10 = pcVar9 + 1;
				cVar1 = *pcVar9;
				pcVar9 = pcVar10;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar8 = (undefined4 *)(pcVar10 + -uVar4);
			puVar11 = (undefined4 *)out_tfname;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
				*puVar11 = *puVar8;
				puVar8 = puVar8 + 1;
				puVar11 = puVar11 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar11 = *(undefined *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			out_tfname[iVar7 + 1] = '\0';
			*out_tnumlen = (uVar3 - iVar7) + -2;
			*out_tstart = local_4;
			return (BOOL)out_tnumlen;
		}
	}
	return (BOOL)NULL;
}



void __cdecl
lego::res::Mesh_GetNextInSequence
					(char *baseName,char *out_nextTextName,uint *out_texNum,uint tnumlen)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	char local_10 [16];
	
	uVar3 = 0xffffffff;
	do {
		pcVar8 = baseName;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar8 = baseName + 1;
		cVar1 = *baseName;
		baseName = pcVar8;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar6 = (undefined4 *)(pcVar8 + -uVar3);
	puVar10 = (undefined4 *)out_nextTextName;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar10 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	std::sprintf(local_10,"%d",*out_texNum);
	uVar3 = 0xffffffff;
	pcVar8 = local_10;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar1 != '\0');
	iVar2 = tnumlen - (~uVar3 - 1);
	while (iVar2 != 0) {
		uVar3 = 0xffffffff;
		pcVar8 = "0";
		do {
			pcVar7 = pcVar8;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar7 = pcVar8 + 1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		iVar5 = -1;
		pcVar8 = out_nextTextName;
		do {
			pcVar9 = pcVar8;
			if (iVar5 == 0) break;
			iVar5 += -1;
			pcVar9 = pcVar8 + 1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar9;
		} while (cVar1 != '\0');
		puVar6 = (undefined4 *)(pcVar7 + -uVar3);
		puVar10 = (undefined4 *)(pcVar9 + -1);
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar10 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar10 = puVar10 + 1;
		}
		iVar2 += -1;
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	uVar3 = 0xffffffff;
	*out_texNum = *out_texNum + 1;
	pcVar8 = local_10;
	do {
		pcVar7 = pcVar8;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar7 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar2 = -1;
	do {
		pcVar8 = out_nextTextName;
		if (iVar2 == 0) break;
		iVar2 += -1;
		pcVar8 = out_nextTextName + 1;
		cVar1 = *out_nextTextName;
		out_nextTextName = pcVar8;
	} while (cVar1 != '\0');
	puVar6 = (undefined4 *)(pcVar7 + -uVar3);
	puVar10 = (undefined4 *)(pcVar8 + -1);
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar10 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return;
}



void __cdecl lego::res::Mesh_UViewMesh(APPOBJ *lightWaveObject,Point2F *textCoords)
{
	ushort *puVar1;
	float fVar2;
	float fVar3;
	char cVar4;
	File *file;
	bool bVar5;
	undefined4 *buffer;
	char *pcVar6;
	float *pfVar7;
	uint uVar8;
	int iVar9;
	uint uVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	float10 fVar14;
	int local_840;
	int local_83c;
	int local_838;
	uint local_834;
	int local_830;
	int local_820;
	char *local_814;
	char *local_810;
	char line [1024];
	char lineSplit [1024];
	
	file = lightWaveObject->aoFileUV;
	local_838 = -1;
	local_83c = -1;
	local_830 = 0;
	local_840 = -2;
	local_834 = 0;
	buffer = (undefined4 *)std::malloc((lightWaveObject->aoSize).lwVertCount << 3);
	puVar11 = buffer;
	for (uVar8 = ((lightWaveObject->aoSize).lwVertCount << 3) >> 2; uVar8 != 0; uVar8 -= 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar9 = 0; iVar9 != 0; iVar9 += -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	pcVar6 = lego::file::File_GetLine(line,0x400,file);
	do {
		if (pcVar6 == NULL) {
			std::free(buffer);
			return;
		}
		uVar8 = 0xffffffff;
		pcVar6 = line;
		do {
			pcVar12 = pcVar6;
			if (uVar8 == 0) break;
			uVar8 -= 1;
			pcVar12 = pcVar6 + 1;
			cVar4 = *pcVar6;
			pcVar6 = pcVar12;
		} while (cVar4 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar12 + -uVar8);
		puVar13 = (undefined4 *)lineSplit;
		for (uVar10 = uVar8 >> 2; uVar10 != 0; uVar10 -= 1) {
			*puVar13 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar13 = puVar13 + 1;
		}
		for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
			*(undefined *)puVar13 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		iVar9 = util::Util_WSTokenise(lineSplit,&local_814);
		if (iVar9 != 0) {
			if (local_830 == 2) {
				local_838 = 0;
			}
			if (local_838 != -1) {
				uVar8 = (lightWaveObject->aoSize).lwSurfaceCount;
				if (local_838 < (int)(uVar8 * 2)) {
					if ((int)uVar8 <= local_838) {
						pcVar6 = util::_strdup(local_814);
						lightWaveObject->aoSurface[local_838 - (lightWaveObject->aoSize).lwSurfaceCount].srfPath
								 = pcVar6;
					}
					local_838 += 1;
				}
				else {
					local_838 = -1;
					local_840 = -1;
				}
			}
			if (local_840 != -2) {
				if (local_840 == -1) {
					local_840 = 0;
				}
				else {
					uVar8 = (lightWaveObject->aoSize).lwPolyCount;
					if ((int)uVar8 <= local_840) {
						return;
					}
					if ((local_83c == -1) || ((int)lightWaveObject->aoPoly[local_820].plyCount <= local_83c))
					{
						if (local_840 < (int)(uVar8 - 1)) {
							local_820 = std::atoi(local_814);
							if (local_83c != -1) {
								local_840 += 1;
							}
							local_83c = 0;
						}
					}
					else {
						fVar14 = std::atof(local_814);
						fVar2 = (float)fVar14;
						fVar14 = std::atof(local_810);
						fVar3 = (float)-fVar14;
						uVar8 = (uint)lightWaveObject->aoPoly[local_820].plyData[local_83c];
						if ((textCoords[uVar8].x == fVar2) && (textCoords[uVar8].y == fVar3)) {
							bVar5 = false;
						}
						else {
							bVar5 = true;
						}
						if (buffer[uVar8] == 0) {
							textCoords[uVar8].x = fVar2;
							textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].y = fVar3;
							puVar1 = lightWaveObject->aoPoly[local_820].plyData + local_83c;
							local_83c += 1;
							buffer[*puVar1] = 1;
						}
						else {
							if (bVar5) {
								if (local_834 == 0) {
									pfVar7 = (float *)std::realloc(lightWaveObject->aoVerts,
																								 ((lightWaveObject->aoSize).lwVertCount + 0xb) * 0xc
																								);
									lightWaveObject->aoVerts = pfVar7;
								}
								uVar10 = (uint)lightWaveObject->aoPoly[local_820].plyData[local_83c];
								uVar8 = (lightWaveObject->aoSize).lwVertCount;
								lightWaveObject->aoVerts[uVar8 * 3] = lightWaveObject->aoVerts[uVar10 * 3];
								lightWaveObject->aoVerts[uVar8 * 3 + 1] = lightWaveObject->aoVerts[uVar10 * 3 + 1];
								lightWaveObject->aoVerts[uVar8 * 3 + 2] = lightWaveObject->aoVerts[uVar10 * 3 + 2];
								lightWaveObject->aoPoly[local_820].plyData[local_83c] =
										 *(ushort *)&(lightWaveObject->aoSize).lwVertCount;
								textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].x = fVar2;
								textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].y = fVar3;
								local_834 += 1;
								(lightWaveObject->aoSize).lwVertCount = (lightWaveObject->aoSize).lwVertCount + 1;
								if (9 < local_834) {
									local_834 = 0;
								}
							}
							local_83c += 1;
						}
					}
				}
			}
			local_830 += 1;
		}
		pcVar6 = lego::file::File_GetLine(line,0x400,file);
	} while( true );
}



void __cdecl
lego::res::Mesh_GetTextureUVsWrap
					(uint vertexCount,Vector3F *vertices,Point2F *coords,float sx,float sy,float sz,float px,
					float py,float pz,LWTEXFLAGS flags)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float *pfVar4;
	
	if (vertexCount != 0) {
		pfVar4 = &vertices->z;
		do {
			fVar1 = pfVar4[-1];
			fVar2 = *pfVar4;
			if ((flags & TFM_AXIS_X) == 0) {
				fVar3 = (pfVar4[-2] - px) / sx;
			}
			else {
				fVar3 = (fVar2 - pz) / sz;
			}
			coords->x = fVar3 - -0.5;
			if ((flags & TFM_AXIS_Y) == 0) {
				fVar1 = (fVar1 - py) / sy;
			}
			else {
				fVar1 = (fVar2 - pz) / sz;
			}
			pfVar4 = pfVar4 + 3;
			vertexCount -= 1;
			coords->y = fVar1 - -0.5;
			coords = coords + 1;
		} while (vertexCount != 0);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_SetTextureTime2(Mesh *mesh,float frame)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	D3DRMGroupIndex groupID;
	float10 fVar4;
	longlong lVar5;
	
	fVar4 = std::fmod((float10)frame,(float10)1.0);
	lVar5 = __ftol((float10)frame - fVar4);
	if ((*(byte *)&mesh->flags & 4) == 0) {
		return 0;
	}
	groupID = D3DRMGROUP_0;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			piVar1 = *(int **)((int)&mesh->groupList->lightWaveSurfaceInfo + iVar3);
			if (((*(byte *)(piVar1 + 0xd) & 0x80) != 0) && (piVar1[2] != 0)) {
				iVar2 = (piVar1[0xe] + (int)lVar5) % piVar1[2];
				if (iVar2 < 0) {
					iVar2 = 0;
				}
				Mesh_SetGroupTexture(mesh,groupID,*(Container_Texture **)(*piVar1 + iVar2 * 4));
			}
			groupID += 1;
			iVar3 += 0x70;
		} while (groupID < mesh->groupCount);
	}
	return 1;
}



void __cdecl lego::res::Mesh_Remove(Mesh *mesh,IDirect3DRMFrame3 *frame)
{
	Mesh *pMVar1;
	IDirect3DRMUserVisual *pIVar2;
	uint uVar3;
	D3DRMGroupIndex groupID;
	int iVar4;
	int iVar5;
	
	(*frame->lpVtbl->DeleteVisual)(frame,(IDirect3DRMVisual *)mesh->uv);
	pMVar1 = mesh->clonedFrom;
	groupID = D3DRMGROUP_0;
	if (pMVar1 != NULL) {
		pIVar2 = mesh->uv;
		if (pIVar2 != NULL) {
			(*pIVar2->lpVtbl->Release)((IUnknown *)pIVar2);
			mesh->uv = NULL;
		}
		std::free(mesh->groupList);
		Mesh_ReturnToList(mesh);
		mesh = pMVar1;
	}
	uVar3 = mesh->numOfRefs - 1;
	mesh->numOfRefs = uVar3;
	if (uVar3 == 0) {
		pIVar2 = mesh->uv;
		if (pIVar2 != NULL) {
			(*pIVar2->lpVtbl->Release)((IUnknown *)pIVar2);
			mesh->uv = NULL;
		}
		if (mesh->groupCount != 0) {
			iVar4 = 0;
			do {
				iVar5 = (int)&mesh->groupList->faceDataSize + iVar4;
				Mesh_RemoveGroupTexture(mesh,groupID);
				std::free(*(void **)(iVar5 + 8));
				std::free(*(void **)(iVar5 + 0xc));
				groupID += 1;
				iVar4 += 0x70;
			} while (groupID < mesh->groupCount);
		}
		if (mesh->lightWaveSurf != NULL) {
			std::free(mesh->lightWaveSurf);
		}
		std::free(mesh->groupList);
		Mesh_ReturnToList(mesh);
	}
	return;
}



Mesh_Group * __cdecl
lego::res::Mesh_GetGroup
					(Mesh *mesh,D3DRMGroupIndex groupID,uint *out_vertexCount,uint *unused_out_faceCount,
					uint *out_vPerFace,uint *out_faceDataSize,uint *out_faceData)
{
	ushort *puVar1;
	Mesh_Group *pMVar2;
	uint uVar3;
	
	pMVar2 = mesh->groupList + groupID;
	if (out_vertexCount != NULL) {
		*out_vertexCount = pMVar2->vertexCount;
	}
	if (out_vPerFace != NULL) {
		*out_vPerFace = 3;
	}
	if (out_faceDataSize != NULL) {
		*out_faceDataSize = pMVar2->faceDataSize;
	}
	if ((out_faceData != NULL) && (uVar3 = 0, pMVar2->faceDataSize != 0)) {
		do {
			puVar1 = pMVar2->faceData + uVar3;
			uVar3 += 1;
			*out_faceData = (uint)*puVar1;
			out_faceData = out_faceData + 1;
		} while (uVar3 < pMVar2->faceDataSize);
	}
	return pMVar2;
}



uint __cdecl lego::res::Mesh_GetGroupCount(Mesh *mesh)
{
	return mesh->groupCount;
}



int __cdecl
lego::res::Mesh_AddGroup(Mesh *mesh,uint vertexCount,uint faceCount,uint vPerFace,uint *faceData)
{
	ushort uVar1;
	Mesh_Group *pMVar2;
	ushort *puVar3;
	uint uVar4;
	Mesh_Vertex *pMVar5;
	int iVar6;
	Mesh_Group *pMVar7;
	uint uVar8;
	
	if (mesh->groupList == NULL) {
		mesh->listSize = 10;
		mesh->groupCount = 1;
		pMVar2 = (Mesh_Group *)std::malloc(0x460);
		mesh->groupList = pMVar2;
	}
	else {
		uVar4 = mesh->groupCount;
		mesh->groupCount = uVar4 + 1;
		if (uVar4 == mesh->listSize) {
			uVar4 = (mesh->listSize * 0x96) / 100;
			pMVar2 = (Mesh_Group *)std::realloc(mesh->groupList,uVar4 * 0x70);
			if (pMVar2 == NULL) {
				return -1;
			}
			mesh->groupList = pMVar2;
			mesh->listSize = uVar4;
		}
	}
	pMVar2 = mesh->groupList + (mesh->groupCount - 1);
	pMVar7 = pMVar2;
	for (iVar6 = 0x1c; iVar6 != 0; iVar6 += -1) {
		pMVar7->faceDataSize = 0;
		pMVar7 = (Mesh_Group *)&pMVar7->vertexCount;
	}
	uVar8 = vPerFace * faceCount;
	puVar3 = (ushort *)std::malloc(uVar8 * 2);
	pMVar2->faceData = puVar3;
	uVar4 = 0;
	pMVar2->faceDataSize = uVar8;
	if (uVar8 != 0) {
		do {
			uVar1 = *(ushort *)faceData;
			faceData = faceData + 1;
			pMVar2->faceData[uVar4] = uVar1;
			uVar4 += 1;
		} while (uVar4 < pMVar2->faceDataSize);
	}
	pMVar5 = (Mesh_Vertex *)std::malloc(vertexCount << 5);
	pMVar2->vertices = pMVar5;
	for (uVar4 = (vertexCount << 5) >> 2; uVar4 != 0; uVar4 -= 1) {
		(pMVar5->position).x = 0.0;
		pMVar5 = (Mesh_Vertex *)&(pMVar5->position).y;
	}
	for (iVar6 = 0; iVar6 != 0; iVar6 += -1) {
		*(undefined *)&(pMVar5->position).x = 0;
		pMVar5 = (Mesh_Vertex *)((int)&(pMVar5->position).x + 1);
	}
	pMVar2->vertexCount = vertexCount;
	pMVar2->flags = 0;
	Mesh_CreateGroupMaterial(mesh,mesh->groupCount + D3DRMGROUP_ALLGROUPS);
	return mesh->groupCount - 1;
}



void __cdecl lego::res::Mesh_AlterGroupRenderFlags(Mesh *mesh,D3DRMGroupIndex groupID,uint newFlags)
{
	mesh->groupList[groupID].renderFlags = newFlags;
	return;
}



void __cdecl lego::res::Mesh_Scale(Mesh *mesh,float x,float y,float z)
{
	float *pfVar1;
	float *pfVar2;
	Mesh_Group *iVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	
	uVar5 = 0;
	if (mesh->groupCount != 0) {
		iVar7 = 0;
		do {
			uVar6 = 0;
			iVar3 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar7);
			if (iVar3->vertexCount != 0) {
				iVar4 = 0;
				do {
					uVar6 += 1;
					*(float *)((int)&(iVar3->vertices->position).x + iVar4) =
							 x * *(float *)((int)&(iVar3->vertices->position).x + iVar4);
					*(float *)((int)&(iVar3->vertices->position).y + iVar4) =
							 y * *(float *)((int)&(iVar3->vertices->position).y + iVar4);
					pfVar1 = (float *)((int)&(iVar3->vertices->position).z + iVar4);
					pfVar2 = (float *)((int)&(iVar3->vertices->position).z + iVar4);
					iVar4 += 0x20;
					*pfVar2 = z * *pfVar1;
				} while (uVar6 < iVar3->vertexCount);
			}
			uVar5 += 1;
			iVar7 += 0x70;
		} while (uVar5 < mesh->groupCount);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *vertices)
{
	int iVar1;
	float *pfVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		iVar1 = index << 5;
		pfVar2 = &vertices->tu;
		do {
			pfVar4 = (float *)((int)&(pMVar3->vertices->position).x + iVar1);
			*pfVar4 = pfVar2[-6];
			pfVar4[1] = pfVar2[-5];
			pfVar4[2] = pfVar2[-4];
			pfVar4 = (float *)((int)&(pMVar3->vertices->normal).x + iVar1);
			count -= 1;
			*pfVar4 = pfVar2[-3];
			pfVar4[1] = pfVar2[-2];
			pfVar4[2] = pfVar2[-1];
			*(float *)((int)&pMVar3->vertices->tu + iVar1) = *pfVar2;
			*(float *)((int)&pMVar3->vertices->tv + iVar1) = pfVar2[1];
			iVar1 = iVar1 + 0x20;
			pfVar2 = pfVar2 + 9;
		} while (count != 0);
	}
	return;
}



void __cdecl
lego::res::Mesh_GetVertices
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *out_vertices)
{
	int iVar1;
	float *pfVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		iVar1 = index << 5;
		pfVar2 = &out_vertices->tu;
		do {
			pfVar4 = (float *)((int)&(pMVar3->vertices->position).x + iVar1);
			pfVar2[-6] = *pfVar4;
			pfVar2[-5] = pfVar4[1];
			pfVar2[-4] = pfVar4[2];
			pfVar4 = (float *)((int)&(pMVar3->vertices->normal).x + iVar1);
			count -= 1;
			pfVar2[-3] = *pfVar4;
			pfVar2[-2] = pfVar4[1];
			pfVar2[-1] = pfVar4[2];
			*pfVar2 = *(float *)((int)&pMVar3->vertices->tu + iVar1);
			pfVar2[1] = *(float *)((int)&pMVar3->vertices->tv + iVar1);
			iVar1 = iVar1 + 0x20;
			pfVar2 = pfVar2 + 9;
		} while (count != 0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_PointNormalAt
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F *position,Point2F *textCoords)
{
	float *pfVar1;
	float fVar2;
	Vector3F *pVVar3;
	int iVar4;
	int iVar5;
	Mesh_Group *pMVar6;
	float *pfVar7;
	
	pVVar3 = position;
	pMVar6 = mesh->groupList + groupID;
	if (count != 0) {
		position = (Vector3F *)count;
		iVar5 = index << 5;
		pfVar7 = &vertices->z;
		do {
			*(float *)((int)&(pMVar6->vertices->position).x + iVar5) = pfVar7[-2];
			*(float *)((int)&(pMVar6->vertices->position).y + iVar5) = pfVar7[-1];
			*(float *)((int)&(pMVar6->vertices->position).z + iVar5) = *pfVar7;
			iVar4 = (int)&(pMVar6->vertices->position).x + iVar5;
			*(float *)(iVar4 + 0xc) = pVVar3->x - *(float *)((int)&(pMVar6->vertices->position).x + iVar5)
			;
			*(float *)(iVar4 + 0x10) = pVVar3->y - *(float *)(iVar4 + 4);
			*(float *)(iVar4 + 0x14) = pVVar3->z - *(float *)(iVar4 + 8);
			fVar2 = *(float *)((int)&(pMVar6->vertices->normal).y + iVar5);
			pfVar1 = (float *)((int)&(pMVar6->vertices->normal).x + iVar5);
			fVar2 = 1.0 / SQRT(*pfVar1 * *pfVar1 + pfVar1[2] * pfVar1[2] + fVar2 * fVar2);
			*pfVar1 = *pfVar1 * fVar2;
			pfVar1[1] = fVar2 * pfVar1[1];
			pfVar1[2] = fVar2 * pfVar1[2];
			*(float *)((int)&pMVar6->vertices->tu + iVar5) = textCoords->x;
			*(float *)((int)&pMVar6->vertices->tv + iVar5) = textCoords->y;
			position = (Vector3F *)((int)&position[-1].z + 3);
			iVar5 = iVar5 + 0x20;
			textCoords = textCoords + 1;
			pfVar7 = pfVar7 + 3;
		} while (position != NULL);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_SameNormal
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F *normal,Point2F *textCoords)
{
	float *pfVar1;
	int iVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		groupID = count;
		iVar2 = index << 5;
		pfVar4 = &vertices->z;
		do {
			*(float *)((int)&(pMVar3->vertices->position).x + iVar2) = pfVar4[-2];
			*(float *)((int)&(pMVar3->vertices->position).y + iVar2) = pfVar4[-1];
			*(float *)((int)&(pMVar3->vertices->position).z + iVar2) = *pfVar4;
			pfVar1 = (float *)((int)&(pMVar3->vertices->normal).x + iVar2);
			*pfVar1 = normal->x;
			pfVar1[1] = normal->y;
			pfVar1[2] = normal->z;
			*(float *)((int)&pMVar3->vertices->tu + iVar2) = textCoords->x;
			*(float *)((int)&pMVar3->vertices->tv + iVar2) = textCoords->y;
			groupID += D3DRMGROUP_ALLGROUPS;
			iVar2 = iVar2 + 0x20;
			pfVar4 = pfVar4 + 3;
			textCoords = textCoords + 1;
		} while (groupID != D3DRMGROUP_0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_VNT
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F **normal,Point2I *textCoords)
{
	int iVar1;
	Mesh_Group *pMVar2;
	float *pfVar3;
	
	pMVar2 = mesh->groupList + groupID;
	if (count != 0) {
		groupID = count;
		iVar1 = index << 5;
		pfVar3 = &vertices->z;
		do {
			*(float *)((int)&(pMVar2->vertices->position).x + iVar1) = pfVar3[-2];
			*(float *)((int)&(pMVar2->vertices->position).y + iVar1) = pfVar3[-1];
			*(float *)((int)&(pMVar2->vertices->position).z + iVar1) = *pfVar3;
			*(float *)((int)&(pMVar2->vertices->normal).x + iVar1) = (*normal)->x;
			*(float *)((int)&(pMVar2->vertices->normal).y + iVar1) = (*normal)->y;
			*(float *)((int)&(pMVar2->vertices->normal).z + iVar1) = (*normal)->z;
			*(int *)((int)&pMVar2->vertices->tu + iVar1) = textCoords->x;
			*(int *)((int)&pMVar2->vertices->tv + iVar1) = textCoords->y;
			groupID += D3DRMGROUP_ALLGROUPS;
			iVar1 = iVar1 + 0x20;
			pfVar3 = pfVar3 + 3;
			normal = normal + 1;
			textCoords = textCoords + 1;
		} while (groupID != D3DRMGROUP_0);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_IsGroupHidden(Mesh *mesh,D3DRMGroupIndex groupID)
{
	return mesh->groupList[groupID].flags & 1;
}



void __cdecl lego::res::Mesh_HideGroup(Mesh *mesh,D3DRMGroupIndex groupID,BOOL hide)
{
	Mesh_Group *pMVar1;
	
	pMVar1 = mesh->groupList + groupID;
	if (hide != 0) {
		pMVar1->flags = pMVar1->flags | 1;
		return;
	}
	pMVar1->flags = pMVar1->flags & 0xfffffffe;
	return;
}



void __cdecl lego::res::Mesh_Hide(Mesh *mesh,BOOL hide)
{
	if (hide != 0) {
		mesh->flags = mesh->flags | 1;
		return;
	}
	mesh->flags = mesh->flags & 0xfffffffe;
	return;
}



BOOL __cdecl
lego::res::Mesh_RenderCallback
					(IDirect3DRMUserVisual *lpD3DRMUV,Mesh *lpArg,D3DRMUserVisualReason lpD3DRMUVreason,
					IUnknown *lpD3DRMDev,IDirect3DRMViewport *lpD3DRMview)
{
	Mesh *mesh;
	IDirect3DRMViewport *This;
	Container *pCVar1;
	Viewport *pVVar2;
	Mesh *view;
	BOOL BVar3;
	bool bVar4;
	uint uVar5;
	int iVar6;
	IDirect3DRMViewport2 *unaff_ESI;
	Mesh_Group *pMVar7;
	int unaff_retaddr;
	IDirect3DRMViewport2 *rmView2;
	Matrix4F transform4d;
	
	mesh = lpArg;
	uVar5 = 0;
	if (lpD3DRMUVreason == D3DRMUSERVISUAL_CANSEE) {
		if (((globs::mainGlobs.imDevice != NULL) && ((*(byte *)&lpArg->flags & 1) == 0)) &&
			 ((pCVar1 = Container_SearchOwner(lpArg->frameCreatedOn), pCVar1 == NULL ||
				((*(byte *)&pCVar1->flags & 0x80) == 0)))) {
			if ((mesh->flags & 0x1000000) == 0) {
				return 1;
			}
			if ((mesh->flags & 0x2000000) != 0) {
				return 1;
			}
						// DWORD IDirect3DRMViewport->GetAppData(this)
						// struct with field_28 -> IDirect3DRMFrame3*
			pVVar2 = (*((IDirect3DRMFrame3Vtbl *)lpD3DRMview->lpVtbl)->GetAppData)(lpD3DRMview);
			if (pVVar2->rendering == 0) {
				return 1;
			}
						// IDirect3DRMFrame3->GetScene(this, IDirect3DRMFrame3** lplpRoot)
			(*mesh->frameCreatedOn->lpVtbl->GetScene)(mesh->frameCreatedOn,(IDirect3DRMFrame3 **)&lpArg);
						// IDirect3DRMViewport2->GetCamera(this, IDirect3DRMFrame3** lplpCamera)
			(*pVVar2->lpVP->lpVtbl->GetCamera)(pVVar2->lpVP,(IDirect3DRMFrame3 **)&lpD3DRMview);
						// IDirect3DRMFrame3->LookAt(this, IDirect3DRMFrame3* lpTarget, IDirect3DRMFrame3*
						// lpRef, TD3DRMFrameConstraint rfcConstraint)
						// 
						//  D3DRMCONSTRAIN_Z (0x0)
			(*mesh->frameCreatedOn->lpVtbl->LookAt)
								(mesh->frameCreatedOn,(IDirect3DRMFrame3 *)lpD3DRMview,(IDirect3DRMFrame3 *)lpArg,
								 D3DRMCONSTRAIN_Z);
			mesh->flags = mesh->flags | 0x2000000;
			return 1;
		}
	}
	else {
		if (lpD3DRMUVreason == D3DRMUSERVISUAL_RENDER) {
			if (globs::mainGlobs.imDevice != NULL) {
				lpD3DRMUVreason = D3DRMUSERVISUAL_CANSEE;
				bVar4 = false;
				lpArg->flags = lpArg->flags & 0xfdffffff;
						// IDirect3DDevice3->GetTransform(this, D3DTransformStateType dtstTransformStateType,
						// Matrix4F* lpD3DMatrix)
				(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTransform)
									(globs::mainGlobs.imDevice,D3DTRANSFORMSTATE_WORLD,&transform4d);
				This = lpD3DRMview;
				Mesh_SetCurrentViewport(lpD3DRMview);
						// IDirect3DRMViewport->QueryInterface(this, IID_IDirect3DRMViewport2,
						// IDirect3DRMViewport2** lplpOut)
				(*((IDirect3DRMFrame3Vtbl *)This->lpVtbl)->QueryInterface)
									((IUnknown *)This,(IID *)&idl::IID_IDirect3DRMViewport2,&rmView2);
						// DWORD IDirect3DRMViewport2->GetAppData(this)
				view = (Mesh *)(*unaff_ESI->lpVtbl->GetAppData)(unaff_ESI);
				lpArg = view;
				if ((*(byte *)&mesh->flags & 2) == 0) {
					if (((mesh->renderDesc).renderFlags & 0x1c00) == 0) {
						Mesh_StoreTextureAndMat();
						Mesh_SetMeshRenderDesc(mesh,(Viewport *)view,(Matrix4F *)&stack0xffffffb4,0);
						bVar4 = true;
						Mesh_RenderMesh(mesh,(Matrix4F *)&stack0xffffffb4,0);
					}
					else {
						if (mesh->groupCount != 0) {
							transform4d.values[3][3] = 0.0;
							do {
								pMVar7 = (Mesh_Group *)
												 ((int)&mesh->groupList->faceDataSize + (int)transform4d.values[3][3]);
								BVar3 = Mesh_CanRenderGroup(pMVar7);
								if (BVar3 != 0) {
									if ((pMVar7->flags & 0x80000) == 0) {
										if (pMVar7->renderFlags == 0) {
											if (!bVar4) {
												Mesh_StoreTextureAndMat();
												Mesh_SetMeshRenderDesc
																	(mesh,(Viewport *)lpArg,(Matrix4F *)&stack0xffffffb4,0);
												bVar4 = true;
											}
											Mesh_RenderGroup(mesh,pMVar7,(Matrix4F *)&stack0xffffffb4,0);
										}
									}
									else {
										unaff_retaddr = 1;
									}
								}
								uVar5 += 1;
								transform4d.values[3][3] = (float)((int)transform4d.values[3][3] + 0x70);
							} while (uVar5 < mesh->groupCount);
						}
						iVar6 = 0;
						transform4d.values[3][3] = 0.0;
						if (mesh->groupCount != 0) {
							do {
								pMVar7 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar6);
								BVar3 = Mesh_CanRenderGroup(pMVar7);
								if (BVar3 != 0) {
									if ((pMVar7->flags & 0x80000) == 0) {
										if (pMVar7->renderFlags != 0) {
											if (!bVar4) {
												Mesh_StoreTextureAndMat();
												Mesh_SetMeshRenderDesc
																	(mesh,(Viewport *)lpArg,(Matrix4F *)&stack0xffffffb4,0);
												bVar4 = true;
											}
											Mesh_RenderGroup(mesh,pMVar7,(Matrix4F *)&stack0xffffffb4,0);
										}
									}
									else {
										unaff_retaddr = 1;
									}
								}
								transform4d.values[3][3] = (float)((int)transform4d.values[3][3] + 1);
								iVar6 += 0x70;
							} while ((uint)transform4d.values[3][3] < mesh->groupCount);
						}
						if (unaff_retaddr != 0) {
							Mesh_AddToPostRenderList(mesh,(Matrix4F *)&stack0xffffffb4);
						}
					}
				}
				else {
					Mesh_AddToPostRenderList(mesh,(Matrix4F *)&stack0xffffffb4);
				}
				if (bVar4) {
					main::Main_RestoreStates();
					Mesh_RestoreTextureAndMat();
				}
				if (unaff_ESI != NULL) {
						// IDirect3DRMViewport2->Release(this)
					(*unaff_ESI->lpVtbl->Release)((IUnknown *)unaff_ESI);
				}
			}
			return 1;
		}
	}
	return 0;
}



void __cdecl
lego::res::Mesh_SetMeshRenderDesc(Mesh *mesh,Viewport *view,Matrix4F *matWorld,BOOL alphaBlend)
{
	MeshRenderCallback p_Var1;
	
	p_Var1 = (mesh->renderDesc).renderCallback;
	if (p_Var1 != NULL) {
		(*p_Var1)(mesh,(mesh->renderDesc).renderCallbackData,view);
	}
						// D3DRENDERSTATE_SPECULARENABLE (0x1d), FALSE (0x0)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SPECULARENABLE,FALSE);
						// D3DRENDERSTATE_SHADEMODE (0x9), D3DSHADE_GOURAUD (0x2)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SHADEMODE,D3DSHADE_GOURAUD);
						// D3DRENDERSTATE_DITHERENABLE (0x1a), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_DITHERENABLE,TRUE);
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
						// D3DTSS_COLORARG1 (0x2), D3DTA_TEXTURE (0x2)
		Mesh_ChangeTextureStageState(D3DTSS_COLORARG1,D3DTA_TEXTURE);
						// D3DTSS_COLORARG2 (0x3), D3DTA_DIFFUSE (0x0)
		Mesh_ChangeTextureStageState(D3DTSS_COLORARG2,D3DTA_DIFFUSE);
						// D3DTSS_ALPHAARG1 (0x5), D3DTA_TEXTURE (0x2)
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAARG1,D3DTA_TEXTURE);
						// D3DTSS_ALPHAARG2 (0x6), D3DTA_DIFFUSE (0x0)
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAARG2,D3DTA_DIFFUSE);
	}
	Mesh_SetRenderDesc((mesh->renderDesc).renderFlags,matWorld,alphaBlend);
	return;
}



void __cdecl lego::res::Mesh_SetRenderDesc(uint flags,Matrix4F *matWorld,BOOL alphaBlend)
{
	uint uVar1;
	undefined4 uVar2;
	DWORD dwRenderState;
	Matrix4F identity;
	
	uVar1 = flags & 0x1c00;
	if ((uVar1 != 0) && (alphaBlend != 0)) {
						// D3DRENDERSTATE_FOGENABLE (0x1c), FALSE (0x0)
		main::Main_ChangeRenderState(D3DRENDERSTATE_FOGENABLE,FALSE);
	}
	if ((uVar1 == 0) || (alphaBlend != 0)) {
		if ((flags & 0x400) == 0) {
			if ((flags & 0x800) == 0) {
				if ((flags & 0x1000) == 0) goto LAB_00482e79;
						// D3DBLEND_SRCALPHA (0x5), D3DBLEND_INVSRCALPHA (0x6)
				Mesh_SetAlphaRender(D3DBLEND_SRCALPHA,D3DBLEND_INVSRCALPHA);
			}
			else {
						// D3DBLEND_SRCALPHA (0x5), D3DBLEND_ONE (0x2)
				Mesh_SetAlphaRender(D3DBLEND_SRCALPHA,D3DBLEND_ONE);
			}
		}
		else {
						// D3DBLEND_ONE (0x2), D3DBLEND_ONE (0x2)
			Mesh_SetAlphaRender(D3DBLEND_ONE,D3DBLEND_ONE);
		}
	}
	else {
LAB_00482e79:
						// D3DRENDERSTATE_ALPHABLENDENABLE (0x1b), FALSE (0x0)
		main::Main_ChangeRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,FALSE);
	}
	if ((flags & 0x4000000) == 0) {
						// D3DCULL_CCW (0x3)
		uVar2 = D3DCULL_CCW;
	}
	else {
						// D3DCULL_NONE (0x1)
		uVar2 = D3DCULL_NONE;
	}
						// D3DRENDERSTATE_CULLMODE (0x16), ...
	main::Main_ChangeRenderState(D3DRENDERSTATE_CULLMODE,uVar2);
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if ((flags & 0x20000) == 0) {
			if ((flags & 0x40000) == 0) {
						// D3DTOP_MODULATE (0x4)
				dwRenderState = D3DTOP_MODULATE;
			}
			else {
						// D3DTOP_SELECTARG2 (0x3)
				dwRenderState = D3DTOP_SELECTARG2;
			}
		}
		else {
						// D3DTOP_SELECTARG1 (0x2)
			dwRenderState = D3DTOP_SELECTARG1;
		}
						// D3DTSS_ALPHAOP (0x4), ...
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAOP,dwRenderState);
	}
						// D3DRENDERSTATE_ZENABLE (0x7), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_ZENABLE,TRUE);
	if ((uVar1 == 0) || (alphaBlend == 0)) {
		uVar2 = TRUE;
	}
	else {
		uVar2 = FALSE;
	}
						// D3DRENDERSTATE_ZWRITEENABLE (0xe), [TRUE (0x1) | FALSE (0x0)]
	main::Main_ChangeRenderState(D3DRENDERSTATE_ZWRITEENABLE,uVar2);
	if ((flags & 0x2000) == 0) {
		if ((flags & 0x4000) == 0) goto LAB_00482f21;
		Mesh_SetIdentityMatrix(&identity);
		matWorld = &identity;
	}
						// D3DTRANSFORMSTATE_WORLD (0x1)
	Mesh_SetTransform(D3DTRANSFORMSTATE_WORLD,matWorld);
LAB_00482f21:
	if ((flags & 0x800000) == 0) {
						// D3DRENDERSTATE_TEXTUREMAG (0x11), D3DFILTER_LINEAR (0x2)
		main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMAG,D3DFILTER_LINEAR);
						// D3DRENDERSTATE_TEXTUREMIN (0x12), D3DFILTER_MIPLINEAR (0x4)
		main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMIN,D3DFILTER_MIPLINEAR);
		return;
	}
						// D3DRENDERSTATE_TEXTUREMAG (0x11), D3DFILTER_NEAREST (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMAG,D3DFILTER_NEAREST);
						// D3DRENDERSTATE_TEXTUREMIN (0x12), D3DFILTER_NEAREST (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMIN,D3DFILTER_NEAREST);
	return;
}



void __cdecl lego::res::Mesh_SetAlphaRender(D3DBlend src,D3DBlend dest)
{
						// D3DRENDERSTATE_ALPHABLENDENABLE (0x1b), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,TRUE);
						// D3DRENDERSTATE_SRCBLEND (0x13)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SRCBLEND,src);
						// D3DRENDERSTATE_DSTBLEND (0x20)
	main::Main_ChangeRenderState(D3DRENDERSTATE_DESTBLEND,dest);
	return;
}



void __cdecl lego::res::Mesh_AddToPostRenderList(Mesh *mesh,Matrix4F *matWorld)
{
	Mesh_PostRenderInfo *pMVar1;
	int iVar2;
	Mesh_PostRenderInfo *pMVar3;
	
	pMVar1 = (Mesh_PostRenderInfo *)std::malloc(0x48);
	pMVar3 = pMVar1;
	for (iVar2 = 0x12; iVar2 != 0; iVar2 += -1) {
		pMVar3->mesh = NULL;
		pMVar3 = (Mesh_PostRenderInfo *)&pMVar3->matWorld;
	}
	pMVar1->mesh = mesh;
	if (matWorld != NULL) {
		pMVar3 = pMVar1;
		for (iVar2 = 0x10; pMVar3 = (Mesh_PostRenderInfo *)&pMVar3->matWorld, iVar2 != 0; iVar2 += -1) {
			(*(float (*) [4])&pMVar3->mesh)[0] = matWorld->values[0];
			matWorld = (Matrix4F *)(matWorld->values + 1);
		}
	}
	pMVar1->next = globs::meshGlobs.postRenderMeshList;
	globs::meshGlobs.postRenderMeshList = pMVar1;
	return;
}



void __cdecl lego::res::Mesh_ClearPostRenderList(void)
{
	Mesh_PostRenderInfo *pMVar1;
	Mesh_PostRenderInfo *buffer;
	
	buffer = globs::meshGlobs.postRenderMeshList;
	if (globs::meshGlobs.postRenderMeshList != NULL) {
		do {
			pMVar1 = buffer->next;
			std::free(buffer);
			buffer = pMVar1;
		} while (pMVar1 != NULL);
	}
	globs::meshGlobs.postRenderMeshList = NULL;
	return;
}



void __cdecl lego::res::Mesh_PostRenderAll(Viewport *view)
{
	BOOL BVar1;
	Mesh *pMVar2;
	int iVar3;
	uint uVar4;
	Mesh_PostRenderInfo *pMVar5;
	Mesh_Group *pMVar6;
	
	pMVar5 = globs::meshGlobs.postRenderMeshList;
	if (globs::meshGlobs.postRenderMeshList != NULL) {
		Mesh_SetCurrentGODSViewport(view);
		Mesh_StoreTextureAndMat();
		do {
			if ((*(byte *)&pMVar5->mesh->flags & 1) == 0) {
				Mesh_SetMeshRenderDesc(pMVar5->mesh,view,&pMVar5->matWorld,1);
				pMVar2 = pMVar5->mesh;
				if ((*(byte *)&pMVar2->flags & 2) == 0) {
					uVar4 = 0;
					if (pMVar2->groupCount != 0) {
						iVar3 = 0;
						do {
							pMVar6 = (Mesh_Group *)((int)&pMVar2->groupList->faceDataSize + iVar3);
							BVar1 = Mesh_CanRenderGroup(pMVar6);
							if (((BVar1 != 0) && ((pMVar6->flags & 0x80000) != 0)) && (pMVar6->renderFlags == 0))
							{
								Mesh_RenderGroup(pMVar5->mesh,pMVar6,&pMVar5->matWorld,1);
							}
							pMVar2 = pMVar5->mesh;
							uVar4 += 1;
							iVar3 += 0x70;
						} while (uVar4 < pMVar2->groupCount);
					}
					pMVar2 = pMVar5->mesh;
					uVar4 = 0;
					if (pMVar2->groupCount != 0) {
						iVar3 = 0;
						do {
							pMVar6 = (Mesh_Group *)((int)&pMVar2->groupList->faceDataSize + iVar3);
							BVar1 = Mesh_CanRenderGroup(pMVar6);
							if (((BVar1 != 0) && ((pMVar6->flags & 0x80000) != 0)) && (pMVar6->renderFlags != 0))
							{
								Mesh_RenderGroup(pMVar5->mesh,pMVar6,&pMVar5->matWorld,1);
							}
							pMVar2 = pMVar5->mesh;
							uVar4 += 1;
							iVar3 += 0x70;
						} while (uVar4 < pMVar2->groupCount);
					}
				}
				else {
					Mesh_RenderMesh(pMVar2,&pMVar5->matWorld,1);
				}
			}
			pMVar5 = pMVar5->next;
		} while (pMVar5 != NULL);
		Mesh_ClearPostRenderList();
		main::Main_RestoreStates();
		Mesh_RestoreTextureAndMat();
	}
	return;
}



Container_Texture * __cdecl
lego::res::Mesh_LoadTexture(char *baseDir,char *name,uint *out_width,uint *out_height)
{
	char cVar1;
	Mesh_TextureReference *pMVar2;
	IDirectDrawSurface4 *surface;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	uint *ref_count;
	IDirectDrawSurface4 *local_10c;
	Container_Texture *local_108;
	char filepath [260];
	
	local_108 = (Container_Texture *)std::malloc(0xc);
	if (baseDir == NULL) {
						// std::strcpy(filepath, filename)
		uVar3 = 0xffffffff;
		pcVar6 = name;
		do {
			pcVar7 = pcVar6;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar7 = pcVar6 + 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar7 + -uVar3);
		puVar8 = (undefined4 *)filepath;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar8 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
	}
	else {
		std::sprintf(filepath,"%s%s",baseDir,name);
	}
	pMVar2 = Mesh_SearchTexturePathList
										 (globs::meshGlobs.textureList,globs::meshGlobs.textureCount,filepath);
	if (pMVar2 != NULL) {
		surface = pMVar2->surface;
		if (surface != NULL) {
			(*surface->lpVtbl->AddRef)((IUnknown *)surface);
		}
		local_10c = (IDirectDrawSurface4 *)pMVar2->trans;
		goto LAB_004832a8;
	}
	surface = Container_LoadTextureSurface(filepath,1,out_width,out_height,(BOOL *)&local_10c);
	if (surface == NULL) {
		if (globs::meshGlobs.sharedTextureDir == NULL) goto LAB_004832a8;
		std::sprintf(filepath,"%s%s",globs::meshGlobs.sharedTextureDir,name);
		pMVar2 = Mesh_SearchTexturePathList
											 (globs::meshGlobs.textureListShared,globs::meshGlobs.textureCountShared,
												filepath);
		if (pMVar2 != NULL) {
			surface = pMVar2->surface;
			if (surface != NULL) {
				(*surface->lpVtbl->AddRef)((IUnknown *)surface);
			}
			local_10c = (IDirectDrawSurface4 *)pMVar2->trans;
			goto LAB_004832a8;
		}
		surface = Container_LoadTextureSurface(filepath,1,out_width,out_height,(BOOL *)&local_10c);
		if (surface == NULL) goto LAB_004832a8;
		ref_count = &globs::meshGlobs.textureCountShared;
		pMVar2 = globs::meshGlobs.textureListShared;
	}
	else {
		ref_count = &globs::meshGlobs.textureCount;
		pMVar2 = globs::meshGlobs.textureList;
	}
	Mesh_AddTexturePathEntry(pMVar2,ref_count,filepath,surface,local_10c);
LAB_004832a8:
	if (surface != NULL) {
		local_108->texture = NULL;
		local_108->surface = surface;
		local_108->colourKey = (BOOL)local_10c;
		return local_108;
	}
	std::free(local_108);
	return NULL;
}



Mesh_TextureReference * __cdecl
lego::res::Mesh_SearchTexturePathList(Mesh_TextureReference *list,uint count,char *path)
{
	int iVar1;
	uint uVar2;
	char **ppcVar3;
	
	uVar2 = 0;
	if (count == 0) {
		return NULL;
	}
	ppcVar3 = &list->path;
	do {
		iVar1 = std::_stricmp(path,*ppcVar3);
		if (iVar1 == 0) {
			return list + uVar2;
		}
		uVar2 += 1;
		ppcVar3 = ppcVar3 + 3;
	} while (uVar2 < count);
	return NULL;
}



void __cdecl
lego::res::Mesh_AddTexturePathEntry
					(Mesh_TextureReference *list,uint *ref_count,char *path,IDirectDrawSurface4 *surface,
					BOOL trans)
{
	char *pcVar1;
	
	pcVar1 = util::_strdup(path);
	list[*ref_count].path = pcVar1;
	list[*ref_count].surface = surface;
	list[*ref_count].trans = trans;
	*ref_count = *ref_count + 1;
	return;
}



void __cdecl
lego::res::Mesh_SetGroupTexture(Mesh *mesh,D3DRMGroupIndex groupID,Container_Texture *mt)
{
	uint *puVar1;
	IDirectDrawSurface4 *This;
	
	if (mt != NULL) {
		This = mt->surface;
		if (This != NULL) {
			(*This->lpVtbl->QueryInterface)
								((IUnknown *)This,(IID *)&idl::IID_IDirect3DTexture2,
								 &mesh->groupList[groupID].imText);
		}
		if (mt->colourKey != 0) {
			puVar1 = &mesh->groupList[groupID].flags;
			*puVar1 = *puVar1 | 0x400000;
			return;
		}
		mesh->groupList[groupID].flags = mesh->groupList[groupID].flags & 0xffbfffff;
	}
	return;
}



void __cdecl lego::res::Mesh_RemoveGroupTexture(Mesh *mesh,D3DRMGroupIndex groupID)
{
	Mesh_Group *pMVar1;
	IDirect3DTexture2 *This;
	
	pMVar1 = mesh->groupList;
	This = pMVar1[groupID].imText;
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
		pMVar1[groupID].imText = NULL;
	}
	return;
}



BOOL __cdecl lego::res::Mesh_CreateGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID)
{
	int iVar1;
	D3DMaterial *pDVar2;
	D3DMaterial *pDVar3;
	D3DMaterial material;
	
	material.hTexture = 0;
	material.dwRampSize = 0;
	material.dwSize = 0x50;
	material.diffuse.red = 1.0;
	material.diffuse.green = 1.0;
	material.diffuse.blue = 1.0;
	material.diffuse.alpha = 1.0;
	material.ambient.red = 0.0;
	material.ambient.green = 0.0;
	material.ambient.blue = 0.0;
	material.ambient.alpha = 0.0;
	material.specular.red = 0.0;
	material.specular.green = 0.0;
	material.specular.blue = 0.0;
	material.specular.alpha = 0.0;
	material.emissive.red = 0.0;
	material.emissive.green = 0.0;
	material.emissive.blue = 0.0;
	material.emissive.alpha = 0.0;
	material.power = 0.0;
	pDVar2 = &material;
	pDVar3 = &mesh->groupList[groupID].material;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 += -1) {
		pDVar3->dwSize = pDVar2->dwSize;
		pDVar2 = (D3DMaterial *)&pDVar2->diffuse;
		pDVar3 = (D3DMaterial *)&pDVar3->diffuse;
	}
	return 1;
}



BOOL __cdecl lego::res::Mesh_SetGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID,D3DMaterial *mat)
{
	int iVar1;
	D3DMaterial *pDVar2;
	
	pDVar2 = &mesh->groupList[groupID].material;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = mat->dwSize;
		mat = (D3DMaterial *)&mat->diffuse;
		pDVar2 = (D3DMaterial *)&pDVar2->diffuse;
	}
	return 1;
}



BOOL __cdecl
lego::res::Mesh_SetGroupColour
					(Mesh *mesh,D3DRMGroupIndex groupID,float r,float g,float b,MaterialType matType)
{
	D3DMaterial *pDVar1;
	Mesh_Group *pMVar2;
	
	pMVar2 = mesh->groupList + groupID;
	pDVar1 = Mesh_GetGroupMaterial(mesh,groupID);
	if (r < 0.0) {
		r = 0.0;
	}
	if (g < 0.0) {
		g = 0.0;
	}
	if (b < 0.0) {
		b = 0.0;
	}
	if ((ushort)((ushort)(r < 1.0) << 8 | (ushort)(r == 1.0) << 0xe) == 0) {
		r = 1.0;
	}
	if ((ushort)((ushort)(g < 1.0) << 8 | (ushort)(g == 1.0) << 0xe) == 0) {
		g = 1.0;
	}
	if ((ushort)((ushort)(b < 1.0) << 8 | (ushort)(b == 1.0) << 0xe) == 0) {
		b = 1.0;
	}
	if (matType == MATERIAL_DIFFUSE) {
		(pDVar1->diffuse).red = r;
		(pDVar1->diffuse).green = g;
		(pDVar1->diffuse).blue = b;
		if (((r == 1.0) && (g == 1.0)) && (b == 1.0)) {
			pMVar2->flags = pMVar2->flags | 0x100000;
			return 1;
		}
		pMVar2->flags = pMVar2->flags & 0xffefffff;
		return 1;
	}
	if (matType == MATERIAL_AMBIENT) {
		(pDVar1->ambient).green = g;
		(pDVar1->ambient).red = r;
		(pDVar1->ambient).blue = b;
		return 1;
	}
	if (matType != MATERIAL_EMISSIVE) {
		if (matType != MATERIAL_SPECULAR) {
			return 1;
		}
		(pDVar1->specular).green = g;
		(pDVar1->specular).red = r;
		(pDVar1->specular).blue = b;
		return 1;
	}
	(pDVar1->emissive).green = g;
	(pDVar1->emissive).red = r;
	(pDVar1->emissive).blue = b;
	return 1;
}



D3DMaterial * __cdecl lego::res::Mesh_GetGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID)
{
	return &mesh->groupList[groupID].material;
}



BOOL __cdecl
lego::res::Mesh_SetGroupMaterialValues
					(Mesh *mesh,D3DRMGroupIndex groupID,float value,MaterialType matType)
{
	D3DMaterial *pDVar1;
	uint uVar2;
	Mesh_Group *pMVar3;
	
	pMVar3 = mesh->groupList + groupID;
	pDVar1 = Mesh_GetGroupMaterial(mesh,groupID);
	if (value < 0.0) {
		value = 0.0;
	}
	if ((ushort)((ushort)(value < 1.0) << 8 | (ushort)(value == 1.0) << 0xe) == 0) {
		value = 1.0;
	}
	if (matType != MATERIAL_ALPHA) {
		if (matType == MATERIAL_POWER) {
			pDVar1->power = value;
			return 1;
		}
		return 1;
	}
	uVar2 = pMVar3->flags & 0xeff7ffff;
	pMVar3->flags = uVar2;
	if (value == 0.0) {
		if (pMVar3->renderFlags == 0) {
			if (((mesh->renderDesc).renderFlags & 0x1c00) == 0) goto LAB_004837a4;
			uVar2 |= 0x10000000;
		}
		else {
			uVar2 |= 0x10000000;
		}
	}
	else {
		if ((value == 1.0) ||
			 ((pMVar3->renderFlags == 0 && (((mesh->renderDesc).renderFlags & 0x1c00) == 0))))
		goto LAB_004837a4;
		uVar2 |= 0x80000;
	}
	pMVar3->flags = uVar2;
LAB_004837a4:
	if (pMVar3->renderFlags == 0) {
		if (((mesh->renderDesc).renderFlags & 0xc00) != 0) {
			pMVar3->flags = pMVar3->flags | 0x80000;
		}
	}
	else {
		if ((pMVar3->renderFlags & 0xc00) != 0) {
			pMVar3->flags = pMVar3->flags | 0x80000;
			(pDVar1->diffuse).alpha = value;
			return 1;
		}
	}
	(pDVar1->diffuse).alpha = value;
	return 1;
}



void __cdecl lego::res::Mesh_SetIdentityMatrix(Matrix4F *out_matrix)
{
	out_matrix->values[1][3] = 0.0;
	out_matrix->values[1][2] = 0.0;
	out_matrix->values[1][0] = 0.0;
	out_matrix->values[3] = 0.0;
	out_matrix->values[2] = 0.0;
	out_matrix->values[1] = 0.0;
	out_matrix->values[3][2] = 0.0;
	out_matrix->values[3][1] = 0.0;
	out_matrix->values[3][0] = 0.0;
	out_matrix->values[2][3] = 0.0;
	out_matrix->values[2][1] = 0.0;
	out_matrix->values[2][0] = 0.0;
	out_matrix->values[3][3] = 1.0;
	out_matrix->values[2][2] = 1.0;
	out_matrix->values[1][1] = 1.0;
	out_matrix->values[0] = 1.0;
	return;
}



BOOL __cdecl lego::res::Mesh_SetCurrentViewport(IDirect3DRMViewport *rmViewport)
{
	HRESULT HVar1;
	int iVar2;
	IDirect3DRMViewport *This;
	IDirect3DViewport *d3dViewport;
	
						// IDirect3DRMViewport->GetDirect3DViewport(this, IDirect3DViewport** lplpD3DViewport)
	HVar1 = (*(code *)rmViewport->lpVtbl->GetDirect3DViewport)
										(rmViewport,(IDirect3DViewport **)&rmViewport);
	if (HVar1 != 0) {
		return 0;
	}
	HVar1 = (*rmViewport->lpVtbl->QueryInterface)
										((IUnknown *)rmViewport,(IID *)&idl::IID_IDirect3DViewport3,&d3dViewport);
	This = rmViewport;
	if (HVar1 == 0) {
		if (rmViewport != NULL) {
			(*rmViewport->lpVtbl->Release)((IUnknown *)rmViewport);
			rmViewport = NULL;
		}
		iVar2 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetCurrentViewport)
											(globs::mainGlobs.imDevice,d3dViewport);
		This = (IDirect3DRMViewport *)d3dViewport;
		if (iVar2 == 0) {
			if (d3dViewport != NULL) {
				(*d3dViewport->lpVtbl->Release)((IUnknown *)d3dViewport);
			}
			return 1;
		}
	}
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
	}
	return 0;
}



BOOL __cdecl lego::res::Mesh_SetCurrentGODSViewport(Viewport *view)
{
	HRESULT HVar1;
	Viewport *pVVar2;
	Viewport *local_4;
	
						// IDirect3DRMViewport2->GetDirect3DViewport(this, IDirect3DViewport** lplpD3DViewport)
	HVar1 = (*view->lpVP->lpVtbl->GetDirect3DViewport)(view->lpVP,(IDirect3DViewport **)&view);
	if (HVar1 != 0) {
		return 0;
	}
						// IDirect3DViewport->QueryInterface(this, IID_IDirect3DViewport3, IDirect3DViewport3**
						// lplpOut)
	HVar1 = (**(code **)view->xoffset)
										((IDirect3DViewport *)view,&idl::IID_IDirect3DViewport3,
										 (IDirect3DViewport3 **)&local_4);
	pVVar2 = view;
	if (HVar1 == 0) {
		if (view != NULL) {
						// IDirect3DViewport->Release(this)
			(**(code **)((int)view->xoffset + 8))((IDirect3DViewport *)view);
			view = NULL;
		}
						// IDirect3DDevice3->SetCurrentViewport(this, IDirect3DViewport3* lpd3dViewport)
		HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetCurrentViewport)
											(globs::mainGlobs.imDevice,(IDirect3DViewport3 *)local_4);
		pVVar2 = local_4;
		if (HVar1 == 0) {
			if (local_4 != NULL) {
						// IDirect3DViewport3->Release(this)
				(**(code **)((int)local_4->xoffset + 8))((IDirect3DViewport3 *)local_4);
			}
			return 1;
		}
	}
	if (pVVar2 != NULL) {
						// IDirect3DViewport->Release(this)
						//  -or-
						// IDirect3DViewport3->Release(this)
		(*((IDirect3DViewportVtbl *)pVVar2->xoffset)->Release)((IDirect3DViewport *)pVVar2);
	}
	return 0;
}



// Sets g_IDirect3DDevice3->SetTransform
// RESULT: false if the current transform was not the same, and SetTransform failed

BOOL __cdecl lego::res::Mesh_SetTransform(D3DTransformStateType state,Matrix4F *matrix)
{
	int iVar1;
	float unaff_EBX;
	float unaff_ESI;
	Matrix4F *pMVar2;
	float unaff_EDI;
	Matrix4F *pMVar3;
	Matrix4F oldMatrix;
	Matrix4F newMatrix;
	
	pMVar2 = matrix;
	pMVar3 = &newMatrix;
						// std::memcpy(newMatrix, oldMatrix, 0x40)
	for (iVar1 = 0x10; iVar1 != 0; iVar1 += -1) {
		pMVar3->values[0] = pMVar2->values[0];
		pMVar2 = (Matrix4F *)(pMVar2->values + 1);
		pMVar3 = (Matrix4F *)(pMVar3->values + 1);
	}
						// IDirect3DDevice3->GetTransform(this, D3DTransformStateType dtstTransformStateType,
						// Matrix4F* lpD3DMatrix)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTransform)
						(globs::mainGlobs.imDevice,state,&oldMatrix);
	if (((((unaff_EDI != oldMatrix.values[3][1]) || (unaff_ESI != oldMatrix.values[3][2])) ||
			 (unaff_EBX != oldMatrix.values[3][3])) ||
			(((oldMatrix.values[0][0] != newMatrix.values[0][0] ||
				(oldMatrix.values[0][1] != newMatrix.values[0][1])) ||
			 ((oldMatrix.values[0][2] != newMatrix.values[0][2] ||
				((oldMatrix.values[0][3] != newMatrix.values[0][3] ||
				 (oldMatrix.values[1][0] != newMatrix.values[1][0])))))))) ||
		 ((oldMatrix.values[1][1] != newMatrix.values[1][1] ||
			(((((oldMatrix.values[1][2] != newMatrix.values[1][2] ||
					(oldMatrix.values[1][3] != newMatrix.values[1][3])) ||
				 (oldMatrix.values[2][0] != newMatrix.values[2][0])) ||
				((oldMatrix.values[2][1] != newMatrix.values[2][1] ||
				 (oldMatrix.values[2][2] != newMatrix.values[2][2])))) ||
			 ((oldMatrix.values[2][3] != newMatrix.values[2][3] ||
				(oldMatrix.values[3][0] != newMatrix.values[3][0])))))))) {
						// IDirect3DDevice3->SetTransform(this, D3DTransformStateType dtstTransformStateType,
						// Matrix4F* lpD3DMatrix)
		iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTransform)
											(globs::mainGlobs.imDevice,state,matrix);
		if (iVar1 != 0) {
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl
lego::res::Mesh_ChangeTextureStageState
					(D3DTextureStageStateType dwRenderStateType,DWORD dwRenderState)
{
	D3DTextureStageStateType dwState;
	HRESULT HVar1;
	
	dwState = dwRenderStateType;
	HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTextureStageState)
										(globs::mainGlobs.imDevice,0,dwRenderStateType,&dwRenderStateType);
	if (HVar1 != 0) {
		dwRenderStateType = ~D3DTSS_TCI_PASSTHRU;
	}
	if (dwRenderStateType != dwRenderState) {
		HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTextureStageState)
											(globs::mainGlobs.imDevice,0,dwState,(DWORD *)dwRenderState);
		if (HVar1 != 0) {
			return 0;
		}
		if (globs::meshGlobs.stateData[dwState].changed == 0) {
			globs::meshGlobs.stateData[dwState].changed = 1;
			globs::meshGlobs.stateData[dwState].origValue = dwRenderStateType;
		}
		else {
			if (globs::meshGlobs.stateData[dwState].origValue == dwRenderStateType) {
				globs::meshGlobs.stateData[dwState].changed = 0;
				return 1;
			}
		}
	}
	return 1;
}



void __cdecl lego::res::Mesh_StoreTextureAndMat(void)
{
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetLightState)
						(globs::mainGlobs.imDevice,1,0x541568);
	globs::meshGlobs.currMatIM = globs::meshGlobs.oldMatIM;
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTexture)(globs::mainGlobs.imDevice,0,0x54156c)
		;
		globs::meshGlobs.currTextureIM = globs::meshGlobs.oldTextureIM;
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
							(globs::mainGlobs.imDevice,1,0x541564);
		if (globs::meshGlobs.oldTextureRM != 0) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)(globs::mainGlobs.imDevice,1,0);
			return;
		}
	}
	else {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
							(globs::mainGlobs.imDevice,1,0x541564);
		globs::meshGlobs.currTextureRM = globs::meshGlobs.oldTextureRM;
	}
	return;
}



void __cdecl lego::res::Mesh_RestoreTextureAndMat(void)
{
	if (globs::meshGlobs.currMatIM != globs::meshGlobs.oldMatIM) {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetLightState)
							(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldMatIM);
	}
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if (globs::meshGlobs.currTextureIM != globs::meshGlobs.oldTextureIM) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTexture)
								(globs::mainGlobs.imDevice,0,globs::meshGlobs.oldTextureIM);
		}
		if (globs::meshGlobs.oldTextureRM != 0) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
								(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldTextureRM);
			return;
		}
	}
	else {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
							(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldTextureRM);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_RenderMesh(Mesh *mesh,Matrix4F *matWorld,BOOL alphaBlend)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	Mesh_Group *pMVar4;
	BOOL local_4;
	
	uVar2 = 0;
	local_4 = 1;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			pMVar4 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar3);
			BVar1 = Mesh_CanRenderGroup(pMVar4);
			if ((BVar1 != 0) && (pMVar4->renderFlags == 0)) {
				BVar1 = Mesh_RenderGroup(mesh,pMVar4,matWorld,alphaBlend);
				if (BVar1 == 0) {
					local_4 = BVar1;
				}
			}
			uVar2 += 1;
			iVar3 += 0x70;
		} while (uVar2 < mesh->groupCount);
	}
	uVar2 = 0;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			pMVar4 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar3);
			BVar1 = Mesh_CanRenderGroup(pMVar4);
			if ((BVar1 != 0) && (pMVar4->renderFlags != 0)) {
				BVar1 = Mesh_RenderGroup(mesh,pMVar4,matWorld,alphaBlend);
				if (BVar1 == 0) {
					local_4 = BVar1;
				}
			}
			uVar2 += 1;
			iVar3 += 0x70;
		} while (uVar2 < mesh->groupCount);
	}
	return local_4;
}



BOOL __cdecl lego::res::Mesh_CanRenderGroup(Mesh_Group *group)
{
	if (((group->flags & 1) == 0) && ((group->flags & 0x10000000) == 0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::res::Mesh_RenderGroup(Mesh *mesh,Mesh_Group *group,Matrix4F *matWorld,BOOL alphaBlend)
{
	BOOL BVar1;
	uint uVar2;
	
	Mesh_SetGroupRenderDesc(mesh,group,matWorld,alphaBlend);
	BVar1 = Mesh_SetMaterial(&group->material);
	uVar2 = (uint)(BVar1 != 0);
	BVar1 = Mesh_RenderTriangleList
										(globs::meshGlobs.matHandle,group->imText,0x112,group->vertices,
										 group->vertexCount,group->faceData,group->faceDataSize);
	if (BVar1 == 0) {
		uVar2 = 0;
	}
	return uVar2;
}



BOOL __cdecl
lego::res::Mesh_SetGroupRenderDesc(Mesh *mesh,Mesh_Group *group,Matrix4F *matWorld,BOOL alphaBlend)
{
	DWORD dwRenderState;
	
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if (((group->flags & 0x100000) == 0) || (group->imText == NULL)) {
						// D3DTOP_MODULATE (0x4)
			dwRenderState = D3DTOP_MODULATE;
		}
		else {
						// D3DTOP_SELECTARG1 (0x2)
			dwRenderState = D3DTOP_SELECTARG1;
		}
						// D3DTSS_COLOROP (0x1), ...
		Mesh_ChangeTextureStageState(D3DTSS_COLOROP,dwRenderState);
	}
						// D3DRENDERSTATE_COLORKEYENABLE (0x29), [BOOL]
	main::Main_ChangeRenderState(D3DRENDERSTATE_COLORKEYENABLE,(uint)((group->flags & 0x400000) != 0))
	;
	if (group->renderFlags != 0) {
		Mesh_SetRenderDesc(group->renderFlags,matWorld,alphaBlend);
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::res::Mesh_RenderTriangleList
					(DWORD matHandle,IDirect3DTexture2 *texture,DWORD renderFlags,Mesh_Vertex *vertices,
					DWORD vertexCount,WORD *faceData,DWORD indexCount)
{
	int iVar1;
	HRESULT HVar2;
	DWORD in_ECX;
	BOOL BVar3;
	DWORD local_4;
	
	BVar3 = 1;
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		local_4 = in_ECX;
		if (texture != globs::meshGlobs.currTextureIM) {
			iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTexture)
												(globs::mainGlobs.imDevice,0,texture);
			if (iVar1 == 0) {
				globs::meshGlobs.currTextureIM = texture;
			}
			else {
				BVar3 = 0;
			}
		}
	}
	else {
		local_4 = 0;
		if (texture != NULL) {
			(*(globs::mainGlobs.imDevice)->lpVtbl->QueryInterface)
								((IUnknown *)globs::mainGlobs.imDevice,(IID *)&idl::IID_IDirect3DDevice2,&texture);
						// IDirect3DDevice2->GetCaps(this, D3DDEVICEDESC_V1* lpD3DHWDevDesc, D3DDEVICEDESC_V1*
						// lpD3DHELDevDesc)
			(*(code *)texture->lpVtbl->GetHandle)(texture,texture,&local_4);
			if (texture != NULL) {
						// IDirect3DDevice2->Release(this)
				(*texture->lpVtbl->Release)((IUnknown *)texture);
			}
		}
		if (local_4 != globs::meshGlobs.currTextureRM) {
						// D3DRENDERSTATE_TEXTUREHANDLE (0x1)
			main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREHANDLE,local_4);
			globs::meshGlobs.currTextureRM = local_4;
		}
	}
	if (matHandle != globs::meshGlobs.currMatIM) {
						// D3DLIGHTSTATE_MATERIAL (0x1)
		iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetLightState)
											(globs::mainGlobs.imDevice,D3DLIGHTSTATE_MATERIAL,matHandle);
		if (iVar1 == 0) {
			globs::meshGlobs.currMatIM = matHandle;
		}
		else {
			BVar3 = 0;
		}
	}
						// IDirect3DDevice3->DrawIndexedPrimitive(this, D3DPrimitiveType dptPrimitiveType, DWORD
						// dwVertexTypeDesc, void* lpvVertices, DWORD dwVertexCount, WORD* lpwIndices, DWORD
						// dwIndexCount, DWORD dwFlags)
						// 
						//  D3DPT_TRIANGLELIST (0x4)
	HVar2 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->DrawIndexedPrimitive)
										(globs::mainGlobs.imDevice,D3DPT_TRIANGLELIST,renderFlags,vertices,vertexCount,
										 faceData,indexCount,0);
	if (HVar2 != 0) {
		BVar3 = 0;
	}
	return BVar3;
}



BOOL __cdecl lego::image::Flic_Setup(char *filename,Flic **out_fsp,FlicUserFlags flags)
{
	char cVar1;
	IDirectDraw4 *pIVar2;
	Flic *flic;
	BOOL BVar3;
	byte *pbVar4;
	File *pFVar5;
	void *pvVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	undefined4 *puVar10;
	DDSURFACEDESC2 *pDVar11;
	char *pcVar12;
	char *pcVar13;
	undefined4 *puVar14;
	DDCOLORKEY colorKey;
	char drive [4];
	DDSURFACEDESC2 surfDesc;
	char errorMessage [128];
	char fname [256];
	char ext [256];
	char dir [256];
	
	pIVar2 = globs::directDrawGlobs.lpDirectDraw;
	flic = (Flic *)std::malloc(0x6e8);
	*out_fsp = flic;
	for (iVar7 = 0x1ba; iVar7 != 0; iVar7 += -1) {
		flic->userflags = FLICDISK;
		flic = (Flic *)&flic->fsXc;
	}
	(*out_fsp)->fsDisplayMode = FLICMODE_HICOLOR;
	std::_splitpath(filename,drive,dir,fname,ext);
	BVar3 = Flic_LoadHeader(filename,out_fsp);
	if (BVar3 == 0) {
		return 0;
	}
	flic = *out_fsp;
	pDVar11 = &surfDesc;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 += -1) {
		pDVar11->dwSize = 0;
		pDVar11 = (DDSURFACEDESC2 *)&pDVar11->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	surfDesc.dwFlags = 7;
	surfDesc.ddsCaps.dwCaps = 0x840;
	surfDesc.dwWidth = (DWORD)(flic->fsHeader).width;
	surfDesc.dwHeight = (DWORD)(flic->fsHeader).height;
	flic->fsXsize = surfDesc.dwWidth;
	(*out_fsp)->fsYsize = surfDesc.dwHeight;
	(*pIVar2->lpVtbl->CreateSurface)(pIVar2,&surfDesc,&(*out_fsp)->fsSurface,NULL);
	colorKey.dwColorSpaceLowValue = 0;
	colorKey.dwColorSpaceHighValue = 0;
						// A GRAPHICAL CRASH(FREEZE?) WAS OBSERVED HERE WHEN RUNNING IN OLLYDBG
						// POINT OF FAILURE (pointer evaluated to -1)
	(*(*out_fsp)->fsSurface->lpVtbl->SetColorKey)((*out_fsp)->fsSurface,8,&colorKey);
	(*out_fsp)->userflags = flags;
	uVar8 = 0xffffffff;
	pcVar12 = filename;
	do {
		pcVar13 = pcVar12;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar13 = pcVar12 + 1;
		cVar1 = *pcVar12;
		pcVar12 = pcVar13;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar10 = (undefined4 *)(pcVar13 + -uVar8);
	puVar14 = (undefined4 *)(*out_fsp)->filename;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar14 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar14 = puVar14 + 1;
	}
	for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar14 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar14 = (undefined4 *)((int)puVar14 + 1);
	}
	(*out_fsp)->fsXc = 0;
	(*out_fsp)->fsYc = 0;
	(*out_fsp)->currentframe = 0;
	(*out_fsp)->overallframe = 0;
	(*out_fsp)->framerate = 0x190000;
	flic = *out_fsp;
	if (((byte)flic->userflags & 1) == 1) {
		flic->pointerposition = 0;
		pbVar4 = (byte *)std::malloc(((*out_fsp)->fsHeader).size);
		(*out_fsp)->rambufferhandle = pbVar4;
		pFVar5 = lego::file::File_Open(filename,"rb");
		(*out_fsp)->filehandle = pFVar5;
		lego::file::File_Seek((*out_fsp)->filehandle,0x80,0);
		flic = *out_fsp;
		lego::file::File_Read(flic->rambufferhandle,(flic->fsHeader).size,1,flic->filehandle);
		lego::file::File_Close((*out_fsp)->filehandle);
	}
	else {
		flic->pointerposition = 0x80;
		pFVar5 = lego::file::File_Open(filename,"rb");
		(*out_fsp)->filehandle = pFVar5;
		if ((*out_fsp)->filehandle == NULL) {
			std::sprintf(errorMessage,"Not Enough Memory > %s",filename);
			return 0;
		}
		lego::file::File_Seek((*out_fsp)->filehandle,0x80,0);
	}
	pvVar6 = std::malloc(20000);
	(*out_fsp)->fsLoadBuffer = pvVar6;
	return TRUE;
}



BOOL __cdecl lego::image::Flic_Close(Flic *fsp)
{
	if (fsp == NULL) {
		return 0;
	}
	if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
		std::free(fsp->rambufferhandle);
	}
	else {
		lego::file::File_Close(fsp->filehandle);
	}
	if (fsp->fsLoadBuffer != NULL) {
		std::free(fsp->fsLoadBuffer);
		fsp->fsLoadBuffer = NULL;
	}
	return TRUE;
}



// see: <https://www.compuphase.com/flic.htm#FLICHEADER>

BOOL __cdecl lego::image::Flic_LoadHeader(char *filename,Flic **fsp)
{
	ushort uVar1;
	Flic *pFVar2;
	File *f;
	int iVar3;
	char *format;
	char errorMessage [128];
	
	f = lego::file::File_Open(filename,"rb");
	if (f == NULL) {
		format = "Flic File Not Found %s";
	}
	else {
		lego::file::File_Seek(f,0,SEEK_SET);
		lego::file::File_Read(&(*fsp)->fsHeader,0x88,1,f);
		pFVar2 = *fsp;
		iVar3 = lego::file::File_Length(f);
		if ((pFVar2->fsHeader).size != iVar3) {
			lego::file::File_Close(f);
			std::sprintf(errorMessage,"Flic File Invalid",filename);
			return 0;
		}
		uVar1 = (pFVar2->fsHeader).magic;
		if (uVar1 < 0x911a) {
			if ((uVar1 == 0x9119) || (uVar1 == 0x1234)) {
LAB_004842d2:
				lego::file::File_Close(f);
				return TRUE;
			}
		}
		else {
			if (((uVar1 == 0xaf11) || (uVar1 == 0xaf12)) || (uVar1 == 0xaf43)) goto LAB_004842d2;
		}
		lego::file::File_Close(f);
		format = "Flic File Invalid %s";
	}
	std::sprintf(errorMessage,format,filename);
	return 0;
}



BOOL __cdecl lego::image::Flic_Animate(Flic *fsp,Area2F *destArea,BOOL advance,BOOL trans)
{
	IDirectDrawSurface4 *pIVar1;
	int iVar2;
	FlicError FVar3;
	DDSURFACEDESC2 *pDVar4;
	uint *puVar5;
	longlong lVar6;
	longlong lVar7;
	longlong lVar8;
	RECT dstRect;
	DDSURFACEDESC2 surfDesc;
	uint ddBltFX [25];
	
	pIVar1 = globs::directDrawGlobs.bSurf;
	lVar6 = __ftol((float10)destArea->x);
	dstRect.left = (int)lVar6;
	lVar7 = __ftol((float10)destArea->y);
	dstRect.top = (int)lVar7;
	lVar8 = __ftol((float10)destArea->width);
	dstRect.right = (int)lVar8 + (int)lVar6;
	lVar6 = __ftol((float10)destArea->height);
	dstRect.bottom = (int)lVar6 + (int)lVar7;
	FVar3 = FLICNOERROR;
	pDVar4 = &surfDesc;
	for (iVar2 = 0x1f; iVar2 != 0; iVar2 += -1) {
		pDVar4->dwSize = 0;
		pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	(*fsp->fsSurface->lpVtbl->Lock)(fsp->fsSurface,NULL,&surfDesc,1,NULL);
	fsp->fsPitch = surfDesc.lPitch;
	fsp->fsSPtr = surfDesc.lpSurface;
	fsp->is15bit = (uint)(surfDesc.ddpfPixelFormat.dwGBitMask == 0x3e0);
	iVar2 = 1;
	if (fsp->currentframe != 0) {
		iVar2 = advance;
	}
	if (iVar2 != 0) {
		if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
			FVar3 = Flic_Memory(fsp);
		}
		else {
			FVar3 = Flic_Load(fsp);
		}
	}
	(*fsp->fsSurface->lpVtbl->Unlock)(fsp->fsSurface,NULL);
	puVar5 = ddBltFX;
	for (iVar2 = 0x19; iVar2 != 0; iVar2 += -1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	ddBltFX[0] = 100;
	ddBltFX[20] = 0xff00;
						// DDBLT_WAIT | (trans ? DDBLT_KEYSRC : 0)  (0x1000000) (0x8000)
	(*pIVar1->lpVtbl->Blt)
						(pIVar1,(LPRECT)&dstRect,fsp->fsSurface,NULL,-(uint)(trans != 0) & 0x8000 | 0x1000000,
						 ddBltFX);
	return (uint)(FVar3 == FLICNOERROR);
}



FlicError __cdecl lego::image::Flic_Memory(Flic *fsp)
{
	int iVar1;
	FlicError FVar2;
	
	FVar2 = FLICNOERROR;
	Flic_FindChunk(fsp);
	if (fsp->currentframe == 0) {
		fsp->ringframe = fsp->pointerposition;
	}
	iVar1 = fsp->currentframe + 1;
	fsp->currentframe = iVar1;
	fsp->overallframe = fsp->overallframe + 1;
	if (((byte)fsp->userflags & FLICLOOPINGON) == FLICLOOPINGON) {
		if (iVar1 == (fsp->fsHeader).frames + 1) {
			fsp->currentframe = 1;
			fsp->pointerposition = fsp->ringframe;
			return FLICNOERROR;
		}
	}
	else {
		if (iVar1 == (fsp->fsHeader).frames + 1) {
			FVar2 = FLICFINISHED;
		}
	}
	return FVar2;
}



FlicError __cdecl lego::image::Flic_Load(Flic *fsp)
{
	int iVar1;
	FlicError FVar2;
	
	FVar2 = FLICNOERROR;
	if (fsp->currentframe == 0) {
		fsp->ringframe = fsp->pointerposition;
	}
	lego::file::File_Read(fsp->fsLoadBuffer,0x10,1,fsp->filehandle);
	Flic_FindChunk(fsp);
	iVar1 = fsp->currentframe + 1;
	fsp->currentframe = iVar1;
	fsp->overallframe = fsp->overallframe + 1;
	if (((byte)fsp->userflags & FLICLOOPINGON) == FLICLOOPINGON) {
		if ((int)(uint)(fsp->fsHeader).frames < iVar1) {
			lego::file::File_Seek(fsp->filehandle,fsp->ringframe,0);
			fsp->pointerposition = fsp->ringframe;
			fsp->currentframe = 0;
			return FLICNOERROR;
		}
	}
	else {
		if ((int)(uint)(fsp->fsHeader).frames < iVar1) {
			FVar2 = FLICFINISHED;
		}
	}
	return FVar2;
}



FlicError __cdecl lego::image::Flic_FindChunk(Flic *fsp)
{
	short sVar1;
	int iVar2;
	bool bVar3;
	int iVar4;
	FlicUserFlags FVar5;
	int iVar6;
	int *piVar7;
	
	FVar5 = fsp->userflags & FLICMEMORY;
	if (FVar5 == FLICMEMORY) {
		piVar7 = (int *)fsp->rambufferhandle;
	}
	else {
		piVar7 = (int *)fsp->fsLoadBuffer;
	}
	iVar2 = fsp->pointerposition;
	if (FVar5 == FLICMEMORY) {
		iVar6 = *(int *)((int)piVar7 + iVar2);
		piVar7 = (int *)((int)piVar7 + iVar2);
		bVar3 = false;
		while (fsp->pointerposition < (fsp->fsHeader).size) {
			sVar1 = *(short *)(piVar7 + 1);
			if (sVar1 == 0xb) {
				Flic_LoadPalette64(fsp);
				iVar4 = fsp->pointerposition + *piVar7;
LAB_00484688:
				fsp->pointerposition = iVar4;
LAB_0048468e:
				piVar7 = (int *)((int)piVar7 + *piVar7);
				iVar6 += *piVar7;
			}
			else {
				if (sVar1 == 0x4b4c) {
					Flic_LoadPointers(fsp);
					fsp->pointerposition = fsp->pointerposition + *piVar7;
					goto LAB_0048468e;
				}
				if (sVar1 != -0xe06) {
					iVar4 = *piVar7 + fsp->pointerposition;
					goto LAB_00484688;
				}
				Flic_FrameChunk(fsp);
				bVar3 = true;
			}
			if (bVar3) {
				fsp->pointerposition = iVar2 + iVar6;
				return FLICNOERROR;
			}
		}
	}
	else {
		iVar6 = *piVar7;
		bVar3 = false;
		do {
			if ((fsp->fsHeader).size <= fsp->pointerposition) break;
			sVar1 = *(short *)(piVar7 + 1);
			if (sVar1 == 0xb) {
				Flic_LoadPalette64(fsp);
LAB_00484704:
				iVar4 = fsp->pointerposition + *piVar7;
				fsp->pointerposition = iVar4;
LAB_00484719:
				lego::file::File_Seek(fsp->filehandle,iVar4,SEEK_SET);
				piVar7 = (int *)fsp->fsLoadBuffer;
				lego::file::File_Read(piVar7,0x10,1,fsp->filehandle);
				iVar6 += *piVar7;
			}
			else {
				if (sVar1 == 0x4b4c) {
					Flic_LoadPointers(fsp);
					goto LAB_00484704;
				}
				if (sVar1 != -0xe06) {
					iVar4 = *piVar7 + fsp->pointerposition;
					fsp->pointerposition = iVar4;
					goto LAB_00484719;
				}
				Flic_FrameChunk(fsp);
				bVar3 = true;
			}
		} while (!bVar3);
	}
	fsp->pointerposition = iVar2 + iVar6;
	return FLICNOERROR;
}



BOOL __cdecl lego::image::Flic_FrameChunk(Flic *fsp)
{
	byte bVar1;
	char cVar2;
	uint size;
	int *piVar3;
	char buff [128];
	
	if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
		bVar1 = (fsp->rambufferhandle + fsp->pointerposition)[6];
		piVar3 = (int *)(fsp->rambufferhandle + fsp->pointerposition + 0x10);
		fsp->pointerposition = fsp->pointerposition + 0x10;
		if ('\0' < (char)bVar1) {
			while (fsp->pointerposition < (fsp->fsHeader).size) {
				fsp->fsSource = piVar3;
				Flic_DoChunk(fsp);
				fsp->pointerposition = fsp->pointerposition + *piVar3;
				piVar3 = (int *)((int)piVar3 + *piVar3);
				bVar1 -= 1;
				if ((char)bVar1 < '\x01') {
					return TRUE;
				}
			}
		}
	}
	else {
		piVar3 = (int *)fsp->fsLoadBuffer;
		cVar2 = *(char *)((int)piVar3 + 6);
		size = *piVar3 - 0x10;
		if (fsp->fsLoadBufferSize < (int)size) {
			if (piVar3 != NULL) {
				std::free(piVar3);
			}
			fsp->fsLoadBufferSize = size;
			piVar3 = (int *)std::malloc(size);
			fsp->fsLoadBuffer = piVar3;
			if (piVar3 == NULL) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return 0;
			}
		}
		lego::file::File_Read(piVar3,size,1,fsp->filehandle);
		fsp->pointerposition = fsp->pointerposition + 0x10;
		while (('\0' < cVar2 && (fsp->pointerposition < (fsp->fsHeader).size))) {
			fsp->fsSource = piVar3;
			Flic_DoChunk(fsp);
			fsp->pointerposition = fsp->pointerposition + *piVar3;
			piVar3 = (int *)((int)piVar3 + *piVar3);
			cVar2 += -1;
		}
	}
	return TRUE;
}



// sort out chunk type

FlicError __cdecl lego::image::Flic_DoChunk(Flic *fsp)
{
	FlicError FVar1;
	int iVar2;
	
	FVar1 = FLICNOERROR;
	iVar2 = (int)*(short *)((int)fsp->fsSource + 4);
	if (iVar2 < 8) {
		if (iVar2 == 7) {
switchD_0048492b_caseD_1b:
			Flic_DeltaWord(fsp);
			return FLICFINISHED;
		}
		if (iVar2 == 4) {
			Flic_Palette256(fsp);
			return FLICFINISHED;
		}
	}
	else {
		if (iVar2 < 0x5345) {
			if (iVar2 != 0x5344) {
				if (false) {
					return FLICNOERROR;
				}
				switch(iVar2) {
				case 0xb:
					nerps::funcs::NERPFunc__True((int *)fsp);
					return FLICFINISHED;
				case 0xc:
					nerps::funcs::NERPFunc__True((int *)fsp);
					return FLICFINISHED;
				case 0xd:
					nerps::funcs::NERPFunc__True((int *)fsp);
					return FLICFINISHED;
				default:
					return FLICNOERROR;
				case 0xf:
				case 0x19:
					Flic_BrunDepack(fsp);
					return FLICFINISHED;
				case 0x10:
					Flic_Copy(fsp);
					return FLICFINISHED;
				case 0x1b:
					goto switchD_0048492b_caseD_1b;
				}
			}
		}
		else {
			if (iVar2 != 0x5555) {
				return FLICNOERROR;
			}
			nerps::funcs::NERPFunc__False((int *)fsp);
		}
		FVar1 = FLICFINISHED;
	}
	return FVar1;
}



// Function to load pointers for each frame of flic.

FlicError __cdecl lego::image::Flic_LoadPointers(Flic *fsp)
{
	uint size;
	uint *buffer;
	char buff [256];
	
	if (((byte)fsp->userflags & FLICMEMORY) != FLICMEMORY) {
		buffer = (uint *)fsp->fsLoadBuffer;
		size = *buffer;
		if (fsp->fsLoadBufferSize < (int)size) {
			if (buffer != NULL) {
				std::free(buffer);
			}
			fsp->fsLoadBufferSize = size;
			buffer = (uint *)std::malloc(size);
			fsp->fsLoadBuffer = buffer;
			if (buffer == NULL) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return FLICNOERROR;
			}
		}
		lego::file::File_Seek(fsp->filehandle,fsp->pointerposition,SEEK_SET);
		lego::file::File_Read(buffer,size,1,fsp->filehandle);
	}
	return FLICNOERROR;
}



// Function to load an 8 bit palette.

FlicError __cdecl lego::image::Flic_LoadPalette64(Flic *fsp)
{
	uint size;
	uint *buffer;
	char buff [128];
	
	if (((byte)fsp->userflags & FLICMEMORY) != FLICMEMORY) {
		buffer = (uint *)fsp->fsLoadBuffer;
		size = *buffer;
		if (fsp->fsLoadBufferSize < (int)size) {
			if (buffer != NULL) {
				std::free(buffer);
			}
			fsp->fsLoadBufferSize = size;
			buffer = (uint *)std::malloc(size);
			fsp->fsLoadBuffer = buffer;
			if (buffer == NULL) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return FLICFINISHED;
			}
		}
		lego::file::File_Seek(fsp->filehandle,fsp->pointerposition,SEEK_SET);
		lego::file::File_Read(buffer,size,1,fsp->filehandle);
	}
	return FLICNOERROR;
}



BOOL __cdecl lego::image::Flic_Copy(Flic *fsp)
{
	if (fsp->fsBitPlanes == 0x10) {
						// FlicCopyHiColorFlic(fsp) => return;
		util::logf_removed((char *)fsp);
		return TRUE;
	}
	if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
						// FlicCopyBytePerPixel(fsp) => return;
		util::logf_removed((char *)fsp);
	}
	if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
						// FlicCopyHiColor(fsp) => return;
		util::logf_removed((char *)fsp);
	}
	return TRUE;
}



BOOL __cdecl lego::image::FlicBRunDepackHiColor(Flic *fsp)
{
	byte n;
	byte bVar1;
	ushort uVar2;
	uint uVar3;
	uint uVar4;
	ushort *puVar5;
	byte *pbVar6;
	byte *pbVar7;
	int local_8;
	uint local_4;
	
	pbVar6 = (byte *)((int)fsp->fsSource + 7);
	if (*(ushort *)&fsp->fsYsize != 0) {
		local_4 = (uint)*(ushort *)&fsp->fsYsize;
		local_8 = 0;
		do {
			uVar2 = *(ushort *)&fsp->fsXsize;
			uVar3 = (uint)uVar2;
			puVar5 = (ushort *)((int)fsp->fsSPtr + (fsp->fsPitch >> 1) * local_8 * 2);
			while (uVar2 != 0) {
				bVar1 = *pbVar6;
				uVar4 = (uint)bVar1;
				pbVar7 = pbVar6 + 1;
				if (bVar1 < 0x80) {
					n = *pbVar7;
					uVar3 -= uVar4;
					pbVar7 = pbVar6 + 2;
					if (bVar1 != 0) {
						do {
							uVar2 = getFlicCol(n,fsp);
							*puVar5 = uVar2;
							puVar5 = puVar5 + 1;
							uVar4 -= 1;
						} while (uVar4 != 0);
					}
				}
				else {
					uVar4 = 0x100 - uVar4;
					uVar3 -= uVar4;
					if ((short)uVar4 != 0) {
						uVar4 &= 0xffff;
						do {
							bVar1 = *pbVar7;
							pbVar7 = pbVar7 + 1;
							uVar2 = getFlicCol(bVar1,fsp);
							*puVar5 = uVar2;
							puVar5 = puVar5 + 1;
							uVar4 -= 1;
						} while (uVar4 != 0);
					}
				}
				pbVar6 = pbVar7;
				uVar2 = (ushort)uVar3;
			}
			local_8 += 1;
			pbVar6 = pbVar6 + 1;
			local_4 -= 1;
		} while (local_4 != 0);
	}
	return TRUE;
}



BOOL __cdecl lego::image::FlicBRunDepackHiColorFlic32k(Flic *fsp)
{
	ushort uVar1;
	short sVar2;
	Flic *pFVar3;
	ushort uVar4;
	uint uVar5;
	uint uVar6;
	ushort *puVar7;
	ushort *puVar8;
	ushort *puVar9;
	short sVar10;
	
	pFVar3 = fsp;
	fsp = NULL;
	sVar2 = *(short *)&pFVar3->fsYsize;
	puVar8 = (ushort *)((int)pFVar3->fsSource + 7);
	if (0 < sVar2) {
		uVar5 = 0;
		do {
			sVar10 = *(short *)&pFVar3->fsXsize;
			puVar7 = (ushort *)((int)pFVar3->fsSPtr + (pFVar3->fsPitch >> 1) * uVar5 * 2);
			while (0 < sVar10) {
				uVar4 = (ushort)*(byte *)puVar8;
				puVar9 = (ushort *)((int)puVar8 + 1);
				if (uVar4 < 0x80) {
					uVar1 = *puVar9;
					sVar10 -= uVar4;
					puVar8 = (ushort *)((int)puVar8 + 3);
					uVar5 = (uVar1 & 0xffe0) << 1;
					if (uVar4 != 0) {
						uVar6 = (uint)uVar4;
						do {
							if (pFVar3->is15bit == 0) {
								uVar4 = (ushort)uVar5;
							}
							else {
								uVar4 = (ushort)((uVar5 & 0xffff) >> 1);
							}
							*puVar7 = uVar4 | uVar1 & 0x1f;
							puVar7 = puVar7 + 1;
							uVar6 -= 1;
						} while (uVar6 != 0);
					}
				}
				else {
					uVar4 = 0x100 - uVar4;
					sVar10 -= uVar4;
					puVar8 = puVar9;
					if (uVar4 != 0) {
						uVar5 = (uint)uVar4;
						do {
							uVar4 = *puVar9;
							puVar9 = puVar9 + 1;
							uVar6 = (uVar4 & 0xffe0) << 1;
							if (pFVar3->is15bit == 0) {
								uVar1 = (ushort)uVar6;
							}
							else {
								uVar1 = (ushort)((uVar6 & 0xffff) >> 1);
							}
							*puVar7 = uVar1 | uVar4 & 0x1f;
							puVar7 = puVar7 + 1;
							uVar5 -= 1;
							puVar8 = puVar9;
						} while (uVar5 != 0);
					}
				}
			}
			puVar8 = (ushort *)((int)puVar8 + 1);
			fsp = (Flic *)((int)&fsp->userflags + 1);
			uVar5 = (uint)fsp & 0xffff;
		} while ((int)uVar5 < (int)sVar2);
	}
	return TRUE;
}



BOOL __cdecl lego::image::Flic_BrunDepack(Flic *fsp)
{
	ushort uVar1;
	
	uVar1 = (fsp->fsHeader).depth;
	if (uVar1 == 8) {
		if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
						// FlicBRunDepackBytePerPixel(fsp) => return TRUE;
			nerps::funcs::NERPFunc__True((int *)fsp);
		}
		if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
			FlicBRunDepackHiColor(fsp);
			return TRUE;
		}
	}
	else {
		if (uVar1 == 0x10) {
			if ((fsp->fsHeader).magic == 0xaf43) {
				FlicBRunDepackHiColorFlic32k(fsp);
				return TRUE;
			}
						// FlicBRunDepackHiColorFlic(fsp) => return TRUE;
			nerps::funcs::NERPFunc__True((int *)fsp);
		}
	}
	return TRUE;
}



int __cdecl lego::nerps::funcs::NERPFunc__True(int *stack)
{
	return TRUE;
}



void __cdecl lego::image::FlicCreateHiColorTable(Flic *fsp)
{
	ColourRGBPacked *pCVar1;
	ushort *puVar2;
	int iVar3;
	
	iVar3 = 0x100;
	pCVar1 = fsp->fsPalette256;
	puVar2 = fsp->fsPalette64k;
	do {
		iVar3 += -1;
		*puVar2 = (ushort)(((uint)pCVar1->green | (pCVar1->red & 0xffff003e) << 5) << 5) |
							(ushort)(pCVar1->blue >> 1);
		pCVar1 = pCVar1 + 1;
		puVar2 = puVar2 + 1;
	} while (iVar3 != 0);
	fsp->fsPalette64k[0] = 0;
	return;
}



BOOL __cdecl lego::image::Flic_Palette256(Flic *fsp)
{
	byte bVar1;
	byte *pbVar2;
	byte *pbVar3;
	ColourRGBPacked *pCVar4;
	uint uVar5;
	int iVar6;
	short sVar7;
	
	pCVar4 = fsp->fsPalette256;
	pbVar2 = (byte *)((int)fsp->fsSource + 8);
	for (sVar7 = *(short *)((int)fsp->fsSource + 6); sVar7 != 0; sVar7 += -1) {
		pbVar3 = pbVar2 + 2;
		uVar5 = (uint)pbVar2[1];
		pCVar4 = pCVar4 + *pbVar2;
		if (pbVar2[1] == 0) {
			sVar7 = 1;
			uVar5 = 0x100;
			pCVar4 = fsp->fsPalette256;
		}
		iVar6 = uVar5 * 3;
		if ((short)iVar6 != 0) {
			do {
				bVar1 = *pbVar3;
				pbVar3 = pbVar3 + 1;
				pCVar4->red = bVar1 >> 2;
				pCVar4 = (ColourRGBPacked *)&pCVar4->green;
				iVar6 += -1;
			} while (iVar6 != 0);
		}
		pbVar2 = pbVar3;
	}
	if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
		FlicCreateHiColorTable(fsp);
	}
	return TRUE;
}



void __cdecl lego::util::logf_removed(char *message,...)
{
	return;
}



void __cdecl lego::image::FlicDeltaWordHiColor(Flic *fsp)
{
	void **ppvVar1;
	byte bVar2;
	byte bVar3;
	ushort uVar4;
	ushort uVar5;
	uint uVar6;
	short sVar7;
	short sVar8;
	ushort *puVar9;
	ushort *puVar10;
	ushort *puVar11;
	uint local_10;
	byte local_4;
	Flic *fsp_00;
	
	fsp_00 = fsp;
	ppvVar1 = &fsp->fsSource;
	fsp = NULL;
	sVar8 = *(short *)((int)*ppvVar1 + 6);
	puVar10 = (ushort *)((int)*ppvVar1 + 8);
	sVar7 = sVar8;
	while( true ) {
		while( true ) {
			if (sVar7 == 0) {
				return;
			}
			uVar5 = *puVar10;
			puVar9 = (ushort *)(((uint)fsp & 0xffff) * fsp_00->fsPitch + (int)fsp_00->fsSPtr);
			uVar4 = uVar5 >> 0xc & 0xc;
			if (uVar4 != 0xc) break;
			puVar10 = puVar10 + 1;
			fsp = (Flic *)((int)fsp - (uint)uVar5);
		}
		if (uVar4 == 4) break;
		if (uVar4 == 8) {
			local_4 = *(byte *)puVar10;
			puVar10 = puVar10 + 1;
		}
		uVar5 = *puVar10;
		puVar10 = puVar10 + 1;
		if (uVar5 != 0) {
			local_10 = (uint)uVar5;
			puVar11 = puVar10;
			do {
				bVar3 = *(byte *)((int)puVar11 + 1);
				uVar6 = (uint)bVar3;
				puVar10 = puVar11 + 1;
				puVar9 = puVar9 + *(byte *)puVar11;
				if ((bVar3 & 0x80) == 0) {
					if (bVar3 != 0) {
						do {
							bVar3 = *(byte *)puVar10;
							bVar2 = *(byte *)((int)puVar10 + 1);
							puVar10 = puVar10 + 1;
							uVar5 = getFlicCol(bVar3,fsp_00);
							*puVar9 = uVar5;
							uVar5 = getFlicCol(bVar2,fsp_00);
							puVar9[1] = uVar5;
							puVar9 = puVar9 + 2;
							uVar6 -= 1;
						} while (uVar6 != 0);
					}
				}
				else {
					bVar3 = *(byte *)((int)puVar11 + 3);
					bVar2 = *(byte *)puVar10;
					puVar10 = puVar11 + 2;
					if ((short)(0x100 - uVar6) != 0) {
						uVar6 = 0x100 - uVar6 & 0xffff;
						do {
							uVar5 = getFlicCol(bVar2,fsp_00);
							*puVar9 = uVar5;
							uVar5 = getFlicCol(bVar3,fsp_00);
							puVar9[1] = uVar5;
							puVar9 = puVar9 + 2;
							uVar6 -= 1;
						} while (uVar6 != 0);
					}
				}
				local_10 -= 1;
				puVar11 = puVar10;
				sVar7 = sVar8;
			} while (local_10 != 0);
		}
		if (uVar4 == 8) {
			uVar5 = getFlicCol(local_4,fsp_00);
			*puVar9 = uVar5;
		}
		sVar8 = sVar7 + -1;
		fsp = (Flic *)((int)&fsp->userflags + 1);
		sVar7 = sVar8;
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::image::FlicDeltaWordHiColorFlic32k(Flic *fsp)
{
	void **ppvVar1;
	byte bVar2;
	ushort uVar3;
	bool bVar4;
	short sVar5;
	Flic *pFVar6;
	ushort uVar7;
	uint uVar8;
	short sVar9;
	uint uVar10;
	ushort *puVar11;
	ushort *puVar12;
	ushort *puVar13;
	uint local_10;
	uint local_8;
	
	pFVar6 = fsp;
	ppvVar1 = &fsp->fsSource;
	fsp = NULL;
	sVar9 = *(short *)((int)*ppvVar1 + 6);
	puVar11 = (ushort *)((int)*ppvVar1 + 8);
	sVar5 = sVar9;
	while( true ) {
		while( true ) {
			if (sVar9 == 0) {
				return;
			}
			uVar3 = *puVar11;
			uVar8 = (uint)uVar3;
			puVar13 = (ushort *)(((uint)fsp & 0xffff) * pFVar6->fsPitch + (int)pFVar6->fsSPtr);
			uVar7 = uVar3 >> 0xc & 0xc;
			if (uVar7 != 0xc) break;
			puVar11 = puVar11 + 1;
			fsp = (Flic *)((int)fsp - uVar8);
		}
		if (uVar7 == 4) break;
		bVar4 = false;
		if (uVar7 == 8) {
			if (pFVar6->is15bit != 0) {
				uVar8 = uVar3 >> 1 & 0x7ff0 | uVar8 & 0x1f;
			}
			puVar11 = puVar11 + 1;
			bVar4 = true;
			local_8 = uVar8;
		}
		uVar3 = *puVar11;
		puVar11 = puVar11 + 1;
		if (uVar3 != 0) {
			local_10 = (uint)uVar3;
			puVar12 = puVar11;
			do {
				bVar2 = *(byte *)((int)puVar12 + 1);
				uVar8 = (uint)bVar2;
				puVar11 = puVar12 + 1;
				puVar13 = puVar13 + *(byte *)puVar12;
				if ((bVar2 & 0x80) == 0) {
					if (bVar2 != 0) {
						do {
							uVar3 = *puVar11;
							puVar11 = puVar11 + 1;
							uVar10 = (uVar3 & 0xffe0) << 1;
							if (pFVar6->is15bit == 0) {
								uVar7 = (ushort)uVar10;
							}
							else {
								uVar7 = (ushort)((uVar10 & 0xffff) >> 1);
							}
							*puVar13 = uVar7 | uVar3 & 0x1f;
							puVar13 = puVar13 + 1;
							uVar8 -= 1;
						} while (uVar8 != 0);
					}
				}
				else {
					uVar3 = *puVar11;
					puVar11 = puVar12 + 2;
					uVar10 = (uVar3 & 0xffe0) << 1;
					if ((short)(0x100 - uVar8) != 0) {
						uVar8 = 0x100 - uVar8 & 0xffff;
						do {
							if (pFVar6->is15bit == 0) {
								uVar7 = (ushort)uVar10;
							}
							else {
								uVar7 = (ushort)((uVar10 & 0xffff) >> 1);
							}
							*puVar13 = uVar7 | uVar3 & 0x1f;
							puVar13 = puVar13 + 1;
							uVar8 -= 1;
						} while (uVar8 != 0);
					}
				}
				local_10 -= 1;
				puVar12 = puVar11;
				sVar9 = sVar5;
			} while (local_10 != 0);
		}
		if (bVar4) {
			*(undefined *)puVar13 = (undefined)local_8;
		}
		fsp = (Flic *)((int)&fsp->userflags + 1);
		sVar9 += -1;
		sVar5 = sVar9;
	}
	return;
}



BOOL __cdecl lego::image::Flic_DeltaWord(Flic *fsp)
{
	ushort uVar1;
	
	uVar1 = (fsp->fsHeader).depth;
	if (uVar1 == 8) {
		if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
						// FlicDeltaWordBytePerPixel(fsp) => return;
			util::logf_removed((char *)fsp);
		}
		if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
			FlicDeltaWordHiColor(fsp);
			return TRUE;
		}
	}
	else {
		if (uVar1 == 0x10) {
			uVar1 = (fsp->fsHeader).magic;
			if (uVar1 == 0x1234) {
						// FlicDeltaWordHiColorDZ(fsp) => return;
				util::logf_removed((char *)fsp);
				return TRUE;
			}
			if (uVar1 == 0xaf43) {
				FlicDeltaWordHiColorFlic32k(fsp);
				return TRUE;
			}
						// FlicDeltaWordHiColorFlic(fsp) => return;
			util::logf_removed((char *)fsp);
		}
	}
	return TRUE;
}



// MACRO: #define FHCOL(n)  getFlicCol(n,fsp)

ushort __cdecl lego::image::getFlicCol(byte n,Flic *fsp)
{
	return fsp->fsPalette64k[n];
}



uint __cdecl lego::image::Flic_GetHeight(Flic *fsp)
{
	return fsp->fsYsize;
}



TextWindow * __cdecl lego::front::TextWindow_Create(Font *font,Area2F *area,uint size)
{
	TextWindow *textWnd;
	void *pvVar1;
	int iVar2;
	TextWindow *pTVar3;
	
	textWnd = (TextWindow *)std::malloc(0x830);
	if (textWnd != NULL) {
		pTVar3 = textWnd;
		for (iVar2 = 0x20c; iVar2 != 0; iVar2 += -1) {
			pTVar3->font = NULL;
			pTVar3 = (TextWindow *)&pTVar3->windowSize;
		}
		textWnd->font = font;
		(textWnd->windowSize).x = area->x;
		(textWnd->windowSize).y = area->y;
		(textWnd->windowSize).width = area->width;
		(textWnd->windowSize).height = area->height;
		pvVar1 = std::malloc(size);
		textWnd->windowBuffer = pvVar1;
		textWnd->bufferSize = size;
		TextWindow_EnableCentering(textWnd,1);
	}
	return textWnd;
}



void __cdecl lego::front::TextWindow_EnableCentering(TextWindow *textWnd,BOOL enable)
{
	if (enable != 0) {
		textWnd->flags = textWnd->flags | 4;
		return;
	}
	textWnd->flags = textWnd->flags & 0xfffffffb;
	return;
}



void __cdecl lego::front::TextWindow_Remove(TextWindow *textWnd)
{
	std::free(textWnd->windowBuffer);
	std::free(textWnd);
	return;
}



void __cdecl lego::front::TextWindow_ChangePosition(TextWindow *textWnd,int xpos,int ypos)
{
	(textWnd->windowSize).x = (float)xpos;
	(textWnd->windowSize).y = (float)ypos;
	return;
}



void __cdecl lego::front::TextWindow_ChangeSize(TextWindow *textWnd,uint width,uint height)
{
	(textWnd->windowSize).width = (float)(ulonglong)width;
	(textWnd->windowSize).height = (float)(ulonglong)height;
	return;
}



void __cdecl lego::front::TextWindow_PagePrintF(TextWindow *textWnd,int page,char *format,...)
{
	TextWindow_VPrintF(textWnd,page,format,&stack0x00000010);
	return;
}



void __cdecl lego::front::TextWindow_PrintF(TextWindow *textWnd,char *format,...)
{
	TextWindow_VPrintF(textWnd,0,format,&stack0x0000000c);
	return;
}



void __cdecl
lego::front::TextWindow_VPrintF(TextWindow *textWnd,int page,char *format,va_list argptr)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	char buff [1024];
	
	iVar3 = 0;
	uVar1 = std::vsprintf(buff,format,argptr);
	uVar2 = 0;
	if (uVar1 != 0) {
		do {
			if (iVar3 == page) break;
			if (buff[uVar2] == '\a') {
				iVar3 += 1;
			}
			uVar2 += 1;
		} while (uVar2 < uVar1);
	}
	if (uVar2 != uVar1) {
		for (; uVar2 < uVar1; uVar2 += 1) {
			*(char *)((int)textWnd->windowBuffer + textWnd->bufferEnd) = buff[uVar2];
			uVar4 = textWnd->bufferEnd + 1;
			textWnd->bufferEnd = uVar4;
			if (uVar4 == textWnd->bufferSize) {
				textWnd->bufferEnd = 0;
				textWnd->flags = textWnd->flags | 1;
			}
		}
	}
	return;
}



void __cdecl
lego::front::TextWindow_PrintFOverlay(TextWindow *textWnd,BOOL oneFrame,char *format,...)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	char *pcVar5;
	char *pcVar6;
	undefined4 *puVar7;
	char local_400 [1024];
	
	std::vsprintf(local_400,format,&stack0x00000010);
	uVar2 = 0xffffffff;
	pcVar5 = local_400;
	do {
		pcVar6 = pcVar5;
		if (uVar2 == 0) break;
		uVar2 -= 1;
		pcVar6 = pcVar5 + 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar6;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	puVar4 = (undefined4 *)(pcVar6 + -uVar2);
	puVar7 = (undefined4 *)textWnd->secondBuffer;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
		*puVar7 = *puVar4;
		puVar4 = puVar4 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar4;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	if (oneFrame == 0) {
		textWnd->displayDelay = 25.0;
	}
	else {
		textWnd->displayDelay = 0.0;
	}
	textWnd->flags = textWnd->flags | 2;
	return;
}



BOOL __cdecl
lego::front::TextWindow_Update
					(TextWindow *textWnd,uint posFromEnd,float elapsed,int *out_lowestPoint)
{
	float fVar1;
	byte c;
	uint uVar2;
	float fVar3;
	uint uVar4;
	uint uVar5;
	BOOL BVar6;
	uint *puVar7;
	uint uVar8;
	int iVar9;
	ulonglong uVar10;
	longlong lVar11;
	uint local_414;
	uint *local_410;
	uint *local_40c;
	uint auStack1028 [257];
	
	uVar8 = 0;
	local_414 = 0;
	local_410 = NULL;
	if (out_lowestPoint != NULL) {
		*out_lowestPoint = 0;
	}
	uVar10 = __ftol((float10)(textWnd->windowSize).height);
	textWnd->linesCapacity = (int)((uVar10 & 0xffffffff) / (ulonglong)textWnd->font->fontHeight);
	if ((textWnd->flags & 2) != 0) {
		BVar6 = TextWindow_UpdateOverlay(textWnd,elapsed,out_lowestPoint);
		return BVar6;
	}
	uVar5 = textWnd->bufferSize;
	if (((textWnd->flags & 1) != 0) && (local_40c = (uint *)textWnd->linesCount, local_40c != NULL)) {
		puVar7 = textWnd->lines;
		do {
			uVar4 = *puVar7 - textWnd->bufferEnd;
			if ((0 < (int)uVar4) && ((int)uVar4 < (int)uVar5)) {
				uVar5 = uVar4;
				local_414 = *puVar7;
			}
			puVar7 = puVar7 + 1;
			local_40c = (uint *)((int)local_40c - 1);
		} while (local_40c != NULL);
	}
	textWnd->linesCount = 0;
	textWnd->lines[0] = local_414;
	textWnd->linesCount = textWnd->linesCount + 1;
	if (local_414 != textWnd->bufferEnd) {
		do {
			c = *(byte *)(local_414 + (int)textWnd->windowBuffer);
			if (c == '\a') break;
			if (c == '\n') {
				textWnd->lines[textWnd->linesCount] = local_414 + 1;
				uVar5 = textWnd->linesCount;
				auStack1028[uVar5] = uVar8;
				textWnd->linesCount = uVar5 + 1;
				local_410 = NULL;
				uVar8 = 0;
			}
			else {
						// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar5 = *(byte *)(std::globals::_pctype + c) & C1_SPACE;
				}
				else {
					uVar5 = std::_isctype((uint)c,C1_SPACE);
				}
				if (uVar5 != 0) {
					local_410 = NULL;
					textWnd->lines[textWnd->linesCount] = local_414 + 1;
					auStack1028[textWnd->linesCount] = uVar8;
				}
				uVar5 = lego::image::Font_GetCharWidth(textWnd->font,c);
				local_410 = (uint *)((int)local_410 + uVar5);
				fVar3 = (float)(uVar8 + uVar5);
				fVar1 = (textWnd->windowSize).width;
				uVar8 = uVar8 + uVar5;
				if ((ushort)((ushort)(fVar3 < fVar1) << 8 | (ushort)(fVar3 == fVar1) << 0xe) == 0) {
					textWnd->linesCount = textWnd->linesCount + 1;
					uVar8 = (uint)local_410;
				}
			}
			local_414 += 1;
			if (textWnd->bufferSize <= local_414) {
				local_414 = 0;
			}
		} while (local_414 != textWnd->bufferEnd);
	}
	textWnd->lines[textWnd->linesCount] = local_414;
	uVar5 = textWnd->linesCount;
	iVar9 = textWnd->linesCapacity;
	auStack1028[uVar5] = uVar8;
	uVar8 = (uVar5 - iVar9) + 1;
	uVar4 = 0;
	if (uVar8 == 0) {
		posFromEnd = 0;
	}
	else {
		posFromEnd %= uVar8;
	}
	if (uVar5 != 0) {
		local_40c = auStack1028;
		local_410 = textWnd->lines;
		do {
			local_40c = local_40c + 1;
			local_410 = local_410 + 1;
			lVar11 = __ftol((float10)(textWnd->windowSize).x);
			local_414 = (uint)lVar11;
			if ((*(byte *)&textWnd->flags & 4) != 0) {
				auStack1028[0] = 0;
				lVar11 = __ftol(((float10)(textWnd->windowSize).width - (float10)(ulonglong)*local_40c) *
												(float10)0.5);
				local_414 += (int)lVar11;
			}
			uVar8 = textWnd->linesCapacity;
			if (uVar8 < uVar5) {
				if ((uVar4 < (uVar5 - posFromEnd) - uVar8) || (uVar5 - posFromEnd <= uVar4)) {
					if (uVar5 <= uVar8) goto LAB_004858e9;
					iVar9 = 0;
				}
				else {
					uVar2 = textWnd->font->fontHeight;
					lVar11 = __ftol((float10)(textWnd->windowSize).y);
					iVar9 = ((posFromEnd + uVar4 + uVar8) - uVar5) * uVar2 + (int)lVar11;
				}
			}
			else {
LAB_004858e9:
				uVar8 = textWnd->font->fontHeight;
				lVar11 = __ftol((float10)(textWnd->windowSize).y);
				iVar9 = uVar8 * uVar4 + (int)lVar11;
			}
			if ((out_lowestPoint != NULL) && (*out_lowestPoint < iVar9)) {
				*out_lowestPoint = iVar9;
			}
			if ((iVar9 != 0) && (uVar8 = local_410[-1], uVar8 != *local_410)) {
				do {
					uVar5 = lego::image::Font_OutputChar
														(textWnd->font,local_414,iVar9,
														 *(char *)(uVar8 + (int)textWnd->windowBuffer),1);
					local_414 += uVar5;
					uVar8 += 1;
					if (uVar8 == textWnd->bufferSize + 1) {
						uVar8 = 0;
					}
				} while (uVar8 != *local_410);
			}
			uVar5 = textWnd->linesCount;
			uVar4 += 1;
		} while (uVar4 < uVar5);
	}
	if (out_lowestPoint != NULL) {
		*out_lowestPoint = *out_lowestPoint + textWnd->font->fontHeight;
	}
	return 0;
}



BOOL __cdecl
lego::front::TextWindow_UpdateOverlay(TextWindow *textWnd,float elapsed,int *out_lowestPoint)
{
	float fVar1;
	uint uVar2;
	float fVar3;
	byte c;
	uint uVar4;
	int iVar5;
	int iVar6;
	undefined *puVar7;
	int iVar8;
	longlong lVar9;
	int *local_820;
	uint local_81c;
	int local_818;
	uint local_810;
	int *local_80c;
	BOOL local_804;
	int local_800 [255];
	int aiStack1028 [2];
	undefined local_3fc [1020];
	
	iVar5 = 0;
	iVar8 = 0;
	iVar6 = 0;
	c = textWnd->secondBuffer[0];
	local_810 = 0;
	local_804 = 0;
	local_800[0] = 0;
	local_81c = 1;
	if (c != 0) {
		local_80c = local_800 + 1;
		local_820 = (int *)0x1;
		puVar7 = local_3fc;
		do {
			if (c == 10) {
				*(int *)(puVar7 + -4) = iVar8;
				local_81c += 1;
				*local_80c = (int)local_820;
				local_80c = local_80c + 1;
				puVar7 = puVar7 + 4;
				iVar6 = 0;
				iVar8 = 0;
			}
			else {
						// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar4 = *(byte *)(std::globals::_pctype + c) & C1_SPACE;
				}
				else {
					uVar4 = std::_isctype((uint)c,C1_SPACE);
				}
				if (uVar4 != 0) {
					*(int *)(puVar7 + -4) = iVar8;
					iVar6 = 0;
					*local_80c = (int)local_820;
				}
				uVar4 = lego::image::Font_GetCharWidth(textWnd->font,c);
				iVar6 += uVar4;
				fVar3 = (float)(iVar8 + uVar4);
				fVar1 = (textWnd->windowSize).width;
				iVar8 = iVar8 + uVar4;
				if ((ushort)((ushort)(fVar3 < fVar1) << 8 | (ushort)(fVar3 == fVar1) << 0xe) == 0) {
					local_81c += 1;
					puVar7 = puVar7 + 4;
					local_80c = local_80c + 1;
					iVar8 = iVar6;
				}
			}
			iVar5 = local_810 + 1;
			local_820 = (int *)((int)local_820 + 1);
			c = textWnd->secondBuffer[local_810 + 1];
			local_810 = iVar5;
		} while (c != 0);
	}
	aiStack1028[local_81c] = iVar8;
	local_800[local_81c] = iVar5;
	local_810 = 0;
	if (local_81c != 0) {
		local_820 = local_800;
		do {
			local_820 = local_820 + 1;
			lVar9 = __ftol((float10)(textWnd->windowSize).x);
			local_818 = (int)lVar9;
			if ((*(byte *)&textWnd->flags & 4) != 0) {
				lVar9 = __ftol(((float10)(textWnd->windowSize).width -
											 (float10)(ulonglong)*(uint *)(local_3fc + local_810 * 4 + -4)) * (float10)0.5
											);
				local_818 += (int)lVar9;
			}
			uVar4 = textWnd->linesCapacity;
			if (uVar4 < local_81c) {
				if ((local_810 < local_81c - uVar4) || (local_81c <= local_810)) {
					if (local_81c <= uVar4) goto LAB_00485b9f;
					iVar8 = 0;
				}
				else {
					uVar2 = textWnd->font->fontHeight;
					lVar9 = __ftol((float10)(textWnd->windowSize).y);
					iVar8 = ((local_810 - local_81c) + uVar4) * uVar2 + (int)lVar9;
					local_804 = 1;
				}
			}
			else {
LAB_00485b9f:
				uVar4 = textWnd->font->fontHeight;
				lVar9 = __ftol((float10)(textWnd->windowSize).y);
				iVar8 = uVar4 * local_810 + (int)lVar9;
			}
			if ((out_lowestPoint != NULL) && (*out_lowestPoint < iVar8)) {
				*out_lowestPoint = iVar8;
			}
			if (iVar8 != 0) {
				iVar6 = *local_820;
				for (iVar5 = local_800[local_810]; iVar5 != iVar6; iVar5 += 1) {
					uVar4 = lego::image::Font_OutputChar
														(textWnd->font,local_818,iVar8,textWnd->secondBuffer[iVar5],1);
					local_818 += uVar4;
				}
			}
			local_810 += 1;
		} while (local_810 < local_81c);
	}
	fVar1 = textWnd->displayDelay - elapsed;
	textWnd->displayDelay = fVar1;
	if (fVar1 < 0.0) {
		textWnd->flags = textWnd->flags & 0xfffffffd;
	}
	return local_804;
}



void __cdecl lego::front::TextWindow_Clear(TextWindow *textWnd)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	undefined4 *puVar4;
	
	uVar2 = textWnd->bufferSize;
	puVar4 = (undefined4 *)textWnd->windowBuffer;
	for (uVar1 = uVar2 >> 2; uVar1 != 0; uVar1 -= 1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		*(undefined *)puVar4 = 0;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	puVar4 = (undefined4 *)textWnd->secondBuffer;
	for (iVar3 = 0x100; iVar3 != 0; iVar3 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	textWnd->linesCount = 0;
	textWnd->bufferEnd = 0;
	textWnd->flags = textWnd->flags & 0xfffffffe;
	return;
}



void __cdecl
lego::front::TextWindow_GetInfo(TextWindow *textWnd,uint *out_linesCount,uint *out_linesCapacity)
{
	*out_linesCount = textWnd->linesCount;
	*out_linesCapacity = textWnd->linesCapacity;
	return;
}



void __cdecl lego::input::Keys_Initialise(void)
{
	int iVar1;
	Key_Globs *pKVar2;
	
	pKVar2 = &globs::keyGlobs;
	for (iVar1 = 0x100; iVar1 != 0; iVar1 += -1) {
		pKVar2->keyName[0] = NULL;
		pKVar2 = (Key_Globs *)(pKVar2->keyName + 1);
	}
	globs::keyGlobs.keyName[1] = "KEY_ESCAPE";
	globs::keyGlobs.keyName[2] = "KEY_ONE";
	globs::keyGlobs.keyName[3] = "KEY_TWO";
	globs::keyGlobs.keyName[4] = "KEY_THREE";
	globs::keyGlobs.keyName[5] = "KEY_FOUR";
	globs::keyGlobs.keyName[6] = "KEY_FIVE";
	globs::keyGlobs.keyName[7] = "KEY_SIX";
	globs::keyGlobs.keyName[8] = "KEY_SEVEN";
	globs::keyGlobs.keyName[9] = "KEY_EIGHT";
	globs::keyGlobs.keyName[10] = "KEY_NINE";
	globs::keyGlobs.keyName[11] = "KEY_ZERO";
	globs::keyGlobs.keyName[12] = "KEY_MINUS";
	globs::keyGlobs.keyName[13] = "KEY_EQUALS";
	globs::keyGlobs.keyName[14] = "KEY_BACKSPACE";
	globs::keyGlobs.keyName[15] = "KEY_TAB";
	globs::keyGlobs.keyName[16] = "KEY_Q";
	globs::keyGlobs.keyName[17] = "KEY_W";
	globs::keyGlobs.keyName[18] = "KEY_E";
	globs::keyGlobs.keyName[19] = "KEY_R";
	globs::keyGlobs.keyName[20] = "KEY_T";
	globs::keyGlobs.keyName[21] = "KEY_Y";
	globs::keyGlobs.keyName[22] = "KEY_U";
	globs::keyGlobs.keyName[23] = "KEY_I";
	globs::keyGlobs.keyName[24] = "KEY_O";
	globs::keyGlobs.keyName[25] = "KEY_P";
	globs::keyGlobs.keyName[26] = "KEY_LEFTBRACE";
	globs::keyGlobs.keyName[27] = "KEY_RIGHTBRACE";
	globs::keyGlobs.keyName[28] = "KEY_RETURN";
	globs::keyGlobs.keyName[29] = "KEY_LEFTCTRL";
	globs::keyGlobs.keyName[30] = "KEY_A";
	globs::keyGlobs.keyName[31] = "KEY_S";
	globs::keyGlobs.keyName[32] = "KEY_D";
	globs::keyGlobs.keyName[33] = "KEY_F";
	globs::keyGlobs.keyName[34] = "KEY_G";
	globs::keyGlobs.keyName[35] = "KEY_H";
	globs::keyGlobs.keyName[36] = "KEY_J";
	globs::keyGlobs.keyName[37] = "KEY_K";
	globs::keyGlobs.keyName[38] = "KEY_L";
	globs::keyGlobs.keyName[39] = "KEY_SEMICOLON";
	globs::keyGlobs.keyName[40] = "KEY_AT";
	globs::keyGlobs.keyName[41] = "KEY_RSINGLEQUOTE";
	globs::keyGlobs.keyName[42] = "KEY_LEFTSHIFT";
	globs::keyGlobs.keyName[43] = "KEY_HASH";
	globs::keyGlobs.keyName[44] = "KEY_Z";
	globs::keyGlobs.keyName[45] = "KEY_X";
	globs::keyGlobs.keyName[46] = "KEY_C";
	globs::keyGlobs.keyName[47] = "KEY_V";
	globs::keyGlobs.keyName[48] = "KEY_B";
	globs::keyGlobs.keyName[49] = "KEY_N";
	globs::keyGlobs.keyName[50] = "KEY_M";
	globs::keyGlobs.keyName[51] = "KEY_LEFTARROW";
	globs::keyGlobs.keyName[52] = "KEY_RIGHTARROW";
	globs::keyGlobs.keyName[53] = "KEY_QUESTIONMARK";
	globs::keyGlobs.keyName[54] = "KEY_RIGHTSHIFT";
	globs::keyGlobs.keyName[55] = "KEYPAD_ASTERISK";
	globs::keyGlobs.keyName[56] = "KEY_ALT";
	globs::keyGlobs.keyName[57] = "KEY_SPACE";
	globs::keyGlobs.keyName[58] = "KEY_CAPLOCK";
	globs::keyGlobs.keyName[59] = "KEY_F1";
	globs::keyGlobs.keyName[60] = "KEY_F2";
	globs::keyGlobs.keyName[61] = "KEY_F3";
	globs::keyGlobs.keyName[62] = "KEY_F4";
	globs::keyGlobs.keyName[63] = "KEY_F5";
	globs::keyGlobs.keyName[64] = "KEY_F6";
	globs::keyGlobs.keyName[65] = "KEY_F7";
	globs::keyGlobs.keyName[66] = "KEY_F8";
	globs::keyGlobs.keyName[67] = "KEY_F9";
	globs::keyGlobs.keyName[68] = "KEY_F10";
	globs::keyGlobs.keyName[69] = "KEYPAD_NUMLOCK";
	globs::keyGlobs.keyName[70] = "KEY_SCROLLLOCK";
	globs::keyGlobs.keyName[71] = "KEYPAD_7";
	globs::keyGlobs.keyName[72] = "KEYPAD_8";
	globs::keyGlobs.keyName[73] = "KEYPAD_9";
	globs::keyGlobs.keyName[74] = "KEYPAD_MINUS";
	globs::keyGlobs.keyName[75] = "KEYPAD_4";
	globs::keyGlobs.keyName[76] = "KEYPAD_5";
	globs::keyGlobs.keyName[77] = "KEYPAD_6";
	globs::keyGlobs.keyName[78] = "KEYPAD_PLUS";
	globs::keyGlobs.keyName[79] = "KEYPAD_1";
	globs::keyGlobs.keyName[80] = "KEYPAD_2";
	globs::keyGlobs.keyName[81] = "KEYPAD_3";
	globs::keyGlobs.keyName[82] = "KEYPAD_0";
	globs::keyGlobs.keyName[83] = "KEYPAD_DELETE";
	globs::keyGlobs.keyName[86] = "KEY_BACKSLASH";
	globs::keyGlobs.keyName[87] = "KEY_F11";
	globs::keyGlobs.keyName[88] = "KEY_F12";
	globs::keyGlobs.keyName[156] = "KEYPAD_ENTER";
	globs::keyGlobs.keyName[157] = "KEY_RIGHTCTRL";
	globs::keyGlobs.keyName[181] = "KEYPAD_FORWARDSLASH";
	globs::keyGlobs.keyName[183] = "KEY_PRINTSCREEN";
	globs::keyGlobs.keyName[184] = "KEY_ALTGR";
	globs::keyGlobs.keyName[199] = "KEY_HOME";
	globs::keyGlobs.keyName[200] = "KEY_CURSORUP";
	globs::keyGlobs.keyName[201] = "KEY_PGUP";
	globs::keyGlobs.keyName[203] = "KEY_CURSORLEFT";
	globs::keyGlobs.keyName[205] = "KEY_CURSORRIGHT";
	globs::keyGlobs.keyName[207] = "KEY_END";
	globs::keyGlobs.keyName[208] = "KEY_CURSORDOWN";
	globs::keyGlobs.keyName[209] = "KEY_PGDN";
	globs::keyGlobs.keyName[210] = "KEY_INSERT";
	globs::keyGlobs.keyName[211] = "KEY_DELETE";
	return;
}



BOOL __cdecl lego::input::Key_Find(char *name,KeysByte *out_keyCode)
{
	char *_Str1;
	int iVar1;
	KeysByte KVar2;
	Key_Globs *pKVar3;
	
	KVar2 = KEY__NONE;
	pKVar3 = &globs::keyGlobs;
	do {
		_Str1 = *(char **)((FileCheck_Globs *)pKVar3)->loadedList;
		if (_Str1 != NULL) {
			iVar1 = std::_stricmp(_Str1,name);
			if (iVar1 == 0) {
				*out_keyCode = KVar2;
				return 1;
			}
		}
		pKVar3 = (Key_Globs *)(((FileCheck_Globs *)pKVar3)->loadedList + 4);
		KVar2 += KEY_ESCAPE;
	} while (pKVar3 < &globs::checkGlobs);
	return 0;
}



void __cdecl lego::draw::Draw_Initialise(Area2F *window)
{
	globs::drawGlobs.flags |= 1;
	Draw_SetClipWindow(window);
	return;
}



void __cdecl lego::draw::Draw_SetClipWindow(Area2F *window)
{
	float fVar1;
	HRESULT HVar2;
	int iVar3;
	DDSURFACEDESC2 *pDVar4;
	DDSURFACEDESC2 desc;
	
	globs::drawGlobs.clipStart.x = 0.0;
	globs::drawGlobs.clipStart.y = 0.0;
	if (window != NULL) {
		if ((ushort)((ushort)(window->x < 0.0) << 8 | (ushort)(window->x == 0.0) << 0xe) == 0) {
			globs::drawGlobs.clipStart.x = window->x;
		}
		if ((ushort)((ushort)(window->y < 0.0) << 8 | (ushort)(window->y == 0.0) << 0xe) == 0) {
			globs::drawGlobs.clipStart.y = window->y;
		}
	}
	pDVar4 = &desc;
	for (iVar3 = 0x1f; iVar3 != 0; iVar3 += -1) {
		pDVar4->dwSize = 0;
		pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
	}
	desc.dwSize = 0x7c;
	HVar2 = (*(code *)(globs::directDrawGlobs.bSurf)->lpVtbl->GetSurfaceDesc)
										(globs::directDrawGlobs.bSurf,&desc);
	if (HVar2 == 0) {
		globs::drawGlobs.clipEnd.x = (float)(ulonglong)desc.dwWidth;
		globs::drawGlobs.clipEnd.y = (float)(ulonglong)desc.dwHeight;
		if (window != NULL) {
			fVar1 = window->width + window->x;
			if (fVar1 < globs::drawGlobs.clipEnd.x) {
				globs::drawGlobs.clipEnd.x = fVar1;
			}
			fVar1 = window->height + window->y;
			if (fVar1 < globs::drawGlobs.clipEnd.y) {
				globs::drawGlobs.clipEnd.y = fVar1;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::draw::Draw_GetClipWindow(Area2F *out_window)
{
	out_window->x = globs::drawGlobs.clipStart.x;
	out_window->y = globs::drawGlobs.clipStart.y;
	out_window->width = globs::drawGlobs.clipEnd.x - globs::drawGlobs.clipStart.x;
	out_window->height = globs::drawGlobs.clipEnd.y - globs::drawGlobs.clipStart.y;
	return;
}



void __cdecl
lego::draw::Draw_LineListEx
					(Point2F *fromList,Point2F *toList,uint count,float r,float g,float b,DrawEffect effect)
{
	IDirectDrawSurface4 *surface;
	BOOL BVar1;
	uint uVar2;
	int y2;
	int x2;
	int y1;
	int iVar3;
	float *pfVar4;
	longlong lVar5;
	uint colour;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar1 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar1 != 0) {
		uVar2 = Draw_GetColour(r,g,b);
		if (count != 0) {
			pfVar4 = &fromList->y;
			iVar3 = (int)toList - (int)fromList;
			do {
				colour = uVar2;
				lVar5 = __ftol((float10)*(float *)(iVar3 + (int)pfVar4));
				y2 = (int)lVar5;
				lVar5 = __ftol((float10)toList->x);
				x2 = (int)lVar5;
				lVar5 = __ftol((float10)*pfVar4);
				y1 = (int)lVar5;
				lVar5 = __ftol((float10)pfVar4[-1]);
				Draw_LineActual((int)lVar5,y1,x2,y2,colour);
				pfVar4 = pfVar4 + 2;
				toList = toList + 1;
				count -= 1;
			} while (count != 0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



void __cdecl
lego::draw::Draw_RectListEx(Area2F *rectList,uint count,float r,float g,float b,DrawEffect effect)
{
	int iVar1;
	IDirectDrawSurface4 *surface;
	BOOL BVar2;
	uint uVar3;
	int iVar4;
	float10 extraout_ST0;
	longlong lVar5;
	longlong lVar6;
	longlong lVar7;
	float local_18;
	float local_10;
	float local_c;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar2 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar2 != 0) {
		uVar3 = Draw_GetColour(r,g,b);
		if (count != 0) {
			effect = (DrawEffect)rectList;
			b = (float)count;
			do {
				local_10 = *(float *)effect;
				local_c = *(float *)(effect + 4);
				local_18 = local_10 + *(float *)(effect + 8);
				if (local_10 < globs::drawGlobs.clipStart.x) {
					local_10 = globs::drawGlobs.clipStart.x;
				}
				if (local_c < globs::drawGlobs.clipStart.y) {
					local_c = globs::drawGlobs.clipStart.y;
				}
				if (globs::drawGlobs.clipEnd.x <= local_18) {
					local_18 = globs::drawGlobs.clipEnd.x - 1.0;
				}
				lVar5 = __ftol((float10)local_18);
				lVar6 = __ftol(extraout_ST0);
				lVar7 = __ftol((float10)local_c);
				iVar4 = (int)lVar7;
				if (iVar4 < (int)lVar6) {
					lVar7 = __ftol((float10)local_10);
					iVar1 = (int)lVar7;
					do {
						for (; iVar1 < (int)lVar5; iVar1 = iVar1 + 1) {
							(*globs::drawGlobs.drawPixelFunc)(iVar1,iVar4,uVar3);
						}
						iVar4 += 1;
						iVar1 = (int)lVar7;
					} while (iVar4 < (int)lVar6);
				}
				effect += 0x10;
				b = (float)((int)b + -1);
			} while (b != 0.0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



void __cdecl lego::draw::Draw_RectList2Ex(Draw_Rect *rectList,uint count,DrawEffect effect)
{
	int iVar1;
	IDirectDrawSurface4 *surface;
	BOOL BVar2;
	uint uVar3;
	float *pfVar4;
	int iVar5;
	float10 extraout_ST0;
	longlong lVar6;
	longlong lVar7;
	longlong lVar8;
	float local_18;
	float local_10;
	float local_c;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar2 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar2 != 0) {
		if (count != 0) {
			pfVar4 = &rectList->g;
			rectList = (Draw_Rect *)count;
			do {
				local_10 = pfVar4[-5];
				local_c = pfVar4[-4];
				local_18 = pfVar4[-3];
				uVar3 = Draw_GetColour(pfVar4[-1],*pfVar4,pfVar4[1]);
				local_18 = local_10 + local_18;
				if (local_10 < globs::drawGlobs.clipStart.x) {
					local_10 = globs::drawGlobs.clipStart.x;
				}
				if (local_c < globs::drawGlobs.clipStart.y) {
					local_c = globs::drawGlobs.clipStart.y;
				}
				if (globs::drawGlobs.clipEnd.x <= local_18) {
					local_18 = globs::drawGlobs.clipEnd.x - 1.0;
				}
				lVar6 = __ftol((float10)local_18);
				lVar7 = __ftol(extraout_ST0);
				lVar8 = __ftol((float10)local_c);
				iVar5 = (int)lVar8;
				if (iVar5 < (int)lVar7) {
					lVar8 = __ftol((float10)local_10);
					iVar1 = (int)lVar8;
					do {
						for (; iVar1 < (int)lVar6; iVar1 = iVar1 + 1) {
							(*globs::drawGlobs.drawPixelFunc)(iVar1,iVar5,uVar3);
						}
						iVar5 += 1;
						iVar1 = (int)lVar8;
					} while (iVar5 < (int)lVar7);
				}
				pfVar4 = pfVar4 + 7;
				rectList = (Draw_Rect *)((int)&rectList[-1].b + 3);
			} while (rectList != NULL);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



float10 __cdecl
lego::draw::Draw_DotCircle
					(Point2F *pos,uint radius,uint dots,float r,float g,float b,DrawEffect effect)
{
	IDirectDrawSurface4 *surface;
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	float10 extraout_ST0;
	float10 fVar4;
	unkbyte10 extraout_ST0_00;
	float10 extraout_ST0_01;
	ulonglong uVar5;
	ulonglong uVar6;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar1 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	fVar4 = extraout_ST0;
	if (BVar1 != 0) {
		uVar2 = Draw_GetColour(r,g,b);
		uVar3 = 0;
		if (dots != 0) {
			do {
				fVar4 = (float10)fsin((float10)(ulonglong)uVar3 *
															(float10)(6.283185 / (float)(ulonglong)dots));
				uVar5 = __ftol(fVar4 * (float10)(ulonglong)radius + (float10)pos->x);
				fVar4 = (float10)fcos(extraout_ST0_00);
				uVar6 = __ftol(fVar4 * (float10)(ulonglong)radius + (float10)pos->y);
				if ((((globs::drawGlobs.clipStart.x <= (float)(uVar5 & 0xffffffff)) &&
						 (globs::drawGlobs.clipStart.y <= (float)(uVar6 & 0xffffffff))) &&
						((float)(uVar5 & 0xffffffff) < globs::drawGlobs.clipEnd.x)) &&
					 ((float)(uVar6 & 0xffffffff) < globs::drawGlobs.clipEnd.y)) {
					(*globs::drawGlobs.drawPixelFunc)((int)uVar5,(int)uVar6,uVar2);
				}
				uVar3 += 1;
			} while (uVar3 < dots);
		}
		Draw_UnlockSurface(surface);
		fVar4 = extraout_ST0_01;
	}
	return fVar4;
}



uint __cdecl lego::draw::Draw_GetColour(float r,float g,float b)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	uint uVar4;
	longlong lVar5;
	longlong lVar6;
	longlong lVar7;
	
	uVar4 = 0;
	if (globs::drawGlobs.bpp != 8) {
		lVar5 = __ftol((float10)r * (float10)255.0);
		cVar1 = (char)globs::drawGlobs.redBits;
		cVar2 = (char)globs::drawGlobs.greenBits;
		bVar3 = (byte)globs::drawGlobs.blueBits;
		lVar6 = __ftol((float10)g * (float10)255.0);
		lVar7 = __ftol((float10)b * (float10)255.0);
		uVar4 = ((uint)lVar5 >> (8U - cVar1 & 0x1f)) << (cVar2 + bVar3 & 0x1f) |
						((uint)lVar6 >> (8U - cVar2 & 0x1f)) << (bVar3 & 0x1f) |
						(uint)lVar7 >> (8 - bVar3 & 0x1f);
	}
	return uVar4;
}



BOOL __cdecl lego::draw::Draw_LockSurface(IDirectDrawSurface4 *surface,DrawEffect effect)
{
	HRESULT HVar1;
	uint uVar2;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	DDSURFACEDESC2 *pDVar6;
	DDSURFACEDESC2 desc;
	
	pDVar6 = &desc;
	for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
		pDVar6->dwSize = 0;
		pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
	}
	desc.dwSize = 0x7c;
	HVar1 = (*surface->lpVtbl->Lock)(surface,NULL,&desc,1,NULL);
	if (HVar1 == 0) {
		globs::drawGlobs.buffer = desc.lpSurface;
		uVar5 = 0;
		globs::drawGlobs.pitch = desc.lPitch;
		globs::drawGlobs.redMask = desc.ddpfPixelFormat.dwRBitMask;
		globs::drawGlobs.greenMask = desc.ddpfPixelFormat.dwGBitMask;
		globs::drawGlobs.blueMask = desc.ddpfPixelFormat.dwBBitMask;
		globs::drawGlobs.bpp = desc.ddpfPixelFormat.dwRGBBitCount;
		globs::drawGlobs.blueBits = 0;
		globs::drawGlobs.greenBits = 0;
		globs::drawGlobs.redBits = 0;
		if (desc.ddpfPixelFormat.dwRGBBitCount != 0) {
			do {
				uVar2 = 1 << ((byte)uVar5 & 0x1f);
				if ((uVar2 & desc.ddpfPixelFormat.dwRBitMask) != 0) {
					globs::drawGlobs.redBits += 1;
				}
				if ((uVar2 & desc.ddpfPixelFormat.dwGBitMask) != 0) {
					globs::drawGlobs.greenBits += 1;
				}
				if ((uVar2 & desc.ddpfPixelFormat.dwBBitMask) != 0) {
					globs::drawGlobs.blueBits += 1;
				}
				uVar5 += 1;
			} while (uVar5 < desc.ddpfPixelFormat.dwRGBBitCount);
		}
		BVar3 = Draw_SetDrawPixelFunc(effect);
		if (BVar3 != 0) {
			return TRUE;
		}
		Draw_UnlockSurface(surface);
	}
	return 0;
}



void __cdecl lego::draw::Draw_UnlockSurface(IDirectDrawSurface4 *surface)
{
	(*surface->lpVtbl->Unlock)(surface,NULL);
	globs::drawGlobs.drawPixelFunc = NULL;
	globs::drawGlobs.buffer = NULL;
	globs::drawGlobs.pitch = 0;
	globs::drawGlobs.bpp = 0;
	globs::drawGlobs.redMask = 0;
	globs::drawGlobs.greenMask = 0;
	globs::drawGlobs.blueMask = 0;
	return;
}



BOOL __cdecl lego::draw::Draw_SetDrawPixelFunc(DrawEffect effect)
{
	if (globs::drawGlobs.bpp == 8) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel8;
		return DRAWEFFECT_XOR;
	}
	if (globs::drawGlobs.bpp != 0x10) {
		if (globs::drawGlobs.bpp == 0x18) {
			globs::drawGlobs.drawPixelFunc = Draw_Pixel24;
			return DRAWEFFECT_XOR;
		}
		if (globs::drawGlobs.bpp == 0x20) {
			globs::drawGlobs.drawPixelFunc = Draw_Pixel32;
			return DRAWEFFECT_XOR;
		}
		globs::drawGlobs.drawPixelFunc = NULL;
		return DRAWEFFECT_NONE;
	}
	if (effect == DRAWEFFECT_XOR) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel16XOR;
		return effect;
	}
	if (effect == DRAWEFFECT_HALFTRANS) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel16HalfTrans;
		return DRAWEFFECT_XOR;
	}
	globs::drawGlobs.drawPixelFunc = Draw_Pixel16;
	return DRAWEFFECT_XOR;
}



void __cdecl lego::draw::Draw_LineActual(int x1,int y1,int x2,int y2,uint colour)
{
	bool bVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	int iVar9;
	uint local_10;
	int local_4;
	
	iVar4 = y1;
	iVar3 = x1;
	uVar8 = x2 - x1 >> 0x1f;
	iVar7 = (x2 - x1 ^ uVar8) - uVar8;
	uVar8 = y2 - y1 >> 0x1f;
	iVar5 = (y2 - y1 ^ uVar8) - uVar8;
	bVar1 = iVar7 < iVar5;
	if (bVar1) {
		iVar6 = iVar7 - iVar5;
		iVar9 = iVar7 * 2 - iVar5;
		local_4 = iVar5;
	}
	else {
		iVar6 = iVar5 - iVar7;
		iVar9 = iVar5 * 2 - iVar7;
		local_4 = iVar7;
		iVar7 = iVar5;
	}
	local_10 = 1;
	y1 = 1;
	x1 = ZEXT14(!bVar1);
	local_4 += 1;
	uVar8 = (uint)bVar1;
	if (x2 < iVar3) {
		y1 = -1;
		x1 = -x1;
	}
	if (y2 < iVar4) {
		uVar8 = -uVar8;
		local_10 = 0xffffffff;
	}
	x2 = iVar3;
	y2 = iVar4;
	if (0 < local_4) {
		do {
			if ((((globs::drawGlobs.clipStart.x <= (float)x2) &&
					 (globs::drawGlobs.clipStart.y <= (float)y2)) && ((float)x2 < globs::drawGlobs.clipEnd.x))
				 && ((float)y2 < globs::drawGlobs.clipEnd.y)) {
				(*globs::drawGlobs.drawPixelFunc)(x2,y2,colour);
			}
			uVar2 = local_10;
			iVar3 = y1;
			iVar4 = iVar6;
			if (iVar9 < 0) {
				uVar2 = uVar8;
				iVar3 = x1;
				iVar4 = iVar7;
			}
			x2 += iVar3;
			iVar9 += iVar4 * 2;
			y2 += uVar2;
			local_4 += -1;
		} while (local_4 != 0);
	}
	return;
}



// 8bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel8(int x,int y,uint value)
{
	*(undefined *)(y * globs::drawGlobs.pitch + x + (int)globs::drawGlobs.buffer) = (undefined)value;
	return;
}



// 16bit (565) Pixel Routine (normal)

void __cdecl lego::draw::Draw_Pixel16(int x,int y,uint value)
{
	*(undefined2 *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch) =
			 (undefined2)value;
	return;
}



// 16bit (565) Pixel Routine (XOR)

void __cdecl lego::draw::Draw_Pixel16XOR(int x,int y,uint value)
{
	ushort *puVar1;
	
	puVar1 = (ushort *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch);
	*puVar1 = *puVar1 ^ (ushort)value;
	return;
}



// 16bit (565) Pixel Routine (HalfTrans)

void __cdecl lego::draw::Draw_Pixel16HalfTrans(int x,int y,uint value)
{
	ushort *puVar1;
	ushort uVar2;
	ushort uVar3;
	
	puVar1 = (ushort *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch);
	uVar2 = *puVar1;
	uVar3 = (ushort)value;
	*puVar1 = (((ushort)globs::drawGlobs.greenMask & uVar2) >> 1 & 0x7fe0) +
						(((ushort)globs::drawGlobs.greenMask & uVar3) >> 1 & 0x7fe0) &
						(ushort)globs::drawGlobs.greenMask |
						((uVar3 & (ushort)globs::drawGlobs.blueMask) >> 1) +
						((uVar2 & (ushort)globs::drawGlobs.blueMask) >> 1) & (ushort)globs::drawGlobs.blueMask |
						(uVar3 >> 1 & 0x7800) + (uVar2 >> 1 & 0x7800) & (ushort)globs::drawGlobs.redMask;
	return;
}



// 24bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel24(int x,int y,uint value)
{
	uint *puVar1;
	
	puVar1 = (uint *)((int)globs::drawGlobs.buffer + x * 3 + y * globs::drawGlobs.pitch);
	*puVar1 = value << 8 | *puVar1 & 0xff;
	return;
}



// 32bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel32(int x,int y,uint value)
{
	*(uint *)((int)globs::drawGlobs.buffer + x * 4 + y * globs::drawGlobs.pitch) = value;
	return;
}



Lws_Info * __cdecl lego::res::Lws_Parse(char *fname,BOOL looping)
{
	char *pcVar1;
	int iVar2;
	float fVar3;
	char cVar4;
	byte bVar5;
	ushort uVar6;
	File *file;
	byte *pbVar7;
	int iVar8;
	byte *pbVar9;
	char *pcVar10;
	Lws_Node *pLVar11;
	int iVar12;
	Lws_KeyInfo *pLVar13;
	float *pfVar14;
	ushort *puVar15;
	uint uVar16;
	uint uVar17;
	Lws_Node *pLVar18;
	Lws_Info *scene;
	char *pcVar19;
	undefined4 *puVar20;
	Lws_Info *pLVar21;
	undefined4 *puVar22;
	bool bVar23;
	float10 fVar24;
	void *local_968;
	uint local_964;
	uint local_960;
	Lws_Node *local_958;
	byte *local_954;
	byte *local_950;
	char *local_94c;
	char *local_948;
	char *local_944;
	char *local_940;
	char *local_93c;
	char *local_938;
	char *local_934;
	char *local_930;
	char local_904 [260];
	char local_800 [1024];
	char local_400 [1024];
	
	scene = NULL;
	std::sprintf(local_904,"%s.%s",fname,"lws");
	file = lego::file::File_Open(local_904,"r");
	if (file != NULL) {
		lego::file::File_GetLine(local_800,0x400,file);
		uVar16 = 0xffffffff;
		pcVar19 = local_800;
		do {
			if (uVar16 == 0) break;
			uVar16 -= 1;
			cVar4 = *pcVar19;
			pcVar19 = pcVar19 + 1;
		} while (cVar4 != '\0');
		pbVar9 = (byte *)(local_800 + (~uVar16 & 0xffff));
		lego::file::File_GetLine((char *)pbVar9,0x400 - (~uVar16 & 0xffff),file);
		pcVar19 = "LWSC";
		pbVar7 = (byte *)local_800;
		do {
			bVar5 = *pbVar7;
			bVar23 = bVar5 < (byte)*pcVar19;
			if (bVar5 != *pcVar19) {
LAB_00486d70:
				iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
				goto LAB_00486d75;
			}
			if (bVar5 == 0) break;
			bVar5 = pbVar7[1];
			bVar23 = bVar5 < ((byte *)pcVar19)[1];
			if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00486d70;
			pbVar7 = pbVar7 + 2;
			pcVar19 = (char *)((byte *)pcVar19 + 2);
		} while (bVar5 != 0);
		iVar8 = 0;
LAB_00486d75:
		if (iVar8 == 0) {
			pcVar19 = "1";
			do {
				bVar5 = *pbVar9;
				bVar23 = bVar5 < (byte)*pcVar19;
				if (bVar5 != *pcVar19) {
LAB_00486da8:
					iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
					goto LAB_00486dad;
				}
				if (bVar5 == 0) break;
				bVar5 = pbVar9[1];
				bVar23 = bVar5 < ((byte *)pcVar19)[1];
				if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00486da8;
				pbVar9 = pbVar9 + 2;
				pcVar19 = (char *)((byte *)pcVar19 + 2);
			} while (bVar5 != 0);
			iVar8 = 0;
LAB_00486dad:
			if (iVar8 == 0) {
				local_964 = 0;
				local_960 = 0;
				pLVar18 = NULL;
				pcVar19 = local_904;
				pcVar10 = local_904;
				cVar4 = local_904[0];
				while (cVar4 != '\0') {
					if (cVar4 == '\\') {
						pcVar19 = pcVar10;
					}
					pcVar1 = pcVar10 + 1;
					pcVar10 = pcVar10 + 1;
					cVar4 = *pcVar1;
				}
				pcVar19[pcVar19 != local_904] = '\0';
				scene = (Lws_Info *)std::malloc(0x38);
				pLVar21 = scene;
				for (iVar8 = 0xe; iVar8 != 0; iVar8 += -1) {
					*(undefined4 *)pLVar21 = 0;
					pLVar21 = (Lws_Info *)&pLVar21->fps;
				}
				if (local_904[0] == '\0') {
					scene->filePath = NULL;
				}
				else {
					pcVar19 = util::_strdup(local_904);
					scene->filePath = pcVar19;
				}
				scene->nodeListSize = 10;
				scene->referenceCount = 1;
				if (looping != 0) {
					scene->flags = scene->flags | 1;
				}
				pLVar11 = (Lws_Node *)std::malloc(0x208);
				scene->nodeList = pLVar11;
				local_968 = std::malloc((uint)scene->nodeListSize << 1);
				pcVar19 = lego::file::File_GetLine(local_800,0x400,file);
				while (pcVar19 != NULL) {
					uVar16 = 0xffffffff;
					pcVar19 = local_800;
					do {
						pcVar10 = pcVar19;
						if (uVar16 == 0) break;
						uVar16 -= 1;
						pcVar10 = pcVar19 + 1;
						cVar4 = *pcVar19;
						pcVar19 = pcVar10;
					} while (cVar4 != '\0');
					uVar16 = ~uVar16;
					puVar20 = (undefined4 *)(pcVar10 + -uVar16);
					puVar22 = (undefined4 *)local_400;
					for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 -= 1) {
						*puVar22 = *puVar20;
						puVar20 = puVar20 + 1;
						puVar22 = puVar22 + 1;
					}
					for (uVar16 &= 3; uVar16 != 0; uVar16 -= 1) {
						*(undefined *)puVar22 = *(undefined *)puVar20;
						puVar20 = (undefined4 *)((int)puVar20 + 1);
						puVar22 = (undefined4 *)((int)puVar22 + 1);
					}
					iVar8 = util::Util_WSTokenise(local_400,(char **)&local_954);
					if (iVar8 != 0) {
						if (pLVar18 == NULL) {
							pcVar19 = "FirstFrame";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486f0b:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486f10;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486f0b;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486f10:
							if (iVar8 == 0) {
								iVar8 = std::atoi((char *)local_950);
								scene->firstFrame = (ushort)iVar8;
							}
							pcVar19 = "LastFrame";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486f55:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486f5a;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486f55;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486f5a:
							if (iVar8 == 0) {
								iVar8 = std::atoi((char *)local_950);
								scene->lastFrame = (ushort)iVar8;
							}
							if (scene->lastFrame == 0) {
								scene->lastFrame = 1;
							}
							pcVar19 = "FramesPerSecond";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486fb3:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486fb8;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486fb3;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486fb8:
							if (iVar8 == 0) {
								fVar24 = std::atof((char *)local_950);
								scene->fps = (float)fVar24;
							}
							pcVar19 = "AddNullObject";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486fff:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00487004;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486fff;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00487004:
							if (iVar8 != 0) {
								pcVar19 = "LoadObject";
								pbVar9 = local_954;
								do {
									bVar5 = *pcVar19;
									bVar23 = bVar5 < *pbVar9;
									if (bVar5 != *pbVar9) {
LAB_00487033:
										iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
										goto LAB_00487038;
									}
									if (bVar5 == 0) break;
									bVar5 = ((byte *)pcVar19)[1];
									bVar23 = bVar5 < pbVar9[1];
									if (bVar5 != pbVar9[1]) goto LAB_00487033;
									pcVar19 = (char *)((byte *)pcVar19 + 2);
									pbVar9 = pbVar9 + 2;
								} while (bVar5 != 0);
								iVar8 = 0;
LAB_00487038:
								if (iVar8 != 0) goto LAB_004877aa;
							}
							if (scene->nodeCount == scene->nodeListSize) {
								uVar6 = scene->nodeListSize + 10;
								scene->nodeListSize = uVar6;
								pLVar18 = (Lws_Node *)std::realloc(scene->nodeList,(uint)uVar6 * 0x34);
								scene->nodeList = pLVar18;
								local_968 = std::realloc(local_968,(uint)scene->nodeListSize << 1);
							}
							*(undefined2 *)((int)local_968 + (uint)scene->nodeCount * 2) = 0;
							pLVar18 = scene->nodeList + scene->nodeCount;
							local_958 = pLVar18;
							pLVar11 = pLVar18;
							for (iVar8 = 0xd; iVar8 != 0; iVar8 += -1) {
								pLVar11->name = NULL;
								pLVar11 = (Lws_Node *)&pLVar11->reference;
							}
							pcVar19 = "AddNullObject";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_004870eb:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_004870f0;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_004870eb;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_004870f0:
							if (iVar8 == 0) {
								pLVar18->flags = pLVar18->flags | 1;
								pcVar19 = util::_strdup(local_800 + 0xe);
								pLVar18->name = pcVar19;
								iVar8 = std::_strnicmp(pcVar19,"SFX",3);
								if ((iVar8 == 0) && (iVar8 = std::_strnicmp(pLVar18->name + 3,",",1), iVar8 == 0)) {
									pLVar18->flags = pLVar18->flags | 2;
									scene->triggerCount = scene->triggerCount + 1;
								}
							}
							else {
								uVar16 = 0xffffffff;
								pcVar19 = local_800;
								do {
									pcVar10 = pcVar19;
									if (uVar16 == 0) break;
									uVar16 -= 1;
									pcVar10 = pcVar19 + 1;
									cVar4 = *pcVar19;
									pcVar19 = pcVar10;
								} while (cVar4 != '\0');
								uVar16 = ~uVar16;
								puVar20 = (undefined4 *)(pcVar10 + -uVar16);
								puVar22 = (undefined4 *)local_400;
								for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 -= 1) {
									*puVar22 = *puVar20;
									puVar20 = puVar20 + 1;
									puVar22 = puVar22 + 1;
								}
								for (uVar16 &= 3; uVar16 != 0; uVar16 -= 1) {
									*(undefined *)puVar22 = *(undefined *)puVar20;
									puVar20 = (undefined4 *)((int)puVar20 + 1);
									puVar22 = (undefined4 *)((int)puVar22 + 1);
								}
								iVar8 = util::Util_Tokenise(local_800,(char **)&local_954,"\\");
								pcVar19 = util::Util_StrIStr((char *)(&local_958)[iVar8],".lwo");
								if (pcVar19 != NULL) {
									*pcVar19 = '\0';
								}
								pcVar19 = util::_strdup((char *)(&local_958)[iVar8]);
								pLVar18->name = pcVar19;
							}
							iVar8 = scene->nodeCount - 1;
							if (-1 < iVar8) {
								pLVar11 = scene->nodeList + iVar8;
								do {
									bVar5 = pLVar11->flags & 1;
									if (((bVar5 != 0) && ((pLVar18->flags & 1) != 0)) ||
										 ((bVar5 == 0 && ((pLVar18->flags & 1) == 0)))) {
										pbVar9 = (byte *)pLVar11->name;
										pbVar7 = (byte *)pLVar18->name;
										do {
											bVar5 = *pbVar7;
											bVar23 = bVar5 < *pbVar9;
											if (bVar5 != *pbVar9) {
LAB_00487222:
												iVar12 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
												goto LAB_00487227;
											}
											if (bVar5 == 0) break;
											bVar5 = pbVar7[1];
											bVar23 = bVar5 < pbVar9[1];
											if (bVar5 != pbVar9[1]) goto LAB_00487222;
											pbVar7 = pbVar7 + 2;
											pbVar9 = pbVar9 + 2;
										} while (bVar5 != 0);
										iVar12 = 0;
LAB_00487227:
										pLVar18 = local_958;
										if (iVar12 == 0) {
											local_958->reference = scene->nodeList[iVar8].reference + 1;
											break;
										}
									}
									iVar8 += -1;
									pLVar11 = pLVar11 + -1;
								} while (-1 < iVar8);
							}
						}
						else {
							if (local_964 == 0) {
								if (local_960 == 0) {
									pcVar19 = "ObjectMotion";
									pbVar9 = local_954;
									do {
										bVar5 = *pbVar9;
										bVar23 = bVar5 < (byte)*pcVar19;
										if (bVar5 != *pcVar19) {
LAB_00487586:
											iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
											goto LAB_0048758b;
										}
										if (bVar5 == 0) break;
										bVar5 = pbVar9[1];
										bVar23 = bVar5 < ((byte *)pcVar19)[1];
										if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487586;
										pbVar9 = pbVar9 + 2;
										pcVar19 = (char *)((byte *)pcVar19 + 2);
									} while (bVar5 != 0);
									iVar8 = 0;
LAB_0048758b:
									if (iVar8 == 0) {
										local_964 = 1;
									}
									else {
										pcVar19 = "ObjDissolve";
										pbVar9 = local_954;
										do {
											bVar5 = *pbVar9;
											bVar23 = bVar5 < (byte)*pcVar19;
											if (bVar5 != *pcVar19) {
LAB_004875c7:
												iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
												goto LAB_004875cc;
											}
											if (bVar5 == 0) break;
											bVar5 = pbVar9[1];
											bVar23 = bVar5 < ((byte *)pcVar19)[1];
											if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004875c7;
											pbVar9 = pbVar9 + 2;
											pcVar19 = (char *)((byte *)pcVar19 + 2);
										} while (bVar5 != 0);
										iVar8 = 0;
LAB_004875cc:
										if (iVar8 == 0) {
											pcVar19 = "(envelope)";
											pbVar9 = local_950;
											do {
												bVar5 = *pbVar9;
												bVar23 = bVar5 < (byte)*pcVar19;
												if (bVar5 != *pcVar19) {
LAB_00487603:
													iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
													goto LAB_00487608;
												}
												if (bVar5 == 0) break;
												bVar5 = pbVar9[1];
												bVar23 = bVar5 < ((byte *)pcVar19)[1];
												if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487603;
												pbVar9 = pbVar9 + 2;
												pcVar19 = (char *)((byte *)pcVar19 + 2);
											} while (bVar5 != 0);
											iVar8 = 0;
LAB_00487608:
											if (iVar8 == 0) {
												local_960 = 1;
											}
											else {
												fVar24 = std::atof((char *)local_950);
												globs::lwsGlobs.staticDissolveLevel[globs::lwsGlobs.staticDissolveCount] =
														 (float)fVar24;
												pLVar18->dissolveLevel =
														 globs::lwsGlobs.staticDissolveLevel +
														 globs::lwsGlobs.staticDissolveCount;
												globs::lwsGlobs.staticDissolveCount += 1;
												pLVar18->dissolveLevel = NULL;
											}
										}
										else {
											pcVar19 = "ParentObject";
											pbVar9 = local_954;
											do {
												bVar5 = *pbVar9;
												bVar23 = bVar5 < (byte)*pcVar19;
												if (bVar5 != *pcVar19) {
LAB_00487680:
													iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
													goto LAB_00487685;
												}
												if (bVar5 == 0) break;
												bVar5 = pbVar9[1];
												bVar23 = bVar5 < ((byte *)pcVar19)[1];
												if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487680;
												pbVar9 = pbVar9 + 2;
												pcVar19 = (char *)((byte *)pcVar19 + 2);
											} while (bVar5 != 0);
											iVar8 = 0;
LAB_00487685:
											if (iVar8 == 0) {
												iVar8 = std::atoi((char *)local_950);
												*(short *)((int)local_968 + (uint)scene->nodeCount * 2) = (short)iVar8;
											}
											else {
												pcVar19 = "PivotPoint";
												pbVar9 = local_954;
												do {
													bVar5 = *pbVar9;
													bVar23 = bVar5 < (byte)*pcVar19;
													if (bVar5 != *pcVar19) {
LAB_004876d8:
														iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
														goto LAB_004876dd;
													}
													if (bVar5 == 0) break;
													bVar5 = pbVar9[1];
													bVar23 = bVar5 < ((byte *)pcVar19)[1];
													if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004876d8;
													pbVar9 = pbVar9 + 2;
													pcVar19 = (char *)((byte *)pcVar19 + 2);
												} while (bVar5 != 0);
												iVar8 = 0;
LAB_004876dd:
												if (iVar8 == 0) {
													fVar24 = std::atof((char *)local_950);
													(pLVar18->pivotVector).x = (float)-fVar24;
													fVar24 = std::atof(local_94c);
													(pLVar18->pivotVector).y = (float)-fVar24;
													fVar24 = std::atof(local_948);
													(pLVar18->pivotVector).z = (float)-fVar24;
												}
												else {
													pcVar19 = "UnseenByCamera";
													pbVar9 = local_954;
													do {
														bVar5 = *pbVar9;
														bVar23 = bVar5 < (byte)*pcVar19;
														if (bVar5 != *pcVar19) {
LAB_00487747:
															iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
															goto LAB_0048774c;
														}
														if (bVar5 == 0) break;
														bVar5 = pbVar9[1];
														bVar23 = bVar5 < ((byte *)pcVar19)[1];
														if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487747;
														pbVar9 = pbVar9 + 2;
														pcVar19 = (char *)((byte *)pcVar19 + 2);
													} while (bVar5 != 0);
													iVar8 = 0;
LAB_0048774c:
													if ((iVar8 == 0) && (iVar8 = std::atoi((char *)local_950), iVar8 == 1)) {
														pLVar18->flags = pLVar18->flags | 4;
													}
													else {
														pcVar19 = "ShadowOptions";
														pbVar9 = local_954;
														do {
															bVar5 = *pbVar9;
															bVar23 = bVar5 < (byte)*pcVar19;
															if (bVar5 != *pcVar19) {
LAB_00487797:
																iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
																goto LAB_0048779c;
															}
															if (bVar5 == 0) break;
															bVar5 = pbVar9[1];
															bVar23 = bVar5 < ((byte *)pcVar19)[1];
															if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487797;
															pbVar9 = pbVar9 + 2;
															pcVar19 = (char *)((byte *)pcVar19 + 2);
														} while (bVar5 != 0);
														iVar8 = 0;
LAB_0048779c:
														if (iVar8 == 0) {
															pLVar18 = NULL;
															scene->nodeCount = scene->nodeCount + 1;
														}
													}
												}
											}
										}
									}
								}
								else {
									if (local_960 != 1) {
										if (local_960 == 2) {
											uVar16 = std::atoi((char *)local_950);
											pLVar18->dissolveCount = (ushort)uVar16;
											pfVar14 = (float *)std::malloc((uVar16 & 0xffff) * 4 + 4);
											pLVar18->dissolveLevel = pfVar14;
											puVar15 = (ushort *)std::malloc((uint)pLVar18->dissolveCount * 2 + 2);
											pLVar18->dissolveFrame = puVar15;
										}
										else {
											uVar16 = (int)(local_960 - 3) / 2;
											if ((ushort)uVar16 < pLVar18->dissolveCount) {
												uVar17 = (int)local_960 >> 0x1f;
												if (((local_960 ^ uVar17) - uVar17 & 1 ^ uVar17) == uVar17) {
													iVar8 = std::atoi((char *)local_950);
													pLVar18->dissolveFrame[uVar16 & 0xffff] = (ushort)iVar8;
												}
												else {
													uVar16 &= 0xffff;
													fVar24 = std::atof((char *)local_950);
													pLVar18->dissolveLevel[uVar16] = (float)fVar24;
													if (pLVar18->dissolveLevel[uVar16] < 0.0) {
														pLVar18->dissolveLevel[uVar16] = 0.0;
													}
													fVar3 = pLVar18->dissolveLevel[uVar16];
													if ((ushort)((ushort)(fVar3 < 1.0) << 8 | (ushort)(fVar3 == 1.0) << 0xe)
															== 0) {
														pLVar18->dissolveLevel[uVar16] = 1.0;
													}
													pLVar18->dissolveLevel[uVar16] = 1.0 - pLVar18->dissolveLevel[uVar16];
												}
											}
										}
									}
									pcVar19 = "EndBehavior";
									pbVar9 = local_954;
									do {
										bVar5 = *pbVar9;
										bVar23 = bVar5 < (byte)*pcVar19;
										if (bVar5 != *pcVar19) {
LAB_00487541:
											uVar16 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
											goto LAB_00487546;
										}
										if (bVar5 == 0) break;
										bVar5 = pbVar9[1];
										bVar23 = bVar5 < ((byte *)pcVar19)[1];
										if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487541;
										pbVar9 = pbVar9 + 2;
										pcVar19 = (char *)((byte *)pcVar19 + 2);
									} while (bVar5 != 0);
									uVar16 = 0;
LAB_00487546:
									local_960 = local_960 + 1;
									if (uVar16 == 0) {
										local_960 = uVar16;
									}
								}
							}
							else {
								if (local_964 != 1) {
									if (local_964 == 2) {
										uVar16 = std::atoi((char *)local_950);
										pLVar18->keyCount = (ushort)uVar16;
										pLVar13 = (Lws_KeyInfo *)std::malloc(((uVar16 & 0xffff) + 1) * 0x28);
										pLVar18->keyList = pLVar13;
									}
									else {
										uVar16 = (int)(local_964 - 3) / 2;
										if ((ushort)uVar16 < pLVar18->keyCount) {
											uVar17 = (int)local_964 >> 0x1f;
											if (((local_964 ^ uVar17) - uVar17 & 1 ^ uVar17) == uVar17) {
												iVar8 = std::atoi((char *)local_950);
												pLVar18->keyList[uVar16 & 0xffff].frame = (ushort)iVar8;
											}
											else {
												uVar16 &= 0xffff;
												fVar24 = std::atof((char *)local_950);
												pLVar18->keyList[uVar16].position.x = (float)fVar24;
												fVar24 = std::atof(local_94c);
												pLVar18->keyList[uVar16].position.y = (float)fVar24;
												fVar24 = std::atof(local_948);
												pLVar18->keyList[uVar16].position.z = (float)fVar24;
												fVar24 = std::atof(local_944);
												pLVar18->keyList[uVar16].hpb.x =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_940);
												pLVar18->keyList[uVar16].hpb.y =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_93c);
												pLVar18->keyList[uVar16].hpb.z =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_938);
												pLVar18->keyList[uVar16].scale.x = (float)fVar24;
												fVar24 = std::atof(local_934);
												pLVar18->keyList[uVar16].scale.y = (float)fVar24;
												fVar24 = std::atof(local_930);
												pLVar18->keyList[uVar16].scale.z = (float)fVar24;
											}
										}
									}
								}
								pcVar19 = "EndBehavior";
								pbVar9 = local_954;
								do {
									bVar5 = *pbVar9;
									bVar23 = bVar5 < (byte)*pcVar19;
									if (bVar5 != *pcVar19) {
LAB_004873f6:
										uVar16 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
										goto LAB_004873fb;
									}
									if (bVar5 == 0) break;
									bVar5 = pbVar9[1];
									bVar23 = bVar5 < ((byte *)pcVar19)[1];
									if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004873f6;
									pbVar9 = pbVar9 + 2;
									pcVar19 = (char *)((byte *)pcVar19 + 2);
								} while (bVar5 != 0);
								uVar16 = 0;
LAB_004873fb:
								local_964 = local_964 + 1;
								if (uVar16 == 0) {
									local_964 = uVar16;
								}
							}
						}
					}
LAB_004877aa:
					pcVar19 = lego::file::File_GetLine(local_800,0x400,file);
				}
				iVar8 = 0;
				if (scene->nodeCount != 0) {
					iVar12 = 0;
					do {
						pbVar9 = scene->nodeList->padding1 + iVar12 + -9;
						if (*(ushort *)(pbVar9 + 0x24) != 1) {
							iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
							if (*(ushort *)(iVar2 + -4) < scene->lastFrame) {
								*(ushort *)(iVar2 + 0x24) = scene->lastFrame;
								puVar20 = (undefined4 *)
													(*(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28);
								*puVar20 = puVar20[-10];
								puVar20[1] = puVar20[-9];
								puVar20[2] = puVar20[-8];
								iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
								*(undefined4 *)(iVar2 + 0xc) = *(undefined4 *)(iVar2 + -0x1c);
								*(undefined4 *)(iVar2 + 0x10) = *(undefined4 *)(iVar2 + -0x18);
								*(undefined4 *)(iVar2 + 0x14) = *(undefined4 *)(iVar2 + -0x14);
								iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
								*(undefined4 *)(iVar2 + 0x18) = *(undefined4 *)(iVar2 + -0x10);
								*(undefined4 *)(iVar2 + 0x1c) = *(undefined4 *)(iVar2 + -0xc);
								*(undefined4 *)(iVar2 + 0x20) = *(undefined4 *)(iVar2 + -8);
								*(short *)(pbVar9 + 0x24) = *(short *)(pbVar9 + 0x24) + 1;
							}
						}
						iVar8 += 1;
						iVar12 += 0x34;
					} while (iVar8 < (int)(uint)scene->nodeCount);
				}
				iVar8 = 0;
				if (scene->nodeCount != 0) {
					iVar12 = 0;
					do {
						pbVar9 = scene->nodeList->padding1 + iVar12 + -9;
						if (*(ushort *)(pbVar9 + 0x26) != 0) {
							puVar15 = (ushort *)(*(int *)(pbVar9 + 0x20) + (uint)*(ushort *)(pbVar9 + 0x26) * 2);
							if (puVar15[-1] < scene->lastFrame) {
								*puVar15 = scene->lastFrame;
								puVar20 = (undefined4 *)
													(*(int *)(pbVar9 + 0x1c) + (uint)*(ushort *)(pbVar9 + 0x26) * 4);
								*puVar20 = puVar20[-1];
								*(short *)(pbVar9 + 0x26) = *(short *)(pbVar9 + 0x26) + 1;
							}
						}
						iVar8 += 1;
						iVar12 += 0x34;
					} while (iVar8 < (int)(uint)scene->nodeCount);
				}
				uVar16 = (uint)scene->nodeCount;
				iVar8 = uVar16 - 1;
				if (-1 < iVar8) {
					puVar15 = (ushort *)((int)local_968 + iVar8 * 2);
					iVar8 *= 0x34;
					do {
						pLVar18 = (Lws_Node *)(scene->nodeList->padding1 + iVar8 + -9);
						if (*puVar15 == 0) {
							pLVar18->next = scene->masterNode;
							scene->masterNode = pLVar18;
						}
						else {
							pLVar11 = scene->nodeList + (*puVar15 - 1);
							pLVar18->next = pLVar11->childList;
							pLVar11->childList = pLVar18;
						}
						iVar8 += -0x34;
						puVar15 = puVar15 + -1;
						uVar16 -= 1;
					} while (uVar16 != 0);
				}
				std::free(local_968);
				Lws_SetupSoundTriggers(scene);
			}
		}
		lego::file::File_Close(file);
	}
	return scene;
}



void __cdecl
lego::res::Lws_Initialise
					(char *sharedDir,LwsFindSFXIDFunc FindSFXID,LwsPlaySample3DFunc PlaySample3D,
					LwsSoundEnabledFunc SoundEnabled)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (sharedDir != NULL) {
		uVar2 = 0xffffffff;
		pcVar6 = sharedDir;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		uVar3 = ~uVar2 - 1;
		if (sharedDir[(uVar3 & 0xffff) - 1] != '\\') {
			uVar3 = ~uVar2;
		}
		uVar3 &= 0xffff;
		globs::lwsGlobs.sharedDir = (char *)std::malloc(uVar3 + 1);
		uVar2 = 0xffffffff;
		do {
			pcVar6 = sharedDir;
			if (uVar2 == 0) break;
			uVar2 -= 1;
			pcVar6 = sharedDir + 1;
			cVar1 = *sharedDir;
			sharedDir = pcVar6;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		puVar5 = (undefined4 *)(pcVar6 + -uVar2);
		puVar7 = (undefined4 *)globs::lwsGlobs.sharedDir;
		for (uVar4 = uVar2 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
		globs::lwsGlobs.sharedDir[uVar3 - 1] = '\\';
		globs::lwsGlobs.sharedDir[uVar3] = '\0';
	}
	globs::lwsGlobs.FindSFXIDFunc = FindSFXID;
	globs::lwsGlobs.SoundEnabledFunc = SoundEnabled;
	globs::lwsGlobs.PlaySample3DFunc = PlaySample3D;
	return;
}



void __cdecl lego::res::Lws_Shutdown(void)
{
	uint uVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::lwsGlobs.meshPathCount != 0) {
		uVar1 = 0;
		do {
			std::free(globs::lwsGlobs.meshPathList[uVar1].path);
			uVar2 += 1;
			uVar1 = uVar2 & 0xffff;
		} while (uVar1 < globs::lwsGlobs.meshPathCount);
	}
	uVar2 = 0;
	if (globs::lwsGlobs.meshPathCountShared != 0) {
		uVar1 = 0;
		do {
			std::free(globs::lwsGlobs.meshPathListShared[uVar1].path);
			uVar2 += 1;
			uVar1 = uVar2 & 0xffff;
		} while (uVar1 < globs::lwsGlobs.meshPathCountShared);
	}
	return;
}



uint __cdecl lego::res::Lws_GetFrameCount(Lws_Info *scene)
{
	return (uint)scene->lastFrame;
}



void __cdecl lego::res::Lws_SetupSoundTriggers(Lws_Info *scene)
{
	Lws_Node *pLVar1;
	char cVar2;
	byte bVar3;
	ushort uVar4;
	ushort uVar5;
	Lws_SoundTrigger *pLVar6;
	int iVar7;
	BOOL BVar8;
	char *pcVar9;
	uint uVar10;
	uint uVar11;
	undefined4 *puVar12;
	ushort *puVar13;
	char *pcVar14;
	undefined4 *puVar15;
	char **ppcVar16;
	uint uStack2052;
	char *local_800;
	char *local_7fc;
	char *apcStack2040 [254];
	undefined4 local_400 [256];
	
	if (globs::lwsGlobs.FindSFXIDFunc == NULL) {
		scene->triggerCount = 0;
	}
	else {
		bVar3 = 0;
		if (scene->triggerCount != 0) {
			pLVar6 = (Lws_SoundTrigger *)std::malloc((uint)scene->triggerCount * 0xd0);
			scene->triggerList = pLVar6;
			uVar5 = 0;
			if (scene->nodeCount != 0) {
				do {
					pLVar1 = scene->nodeList + uVar5;
					if ((scene->nodeList[uVar5].flags & 2) != 0) {
						pLVar6 = scene->triggerList + bVar3;
						pLVar1->triggerIndex = bVar3;
						bVar3 += 1;
						uVar10 = 0xffffffff;
						pcVar9 = pLVar1->name;
						do {
							pcVar14 = pcVar9;
							if (uVar10 == 0) break;
							uVar10 -= 1;
							pcVar14 = pcVar9 + 1;
							cVar2 = *pcVar9;
							pcVar9 = pcVar14;
						} while (cVar2 != '\0');
						uVar10 = ~uVar10;
						puVar12 = (undefined4 *)(pcVar14 + -uVar10);
						puVar15 = local_400;
						for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
							*puVar15 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar15 = puVar15 + 1;
						}
						for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
							*(undefined *)puVar15 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar15 = (undefined4 *)((int)puVar15 + 1);
						}
						iVar7 = util::Util_Tokenise((char *)local_400,&local_800,",");
						pLVar6->count = (short)iVar7 - 2;
						BVar8 = (*globs::lwsGlobs.FindSFXIDFunc)(local_7fc,&pLVar6->sfxID);
						if (((globs::mainGlobs.flags & CMD_REDUCESAMPLES) != CMD_NONE) && (BVar8 == 0)) {
							pLVar6->sfxID = 0;
						}
						uStack2052 = 0;
						if (pLVar6->count != 0) {
							ppcVar16 = apcStack2040;
							puVar13 = pLVar6->frameEndList;
							do {
								pcVar9 = std::strstr(*ppcVar16,"-");
								iVar7 = std::atoi(*ppcVar16);
								uVar4 = (ushort)iVar7;
								puVar13[-0x19] = uVar4;
								if (pcVar9 != NULL) {
									iVar7 = std::atoi(pcVar9 + 1);
									uVar4 = (ushort)iVar7;
								}
								*puVar13 = uVar4;
								uStack2052 += 1;
								puVar13 = puVar13 + 1;
								ppcVar16 = ppcVar16 + 1;
							} while (uStack2052 < pLVar6->count);
						}
					}
					uVar5 += 1;
					if (scene->nodeCount <= uVar5) {
						return;
					}
				} while( true );
			}
		}
	}
	return;
}



void __cdecl lego::res::Lws_LoadMeshes(Lws_Info *scene,IDirect3DRMFrame3 *parent)
{
	Lws_Node *node;
	IDirect3DRMFrame3 *pIVar1;
	undefined4 local_4;
	
	local_4 = 0;
	pIVar1 = (IDirect3DRMFrame3 *)std::malloc((uint)scene->nodeCount << 2);
	node = scene->masterNode;
	scene->frameList = pIVar1;
	for (; node != NULL; node = node->next) {
		Lws_CreateFrames(scene,node,parent,(ushort *)&local_4);
		Lws_LoadNodes(scene,node);
	}
	Lws_SetTime(scene,0.0);
	return;
}



Lws_Info * __cdecl lego::res::Lws_Clone(Lws_Info *scene,IDirect3DRMFrame3 *parent)
{
	Lws_Node *pLVar1;
	Lws_Info *scene_00;
	IDirect3DRMFrame3 *pIVar2;
	uint uVar3;
	Mesh *mesh;
	int iVar4;
	Lws_Info *pLVar5;
	undefined4 unaff_EBP;
	Lws_Info *pLVar6;
	Lws_Info *pLVar7;
	IDirect3DRMFrame3Vtbl *pIVar8;
	int *piVar9;
	int local_50 [2];
	undefined4 local_48;
	undefined auStack68 [40];
	int *piStack28;
	code **ppcStack16;
	undefined auStack4 [4];
	
	scene_00 = (Lws_Info *)std::malloc(0x38);
	local_48 = 0;
	pLVar5 = scene;
	if (scene->clonedFrom != NULL) {
		pLVar5 = scene->clonedFrom;
	}
	pLVar6 = scene_00;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 += -1) {
		*(undefined4 *)pLVar6 = 0;
		pLVar6 = (Lws_Info *)&pLVar6->fps;
	}
	pLVar6 = pLVar5;
	pLVar7 = scene_00;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 += -1) {
		*(undefined4 *)pLVar7 = *(undefined4 *)pLVar6;
		pLVar6 = (Lws_Info *)&pLVar6->fps;
		pLVar7 = (Lws_Info *)&pLVar7->fps;
	}
	scene_00->referenceCount = 1;
	pIVar2 = (IDirect3DRMFrame3 *)std::malloc((uint)scene_00->nodeCount << 2);
	pLVar1 = scene_00->masterNode;
	scene_00->frameList = pIVar2;
	for (; pLVar1 != NULL; pLVar1 = pLVar1->next) {
		Lws_CreateFrames(scene_00,pLVar1,parent,(ushort *)&local_48);
	}
	scene = NULL;
	if (scene_00->nodeCount != 0) {
		do {
			uVar3 = (uint)scene & 0xffff;
			pLVar1 = scene_00->nodeList + uVar3;
			piVar9 = local_50;
			pIVar8 = pLVar5->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x5c))(pIVar8);
			pIVar8 = pLVar5->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x74))(pIVar8,unaff_EBP,&local_48);
			(**(code **)(*piVar9 + 8))(piVar9);
			pIVar8 = scene_00->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x38))(pIVar8,0,&stack0xffffffa8);
			if ((pLVar1->flags & 1) == 0) {
				pIVar8 = pLVar5->frameList[pLVar1->frameIndex].lpVtbl;
				(**(code **)(pIVar8->QueryInterface + 0x80))(pIVar8,auStack68);
				piVar9 = local_50;
				(**(code **)(pIVar8->QueryInterface + 0x80))(pIVar8,piVar9,auStack4);
				(**(code **)*ppcStack16)(ppcStack16,&idl::IID_IDirect3DRMUserVisual,&stack0xffffff9c);
				(**(code **)(*piStack28 + 8))(piStack28);
				mesh = (Mesh *)(**(code **)(*piVar9 + 0x1c))(piVar9);
				(**(code **)(pIVar8->QueryInterface + 8))(pIVar8);
				Mesh_Clone(mesh,(IDirect3DRMFrame3 *)scene_00->frameList[pLVar1->frameIndex].lpVtbl);
			}
			scene = (Lws_Info *)((int)&scene->firstFrame + 1);
		} while ((ushort)scene < scene_00->nodeCount);
	}
	scene_00->clonedFrom = pLVar5;
	pLVar5->referenceCount = pLVar5->referenceCount + 1;
	Lws_SetTime(scene_00,0.0);
	return scene_00;
}



void __cdecl lego::res::Lws_SetTime(Lws_Info *scene,float time)
{
	Lws_Node *node;
	float fVar1;
	Lws_Info *scene_00;
	Lws_Info *pLVar2;
	ushort uVar3;
	float10 fVar4;
	
	scene_00 = scene;
	scene->lastTime = scene->time;
	if ((scene->flags & 1) == 0) {
		pLVar2 = (Lws_Info *)(uint)scene->lastFrame;
		fVar1 = (float)(int)pLVar2;
		if ((ushort)((ushort)(time < fVar1) << 8 | (ushort)(time == fVar1) << 0xe) == 0) {
			scene->time = fVar1;
			scene = pLVar2;
		}
		else {
			scene->time = time;
			scene = pLVar2;
		}
	}
	else {
		fVar4 = (float10)time;
		time = (float)(uint)scene->lastFrame;
		fVar4 = std::fmod(fVar4,(float10)(int)time);
		scene_00->time = (float)fVar4;
	}
	uVar3 = 0;
	if (scene_00->nodeCount != 0) {
		do {
			node = scene_00->nodeList + uVar3;
			if (1 < scene_00->nodeList[uVar3].keyCount) {
				fVar4 = Lws_FindPrevKey(node,scene_00->time,(ushort *)&scene);
				time = (float)fVar4;
				Lws_InterpolateKeys(scene_00,node,(ushort)scene,time);
			}
			if (1 < node->dissolveCount) {
				fVar4 = Lws_FindPrevDissolve(node,scene_00->time,(ushort *)&scene);
				time = (float)fVar4;
				Lws_InterpolateDissolve(scene_00,node,(ushort)scene,time);
			}
			Lws_AnimateTextures(scene_00,node);
			Lws_HandleTrigger(scene_00,node);
			uVar3 += 1;
		} while (uVar3 < scene_00->nodeCount);
	}
	return;
}



float10 __cdecl lego::res::Lws_FindPrevKey(Lws_Node *node,float time,ushort *prev)
{
	float fVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	float10 fVar6;
	
	uVar2 = 0;
	uVar5 = (uint)node->keyCount;
	while( true ) {
		uVar4 = uVar2;
		uVar3 = (uVar5 + uVar4) / 2;
		uVar2 = (uint)node->keyList[uVar3].frame;
		if ((ushort)uVar3 == (ushort)uVar4) break;
		fVar1 = (float)uVar2;
		uVar2 = uVar3;
		if ((ushort)((ushort)(fVar1 < time) << 8 | (ushort)(fVar1 == time) << 0xe) == 0) {
			uVar2 = uVar4;
			uVar5 = uVar3;
		}
	}
	fVar6 = (float10)uVar2;
	*prev = (ushort)uVar3;
	return ((float10)time - fVar6) / ((float10)(uint)node->keyList[uVar3 + 1].frame - fVar6);
}



// WARNING: Restarted to delay deadcode elimination for space: stack

void __cdecl lego::res::Lws_AnimateTextures(Lws_Info *scene,Lws_Node *node)
{
	Mesh *mesh;
	IDirect3DRMFrame3Vtbl *pIVar1;
	int *piStack20;
	code **ppcStack16;
	int local_4;
	
	if ((node->flags & 1) == 0) {
		ppcStack16 = NULL;
		pIVar1 = scene->frameList[node->frameIndex].lpVtbl;
		piStack20 = &local_4;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1);
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,&ppcStack16);
		(**(code **)*ppcStack16)(ppcStack16,&idl::IID_IDirect3DRMUserVisual);
		(**(code **)(local_4 + 8))(&local_4);
		mesh = (Mesh *)(**(code **)(pIVar1->QueryInterface + 0x1c))(pIVar1);
		(*(code *)piStack20[2])(&piStack20);
		Mesh_SetTextureTime2(mesh,scene->time);
	}
	return;
}



void __cdecl lego::res::Lws_HandleTrigger(Lws_Info *scene,Lws_Node *node)
{
	ushort *puVar1;
	IDirect3DRMFrame3Vtbl *frame;
	Lws_Node *pLVar2;
	BOOL BVar3;
	uint uVar4;
	uint loop;
	Lws_SoundTrigger *pLVar5;
	uint uVar6;
	
	pLVar2 = node;
	if ((node->flags & 2) != 0) {
		puVar1 = &node->frameIndex;
		node = NULL;
		frame = scene->frameList[*puVar1].lpVtbl;
		pLVar5 = scene->triggerList + pLVar2->triggerIndex;
		if (pLVar5->count != 0) {
			do {
				uVar6 = (uint)node & 0xffff;
				loop = (uint)(pLVar5->frameStartList[uVar6] != pLVar5->frameEndList[uVar6]);
				BVar3 = Lws_KeyPassed(scene,(uint)pLVar5->frameStartList[uVar6]);
				if ((BVar3 != 0) && (BVar3 = (*globs::lwsGlobs.SoundEnabledFunc)(), BVar3 != 0)) {
					uVar4 = (*globs::lwsGlobs.PlaySample3DFunc)
														((IDirect3DRMFrame3 *)frame,pLVar5->sfxID,loop,1,NULL);
					pLVar5->loopUID[uVar6] = uVar4;
				}
				if ((loop != 0) &&
					 (BVar3 = Lws_KeyPassed(scene,(uint)pLVar5->frameEndList[uVar6]), BVar3 != 0)) {
					snd::Sound3D_StopSound(pLVar5->loopUID[uVar6]);
				}
				node = (Lws_Node *)((int)&node->name + 1);
			} while ((ushort)node < pLVar5->count);
		}
	}
	return;
}



BOOL __cdecl lego::res::Lws_KeyPassed(Lws_Info *scene,uint key)
{
	Lws_Info *pLVar1;
	Lws_Info *pLVar2;
	float fVar3;
	Lws_Info *pLVar4;
	uint uVar5;
	
	pLVar1 = (Lws_Info *)scene->lastTime;
	pLVar2 = (Lws_Info *)scene->time;
	fVar3 = (float)(ulonglong)key;
	uVar5 = Lws_GetFrameCount(scene);
	pLVar4 = pLVar2;
	if ((ushort)((ushort)((float)pLVar1 < (float)pLVar2) << 8 |
							(ushort)((float)pLVar1 == (float)pLVar2) << 0xe) == 0) {
		pLVar4 = pLVar1;
	}
	scene = pLVar2;
	if ((float)pLVar1 < (float)pLVar2) {
		scene = pLVar1;
	}
	if (0.5 <= ((float)pLVar4 - (float)scene) / (float)(ulonglong)uVar5) {
		if ((fVar3 >= (float)pLVar4) ||
			 ((ushort)((ushort)(fVar3 < (float)scene) << 8 | (ushort)(fVar3 == (float)scene) << 0xe) != 0)
			 ) {
			return TRUE;
		}
	}
	else {
		if (((ushort)((ushort)(fVar3 < (float)pLVar4) << 8 | (ushort)(fVar3 == (float)pLVar4) << 0xe) !=
				 0) && ((float)scene <= fVar3)) {
			return TRUE;
		}
	}
	return 0;
}



float10 __cdecl lego::res::Lws_FindPrevDissolve(Lws_Node *node,float time,ushort *prev)
{
	ushort uVar1;
	ushort uVar2;
	ushort uVar3;
	
	uVar1 = node->dissolveCount;
	uVar3 = 1;
	if (uVar1 < 2) {
		*prev = uVar1 - 1;
		return (float10)0.0;
	}
	do {
		uVar2 = node->dissolveFrame[uVar3];
		if (time <= (float)(uint)uVar2) {
			*prev = uVar3 - 1;
			return ((float10)time - (float10)(uint)node->dissolveFrame[(ushort)(uVar3 - 1)]) /
						 ((float10)(uint)uVar2 - (float10)(uint)node->dissolveFrame[(ushort)(uVar3 - 1)]);
		}
		uVar3 += 1;
	} while (uVar3 < uVar1);
	*prev = uVar1 - 1;
	return (float10)0.0;
}



void __cdecl
lego::res::Lws_InterpolateDissolve(Lws_Info *scene,Lws_Node *node,ushort prev,float delta)
{
	float level;
	uint uVar1;
	
	uVar1 = (uint)prev;
	level = node->dissolveLevel[uVar1];
	if (uVar1 == node->dissolveCount - 1) {
		Lws_SetDissolveLevel(scene,node,level);
		return;
	}
	Lws_SetDissolveLevel(scene,node,(node->dissolveLevel[uVar1 + 1] - level) * delta + level);
	return;
}



void __cdecl lego::res::Lws_SetDissolveLevel(Lws_Info *scene,Lws_Node *node,float level)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	code **unaff_EDI;
	IDirect3DRMFrame3Vtbl *pIVar2;
	int *value;
	IDirect3DRMFrame3Vtbl *pIVar3;
	undefined4 uStack20;
	undefined local_4 [4];
	
	pIVar2 = scene->frameList[node->frameIndex].lpVtbl;
	uStack20 = 0;
	pIVar3 = pIVar2;
	(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,local_4);
	value = (int *)&stack0xfffffff0;
	(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,value,local_4);
	(**(code **)*unaff_EDI)(unaff_EDI,&idl::IID_IDirect3DRMUserVisual,&uStack20);
	(**(code **)(pIVar3->QueryInterface + 8))(pIVar3);
	mesh = (Mesh *)(**(code **)(*value + 0x1c))(value);
	(**(code **)(pIVar2->QueryInterface + 8))(pIVar2);
	DVar1 = Mesh_GetGroupCount(mesh);
	groupID = D3DRMGROUP_0;
	if (DVar1 != D3DRMGROUP_0) {
		do {
			Mesh_SetGroupMaterialValues(mesh,groupID,(float)value,MATERIAL_ALPHA);
			groupID += 1;
		} while (groupID < DVar1);
	}
	return;
}



void __cdecl lego::res::Lws_InterpolateKeys(Lws_Info *scene,Lws_Node *node,ushort key,float delta)
{
	int iVar1;
	Lws_KeyInfo *pLVar2;
	Lws_KeyInfo *pLVar3;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	pLVar3 = node->keyList;
	iVar1 = key + 1;
	pLVar2 = pLVar3 + key;
	local_18.x = (pLVar2->position).x + (pLVar3[iVar1].position.x - (pLVar2->position).x) * delta;
	local_18.y = (pLVar3[iVar1].position.y - (pLVar2->position).y) * delta + (pLVar2->position).y;
	local_18.z = (pLVar3[iVar1].position.z - (pLVar2->position).z) * delta + (pLVar2->position).z;
	local_24.x = (pLVar2->scale).x + (pLVar2[1].scale.x - (pLVar2->scale).x) * delta;
	local_24.y = (pLVar2[1].scale.y - (pLVar2->scale).y) * delta + (pLVar2->scale).y;
	local_24.z = (pLVar2[1].scale.z - (pLVar2->scale).z) * delta + (pLVar2->scale).z;
	local_c.x = (pLVar2->hpb).x + (pLVar2[1].hpb.x - (pLVar2->hpb).x) * delta;
	local_c.y = (pLVar2[1].hpb.y - (pLVar2->hpb).y) * delta + (pLVar2->hpb).y;
	local_c.z = (pLVar2[1].hpb.z - (pLVar2->hpb).z) * delta + (pLVar2->hpb).z;
	Lws_SetupNodeTransform(scene,node,&local_18,&local_c,&local_24);
	return;
}



void __cdecl
lego::res::Lws_SetupNodeTransform
					(Lws_Info *scene,Lws_Node *node,Vector3F *pos,Vector3F *hpb,Vector3F *scale)
{
	float *pfVar1;
	float fVar2;
	Lws_Node *pLVar3;
	float fVar4;
	IDirect3DRMFrame3Vtbl *pIVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float10 fVar11;
	float10 fVar12;
	float10 fVar13;
	float10 fVar14;
	float10 fVar15;
	float10 fVar16;
	undefined4 unaff_retaddr;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	undefined4 local_34;
	float local_30;
	float local_2c;
	float local_28;
	undefined4 local_24;
	float local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	int *local_c;
	float local_8;
	undefined4 local_4;
	
	pIVar5 = scene->frameList[node->frameIndex].lpVtbl;
	if ((node->flags & 4) == 0) {
		fVar11 = (float10)fsin((float10)hpb->z);
		fVar12 = (float10)fsin((float10)hpb->y);
		fVar13 = (float10)fcos((float10)hpb->z);
		fVar14 = (float10)fsin((float10)hpb->x);
		fVar6 = (node->pivotVector).x;
		fVar15 = (float10)fcos((float10)hpb->x);
		fVar16 = (float10)fcos((float10)hpb->y);
		local_3c = scale->x * (float)fVar11;
		fVar9 = scale->x * (float)fVar13;
		fVar2 = (float)fVar14;
		pLVar3 = (Lws_Node *)(float)fVar15;
		local_44 = scale->y * (float)fVar13;
		fVar4 = (float)(fVar12 * (float10)local_3c);
		hpb = (Vector3F *)(float)fVar16;
		local_3c = (float)hpb * local_3c;
		local_48 = (float)fVar12 * local_44;
		fVar7 = (node->pivotVector).y;
		fVar8 = (node->pivotVector).z;
		fVar10 = -(scale->y * (float)fVar11);
		local_40 = (float)((float10)fVar2 * (float10)fVar4 + fVar15 * (float10)fVar9);
		local_38 = (float)((float10)(float)pLVar3 * (float10)fVar4 + -(fVar14 * (float10)fVar9));
		pfVar1 = &scale->z;
		scale = (Vector3F *)(scale->z * (float)hpb);
		local_1c = -(*pfVar1 * (float)fVar12);
		local_20 = fVar2 * (float)scale;
		local_18 = (float)pLVar3 * (float)scale;
		local_2c = (float)hpb * local_44;
		local_30 = fVar2 * local_48 + (float)pLVar3 * fVar10;
		local_28 = -(fVar2 * fVar10) + (float)pLVar3 * local_48;
		local_34 = 0;
		local_24 = 0;
		local_10 = fVar7 * local_30 + fVar6 * local_40 + fVar8 * local_20 + pos->x;
		local_c = (int *)(fVar7 * local_2c + fVar6 * local_3c + fVar8 * local_1c + pos->y);
		local_8 = fVar7 * local_28 + fVar6 * local_38 + fVar8 * local_18 + pos->z;
		local_14 = 0;
		local_4 = 0x3f800000;
		node = pLVar3;
	}
	else {
		(**(code **)(pIVar5->QueryInterface + 0x5c))(pIVar5,&node);
		(**(code **)(pIVar5->QueryInterface + 0x74))(pIVar5,unaff_retaddr,&local_48);
		(**(code **)(*local_c + 8))(local_c);
		node = NULL;
		local_40 = local_40 * scale->x;
		local_2c = scale->y * local_2c;
		local_18 = scale->z * local_18;
		local_10 = pos->x;
		local_c = (int *)pos->y;
		local_8 = pos->z;
	}
	(**(code **)(pIVar5->QueryInterface + 0x38))(pIVar5,0,&local_40);
	return;
}



Mesh * __cdecl
lego::res::Lws_LoadMesh(char *baseDir,char *fname,IDirect3DRMFrame3 *frame,BOOL noTextures)
{
	char cVar1;
	Mesh *pMVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char filenameBuffer [260];
	
	if (baseDir == NULL) {
		uVar3 = 0xffffffff;
		pcVar6 = fname;
		do {
			pcVar7 = pcVar6;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar7 = pcVar6 + 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar7 + -uVar3);
		puVar8 = (undefined4 *)filenameBuffer;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar8 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
	}
	else {
		std::sprintf(filenameBuffer,"%s%s",baseDir,fname);
	}
	pMVar2 = Lws_SearchMeshPathList
										 (globs::lwsGlobs.meshPathList,globs::lwsGlobs.meshPathCount,filenameBuffer);
	if (pMVar2 != NULL) {
		Mesh_Clone(pMVar2,frame);
		return pMVar2;
	}
	pMVar2 = Mesh_Load(filenameBuffer,frame,noTextures);
	if (pMVar2 != NULL) {
		Lws_AddMeshPathEntry
							(globs::lwsGlobs.meshPathList,&globs::lwsGlobs.meshPathCount,filenameBuffer,pMVar2);
		return pMVar2;
	}
	if (globs::lwsGlobs.sharedDir != NULL) {
		std::sprintf(filenameBuffer,"%s%s",globs::lwsGlobs.sharedDir,fname);
		pMVar2 = Lws_SearchMeshPathList
											 (globs::lwsGlobs.meshPathListShared,globs::lwsGlobs.meshPathCountShared,fname
											 );
		if (pMVar2 != NULL) {
			Mesh_Clone(pMVar2,frame);
			return pMVar2;
		}
		pMVar2 = Mesh_Load(filenameBuffer,frame,noTextures);
		if (pMVar2 != NULL) {
			Lws_AddMeshPathEntry
								(globs::lwsGlobs.meshPathListShared,&globs::lwsGlobs.meshPathCountShared,fname,
								 pMVar2);
			return pMVar2;
		}
	}
	return NULL;
}



Mesh * __cdecl lego::res::Lws_SearchMeshPathList(Lws_MeshPath *list,uint count,char *path)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	
	uVar3 = 0;
	if (count == 0) {
		return NULL;
	}
	uVar1 = 0;
	do {
		iVar2 = std::_stricmp(path,list[uVar1].path);
		if (iVar2 == 0) {
			return list[uVar3 & 0xffff].mesh;
		}
		uVar3 += 1;
		uVar1 = uVar3 & 0xffff;
	} while (uVar1 < count);
	return NULL;
}



void __cdecl
lego::res::Lws_AddMeshPathEntry(Lws_MeshPath *ref_list,uint *ref_count,char *path,Mesh *mesh)
{
	char *pcVar1;
	
	pcVar1 = util::_strdup(path);
	ref_list[*ref_count].path = pcVar1;
	ref_list[*ref_count].mesh = mesh;
	*ref_count = *ref_count + 1;
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl
lego::res::Lws_CreateFrames
					(Lws_Info *scene,Lws_Node *node,IDirect3DRMFrame3 *parent,ushort *ref_frameCount)
{
	byte *pbVar1;
	Lws_Node *node_00;
	uint uVar2;
	int iVar3;
	IDirect3DRMFrame3 *unaff_EBP;
	byte *pbVar4;
	undefined4 *puVar5;
	IDirect3DRMFrame3 local_444;
	undefined4 auStack1088 [5];
	undefined4 uStack1068;
	undefined4 uStack1048;
	undefined4 uStack1040;
	undefined4 uStack1036;
	undefined4 uStack1032;
	undefined4 uStack1028;
	byte abStack1024 [1024];
	
	(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
						(globs::mainGlobs.lpD3DRM,parent,(IDirect3DRMFrame3 **)&local_444);
	if ((node->flags & 4) != 0) {
		puVar5 = auStack1088;
		for (iVar3 = 0x10; iVar3 != 0; iVar3 += -1) {
			*puVar5 = 0;
			puVar5 = puVar5 + 1;
		}
		uStack1032 = 0;
		uStack1036 = 0;
		uStack1040 = 0;
		uStack1028 = 0x3f800000;
		uStack1048 = 0x3f800000;
		uStack1068 = 0x3f800000;
		auStack1088[0] = 0x3f800000;
		(**(code **)(*(int *)local_444 + 0x38))(local_444,0,auStack1088);
	}
	scene->frameList[*ref_frameCount].lpVtbl = local_444;
	node->frameIndex = *ref_frameCount;
	*ref_frameCount = *ref_frameCount + 1;
	std::sprintf((char *)abStack1024,"%s_%0.2i",node->name,(uint)node->reference);
	pbVar4 = abStack1024;
	while (abStack1024[0] != 0) {
						// int std::isgraph(int c)
						//  (or close enough to this?)
		if (std::globals::_pcharwidth < 2) {
						// C1_ALPHA | C1_BLANK | C1_PUNCT | C1_DIGIT | C1_LOWER | C1_UPPER (0x100 | 0x40 | 0x10
						// | 0x4 | 0x2 | 0x1)
			uVar2 = std::globals::_pctype[*pbVar4] & 0x157;
		}
		else {
			uVar2 = std::_isctype((uint)*pbVar4,0x157);
		}
		if (uVar2 == 0) {
			*pbVar4 = 0x5f;
		}
		pbVar1 = pbVar4 + 1;
		pbVar4 = pbVar4 + 1;
		abStack1024[0] = *pbVar1;
	}
	(**(code **)(*(int *)local_444 + 0x20))(local_444,abStack1024);
	for (node_00 = node->childList; node_00 != NULL; node_00 = node_00->next) {
		Lws_CreateFrames(scene,node_00,unaff_EBP,ref_frameCount);
	}
	return;
}



void __cdecl lego::res::Lws_LoadNodes(Lws_Info *scene,Lws_Node *node)
{
	IDirect3DRMFrame3Vtbl *frame;
	Lws_Node *node_00;
	Mesh *pMVar1;
	
	frame = scene->frameList[node->frameIndex].lpVtbl;
	if (node->keyCount == 1) {
		Lws_SetAbsoluteKey(scene,node,0);
	}
	if (((node->flags & 1) == 0) &&
		 (pMVar1 = Lws_LoadMesh(scene->filePath,node->name,(IDirect3DRMFrame3 *)frame,0), pMVar1 != NULL
		 )) {
		if ((node->flags & 4) != 0) {
			pMVar1->flags = pMVar1->flags | 0x1000000;
		}
		if ((node->dissolveLevel != NULL) && (node->dissolveCount == 0)) {
			Lws_SetDissolveLevel(scene,node,*node->dissolveLevel);
			node->dissolveLevel = NULL;
		}
	}
	for (node_00 = node->childList; node_00 != NULL; node_00 = node_00->next) {
		Lws_LoadNodes(scene,node_00);
	}
	return;
}



void __cdecl lego::res::Lws_SetAbsoluteKey(Lws_Info *scene,Lws_Node *node,ushort key)
{
	Lws_KeyInfo *pos;
	
	pos = node->keyList + key;
	Lws_SetupNodeTransform(scene,node,&pos->position,&pos->hpb,&pos->scale);
	return;
}



void __cdecl lego::res::Lws_Free(Lws_Info *scene)
{
	Lws_Info *pLVar1;
	uint uVar2;
	ushort uVar3;
	
	do {
		pLVar1 = scene->clonedFrom;
		uVar2 = scene->referenceCount - 1;
		scene->referenceCount = uVar2;
		if (uVar2 == 0) {
			uVar3 = 0;
			if (scene->nodeCount != 0) {
				do {
					Lws_FreeNode(scene,scene->nodeList + uVar3);
					uVar3 += 1;
				} while (uVar3 < scene->nodeCount);
			}
			if (scene->clonedFrom == NULL) {
				std::free(scene->nodeList);
				std::free(scene->filePath);
				if (scene->triggerCount != 0) {
					std::free(scene->triggerList);
				}
			}
			std::free(scene->frameList);
			std::free(scene);
		}
		scene = pLVar1;
	} while (pLVar1 != NULL);
	return;
}



void __cdecl lego::res::Lws_FreeNode(Lws_Info *scene,Lws_Node *node)
{
	Mesh *mesh;
	code **unaff_EDI;
	IDirect3DRMFrame3Vtbl *pIVar1;
	int *piVar2;
	IDirect3DRMFrame3Vtbl *pIVar3;
	undefined local_4 [4];
	
	if ((node->flags & 1) == 0) {
		pIVar1 = scene->frameList[node->frameIndex].lpVtbl;
		pIVar3 = pIVar1;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,local_4);
		piVar2 = (int *)&stack0xfffffff0;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,piVar2,local_4);
		(**(code **)*unaff_EDI)(unaff_EDI,&idl::IID_IDirect3DRMUserVisual,&stack0xffffffec);
		(**(code **)(pIVar3->QueryInterface + 8))(pIVar3);
		mesh = (Mesh *)(**(code **)(*piVar2 + 0x1c))(piVar2);
		(**(code **)(pIVar1->QueryInterface + 8))(pIVar1);
		Mesh_Remove(mesh,(IDirect3DRMFrame3 *)scene->frameList[node->frameIndex].lpVtbl);
	}
	if ((scene->clonedFrom == NULL) && (scene->referenceCount == 0)) {
		std::free(node->name);
		std::free(node->keyList);
		if (node->dissolveCount != 0) {
			std::free(node->dissolveLevel);
			std::free(node->dissolveFrame);
		}
	}
	return;
}



BOOL __cdecl lego::snd::Sound_Initialise(BOOL nosound)
{
	BOOL BVar1;
	
	globs::soundGlobs.initialised = ZEXT14(nosound == 0);
	globs::soundGlobs.loopCDTrack = -1;
	if (nosound != 0) {
		globs::soundGlobs.loopCDTrack = -1;
		return 1;
	}
	BVar1 = Sound3D_Initialise(globs::mainGlobs.hWnd);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::snd::Sound_IsInitialised(void)
{
	if ((globs::soundGlobs.initialised != 0) && (globs::sound3DGlobs.intialised != 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::snd::Sound_PlayCDTrack(uint track,SoundMode mode,SoundCDStopCallback stopCallback)
{
	BOOL BVar1;
	
	BVar1 = globs::soundGlobs.initialised;
	if (globs::soundGlobs.initialised != 0) {
		if (mode == SOUND_LOOP) {
			globs::soundGlobs.loopCDTrack = TRUE;
		}
		globs::soundGlobs.currTrack = track;
		globs::soundGlobs.CDStopCallback = stopCallback;
		BVar1 = Play_CDTrack(track);
	}
	return BVar1;
}



BOOL __cdecl lego::snd::Sound_StopCD(void)
{
	BOOL BVar1;
	
	if (globs::soundGlobs.initialised != 0) {
		BVar1 = Stop_CDTrack();
		return BVar1;
	}
	return 0;
}



void __cdecl lego::snd::Sound_Update(BOOL cdtrack)
{
	uint uVar1;
	DWORD DVar2;
	BOOL BVar3;
	
	uVar1 = globs::soundGlobs.s_Update_lastUpdate;
	if ((((globs::soundGlobs.initialised != 0) &&
			 (DVar2 = timeGetTime(), uVar1 = globs::soundGlobs.s_Update_lastUpdate,
			 globs::soundGlobs.s_Update_lastUpdate + 4000 < DVar2)) && (uVar1 = DVar2, cdtrack != 0)) &&
		 (BVar3 = Status_CDTrack(globs::soundGlobs.currTrack), BVar3 == 0)) {
		if (globs::soundGlobs.loopCDTrack != 0) {
			Restart_CDTrack(globs::soundGlobs.currTrack);
		}
		if (globs::soundGlobs.CDStopCallback != NULL) {
			(*globs::soundGlobs.CDStopCallback)();
		}
	}
	globs::soundGlobs.s_Update_lastUpdate = uVar1;
	return;
}



// WARNING: Could not reconcile some variable overlaps
// This function will open a wave input file and prepare it for reading,
// so the data can be easily
// read with WaveReadFile. Returns 0 if successful, the error code if not.
//     pszFileName - Input filename to load.
//     phmmioIn    - Pointer to handle which will be used
//         for further mmio routines.
//     ppwfxInfo   - Ptr to ptr to WaveFormatEx structure
//         with all info about the file. 

int __cdecl
lego::snd::WaveOpenFile
					(void *fileData,uint fileSize,HMMIO *out_phmmioIn,WAVEFORMATEX **out_ppwfxInfo,
					MMCKINFO *out_pckInRIFF)
{
	WAVEFORMATEX **ppWVar1;
	MMCKINFO *pmmckiParent;
	HMMIO hmmio;
	LONG LVar2;
	WAVEFORMATEX *pWVar3;
	uint uVar4;
	int iVar5;
	MMRESULT MVar6;
	_MMIOINFO *p_Var7;
	undefined4 local_6c;
	DWORD local_68;
	DWORD local_64;
	undefined4 local_60;
	_MMCKINFO local_5c;
	_MMIOINFO local_48;
	
	*out_ppwfxInfo = NULL;
	p_Var7 = &local_48;
	for (iVar5 = 0x12; iVar5 != 0; iVar5 += -1) {
		p_Var7->dwFlags = 0;
		p_Var7 = (_MMIOINFO *)&p_Var7->fccIOProc;
	}
						// "MEM "
	local_48.fccIOProc = 0x204d454d;
	local_48.pchBuffer = (HPSTR)fileData;
	local_48.cchBuffer = fileSize;
	hmmio = mmioOpenA(NULL,(LPMMIOINFO)&local_48,0x10000);
	pmmckiParent = out_pckInRIFF;
	if (hmmio == NULL) {
		MVar6 = 0xe100;
	}
	else {
		MVar6 = mmioDescend(hmmio,(LPMMCKINFO)out_pckInRIFF,NULL,0);
		if (MVar6 == 0) {
			if ((pmmckiParent->ckid == 0x46464952) && (pmmckiParent->fccType == 0x45564157)) {
				local_5c.ckid = 0x20746d66;
				MVar6 = mmioDescend(hmmio,(LPMMCKINFO)&local_5c,pmmckiParent,0x10);
				if (MVar6 != 0) goto LAB_004890e9;
				if (0xf < local_5c.cksize) {
					LVar2 = mmioRead(hmmio,(HPSTR)&local_6c,0x10);
					if (LVar2 != 0x10) {
						MVar6 = 0xe102;
						goto LAB_004890e9;
					}
					if ((short)local_6c == 1) {
						fileData = NULL;
					}
					else {
						LVar2 = mmioRead(hmmio,(HPSTR)&fileData,2);
						if (LVar2 != 2) {
							MVar6 = 0xe102;
							goto LAB_004890e9;
						}
					}
					pWVar3 = (WAVEFORMATEX *)GlobalAlloc(0,((uint)fileData & 0xffff) + 0x12);
					*out_ppwfxInfo = pWVar3;
					if (pWVar3 == NULL) {
						MVar6 = 0xe000;
						goto LAB_004890e9;
					}
					*(undefined4 *)pWVar3 = local_6c;
					pWVar3->nSamplesPerSec = local_68;
					pWVar3->nAvgBytesPerSec = local_64;
					*(undefined4 *)&pWVar3->nBlockAlign = local_60;
					(*out_ppwfxInfo)->cbSize = (WORD)fileData;
					if (((WORD)fileData == 0) ||
						 (uVar4 = mmioRead(hmmio,(HPSTR)(*out_ppwfxInfo + 1),(uint)fileData & 0xffff),
						 uVar4 == ((uint)fileData & 0xffff))) {
						MVar6 = mmioAscend(hmmio,(LPMMCKINFO)&local_5c,0);
						if (MVar6 == 0) {
							*out_phmmioIn = hmmio;
							return 0;
						}
						goto LAB_004890e9;
					}
				}
			}
			MVar6 = 0xe101;
		}
	}
LAB_004890e9:
	ppWVar1 = out_ppwfxInfo;
	if (*out_ppwfxInfo != NULL) {
		GlobalFree(*out_ppwfxInfo);
		*ppWVar1 = NULL;
	}
	if (hmmio != NULL) {
		mmioClose(hmmio,0);
		hmmio = NULL;
	}
	*out_phmmioIn = hmmio;
	return MVar6;
}



uint __cdecl lego::snd::GetWaveAvgBytesPerSec(char *pszFileName)
{
	HMMIO hmmio;
	MMRESULT MVar1;
	LONG LVar2;
	uint uVar3;
	PCMWAVEFORMAT local_38;
	_MMCKINFO local_28;
	_MMCKINFO local_14;
	
	uVar3 = 0;
	hmmio = mmioOpenA(pszFileName,NULL,0);
	if (hmmio != NULL) {
		MVar1 = mmioDescend(hmmio,(LPMMCKINFO)&local_28,NULL,0);
						// "RIFF", "WAVE"
		if (((MVar1 == 0) && (local_28.ckid == L'\x46464952')) && (local_28.fccType == L'\x45564157')) {
						// "fmt "
			local_14.ckid = L'\x20746d66';
			MVar1 = mmioDescend(hmmio,(LPMMCKINFO)&local_14,(MMCKINFO *)&local_28,0x10);
			if ((MVar1 == 0) && (0xf < local_14.cksize)) {
				LVar2 = mmioRead(hmmio,(HPSTR)&local_38,0x10);
				if (LVar2 == 0x10) {
					uVar3 = local_38.wf.nAvgBytesPerSec;
				}
			}
		}
		if (hmmio != NULL) {
			mmioClose(hmmio,0);
		}
	}
	return uVar3;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl
lego::snd::WaveOpenFile2
					(char *pszFileName,HMMIO *out_phmmioIn,WAVEFORMATEX **out_ppwfxInfo,
					MMCKINFO *out_pckInRIFF)
{
	WAVEFORMATEX **ppWVar1;
	MMCKINFO *pmmckiParent;
	HMMIO hmmio;
	LONG LVar2;
	WAVEFORMATEX *pWVar3;
	uint uVar4;
	MMRESULT MVar5;
	undefined4 local_24;
	DWORD local_20;
	DWORD local_1c;
	undefined4 local_18;
	_MMCKINFO local_14;
	
	*out_ppwfxInfo = NULL;
	hmmio = mmioOpenA(pszFileName,NULL,0x10000);
	pmmckiParent = out_pckInRIFF;
	if (hmmio == NULL) {
		MVar5 = 0xe100;
	}
	else {
		MVar5 = mmioDescend(hmmio,(LPMMCKINFO)out_pckInRIFF,NULL,0);
		if (MVar5 == 0) {
			if ((pmmckiParent->ckid == L'\x46464952') && (pmmckiParent->fccType == L'\x45564157')) {
				local_14.ckid = L'\x20746d66';
				MVar5 = mmioDescend(hmmio,(LPMMCKINFO)&local_14,pmmckiParent,0x10);
				if (MVar5 != 0) goto LAB_00489343;
				if (0xf < local_14.cksize) {
					LVar2 = mmioRead(hmmio,(HPSTR)&local_24,0x10);
					if (LVar2 != 0x10) {
						MVar5 = 0xe102;
						goto LAB_00489343;
					}
					if ((short)local_24 == 1) {
						pszFileName = NULL;
					}
					else {
						LVar2 = mmioRead(hmmio,(HPSTR)&pszFileName,2);
						if (LVar2 != 2) {
							MVar5 = 0xe102;
							goto LAB_00489343;
						}
					}
					pWVar3 = (WAVEFORMATEX *)GlobalAlloc(0,((uint)pszFileName & 0xffff) + 0x12);
					*out_ppwfxInfo = pWVar3;
					if (pWVar3 == NULL) {
						MVar5 = 0xe000;
						goto LAB_00489343;
					}
					*(undefined4 *)pWVar3 = local_24;
					pWVar3->nSamplesPerSec = local_20;
					pWVar3->nAvgBytesPerSec = local_1c;
					*(undefined4 *)&pWVar3->nBlockAlign = local_18;
					(*out_ppwfxInfo)->cbSize = (WORD)pszFileName;
					if (((WORD)pszFileName == 0) ||
						 (uVar4 = mmioRead(hmmio,(HPSTR)(*out_ppwfxInfo + 1),(uint)pszFileName & 0xffff),
						 uVar4 == ((uint)pszFileName & 0xffff))) {
						MVar5 = mmioAscend(hmmio,(LPMMCKINFO)&local_14,0);
						if (MVar5 == 0) {
							*out_phmmioIn = hmmio;
							return 0;
						}
						goto LAB_00489343;
					}
				}
			}
			MVar5 = 0xe101;
		}
	}
LAB_00489343:
	ppWVar1 = out_ppwfxInfo;
	if (*out_ppwfxInfo != NULL) {
		GlobalFree(*out_ppwfxInfo);
		*ppWVar1 = NULL;
	}
	if (hmmio != NULL) {
		mmioClose(hmmio,0);
		hmmio = NULL;
	}
	*out_phmmioIn = hmmio;
	return MVar5;
}



// This routine has to be called before WaveReadFile as it searchs for the chunk to descend into for
// reading, that is, the 'data' chunk.  For simplicity, this used to be in the open routine, but was
// taken out and moved to a separate routine so there was more control on the chunks that are before
// the data chunk, such as 'fact', etc...

int __cdecl lego::snd::WaveStartDataRead(HMMIO *phmmioIn,MMCKINFO *pckIn,MMCKINFO *pckInRIFF)
{
	MMRESULT MVar1;
	
	mmioSeek(*phmmioIn,pckInRIFF->dwDataOffset + 4,0);
	pckIn->ckid = L'\x61746164';
	MVar1 = mmioDescend(*phmmioIn,(LPMMCKINFO)pckIn,pckInRIFF,0x10);
	return MVar1;
}



// This will read wave data from the wave file.  Makre sure we're descended into
// the data chunk, else this will fail bigtime!
// hmmioIn         - Handle to mmio.
// cbRead          - # of bytes to read.   
// pbDest          - Destination buffer to put bytes.
// cbActualRead- # of bytes actually read.

int __cdecl
lego::snd::WaveReadFile(HMMIO hmmioIn,uint cbRead,byte *pbDest,MMCKINFO *pckIn,uint *cbActualRead)
{
	byte bVar1;
	MMRESULT MVar2;
	uint uVar3;
	byte *pbVar4;
	uint uVar5;
	_MMIOINFO local_48;
	
	MVar2 = mmioGetInfo(hmmioIn,(LPMMIOINFO)&local_48,0);
	uVar3 = (uint)(MVar2 != 0);
	if (uVar3 == 0) {
		uVar3 = pckIn->cksize;
		if (uVar3 < cbRead) {
			cbRead = uVar3;
		}
		uVar5 = 0;
		pckIn->cksize = uVar3 - cbRead;
		pbVar4 = (byte *)local_48.pchEndRead;
		if (cbRead != 0) {
			do {
				if ((byte *)local_48.pchNext == pbVar4) {
					uVar3 = mmioAdvance(hmmioIn,(LPMMIOINFO)&local_48,0);
					if (uVar3 != 0) goto LAB_00489456;
					pbVar4 = (byte *)local_48.pchEndRead;
					if (local_48.pchNext == local_48.pchEndRead) {
						*cbActualRead = 0;
						return 0xe103;
					}
				}
				bVar1 = *local_48.pchNext;
				local_48.pchNext = (HPSTR)((byte *)local_48.pchNext + 1);
				pbDest[uVar5] = bVar1;
				uVar5 += 1;
			} while (uVar5 < cbRead);
		}
		uVar3 = mmioSetInfo(hmmioIn,(LPCMMIOINFO)&local_48,0);
		if (uVar3 == 0) {
			*cbActualRead = cbRead;
			return 0;
		}
	}
LAB_00489456:
	*cbActualRead = 0;
	return uVar3;
}



// This will close the wave file openned with WaveOpenFile.  
// phmmioIn - Pointer to the handle to input MMIO.
// ppwfxSrc - Pointer to pointer to WaveFormatEx structure.
// 
// Returns 0 if successful, non-zero if there was a warning.

int __cdecl lego::snd::WaveCloseReadFile(HMMIO *phmmio,WAVEFORMATEX **ppwfxSrc)
{
	if (*ppwfxSrc != NULL) {
		GlobalFree(*ppwfxSrc);
		*ppwfxSrc = NULL;
	}
	if (*phmmio != NULL) {
		mmioClose(*phmmio,0);
		*phmmio = NULL;
	}
	return 0;
}



BOOL __cdecl lego::snd::Restart_CDTrack(int track)
{
	CHAR local_64 [100];
	
	wsprintfA(local_64,"play cdaudio from %i",track + 1);
	globs::soundGlobs.mciErr = mciSendStringA(local_64,globs::mciReturn,200,NULL);
	if (globs::soundGlobs.mciErr != 0) {
		ReportCDError();
		return 0;
	}
	return TRUE;
}



void __cdecl lego::snd::ReportCDError(void)
{
	mciGetErrorStringA(globs::soundGlobs.mciErr,globs::mciReturn,200);
	return;
}



BOOL __cdecl lego::snd::Status_CDTrack(int track)
{
	int iVar1;
	char buff [100];
	
	std::sprintf(buff,"status cdaudio mode");
	globs::soundGlobs.mciErr = mciSendStringA(buff,globs::mciReturn,200,NULL);
	iVar1 = std::_stricmp(globs::mciReturn,"stopped");
	if (iVar1 != 0) {
		std::sprintf(buff,"status cdaudio current track");
		globs::soundGlobs.mciErr = mciSendStringA(buff,globs::mciReturn,200,NULL);
		iVar1 = std::atoi(globs::mciReturn);
		if (iVar1 <= track + 1) {
			return TRUE;
		}
	}
	ReportCDError();
	return 0;
}



BOOL __cdecl lego::snd::Play_CDTrack(int track)
{
	globs::soundGlobs.mciErr = mciSendStringA("open cdaudio",globs::mciReturn,200,NULL);
	if (globs::soundGlobs.mciErr == 0) {
		globs::soundGlobs.mciErr =
				 mciSendStringA("set cdaudio time format tmsf",globs::mciReturn,200,NULL);
		if (globs::soundGlobs.mciErr == 0) {
			Restart_CDTrack(track);
			if (globs::soundGlobs.mciErr == 0) {
				return 1;
			}
		}
	}
	ReportCDError();
	return 0;
}



BOOL __cdecl lego::snd::Stop_CDTrack(void)
{
	globs::soundGlobs.mciErr = mciSendStringA("stop cdaudio",globs::mciReturn,200,NULL);
	if (globs::soundGlobs.mciErr == 0) {
		globs::soundGlobs.mciErr = mciSendStringA("close cdaudio",globs::mciReturn,200,NULL);
		if (globs::soundGlobs.mciErr == 0) {
			return TRUE;
		}
	}
	ReportCDError();
	return 0;
}



void __cdecl lego::file::Mem_Initialise(void)
{
	Mem_HandleFlags *pMVar1;
	
	pMVar1 = &globs::memGlobs.handleList[0].flags;
	do {
		pMVar1[-1] = MEMORY_HANDLE_FLAG_NONE;
		*pMVar1 = MEMORY_HANDLE_FLAG_NONE;
		pMVar1 = pMVar1 + 2;
	} while (pMVar1 < &DAT_005498a4);
	return;
}



uint __cdecl lego::file::Mem_AllocHandle(uint size)
{
	Mem_HandleFlags *pMVar1;
	void *pvVar2;
	uint uVar3;
	
	uVar3 = 0;
	pMVar1 = &globs::memGlobs.handleList[0].flags;
	do {
		if ((*(byte *)pMVar1 & MEMORY_HANDLE_FLAG_USED) == 0) {
			pvVar2 = std::malloc(size);
			globs::memGlobs.handleList[uVar3].addr = pvVar2;
			globs::memGlobs.handleList[uVar3].flags = globs::memGlobs.handleList[uVar3].flags | 1;
			return uVar3;
		}
		pMVar1 = pMVar1 + 2;
		uVar3 += 1;
	} while (pMVar1 < &DAT_005498a4);
	return 0xffffffff;
}



void __cdecl lego::file::Mem_FreeHandle(uint handle)
{
	if ((handle < 2000) && ((*(byte *)&globs::memGlobs.handleList[handle].flags & 1) != 0)) {
		std::free(globs::memGlobs.handleList[handle].addr);
		globs::memGlobs.handleList[handle].addr = NULL;
		globs::memGlobs.handleList[handle].flags = MEMORY_HANDLE_FLAG_NONE;
	}
	return;
}



void * __cdecl lego::file::Mem_AddressHandle(uint handle)
{
	if ((handle < 2000) && ((*(byte *)&globs::memGlobs.handleList[handle].flags & 1) != 0)) {
		return globs::memGlobs.handleList[handle].addr;
	}
	return NULL;
}



IDirect3DRMMaterial2 * __cdecl
lego::res::Material_Create
					(float emissiveRed,float emissiveGreen,float emissiveBlue,float specularRed,
					float specularGreen,float specularBlue,float power)
{
	HRESULT HVar1;
	
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMaterial)
										(globs::mainGlobs.lpD3DRM,power,(IDirect3DRMMaterial2 **)&power);
	if (HVar1 == 0) {
						// IDirect3DRMMaterial2->SetEmissive(this, float r, float g, float b)
		(**(code **)((int)*(IDirect3DRMMaterial2 *)power + 0x34))
							((IDirect3DRMMaterial2 *)power,emissiveRed,emissiveGreen,emissiveBlue);
						// IDirect3DRMMaterial2->SetSpecular(this, float r, float g, float b)
		(**(code **)((int)*(IDirect3DRMMaterial2 *)power + 0x30))
							((IDirect3DRMMaterial2 *)power,specularRed,specularGreen,specularBlue);
		return (IDirect3DRMMaterial2 *)power;
	}
	return NULL;
}



AnimClone * __cdecl
lego::res::AnimClone_Register
					(IDirect3DRMAnimationSet2 *animSet,IDirect3DRMFrame3 *root,uint frameCount)
{
	uint *data;
	AnimClone *actFrame;
	IDirect3DRMFrame3 **ppIVar1;
	AnimClone dummyActFrame;
	
	actFrame = (AnimClone *)std::malloc(0x20);
	actFrame->clonedFrom = NULL;
	actFrame->animSet = animSet;
	actFrame->scene = NULL;
	actFrame->lws = 0;
	actFrame->root = root;
	(*root->lpVtbl->AddRef)((IUnknown *)root);
	data = &actFrame->partCount;
	*data = 0;
	actFrame->frameCount = (uint)root;
	AnimClone_WalkTree(root,0,AnimClone_FrameCountCallback,data);
	ppIVar1 = (IDirect3DRMFrame3 **)std::malloc(*data << 2);
	actFrame->partArray = ppIVar1;
	AnimClone_WalkTree(root,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffdc);
	return actFrame;
}



AnimClone * __cdecl
lego::res::AnimClone_RegisterLws(void *struct38,IDirect3DRMFrame3 *rmFrame3,undefined4 field1c)
{
	uint *data;
	AnimClone *pAVar1;
	IDirect3DRMFrame3 **ppIVar2;
	AnimClone dummyActFrame;
	
	pAVar1 = (AnimClone *)std::malloc(0x20);
	pAVar1->clonedFrom = NULL;
	pAVar1->animSet = NULL;
	pAVar1->scene = (Lws_Info *)struct38;
	pAVar1->lws = 1;
	pAVar1->root = rmFrame3;
	(*rmFrame3->lpVtbl->AddRef)((IUnknown *)rmFrame3);
	data = &pAVar1->partCount;
	*data = 0;
	pAVar1->frameCount = (uint)rmFrame3;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_FrameCountCallback,data);
	ppIVar2 = (IDirect3DRMFrame3 **)std::malloc(*data << 2);
	pAVar1->partArray = ppIVar2;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffdc);
	return pAVar1;
}



AnimClone * __cdecl
lego::res::AnimClone_Make(AnimClone *lastActFrameRes,IDirect3DRMFrame3 *parent,uint *out_frameCount)
{
	IDirect3DRMFrame3 **lplpD3DRMFrame;
	AnimClone *pAVar1;
	Lws_Info *pLVar2;
	IDirect3DRMFrame3 **ppIVar3;
	int iVar4;
	AnimClone *pAVar5;
	AnimClone *pAVar6;
	uint *unaff_retaddr;
	
	pAVar1 = (AnimClone *)std::malloc(0x20);
	iVar4 = 8;
	pAVar5 = lastActFrameRes;
	pAVar6 = pAVar1;
	if (lastActFrameRes->lws == 0) {
		for (; iVar4 != 0; iVar4 += -1) {
			pAVar6->clonedFrom = NULL;
			pAVar6 = (AnimClone *)&pAVar6->scene;
		}
						// IDirect3DRMAnimationSet2->SetTime(IDirect3DRMAnimationSet2* this, float rvTime)
		(*(code *)lastActFrameRes->animSet->lpVtbl->SetTime)(lastActFrameRes->animSet,0.0);
		pAVar1->animSet = NULL;
		pAVar1->clonedFrom = lastActFrameRes;
		lplpD3DRMFrame = &pAVar1->root;
						// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame, IDirect3DRMFrame3**
						// lplpD3DRMFrame)
		(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
							(globs::mainGlobs.lpD3DRM,parent,lplpD3DRMFrame);
		ppIVar3 = (IDirect3DRMFrame3 **)std::malloc(lastActFrameRes->partCount << 2);
		pAVar1->partArray = ppIVar3;
		AnimClone_CreateCopy(lastActFrameRes->root,*lplpD3DRMFrame,lastActFrameRes->lws);
		pAVar1->partCount = lastActFrameRes->partCount;
		if (unaff_retaddr != NULL) {
			*unaff_retaddr = lastActFrameRes->frameCount;
		}
		AnimClone_WalkTree(*lplpD3DRMFrame,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffd4);
	}
	else {
		for (; iVar4 != 0; iVar4 += -1) {
			pAVar6->clonedFrom = pAVar5->clonedFrom;
			pAVar5 = (AnimClone *)&pAVar5->scene;
			pAVar6 = (AnimClone *)&pAVar6->scene;
		}
		pLVar2 = Lws_Clone(lastActFrameRes->scene,parent);
		pAVar1->scene = pLVar2;
		pAVar1->clonedFrom = NULL;
		if (out_frameCount != NULL) {
			*out_frameCount = lastActFrameRes->frameCount;
			return pAVar1;
		}
	}
	return pAVar1;
}



void __cdecl lego::res::AnimClone_Remove(AnimClone *actFrameRes)
{
	uint uVar1;
	
	if (actFrameRes != NULL) {
		if (actFrameRes->clonedFrom == NULL) {
			if (actFrameRes->lws == 0) {
				(*actFrameRes->animSet->lpVtbl->Release)((IUnknown *)actFrameRes->animSet);
				(*actFrameRes->root->lpVtbl->Release)((IUnknown *)actFrameRes->root);
			}
			else {
				Lws_Free(actFrameRes->scene);
			}
		}
		if (actFrameRes->lws == 0) {
			uVar1 = 0;
			if (actFrameRes->partCount != 0) {
				do {
					(*actFrameRes->partArray[uVar1]->lpVtbl->Release)
										((IUnknown *)actFrameRes->partArray[uVar1]);
					uVar1 += 1;
				} while (uVar1 < actFrameRes->partCount);
			}
			std::free(actFrameRes->partArray);
		}
		std::free(actFrameRes);
	}
	return;
}



// This function performs the same accessor,
//  shared between 3 different structure types.
// uint __cdecl Flic_GetWidth(ImageFlic* fsp);
// BOOL __cdecl AnimClone_IsLws(AnimClone* clone);
// uint __cdecl Flocks_GetNumSubdata(Flocks* flocksData);

BOOL __cdecl lego::res::AnimClone_IsLws__Flic_GetWidth(AnimClone *clone)
{
	return clone->lws;
}



void __cdecl lego::res::AnimClone_SetTime(AnimClone *clone,float time,float *out_oldTime)
{
	AnimClone *pAVar1;
	uint uVar2;
	Matrix4F local_40;
	
	pAVar1 = clone->clonedFrom;
	if (pAVar1 == NULL) {
		if (clone->lws != 0) {
			Lws_SetTime(clone->scene,time);
			return;
		}
		(*(code *)clone->animSet->lpVtbl->SetTime)(clone->animSet,time);
	}
	else {
		if (pAVar1->lws == 0) {
			(*(code *)pAVar1->animSet->lpVtbl->SetTime)(pAVar1->animSet,time);
		}
		else {
			Lws_SetTime(pAVar1->scene,time);
		}
		uVar2 = 0;
		if (clone->partCount != 0) {
			do {
				(*pAVar1->partArray[uVar2]->lpVtbl->GetParent)
									(pAVar1->partArray[uVar2],(IDirect3DRMFrame3 **)&time);
				(*pAVar1->partArray[uVar2]->lpVtbl->GetTransform)
									(pAVar1->partArray[uVar2],(IDirect3DRMFrame3 *)time,&local_40);
				(**(code **)((int)*(IDirect3DRMFrame3 *)time + 8))((IUnknown *)time);
				(*clone->partArray[uVar2]->lpVtbl->AddTransform)
									(clone->partArray[uVar2],D3DRMCOMBINE_REPLACE,&local_40);
				uVar2 += 1;
			} while (uVar2 < clone->partCount);
		}
		if (out_oldTime != NULL) {
			if (pAVar1->lws != 0) {
				Lws_SetTime(pAVar1->scene,*out_oldTime);
				return;
			}
			(*(code *)pAVar1->animSet->lpVtbl->SetTime)(pAVar1->animSet,*out_oldTime);
			return;
		}
	}
	return;
}



BOOL __cdecl lego::res::AnimClone_FrameCountCallback(IDirect3DRMFrame3 *frame,int *lpFramesCount)
{
	*lpFramesCount = *lpFramesCount + 1;
	return 0;
}



BOOL __cdecl
lego::res::AnimClone_SetupFrameArrayCallback(IDirect3DRMFrame3 *frame,AnimClone *actFrameRes)
{
	actFrameRes->partArray[actFrameRes->partCount] = frame;
	actFrameRes->partCount = actFrameRes->partCount + 1;
	return 0;
}



BOOL __cdecl
lego::res::AnimClone_WalkTree
					(IDirect3DRMFrame3 *frame,uint level,AnimCloneWalkTreeCallback Callback,
					IDirect3DRMFrame3 *data)
{
	uint level_00;
	IDirect3DRMFrame3 *pIVar1;
	AnimCloneWalkTreeCallback Callback_00;
	IDirect3DRMFrame3 *data_00;
	int iVar2;
	HRESULT HVar3;
	uint uVar4;
	BOOL BVar5;
	uint index;
	BOOL local_8;
	
	data_00 = data;
	Callback_00 = Callback;
	pIVar1 = frame;
	local_8 = 0;
	iVar2 = (*Callback)(frame,data);
	if (iVar2 != 0) {
		return 1;
	}
						// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar3 = (*pIVar1->lpVtbl->GetChildren)(pIVar1,(IDirect3DRMFrameArray **)&frame);
	if (HVar3 == 0) {
						// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar4 = (*frame->lpVtbl->Clone)((IDirect3DRMFrameArray *)frame);
		index = 0;
		if (uVar4 != 0) {
			level_00 = level + 1;
			do {
						// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
						// lplpD3DRMFrame)
				(*frame->lpVtbl->AddDestroyCallback)
									((IDirect3DRMFrameArray *)frame,index,(IUnknown **)&Callback);
						// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3, IDirect3DRMFrame3**
						// lplpOut)
				(**(code **)*(IUnknown *)Callback)((IUnknown *)Callback,&idl::IID_IDirect3DRMFrame3,&data);
						// IDirect3DRMFrame->Release(this)
				(**(code **)((int)*(IUnknown *)Callback + 8))((IUnknown *)Callback);
				BVar5 = AnimClone_WalkTree(data,level_00,Callback_00,data_00);
				if (BVar5 != 0) {
					local_8 = 1;
					(*data->lpVtbl->Release)((IUnknown *)data);
					break;
				}
				(*data->lpVtbl->Release)((IUnknown *)data);
				index += 1;
			} while (index < uVar4);
		}
		(*frame->lpVtbl->Release)((IUnknown *)frame);
	}
	return local_8;
}



void __cdecl
lego::res::AnimClone_CreateCopy(IDirect3DRMFrame3 *orig,IDirect3DRMFrame3 *clone,BOOL lws)
{
	IDirect3DRMFrame3 *this;
	IDirect3DRMFrame3 *this_00;
	BOOL lws_00;
	LPCSTR lpName;
	HRESULT HVar1;
	uint uVar2;
	LPVOID *unaff_EBP;
	IID *unaff_ESI;
	DWORD index;
	IUnknown *unaff_EDI;
	IDirect3DRMFrameArray *in_stack_00000014;
	Matrix4F local_40;
	
	lws_00 = lws;
	this_00 = clone;
	this = orig;
	if ((IDirect3DRMFrame3 *)lws == NULL) {
		AnimClone_ReferenceVisuals(orig,clone);
	}
	else {
		AnimClone_CloneLwsMesh(orig,clone);
	}
						// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
	(*this->lpVtbl->GetName)(this,(LPDWORD)&orig,NULL);
	if (orig != NULL) {
		lpName = (LPCSTR)std::malloc((uint)orig);
						// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
		(*this->lpVtbl->GetName)(this,(LPDWORD)&orig,lpName);
						// IDirect3DRMFrame3->SetName(this, LPCSTR lpName)
		(*this_00->lpVtbl->SetName)(this_00,lpName);
		std::free(lpName);
	}
						// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
	(*this->lpVtbl->GetParent)(this,(IDirect3DRMFrame3 **)&lws);
						// IDirect3DRMFrame3->GetTransform(this, IDirect3DRMFrame3* lpRefFrame, Matrix4F**
						// rmMatrix)
	(*this->lpVtbl->GetTransform)(this,(IDirect3DRMFrame3 *)lws,(Matrix4F **)&local_40);
						// IDirect3DRMFrame3->Release(this)
						//  (this = GetParent)
	(**(code **)((int)*(IDirect3DRMFrame3 *)lws + 8))((IDirect3DRMFrame3 *)lws);
						// IDirect3DRMFrame3->AddTransform(this, TD3DRMCombineType rctCombine, Matrix4F*
						// rmMatrix)
	(*this_00->lpVtbl->AddTransform)(this_00,D3DRMCOMBINE_REPLACE,&local_40);
						// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar1 = (*this->lpVtbl->GetChildren)(this,(IDirect3DRMFrameArray **)&clone);
	if (HVar1 == 0) {
						// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar2 = (*clone->lpVtbl->Clone)((IUnknown *)clone,unaff_EDI,unaff_ESI,unaff_EBP);
		index = 0;
		if (uVar2 != 0) {
			do {
						// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
						// lplpD3DRMFrame)
				(*in_stack_00000014->lpVtbl->GetElement)(in_stack_00000014,index,(IUnknown **)&local_40);
						// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3, IDirect3DRMFrame3**
						// lplpOut)
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][0])->QueryInterface)
									((IUnknown *)local_40.values[0][0],&idl::IID_IDirect3DRMFrame3,
									 (IDirect3DRMFrame3 **)(local_40.values + 2));
						// IDirect3DRMFrame->Release(this)
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][0])->Release)
									((IUnknown *)local_40.values[0][0]);
						// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame, IDirect3DRMFrame3**
						// lplpD3DRMFrame)
				(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
									(globs::mainGlobs.lpD3DRM,this_00,(IDirect3DRMFrame3 **)&local_40);
				AnimClone_CreateCopy
									((IDirect3DRMFrame3 *)local_40.values[0][1],
									 (IDirect3DRMFrame3 *)local_40.values[0][0],lws_00);
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][0])->Release)
									((IUnknown *)local_40.values[0][0]);
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][1])->Release)
									((IUnknown *)local_40.values[0][1]);
				index += 1;
			} while (index < uVar2);
		}
		(*in_stack_00000014->lpVtbl->Release)((IUnknown *)in_stack_00000014);
	}
	return;
}



void __cdecl
lego::res::AnimClone_CloneLwsMesh(IDirect3DRMFrame3 *rmFrame3,IDirect3DRMFrame3 *param_2)
{
	IDirect3DRMFrame3 *pIVar1;
	HRESULT HVar2;
	Mesh *mesh;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMFrame3 *pIVar4;
	IDirect3DRMUserVisual *local_14;
	IDirect3DRMVisual *local_10 [4];
	
	pIVar1 = rmFrame3;
						// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount, IDirect3DRMVisualArray**
						// lplpVisuals)
						//  (NOTE: lightalloy's implementation is missing an argument)
	(*rmFrame3->lpVtbl->GetVisuals)(rmFrame3,(DWORD *)&rmFrame3,NULL);
	if (rmFrame3 != NULL) {
						// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount, IDirect3DRMVisualArray**
						// lplpVisuals)
						//  (NOTE: lightalloy's implementation is missing an argument)
		(*pIVar1->lpVtbl->GetVisuals)(pIVar1,(DWORD *)&rmFrame3,local_10);
		pIVar1 = param_2;
		pIVar4 = NULL;
		if (rmFrame3 != NULL) {
			ppIVar3 = local_10;
			do {
				HVar2 = (*(*ppIVar3)->lpVtbl->QueryInterface)
													(*ppIVar3,&idl::IID_IDirect3DRMUserVisual,&local_14);
				if (HVar2 == 0) {
					mesh = (Mesh *)(*local_14->lpVtbl->GetAppData)((IUnknown *)local_14);
					Mesh_Clone(mesh,pIVar1);
				}
				pIVar4 = (IDirect3DRMFrame3 *)((int)&pIVar4->lpVtbl + 1);
				ppIVar3 = ppIVar3 + 1;
			} while (pIVar4 < rmFrame3);
		}
	}
	return;
}



void __cdecl lego::res::AnimClone_ReferenceVisuals(IDirect3DRMFrame3 *orig,IDirect3DRMFrame3 *clone)
{
	IDirect3DRMFrame3 *pIVar1;
	IDirect3DRMFrame3 *pIVar2;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMVisual *local_10 [4];
	
	pIVar1 = orig;
	(*orig->lpVtbl->GetVisuals)(orig,(DWORD *)&orig,NULL);
	if (orig != NULL) {
		(*pIVar1->lpVtbl->GetVisuals)(pIVar1,(DWORD *)&orig,local_10);
		pIVar1 = clone;
		pIVar2 = NULL;
		if (orig != NULL) {
			ppIVar3 = local_10;
			do {
				(*pIVar1->lpVtbl->AddVisual)(pIVar1,*ppIVar3);
				pIVar2 = (IDirect3DRMFrame3 *)((int)&pIVar2->lpVtbl + 1);
				ppIVar3 = ppIVar3 + 1;
			} while (pIVar2 < orig);
		}
	}
	return;
}



void __cdecl lego::image::BMP_Parse(BITMAP_FILE_INFO_STRUCT *data,uint size,D3DRMImage *istruct)
{
	byte bVar1;
	D3DRMPaletteEntry *pDVar2;
	int iVar3;
	DWORD DVar4;
	D3DRMPaletteEntry *pDVar5;
	uint uVar6;
	DWORD DVar7;
	D3DRMPaletteEntry *pDVar8;
	
	if ((data->bmi).biBitCount == 8) {
		DVar7 = (data->bmi).biClrUsed;
		if (DVar7 == 0) {
			DVar7 = 0x100;
		}
		pDVar2 = (D3DRMPaletteEntry *)std::malloc(0x400);
		pDVar5 = pDVar2;
		for (iVar3 = 0x100; iVar3 != 0; iVar3 += -1) {
			*pDVar5 = (D3DRMPaletteEntry)0x0;
			pDVar5 = pDVar5 + 1;
		}
		pDVar5 = (D3DRMPaletteEntry *)data->bmiColors;
		pDVar8 = pDVar2;
		for (DVar4 = DVar7; DVar4 != 0; DVar4 -= 1) {
			*pDVar8 = *pDVar5;
			pDVar5 = pDVar5 + 1;
			pDVar8 = pDVar8 + 1;
		}
		istruct->rgb = 0;
		istruct->red_mask = 0xfc;
		istruct->green_mask = 0xfc;
		istruct->blue_mask = 0xfc;
		istruct->alpha_mask = 0xfc;
		istruct->palette_size = DVar7;
		pDVar5 = pDVar2;
		if (0 < (int)DVar7) {
			do {
				bVar1 = pDVar5->red;
				pDVar5->red = pDVar5->blue;
				pDVar5->blue = bVar1;
				DVar7 -= 1;
				pDVar5 = pDVar5 + 1;
			} while (DVar7 != 0);
		}
		istruct->palette = pDVar2;
	}
	else {
		istruct->rgb = 1;
		istruct->palette_size = 0;
		istruct->palette = NULL;
	}
	istruct->width = (data->bmi).biWidth;
	istruct->height = (data->bmi).biHeight;
	uVar6 = (uint)(data->bmi).biBitCount;
	istruct->depth = uVar6;
	if (false) {
switchD_00489faf_caseD_9:
		iVar3 = 0;
	}
	else {
		switch(uVar6) {
		case 8:
			iVar3 = 1;
			break;
		default:
			goto switchD_00489faf_caseD_9;
		case 0xf:
		case 0x10:
			iVar3 = 2;
			break;
		case 0x18:
			iVar3 = 3;
			break;
		case 0x20:
			iVar3 = 4;
		}
	}
	istruct->bytes_per_line = iVar3 * istruct->width + 3U & 0xfffffffc;
	DVar7 = (data->hdr).bfOffBits;
	istruct->aspecty = 1;
	istruct->aspectx = 1;
	istruct->buffer1 = (byte *)((int)data->bmiColors + (DVar7 - 0x36));
	istruct->buffer2 = NULL;
	return;
}



void __cdecl lego::image::BMP_Cleanup(D3DRMImage *istruct)
{
	if (istruct->palette != NULL) {
		std::free(istruct->palette);
	}
	return;
}



void __cdecl lego::debug::SE(char *error,char *errorDesc)
{
	std::sprintf(globs::dxbugGlobs.DXErrorString,
							 "A DirectX error was set in module %s at line no %i.\nError : %s (code %i)\nDX Module : %s\nError Description : %s\n"
							 ,globs::dxbugGlobs.file,globs::dxbugGlobs.line,error,globs::dxbugGlobs.errnum,
							 globs::constant::DXModuleName[globs::dxbugGlobs.DXModuleNameNumber],errorDesc);
	return;
}



HRESULT __cdecl lego::debug::Error_SetDXError(HRESULT err,int DXModule,char *File,int Line)
{
	globs::dxbugGlobs.errnum = err;
	if ((DXModule < 1) || (globs::dxbugGlobs.DXModuleNameNumber = DXModule, 7 < DXModule)) {
		globs::dxbugGlobs.DXModuleNameNumber = 0;
	}
	globs::dxbugGlobs.line = Line;
	globs::dxbugGlobs.DXNumErrorsSet += 1;
	globs::dxbugGlobs.file = File;
	switch(DXModule) {
	case 2:
		if (err < -0x7fffbffe) {
			if (err == -0x7fffbfff) {
				SE("DIERR_UNSUPPORTED",
					 "The function called is not supported at this time.\nThis value is equal to the E_NOTIMPL\nstandard COM return value."
					);
				return -0x7fffbfff;
			}
			if (err == -0x7ffffff6) {
				SE("E_PENDING","Data is not yet availabe.");
				return -0x7ffffff6;
			}
		}
		else {
			if (err < -0x7fffbffa) {
				if (err == -0x7fffbffb) {
					SE("DIERR_GENERIC",
						 "An undetermined error occurred inside the DirectInput subsystem.\nThis value is equal to the E_FAIL standard\nCOM return value."
						);
					return -0x7fffbffb;
				}
				if (err == -0x7fffbffe) {
					SE("DIERR_NOINTERFACE",
						 "The specified interface is not supported by\nthe object. This value is equal to the E_NOINTERFACE\nstandard COM return value."
						);
					return -0x7fffbffe;
				}
			}
			else {
				if (err < -0x7ffbfeab) {
					if (err == -0x7ffbfeac) {
						SE("DIERR_DEVICENOTREG",
							 "The device or device instance is not registered with\nDirectInput. This value is equal to the\nREGDB_E_CLASSNOTREG standard COM return value."
							);
						return -0x7ffbfeac;
					}
					if (err == -0x7ffbfef0) {
						SE("DIERR_NOAGGREGATION","This object does not support aggregation.");
						return -0x7ffbfef0;
					}
				}
				else {
					if (err < -0x7ff8fffd) {
						if (err == -0x7ff8fffe) {
							SE("DIERR_NOTFOUND","The requested object does not exist.");
							return -0x7ff8fffe;
						}
						switch(err) {
						case -0x7ffbfdff:
							SE("DIERR_DEVICEFULL","The device is full.");
							return err;
						case -0x7ffbfdfe:
							SE("DIERR_MOREDATA","Not all the requested information fitted into the buffer");
							return err;
						case -0x7ffbfdfd:
							SE("DIERR_NOTDOWNLOADED","The effect is not downloaded");
							return err;
						case -0x7ffbfdfc:
							SE("DIERR_HASEFFECTS",
								 "The device cannot be reinitialized because there\nare still effects attached to it"
								);
							return err;
						case -0x7ffbfdfb:
							SE("DIERR_NOTEXCLUSIVEACQUIRED",
								 "The operation cannot be performed unless the device\nis acquired in DISCL_EXCLUSIVE mode."
								);
							return err;
						case -0x7ffbfdfa:
							SE("DIERR_INCOMPLETEEFFECT",
								 "The effect could not be downloaded because essential\ninformation is missing. For example, no axes have\nbeen associated with the effect, or no type-specific\ninformation has been supplied"
								);
							return err;
						case -0x7ffbfdf9:
							SE("DIERR_NOTBUFFERED",
								 "The device is not buffered.\nSet the DIPROP_BUFFERSIZE property to enable buffering"
								);
							return err;
						case -0x7ffbfdf8:
							SE("DIERR_EFFECTPLAYING",
								 "The parameters were updated in memory but were not\ndownloaded to the device because the device does not\nsupport updating an effect while it is still playing."
								);
							return err;
						}
					}
					else {
						if (err < -0x7ff8fff3) {
							if (err == -0x7ff8fff4) {
								SE("DIERR_NOTACQUIRED",
									 "The operation cannot be performed unless\nthe device is acquired.");
								return -0x7ff8fff4;
							}
							if (err == -0x7ff8fffb) {
								SE("DIERR_HANDLEEXISTS",
									 "The device already has an event notification associated\nwith it. This value is equal to the E_ACCESSDENIED\nstandard COM return value."
									);
								return -0x7ff8fffb;
							}
						}
						else {
							if (err < -0x7ff8ffea) {
								if (err == -0x7ff8ffeb) {
									SE("DIERR_NOTINITIALIZED","This object has not been initialized.");
									return -0x7ff8ffeb;
								}
								if (err == -0x7ff8fff2) {
									SE("DIERR_OUTOFMEMORY",
										 "The DirectInput subsystem couldn\'t allocate\nsufficient memory to complete the call.\nThis value is equal to the E_OUTOFMEMORY\nstandard COM return value."
										);
									return -0x7ff8fff2;
								}
							}
							else {
								if (err < -0x7ff8ffa8) {
									if (err == -0x7ff8ffa9) {
										SE("DIERR_INVALIDPARAM",
											 "An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard COM return value."
											);
										return -0x7ff8ffa9;
									}
									if (err == -0x7ff8ffe2) {
										SE("DIERR_INPUTLOST",
											 "Access to the input device has been lost. It must be reacquired.");
										return -0x7ff8ffe2;
									}
								}
								else {
									if (err < -0x7ff8ff55) {
										if (err == -0x7ff8ff56) {
											SE("DIERR_ACQUIRED",
												 "The operation cannot be performed while\nthe device is acquired.");
											return -0x7ff8ff56;
										}
										if (err == -0x7ff8ff89) {
											SE("DIERR_BADDRIVERVER",
												 "The object could not be created due to an\nincompatible driver version or mismatched or\nincomplete driver components."
												);
											return -0x7ff8ff89;
										}
									}
									else {
										if (err < -0x7ff8fb7e) {
											if (err == -0x7ff8fb7f) {
												SE("DIERR_BETADIRECTINPUTVERSION",
													 "The application was written for an unsupported\nprerelease version of DirectInput."
													);
												return -0x7ff8fb7f;
											}
											if (err == -0x7ff8fb82) {
												SE("DIERR_OLDDIRECTINPUTVERSION",
													 "The application requires a newer version of DirectInput.");
												return -0x7ff8fb82;
											}
										}
										else {
											if (err < 1) {
												if (err == 0) {
													SE("DI_OK",
														 "The operation completed successfully.\nThis value is equal to the S_OK standard\nCOM return value."
														);
													return 0;
												}
												if (err == -0x7ff8fb21) {
													SE("DIERR_ALREADYINITIALIZED","This object is already initialized");
													return -0x7ff8fb21;
												}
											}
											else {
												if (true) {
													switch(err) {
													case 1:
														SE("DI_BUFFEROVERFLOW",
															 "The device buffer overflowed and some input was lost.\nThis value is equal to the S_FALSE\nstandard COM return value."
															);
														return err;
													case 2:
														SE("DI_POLLEDDEVICE",
															 "The device is a polled device.\nAs a result, device buffering will not collect\nany data and event notifications will not be signaled\nuntil the IDirectInputDevice2::Poll method is called."
															);
														return err;
													case 3:
														SE("DI_DOWNLOADSKIPPED",
															 "The parameters of the effect were successfully updated,\nbut the effect could not be downloaded because the associated\ndevice was not acquired in exclusive mode."
															);
														return err;
													case 4:
														SE("DI_EFFECTRESTARTED",
															 "The effect was stopped,\nthe parameters were updated,\nand the effect was restarted."
															);
														return err;
													case 8:
														SE("DI_TRUNCATED",
															 "The parameters of the effect were successfully updated,\nbut some of them were beyond the capabilities of the\ndevice and were truncated to the nearest supported value."
															);
														return err;
													case 0xc:
														SE("DI_TRUNCATEDANDRESTARTED",
															 "Equal to DI_EFFECTRESTARTED | DI_TRUNCATED");
														return err;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 3:
		if (err < -0x7fffbffa) {
			if (err == -0x7fffbffb) {
				SE("DDERR_GENERIC","There is an undefined error condition.");
				return -0x7fffbffb;
			}
			if (err == -0x7fffbfff) {
				SE("DDERR_UNSUPPORTED","The operation is not supported.");
				return -0x7fffbfff;
			}
		}
		else {
			if (err < -0x7ff8fff1) {
				if (err == -0x7ff8fff2) {
					SE("DDERR_OUTOFMEMORY","DirectDraw does not have enough\nmemory to perform the operation."
						);
					return -0x7ff8fff2;
				}
				if (err == -0x7ffbfe10) {
					SE("DDERR_NOTINITIALIZED",
						 "An attempt was made to call an interface method\nof a DirectDraw object created by CoCreateInstance before\nthe object was initialized."
						);
					return -0x7ffbfe10;
				}
			}
			else {
				if (err < -0x7789fffa) {
					if (err == -0x7789fffb) {
						SE("DDERR_ALREADYINITIALIZED","The object has already been initialized.");
						return -0x7789fffb;
					}
					if (err == -0x7ff8ffa9) {
						SE("DDERR_INVALIDPARAMS",
							 "One or more of the parameters passed to the\nmethod are incorrect.");
						return -0x7ff8ffa9;
					}
				}
				else {
					if (err < -0x7789ffeb) {
						if (err == -0x7789ffec) {
							SE("DDERR_CANNOTDETACHSURFACE",
								 "A surface cannot be detached from another\nrequested surface.");
							return -0x7789ffec;
						}
						if (err == -0x7789fff6) {
							SE("DDERR_CANNOTATTACHSURFACE",
								 "A surface cannot be attached to\nanother requested surface.");
							return -0x7789fff6;
						}
					}
					else {
						if (err < -0x7789ffc8) {
							if (err == -0x7789ffc9) {
								SE("DDERR_EXCEPTION",
									 "An exception was encountered while performing the requested operation.");
								return -0x7789ffc9;
							}
							if (err == -0x7789ffd8) {
								SE("DDERR_CURRENTLYNOTAVAIL","No support is currently available.");
								return -0x7789ffd8;
							}
						}
						else {
							if (err < -0x7789ffa0) {
								if (err == -0x7789ffa1) {
									SE("DDERR_INCOMPATIBLEPRIMARY",
										 "The primary surface creation request does\nnot match with the existing primary surface."
										);
									return -0x7789ffa1;
								}
								if (err == -0x7789ffa6) {
									SE("DDERR_HEIGHTALIGN",
										 "The height of the provided rectangle is not\na multiple of the required alignment."
										);
									return -0x7789ffa6;
								}
							}
							else {
								if (err < -0x7789ff91) {
									if (err == -0x7789ff92) {
										SE("DDERR_INVALIDCLIPLIST","DirectDraw does not support the provided clip list."
											);
										return -0x7789ff92;
									}
									if (err == -0x7789ff9c) {
										SE("DDERR_INVALIDCAPS",
											 "One or more of the capability bits passed to\nthe callback function are incorrect."
											);
										return -0x7789ff9c;
									}
								}
								else {
									if (err < -0x7789ff7d) {
										if (err == -0x7789ff7e) {
											SE("DDERR_INVALIDOBJECT",
												 "DirectDraw received a pointer that was an\ninvalid DirectDraw object.");
											return -0x7789ff7e;
										}
										if (err == -0x7789ff88) {
											SE("DDERR_INVALIDMODE","DirectDraw does not support the requested mode.");
											return -0x7789ff88;
										}
									}
									else {
										if (err < -0x7789ff69) {
											if (err == -0x7789ff6a) {
												SE("DDERR_INVALIDRECT","The provided rectangle was invalid.");
												return -0x7789ff6a;
											}
											if (err == -0x7789ff6f) {
												SE("DDERR_INVALIDPIXELFORMAT","The pixel format was invalid as specified.");
												return -0x7789ff6f;
											}
										}
										else {
											if (err < -0x7789ff55) {
												if (err == -0x7789ff56) {
													SE("DDERR_NO3D","No 3-D hardware or emulation is present.");
													return -0x7789ff56;
												}
												if (err == -0x7789ff60) {
													SE("DDERR_LOCKEDSURFACES",
														 "One or more surfaces are locked, causing the failure of\nthe requested operation."
														);
													return -0x7789ff60;
												}
											}
											else {
												if (err < -0x7789ff32) {
													if (err == -0x7789ff33) {
														SE("DDERR_NOCLIPLIST","No clip list is available.");
														return -0x7789ff33;
													}
													if (err == -0x7789ff4c) {
														SE("DDERR_NOALPHAHW",
															 "No alpha acceleration hardware is present or\navailable, causing the failure of\nthe requested operation."
															);
														return -0x7789ff4c;
													}
												}
												else {
													if (err < -0x7789ff23) {
														if (err == -0x7789ff24) {
															SE("DDERR_NOCOLORKEYHW",
																 "The operation cannot be carried out because there is\nno hardware support for the destination color key."
																);
															return -0x7789ff24;
														}
														if (err == -0x7789ff2e) {
															SE("DDERR_NOCOLORCONVHW",
																 "The operation cannot be carried out because no\ncolor-conversion hardware is present or available."
																);
															return -0x7789ff2e;
														}
														if (err == -0x7789ff2c) {
															SE("DDERR_NOCOOPERATIVELEVELSET",
																 "A create function is called without the\nIDirectDraw2::SetCooperativeLevel method being called."
																);
															return -0x7789ff2c;
														}
														if (err == -0x7789ff29) {
															SE("DDERR_NOCOLORKEY",
																 "The surface does not currently have a color key.");
															return -0x7789ff29;
														}
													}
													else {
														if (err < -0x7789ff1e) {
															if (err == -0x7789ff1f) {
																SE("DDERR_NOEXCLUSIVEMODE",
																	 "The operation requires the application to have exclusive mode,\nbut the application does not have exclusive mode."
																	);
																return -0x7789ff1f;
															}
															if (err == -0x7789ff22) {
																SE("DDERR_NODIRECTDRAWSUPPORT",
																	 "DirectDraw support is not possible\nwith the current display driver."
																	);
																return -0x7789ff22;
															}
														}
														else {
															if (err < -0x7789ff0f) {
																if (err == -0x7789ff10) {
																	SE("DDERR_NOGDI","No GDI is present.");
																	return -0x7789ff10;
																}
																if (err == -0x7789ff1a) {
																	SE("DDERR_NOFLIPHW","Flipping visible surfaces is not supported.")
																	;
																	return -0x7789ff1a;
																}
															}
															else {
																if (err < -0x7789ff00) {
																	if (err == -0x7789ff01) {
																		SE("DDERR_NOTFOUND","The requested item was not found.");
																		return -0x7789ff01;
																	}
																	if (err == -0x7789ff06) {
																		SE("DDERR_NOMIRRORHW",
																			 "The operation cannot be carried out because no mirroring\nhardware is present or available."
																			);
																		return -0x7789ff06;
																	}
																}
																else {
																	if (err < -0x7789fee7) {
																		if (err == -0x7789fee8) {
																			SE("DDERR_NORASTEROPHW",
																				 "The operation cannot be carried out because no appropriate\nraster operation hardware is present or available."
																				);
																			return -0x7789fee8;
																		}
																		if (err == -0x7789fefc) {
																			SE("DDERR_NOOVERLAYHW",
																				 "The operation cannot be carried out because no\noverlay hardware is present or available."
																				);
																			return -0x7789fefc;
																		}
																	}
																	else {
																		if (err < -0x7789fec9) {
																			if (err == -0x7789feca) {
																				SE("DDERR_NOSTRETCHHW",
																					 "The operation cannot be carried out because\nthere is no hardware support for stretching."
																					);
																				return -0x7789feca;
																			}
																			if (err == -0x7789fede) {
																				SE("DDERR_NOROTATIONHW",
																					 "The operation cannot be carried out because\nno rotation hardware is present or available."
																					);
																				return -0x7789fede;
																			}
																		}
																		else {
																			if (err < -0x7789feb5) {
																				if (err == -0x7789feb6) {
																					SE("DDERR_NOTEXTUREHW",
																						 "The operation cannot be carried out because no\ntexture-mapping hardware is present or available."
																						);
																					return -0x7789feb6;
																				}
																				if (err == -0x7789fec4) {
																					SE("DDERR_NOT4BITCOLOR",
																						 "The DirectDrawSurface object is not using a 4-bit color palette\nand the requested operation requires a 4-bit color palette."
																						);
																					return -0x7789fec4;
																				}
																				if (err == -0x7789fec3) {
																					SE("DDERR_NOT4BITCOLORINDEX",
																						 "The DirectDrawSurface object is not using a 4-bit color index\npalette and the requested operation requires a\n4-bit color index palette."
																						);
																					return -0x7789fec3;
																				}
																				if (err == -0x7789fec0) {
																					SE("DDERR_NOT8BITCOLOR",
																						 "The DirectDrawSurface object is not using an 8-bit color\npalette and the requested operation requires\nan 8-bit color palette."
																						);
																					return -0x7789fec0;
																				}
																			}
																			else {
																				if (err < -0x7789feab) {
																					if (err == -0x7789feac) {
																						SE("DDERR_NOZBUFFERHW",
																							 "The operation to create a z-buffer in display memory\nor to perform a blit using a z-buffer cannot be\ncarried out because there is no hardware support\nfor z-buffers."
																							);
																						return -0x7789feac;
																					}
																					if (err == -0x7789feb1) {
																						SE("DDERR_NOVSYNCHW",
																							 "The operation cannot be carried out because\nthere is no hardware support for vertical\nblank synchronized operations."
																							);
																						return -0x7789feb1;
																					}
																				}
																				else {
																					if (err < -0x7789fe97) {
																						if (err == -0x7789fe98) {
																							SE("DDERR_OUTOFCAPS",
																								 "The hardware needed for the requested\noperation has already been allocated."
																								);
																							return -0x7789fe98;
																						}
																						if (err == -0x7789fea2) {
																							SE("DDERR_NOZOVERLAYHW",
																								 "The overlay surfaces cannot be z-layered based on the\nz-order because the hardware does not support\nz-ordering of overlays."
																								);
																							return -0x7789fea2;
																						}
																					}
																					else {
																						if (err < -0x7789fe6f) {
																							if (err == -0x7789fe70) {
																								SE("DDERR_COLORKEYNOTSET",
																																																			
																									"No source color key is specified for this operation."
																									);
																								return -0x7789fe70;
																							}
																							if (true) {
																								switch(err) {
																								case -0x7789fe84:
																									SE("DDERR_OUTOFVIDEOMEMORY",
																																																					
																									"DirectDraw does not have enough display\nmemory to perform the operation."
																									);
																									return err;
																								case -0x7789fe82:
																									SE("DDERR_OVERLAYCANTCLIP",
																																																					
																									"The hardware does not support clipped overlays.")
																									;
																									return err;
																								case -0x7789fe80:
																									SE("DDERR_OVERLAYCOLORKEYONLYONEACTIVE",
																																																					
																									"An attempt was made to have more than one\ncolor key active on an overlay."
																									);
																									return err;
																								case -0x7789fe7d:
																									SE("DDERR_PALETTEBUSY",
																																																					
																									"Access to this palette is refused because\nthe palette is locked by another thread."
																									);
																									return err;
																								}
																							}
																						}
																						else {
																							if (err < -0x7789fe5b) {
																								if (err == -0x7789fe5c) {
																									SE("DDERR_SURFACEALREADYDEPENDENT",
																																																					
																									"An attempt was made to make a surface a dependency\nof another surface to which it is\nalready dependent."
																									);
																									return -0x7789fe5c;
																								}
																								if (err == -0x7789fe66) {
																									SE("DDERR_SURFACEALREADYATTACHED",
																																																					
																									"An attempt was made to attach a surface to another\nsurface to which it is already attached."
																									);
																									return -0x7789fe66;
																								}
																							}
																							else {
																								if (err < -0x7789fe4c) {
																									if (err == -0x7789fe4d) {
																										SE("DDERR_CANTLOCKSURFACE",
																																																							
																									"Access to this surface is refused because an\nattempt was made to lock the primary\nsurface without DCI support."
																									);
																									return -0x7789fe4d;
																									}
																									if (err == -0x7789fe52) {
																										SE("DDERR_SURFACEBUSY",
																																																							
																									"Access to the surface is refused because\nthe surface is locked by another thread."
																									);
																									return -0x7789fe52;
																									}
																								}
																								else {
																									if (err < -0x7789fe3d) {
																										if (err == -0x7789fe3e) {
																											SE("DDERR_SURFACELOST",
																																																									
																									"Access to the surface is refused because the surface\nmemory is gone. The DirectDrawSurface object representing this\nsurface should have the IDirectDrawSurface3::Restore\nmethod called on it."
																									);
																									return -0x7789fe3e;
																									}
																									if (err == -0x7789fe48) {
																										SE("DDERR_SURFACEISOBSCURED",
																																																							
																									"Access to the surface is refused\nbecause the surface is obscured."
																									);
																									return -0x7789fe48;
																									}
																									}
																									else {
																										if (err < -0x7789fe29) {
																											if (err == -0x7789fe2a) {
																												SE("DDERR_TOOBIGHEIGHT",
																																																											
																									"The height requested by DirectDraw is too large."
																									);
																									return -0x7789fe2a;
																									}
																									if (err == -0x7789fe34) {
																										SE("DDERR_SURFACENOTATTACHED",
																											 "The requested surface is not attached.");
																										return -0x7789fe34;
																									}
																									}
																									else {
																										if (err < -0x7789fe15) {
																											if (err == -0x7789fe16) {
																												SE("DDERR_TOOBIGWIDTH",
																																																											
																									"The width requested by DirectDraw\nis too large."
																									);
																									return -0x7789fe16;
																									}
																									if (err == -0x7789fe20) {
																										SE("DDERR_TOOBIGSIZE",
																																																							
																									"The size requested by DirectDraw is too large.\nHowever, the individual height and\nwidth are OK."
																									);
																									return -0x7789fe20;
																									}
																									}
																									else {
																										if (err < -0x7789fdf7) {
																											if (err == -0x7789fdf8) {
																												SE("DDERR_UNSUPPORTEDMASK",
																																																											
																									"The bitmask in the pixel format requested\nis not supported by DirectDraw."
																									);
																									return -0x7789fdf8;
																									}
																									if (err == -0x7789fe02) {
																										SE("DDERR_UNSUPPORTEDFORMAT",
																																																							
																									"The FourCC format requested is\nnot supported by DirectDraw."
																									);
																									return -0x7789fe02;
																									}
																									}
																									else {
																										if (err < -0x7789fde3) {
																											if (err == -0x7789fde4) {
																												SE("DDERR_WASSTILLDRAWING",
																																																											
																									"The previous blit operation that is transferring\ninformation to or from this\nsurface is incomplete."
																									);
																									return -0x7789fde4;
																									}
																									if (err == -0x7789fde7) {
																										SE("DDERR_VERTICALBLANKINPROGRESS",
																											 "A vertical blank is in progress.");
																										return -0x7789fde7;
																									}
																									}
																									else {
																										if (err < -0x7789fd89) {
																											if (err == -0x7789fd8a) {
																												SE("DDERR_NONONLOCALVIDME",
																																																											
																									"An attempt was made to allocate non-local video\nmemory from a device that does not support non-local\nvideo memory"
																									);
																									return -0x7789fd8a;
																									}
																									if (true) {
																										switch(err) {
																										case -0x7789fdd0:
																											SE("DDERR_XALIGN",
																																																									
																									"The provided rectangle was not horizontally\naligned on a required boundary."
																									);
																									return err;
																									case -0x7789fdcf:
																										SE("DDERR_INVALIDDIRECTDRAWGUID",
																																																							
																									"The globally unique identifier (GUID) passed to the\nDirectDrawCreate function is not a valid DirectDraw\ndriver identifier."
																									);
																									return err;
																									case -0x7789fdce:
																										SE("DDERR_DIRECTDRAWALREADYCREATED",
																																																							
																									"A DirectDraw object representing this driver\nhas already been created for this process."
																									);
																									return err;
																									case -0x7789fdcd:
																										SE("DDERR_NODIRECTDRAWHW",
																																																							
																									"Hardware-only DirectDraw object creation is not possible;\nthe driver does not support any hardware."
																									);
																									return err;
																									case -0x7789fdcc:
																										SE("DDERR_PRIMARYSURFACEALREADYEXISTS",
																																																							
																									"This process has already created a primary surface."
																									);
																									return err;
																									case -0x7789fdcb:
																										SE("DDERR_NOEMULATION",
																											 "Software emulation is not available.");
																										return err;
																									case -0x7789fdca:
																										SE("DDERR_REGIONTOOSMALL",
																																																							
																									"The region passed to the\nIDirectDrawClipper::GetClipList\nmethod is too small."
																									);
																									return err;
																									case -0x7789fdc9:
																										SE("DDERR_CLIPPERISUSINGHWND",
																																																							
																									"An attempt was made to set a clip list for a\nDirectDrawClipper object that is already monitoring\na window handle."
																									);
																									return err;
																									case -0x7789fdc8:
																										SE("DDERR_NOCLIPPERATTACHED",
																																																							
																									"No DirectDrawClipper object is attached\nto the surface object."
																									);
																									return err;
																									case -0x7789fdc7:
																										SE("DDERR_NOHWND",
																																																							
																									"Clipper notification requires a window handle,\nor no window handle has been previously set as\nthe cooperative level window handle."
																									);
																									return err;
																									case -0x7789fdc6:
																										SE("DDERR_HWNDSUBCLASSED",
																																																							
																									"DirectDraw is prevented from restoring state\nbecause the DirectDraw cooperative level window\nhandle has been subclassed."
																									);
																									return err;
																									case -0x7789fdc5:
																										SE("DDERR_HWNDALREADYSET",
																																																							
																									"The DirectDraw cooperative level window handle\nhas already been set. It cannot be reset while the process\nhas surfaces or palettes created."
																									);
																									return err;
																									case -0x7789fdc4:
																										SE("DDERR_NOPALETTEATTACHED",
																																																							
																									"No palette object is attached to this surface.");
																									return err;
																									case -0x7789fdc3:
																										SE("DDERR_NOPALETTEHW",
																																																							
																									"There is no hardware support for 16- or 256-color palettes."
																									);
																									return err;
																									case -0x7789fdc2:
																										SE("DDERR_BLTFASTCANTCLIP",
																																																							
																									"A DirectDrawClipper object is attached to a source\nsurface that has passed into a call to the\nIDirectDrawSurface3::BltFast method."
																									);
																									return err;
																									case -0x7789fdc1:
																										SE("DDERR_NOBLTHW",
																											 "No blitter hardware is present.");
																										return err;
																									case -0x7789fdc0:
																										SE("DDERR_NODDROPSHW",
																																																							
																									"No DirectDraw raster operation (ROP) hardware is available."
																									);
																									return err;
																									case -0x7789fdbf:
																										SE("DDERR_OVERLAYNOTVISIBLE",
																																																							
																									"The IDirectDrawSurface3::GetOverlayPosition method\nis called on a hidden overlay."
																									);
																									return err;
																									case -0x7789fdbe:
																										SE("DDERR_NOOVERLAYDEST",
																																																							
																									"The IDirectDrawSurface3::GetOverlayPosition method is called\non an overlay that the IDirectDrawSurface3::UpdateOverlay method\nhas not been called on to establish a destination."
																									);
																									return err;
																									case -0x7789fdbd:
																										SE("DDERR_INVALIDPOSITION",
																																																							
																									"The position of the overlay on the destination is no longer legal."
																									);
																									return err;
																									case -0x7789fdbc:
																										SE("DDERR_NOTAOVERLAYSURFACE",
																																																							
																									"An overlay component is called for a non-overlay surface."
																									);
																									return err;
																									case -0x7789fdbb:
																										SE("DDERR_EXCLUSIVEMODEALREADYSET",
																																																							
																									"An attempt was made to set the cooperative level\nwhen it was already set to exclusive."
																									);
																									return err;
																									case -0x7789fdba:
																										SE("DDERR_NOTFLIPPABLE",
																																																							
																									"An attempt has been made to flip\na surface that cannot be flipped."
																									);
																									return err;
																									case -0x7789fdb9:
																										SE("DDERR_CANTDUPLICATE",
																																																							
																									"Primary and 3-D surfaces, or surfaces that\nare implicitly created, cannot be duplicated."
																									);
																									return err;
																									case -0x7789fdb8:
																										SE("DDERR_NOTLOCKED",
																																																							
																									"An attempt is made to unlock a\nsurface that was not locked."
																									);
																									return err;
																									case -0x7789fdb7:
																										SE("DDERR_CANTCREATEDC",
																																																							
																									"Windows cannot create any more device\ncontexts (DCs)."
																									);
																									return err;
																									case -0x7789fdb6:
																										SE("DDERR_NODC",
																																																							
																									"No DC has ever been created for this surface.");
																									return err;
																									case -0x7789fdb5:
																										SE("DDERR_WRONGMODE",
																																																							
																									"This surface cannot be restored because it\nwas created in a different mode."
																									);
																									return err;
																									case -0x7789fdb4:
																										SE("DDERR_IMPLICITLYCREATED",
																																																							
																									"The surface cannot be restored because\nit is an implicitly created surface."
																									);
																									return err;
																									case -0x7789fdb3:
																										SE("DDERR_NOTPALETTIZED",
																																																							
																									"The surface being used is not a\npalette-based surface."
																									);
																									return err;
																									case -0x7789fdb2:
																										SE("DDERR_UNSUPPORTEDMODE",
																																																							
																									"The display is currently in\nan unsupported mode."
																									);
																									return err;
																									case -0x7789fdb1:
																										SE("DDERR_NOMIPMAPHW",
																																																							
																									"The operation cannot be carried out because no mipmap\ntexture mapping hardware is present or available."
																									);
																									return err;
																									case -0x7789fdb0:
																										SE("DDERR_INVALIDSURFACETYPE",
																																																							
																									"The requested operation could not be performed\nbecause the surface was of the wrong type."
																									);
																									return err;
																									case -0x7789fda8:
																										SE("DDERR_NOOPTIMIZEH",
																																																							
																									"The device does not support optimized surfaces");
																									return err;
																									case -0x7789fda7:
																										SE("DDERR_NOTLOADE",
																																																							
																									"The surface is an optimized surface,\nbut it has not yet been allocated any memory"
																									);
																									return err;
																									case -0x7789fd94:
																										SE("DDERR_DCALREADYCREATED",
																																																							
																									"A device context (DC) has already been returned\nfor this surface. Only one DC can be retrieved for each surface."
																									);
																									return err;
																									}
																									}
																									}
																									else {
																										if (err < -0x7789fd6b) {
																											if (err == -0x7789fd6c) {
																												SE("DDERR_CANTPAGEUNLOCK",
																																																											
																									"An attempt to page unlock a surface failed.\nPage unlock will not work on a display-memory\nsurface or an emulated primary surface."
																									);
																									return -0x7789fd6c;
																									}
																									if (err == -0x7789fd80) {
																										SE("DDERR_CANTPAGELOCK",
																																																							
																									"An attempt to page lock a surface failed.\nPage lock will not work on a display-memory surface or\nan emulated primary surface."
																									);
																									return -0x7789fd80;
																									}
																									}
																									else {
																										if (err < -0x7789fd4d) {
																											if (err == -0x7789fd4e) {
																												SE("DDERR_MOREDAT",
																																																											
																									"There is more data available than the\nspecified buffer size can hold"
																									);
																									return -0x7789fd4e;
																									}
																									if (err == -0x7789fd58) {
																										SE("DDERR_NOTPAGELOCKED",
																																																							
																									"An attempt is made to page unlock a\nsurface with no outstanding page locks."
																									);
																									return -0x7789fd58;
																									}
																									}
																									else {
																										if (err == -0x7789fd49) {
																											SE("DDERR_VIDEONOTACTIV",
																												 "The video port is not active");
																											return -0x7789fd49;
																										}
																										if (err == -0x7789fd45) {
																											SE("DDERR_DEVICEDOESNTOWNSURFAC",
																																																									
																									"Surfaces created by one direct draw device cannot\nbe used directly by another direct draw device"
																									);
																									return -0x7789fd45;
																									}
																									if (err == 0) {
																										SE("DD_OK","The request completed successfully."
																											);
																										return 0;
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 4:
		SE("Unknown","Error handling is unsupported in this module");
	case 5:
		SE("Unknown","Error handling is unsupported in this module");
	case 6:
		SE("Unknown","Error handling is unsupported in this module");
	case 1:
		if (err < 1) {
			if (err == 0) {
				SE("D3DRM_OK","No error.");
				return 0;
			}
			if (true) {
				switch(err) {
				case -0x7789fcf3:
					SE("D3DRMERR_BADOBJECT","Object expected in argument.");
					return err;
				case -0x7789fcf2:
					SE("D3DRMERR_BADTYPE","Bad argument type passed.");
					return err;
				case -0x7789fcf1:
					SE("D3DRMERR_BADALLOC","Out of memory.");
					return err;
				case -0x7789fcf0:
					SE("D3DRMERR_FACEUSED","Face already used in a mesh.");
					return err;
				case -0x7789fcef:
					SE("D3DRMERR_NOTFOUND","Object not found in specified place.");
					return err;
				case -0x7789fcee:
					SE("D3DRMERR_NOTDONEYET","Unimplemented.");
					return err;
				case -0x7789fced:
					SE("D3DRMERR_FILENOTFOUND","File cannot be opened.");
					return err;
				case -0x7789fcec:
					SE("D3DRMERR_BADFILE","Data file is corrupt.");
					return err;
				case -0x7789fceb:
					SE("D3DRMERR_BADDEVICE","Device is not compatible with renderer.");
					return err;
				case -0x7789fcea:
					SE("D3DRMERR_BADVALUE","Bad argument value passed.");
					return err;
				case -0x7789fce9:
					SE("D3DRMERR_BADMAJORVERSION","Bad DLL major version.");
					return err;
				case -0x7789fce8:
					SE("D3DRMERR_BADMINORVERSION","Bad DLL minor version.");
					return err;
				case -0x7789fce7:
					SE("D3DRMERR_UNABLETOEXECUTE","Unable to carry out procedure.");
					return err;
				case -0x7789fce4:
					SE("D3DRMERR_PENDING",
						 "The data required to supply the requested\ninformation has not finished loading.");
					return err;
				case -0x7789fce3:
					SE("D3DRMERR_NOTENOUGHDATA",
						 "Not enough data has been loaded to\nperform the requested operation.");
					return err;
				case -0x7789fce2:
					SE("D3DRMERR_REQUESTTOOLARGE",
						 "An attempt was made to set a level\nof detail in a progressive mesh greater than the maximum available."
						);
					return err;
				case -0x7789fce1:
					SE("D3DRMERR_REQUESTTOOSMALL",
						 "An attempt was made to set the minimum\nrendering detail of a progressive mesh smaller than\nthe detail in the base mesh\n(the minimum for rendering)."
						);
					return err;
				case -0x7789fce0:
					SE("D3DRMERR_CONNECTIONLOST",
						 "Data connection was lost during a load,\nclone, or duplicate.");
					return err;
				case -0x7789fcdc:
					SE("D3DRMERR_BOXNOTSET",
						 "An attempt was made to access a bounding box\n(for example, with IDirect3DRMFrame2::GetBox)\nwhen no bounding box was set on the frame."
						);
					return err;
				case -0x7789fcdb:
					SE("D3DRMERR_BADPMDATA",
						 "The data in the X File is corrupted.\nThe conversion to a progressive mesh succeeded but\nproduced an invalid progressive mesh in\nthe X File."
						);
					return err;
				}
			}
		}
		break;
	case 7:
		SE("QUERY_INTERFACE","The requested interface could not be obtained");
		return err;
	default:
		SE("Unknown","An error in an unknown DirectX module/object was raised");
		return err;
	}
	SE("UNKNOWN ERROR","Invalid error code specified");
	return err;
}



void __cdecl lego::debug::Error_Initialise(void)
{
	globs::errorGlobs.dumpFile = NULL;
	globs::errorGlobs.loadLogFile = NULL;
	globs::errorGlobs.loadErrorLogFile = NULL;
	globs::errorGlobs.redundantLogFile = NULL;
	globs::errorGlobs.fullScreen = 0;
	return;
}



void __cdecl lego::debug::Error_FullScreen(BOOL on)
{
	globs::errorGlobs.fullScreen = on;
	return;
}



void __cdecl lego::debug::Error_CloseLog(void)
{
	if (globs::errorGlobs.dumpFile != NULL) {
		lego::file::File_Close(globs::errorGlobs.dumpFile);
	}
	if (globs::errorGlobs.loadLogFile != NULL) {
		lego::file::File_Close(globs::errorGlobs.loadLogFile);
	}
	if (globs::errorGlobs.loadErrorLogFile != NULL) {
		lego::file::File_Close(globs::errorGlobs.loadErrorLogFile);
	}
	globs::errorGlobs.dumpFile = NULL;
	globs::errorGlobs.loadLogFile = NULL;
	globs::errorGlobs.loadErrorLogFile = NULL;
	return;
}



void __cdecl lego::debug::Error_Shutdown(void)
{
	Error_CloseLog();
	globs::errorGlobs.redundantLogFile = lego::file::File_Open(globs::errorGlobs.redundantLogName,"w")
	;
	if (globs::errorGlobs.redundantLogFile != NULL) {
		lego::file::File_CheckRedundantFiles(globs::errorGlobs.loadLogName);
		lego::file::File_Close(globs::errorGlobs.redundantLogFile);
	}
	return;
}



char * __cdecl lego::registry::Registry_GetKeyFromPath(char *path,char *out_str)
{
	char cVar1;
	
	*out_str = '\0';
	cVar1 = *path;
	while ((cVar1 != '\0' && (cVar1 != '\\'))) {
		path = path + 1;
		*out_str = cVar1;
		out_str = out_str + 1;
		cVar1 = *path;
	}
	if (*path == '\\') {
		path = path + 1;
	}
	*out_str = '\0';
	return path;
}



BOOL __cdecl
lego::registry::Registry_GetValue
					(char *path,char *key,RegistryType dataType,char *out_data,uint dataSize)
{
	BOOL BVar1;
	
	BVar1 = Registry_GetValue_Recursive((HKEY)HKEY_LOCAL_MACHINE,path,key,dataType,out_data,dataSize);
	return BVar1;
}



BOOL __cdecl
lego::registry::Registry_GetValue_Recursive
					(HKEY parent,char *path,char *key,RegistryType dataType,char *out_data,uint dataSize)
{
	char *path_00;
	LSTATUS LVar1;
	HKEY pHVar2;
	HKEY local_68;
	char str [100];
	
	path_00 = Registry_GetKeyFromPath(path,str);
	if (str[0] != '\0') {
						// Open the key and recurse
		RegCreateKeyA(parent,str,&local_68);
		if (local_68 == NULL) {
			return (BOOL)local_68;
		}
		pHVar2 = (HKEY)Registry_GetValue_Recursive(local_68,path_00,key,dataType,out_data,dataSize);
		RegCloseKey(local_68);
		return (BOOL)pHVar2;
	}
	path = NULL;
						// REG_NONE (0x0)
	if (dataType != REGISTRY_STRING_VALUE) {
						// REG_SZ (0x1)
		if (dataType != REGISTRY_DWORD_VALUE) {
			return (BOOL)NULL;
		}
		LVar1 = RegQueryValueExA(parent,key,NULL,(LPDWORD)&path,(LPBYTE)out_data,&dataSize);
		return (BOOL)(HKEY)(uint)(LVar1 == 0);
	}
	LVar1 = RegQueryValueExA(parent,key,NULL,(LPDWORD)&path,(LPBYTE)out_data,&dataSize);
	return (BOOL)(HKEY)(uint)(LVar1 == 0);
}



BOOL __cdecl lego::wad::GetFileName(FILE *f,char *out_str)
{
	char cVar1;
	int iVar2;
	
	iVar2 = std::fgetc(f);
	cVar1 = (char)iVar2;
	while (cVar1 != '\0') {
		*out_str = (char)iVar2;
		out_str = out_str + 1;
		iVar2 = std::fgetc(f);
		cVar1 = (char)iVar2;
	}
	*out_str = '\0';
	return TRUE;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe
// Open the wad and map in the file data.
// Returns a handle to the wad file.

int __cdecl lego::wad::Wad_Load(char *fName)
{
	char cVar1;
	int wadNo;
	FILE *stream;
	Wad *pWVar2;
	size_t sVar3;
	char **ppcVar4;
	BOOL BVar5;
	char *pcVar6;
	WadEntry *pWVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	int iVar11;
	undefined4 *puVar12;
	char *pcVar13;
	undefined4 *puVar14;
	bool bVar15;
	size_t sVar16;
	FILE *pFVar17;
	char acStack4100 [4];
	char acStack4096 [4092];
	undefined4 uStack4;
	
	uStack4 = 0x48b7aa;
	iVar11 = 0;
	wadNo = Wad_GetFreeWadSlot();
	if (wadNo != -1) {
		stream = std::fopen(fName,"rb");
		pWVar2 = Wad_Get(wadNo);
		pWVar2->fWad = stream;
		if (stream != NULL) {
			pWVar2 = Wad_Get(wadNo);
			pWVar2->active = 1;
			sVar3 = std::fread(acStack4100,1,4,stream);
			if (sVar3 != 4) {
				std::fclose(stream);
				return -1;
			}
			iVar8 = 4;
			bVar15 = true;
			pcVar6 = acStack4100;
			pcVar13 = "WWAD";
			do {
				if (iVar8 == 0) break;
				iVar8 += -1;
				bVar15 = *pcVar6 == *pcVar13;
				pcVar6 = pcVar6 + 1;
				pcVar13 = pcVar13 + 1;
			} while (bVar15);
			if (!bVar15) {
				std::fclose(stream);
				return -1;
			}
			sVar16 = 4;
			sVar3 = 1;
			pFVar17 = stream;
			pWVar2 = Wad_Get(wadNo);
			sVar3 = std::fread(&pWVar2->numFiles,sVar3,sVar16,pFVar17);
			if (sVar3 != 4) {
				std::fclose(stream);
				return -1;
			}
			pWVar2 = Wad_Get(wadNo);
			ppcVar4 = (char **)std::malloc(pWVar2->numFiles << 2);
			pWVar2 = Wad_Get(wadNo);
			pWVar2->wadNames = ppcVar4;
			pWVar2 = Wad_Get(wadNo);
			ppcVar4 = (char **)std::malloc(pWVar2->numFiles << 2);
			pWVar2 = Wad_Get(wadNo);
			pWVar2->fileNames = ppcVar4;
			pWVar2 = Wad_Get(wadNo);
			if ((pWVar2->wadNames != NULL) && (pWVar2 = Wad_Get(wadNo), pWVar2->fileNames != NULL)) {
				pWVar2 = Wad_Get(wadNo);
				uVar9 = pWVar2->numFiles;
				pWVar2 = Wad_Get(wadNo);
				ppcVar4 = pWVar2->wadNames;
				for (uVar9 &= 0x3fffffff; uVar9 != 0; uVar9 -= 1) {
					*ppcVar4 = NULL;
					ppcVar4 = ppcVar4 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 += -1) {
					*(undefined *)ppcVar4 = 0;
					ppcVar4 = (char **)((int)ppcVar4 + 1);
				}
				pWVar2 = Wad_Get(wadNo);
				uVar9 = pWVar2->numFiles;
				pWVar2 = Wad_Get(wadNo);
				ppcVar4 = pWVar2->fileNames;
				for (uVar9 &= 0x3fffffff; uVar9 != 0; uVar9 -= 1) {
					*ppcVar4 = NULL;
					ppcVar4 = ppcVar4 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 += -1) {
					*(undefined *)ppcVar4 = 0;
					ppcVar4 = (char **)((int)ppcVar4 + 1);
				}
				pWVar2 = Wad_Get(wadNo);
				if (0 < pWVar2->numFiles) {
					do {
						BVar5 = GetFileName(stream,acStack4096);
						if (BVar5 == 0) {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->wadNames != NULL) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->wadNames[iVar11] != NULL) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->wadNames[iVar11]);
										}
										iVar11 += 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames);
							}
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != NULL) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames);
							}
							std::fclose(stream);
							return -1;
						}
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							if (uVar9 == 0) break;
							uVar9 -= 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar6 + 1;
						} while (cVar1 != '\0');
						pcVar6 = (char *)std::malloc(~uVar9);
						pWVar2 = Wad_Get(wadNo);
						pWVar2->wadNames[iVar11] = pcVar6;
						pWVar2 = Wad_Get(wadNo);
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							pcVar13 = pcVar6;
							if (uVar9 == 0) break;
							uVar9 -= 1;
							pcVar13 = pcVar6 + 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar13;
						} while (cVar1 != '\0');
						uVar9 = ~uVar9;
						puVar12 = (undefined4 *)(pcVar13 + -uVar9);
						puVar14 = (undefined4 *)pWVar2->wadNames[iVar11];
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
							*puVar14 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar14 = puVar14 + 1;
						}
						for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
							*(undefined *)puVar14 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar14 = (undefined4 *)((int)puVar14 + 1);
						}
						pWVar2 = Wad_Get(wadNo);
						lego::file::File_Error("%s\n",pWVar2->wadNames[iVar11]);
						iVar11 += 1;
						pWVar2 = Wad_Get(wadNo);
					} while (iVar11 < pWVar2->numFiles);
				}
				iVar11 = 0;
				pWVar2 = Wad_Get(wadNo);
				if (0 < pWVar2->numFiles) {
					do {
						BVar5 = GetFileName(stream,acStack4096);
						if (BVar5 == 0) {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != NULL) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->wadNames[iVar11] != NULL) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->wadNames[iVar11]);
										}
										iVar11 += 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames);
							}
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != NULL) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->fileNames[iVar11] != NULL) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->fileNames[iVar11]);
										}
										iVar11 += 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames);
								std::fclose(stream);
								return -1;
							}
							goto LAB_0048be6d;
						}
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							if (uVar9 == 0) break;
							uVar9 -= 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar6 + 1;
						} while (cVar1 != '\0');
						pcVar6 = (char *)std::malloc(~uVar9);
						pWVar2 = Wad_Get(wadNo);
						pWVar2->fileNames[iVar11] = pcVar6;
						pWVar2 = Wad_Get(wadNo);
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							pcVar13 = pcVar6;
							if (uVar9 == 0) break;
							uVar9 -= 1;
							pcVar13 = pcVar6 + 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar13;
						} while (cVar1 != '\0');
						uVar9 = ~uVar9;
						puVar12 = (undefined4 *)(pcVar13 + -uVar9);
						puVar14 = (undefined4 *)pWVar2->fileNames[iVar11];
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
							*puVar14 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar14 = puVar14 + 1;
						}
						for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
							*(undefined *)puVar14 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar14 = (undefined4 *)((int)puVar14 + 1);
						}
						pWVar2 = Wad_Get(wadNo);
						lego::file::File_Error("%s\n",pWVar2->fileNames[iVar11]);
						iVar11 += 1;
						pWVar2 = Wad_Get(wadNo);
					} while (iVar11 < pWVar2->numFiles);
				}
				pWVar2 = Wad_Get(wadNo);
				pWVar7 = (WadEntry *)std::malloc(pWVar2->numFiles << 4);
				pWVar2 = Wad_Get(wadNo);
				pWVar2->wadEntries = pWVar7;
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->wadEntries == NULL) {
					pWVar2 = Wad_Get(wadNo);
					if (pWVar2->fileNames != NULL) {
						iVar11 = 0;
						pWVar2 = Wad_Get(wadNo);
						if (0 < pWVar2->numFiles) {
							do {
								pWVar2 = Wad_Get(wadNo);
								if (pWVar2->wadNames[iVar11] != NULL) {
									pWVar2 = Wad_Get(wadNo);
									std::free(pWVar2->wadNames[iVar11]);
								}
								iVar11 += 1;
								pWVar2 = Wad_Get(wadNo);
							} while (iVar11 < pWVar2->numFiles);
						}
						pWVar2 = Wad_Get(wadNo);
						std::free(pWVar2->wadNames);
					}
					pWVar2 = Wad_Get(wadNo);
					if (pWVar2->fileNames != NULL) {
						iVar11 = 0;
						pWVar2 = Wad_Get(wadNo);
						if (0 < pWVar2->numFiles) {
							do {
								pWVar2 = Wad_Get(wadNo);
								if (pWVar2->fileNames[iVar11] != NULL) {
									pWVar2 = Wad_Get(wadNo);
									std::free(pWVar2->fileNames[iVar11]);
								}
								iVar11 += 1;
								pWVar2 = Wad_Get(wadNo);
							} while (iVar11 < pWVar2->numFiles);
						}
						pWVar2 = Wad_Get(wadNo);
						std::free(pWVar2->fileNames);
					}
					std::fclose(stream);
					return -1;
				}
				pFVar17 = stream;
				pWVar2 = Wad_Get(wadNo);
				sVar3 = pWVar2->numFiles << 4;
				sVar16 = 1;
				pWVar2 = Wad_Get(wadNo);
				sVar3 = std::fread(pWVar2->wadEntries,sVar16,sVar3,pFVar17);
				pWVar2 = Wad_Get(wadNo);
				if (sVar3 == pWVar2->numFiles << 4) {
					return wadNo;
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->fileNames != NULL) {
					iVar11 = 0;
					pWVar2 = Wad_Get(wadNo);
					if (0 < pWVar2->numFiles) {
						do {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->wadNames[iVar11] != NULL) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames[iVar11]);
							}
							iVar11 += 1;
							pWVar2 = Wad_Get(wadNo);
						} while (iVar11 < pWVar2->numFiles);
					}
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->wadNames);
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->fileNames != NULL) {
					iVar11 = 0;
					pWVar2 = Wad_Get(wadNo);
					if (0 < pWVar2->numFiles) {
						do {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames[iVar11] != NULL) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames[iVar11]);
							}
							iVar11 += 1;
							pWVar2 = Wad_Get(wadNo);
						} while (iVar11 < pWVar2->numFiles);
					}
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->fileNames);
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->wadEntries != NULL) {
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->wadEntries);
				}
LAB_0048be6d:
				std::fclose(stream);
				return -1;
			}
			std::fclose(stream);
			pWVar2 = Wad_Get(wadNo);
			if (pWVar2->wadNames != NULL) {
				pWVar2 = Wad_Get(wadNo);
				std::free(pWVar2->wadNames);
			}
			pWVar2 = Wad_Get(wadNo);
			if (pWVar2->fileNames != NULL) {
				pWVar2 = Wad_Get(wadNo);
				std::free(pWVar2->fileNames);
			}
		}
	}
	return -1;
}



Wad * __cdecl lego::wad::Wad_Get(int wadNo)
{
	return globs::wadGlobs.wads + wadNo;
}



int __cdecl lego::wad::Wad_FileLength(int wadNo,int fileNo)
{
	Wad *pWVar1;
	
	pWVar1 = Wad_Get(wadNo);
	return pWVar1->wadEntries[fileNo].decompressedLength;
}



int __cdecl lego::wad::Wad_FileCompressedLength(int wadNo,int fileNo)
{
	Wad *pWVar1;
	
	pWVar1 = Wad_Get(wadNo);
	return pWVar1->wadEntries[fileNo].fileLength;
}



int __cdecl lego::wad::Wad_FindFreeFileHandle(void)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = 0;
	piVar2 = &globs::wadGlobs.fileHandles[0].active;
	do {
		if (*piVar2 == 0) {
			return iVar1;
		}
		piVar2 = piVar2 + 4;
		iVar1 += 1;
	} while ((int)piVar2 < 0x576ce4);
	return -1;
}



int __cdecl lego::wad::Wad_IsFileInWad(char *fName,int opt_wadNo)
{
	Wad *pWVar1;
	int iVar2;
	int iVar3;
	
	if (opt_wadNo != -1) {
		iVar3 = _Wad_IsFileInWad(fName,opt_wadNo);
		return iVar3;
	}
	iVar3 = 9;
	while ((pWVar1 = Wad_Get(iVar3), pWVar1->active == 0 ||
				 (iVar2 = _Wad_IsFileInWad(fName,iVar3), iVar2 == -1))) {
		iVar3 += -1;
		if (iVar3 < 0) {
			return -1;
		}
	}
	return iVar2;
}



int __cdecl lego::wad::_Wad_IsFileInWad(char *fName,int wadNo)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if (globs::wadGlobs.wads[wadNo].numFiles < 1) {
		return -1;
	}
	do {
		iVar1 = std::_stricmp(globs::wadGlobs.wads[wadNo].wadNames[iVar2],fName);
		if (iVar1 == 0) {
			return iVar2;
		}
		iVar2 += 1;
	} while (iVar2 < globs::wadGlobs.wads[wadNo].numFiles);
	return -1;
}



int __cdecl lego::wad::Wad_GetFreeWadSlot(void)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	Wad *pWVar4;
	
	iVar3 = 0;
	piVar1 = &globs::wadGlobs.wads[0].active;
	do {
		if (*piVar1 == 0) {
			pWVar4 = globs::wadGlobs.wads + iVar3;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				pWVar4->fName = NULL;
				pWVar4 = (Wad *)&pWVar4->active;
			}
			return iVar3;
		}
		piVar1 = piVar1 + 9;
		iVar3 += 1;
	} while ((int)piVar1 < 0x57666c);
	return -1;
}



int __cdecl lego::wad::_Wad_FileOpen(char *fName,int wadNo)
{
	int iVar1;
	int fileNo;
	uint size;
	void *out_buffer;
	Wad *pWVar2;
	size_t sVar3;
	int offset;
	size_t count;
	int origin;
	FILE *stream;
	int wadNo_00;
	
	iVar1 = Wad_FindFreeFileHandle();
	wadNo_00 = wadNo;
	if (iVar1 == -1) {
		return -1;
	}
	fileNo = Wad_IsFileInWad(fName,wadNo);
	if (fileNo == -1) {
		return -1;
	}
	size = Wad_FileCompressedLength(wadNo_00,fileNo);
	out_buffer = std::malloc(size);
	if (out_buffer == NULL) {
		return -1;
	}
	origin = 0;
	pWVar2 = Wad_Get(wadNo_00);
	offset = pWVar2->wadEntries[fileNo].addr;
	pWVar2 = Wad_Get(wadNo_00);
	std::fseek(pWVar2->fWad,offset,origin);
	pWVar2 = Wad_Get(wadNo_00);
	stream = pWVar2->fWad;
	count = 1;
	sVar3 = Wad_FileCompressedLength(wadNo_00,fileNo);
	sVar3 = std::fread(out_buffer,sVar3,count,stream);
	if (sVar3 != 1) {
		std::free(out_buffer);
		return -1;
	}
	pWVar2 = Wad_Get(wadNo_00);
	wadNo = (int)out_buffer;
	if ((*(byte *)&pWVar2->wadEntries[fileNo].compression & 2) != 0) {
		wadNo = 0;
		rnc::RNC_Uncompress(out_buffer,(void **)&wadNo);
		std::free(out_buffer);
	}
	globs::wadGlobs.fileHandles[iVar1].data = (void *)wadNo;
	globs::wadGlobs.fileHandles[iVar1].active = 1;
	globs::wadGlobs.fileHandles[iVar1].wadFile = wadNo_00;
	globs::wadGlobs.fileHandles[iVar1].indexOfFileInWad = fileNo;
	return iVar1;
}



int __cdecl lego::wad::Wad_FileOpen(char *fName,int opt_wadNo)
{
	Wad *pWVar1;
	int iVar2;
	int iVar3;
	
	if (opt_wadNo != -1) {
		iVar3 = _Wad_FileOpen(fName,opt_wadNo);
		return iVar3;
	}
	iVar3 = 9;
	while ((pWVar1 = Wad_Get(iVar3), pWVar1->active == 0 ||
				 (iVar2 = _Wad_FileOpen(fName,iVar3), iVar2 == -1))) {
		iVar3 += -1;
		if (iVar3 < 0) {
			return -1;
		}
	}
	return iVar2;
}



void __cdecl lego::wad::Wad_FileClose(int handle)
{
	if (globs::wadGlobs.fileHandles[handle].active != 0) {
		std::free(globs::wadGlobs.fileHandles[handle].data);
		globs::wadGlobs.fileHandles[handle].active = 0;
	}
	return;
}



void * __cdecl lego::wad::Wad_FileGetPointer(int handle)
{
	if (globs::wadGlobs.fileHandles[handle].active != 0) {
		return globs::wadGlobs.fileHandles[handle].data;
	}
	return NULL;
}



int __cdecl lego::wad::Wad_hLength(int handle)
{
	int iVar1;
	
	iVar1 = Wad_FileLength(globs::wadGlobs.fileHandles[handle].wadFile,
												 globs::wadGlobs.fileHandles[handle].indexOfFileInWad);
	return iVar1;
}



void * __cdecl lego::wad::Wad_hData(int handle)
{
	void *pvVar1;
	
	pvVar1 = Wad_FileGetPointer(handle);
	return pvVar1;
}



char * __cdecl lego::lw::lwExtractString(char *str1,char *str2,uint *out_pos,uint *out_len)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	size_t _MaxCount;
	char *pcVar5;
	
	uVar3 = 0xffffffff;
	pcVar5 = str1;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	uVar4 = 0xffffffff;
	pcVar5 = str2;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	_MaxCount = ~uVar4 - 1;
	if (((uVar3 != 1) && (_MaxCount != 0)) && (uVar4 = 0, uVar3 != 1)) {
		do {
			iVar2 = std::_strnicmp(str1,str2,_MaxCount);
			if (iVar2 == 0) {
				if (out_pos != NULL) {
					*out_pos = uVar4;
				}
				if (out_len != NULL) {
					*out_len = _MaxCount;
				}
				return str1;
			}
			uVar4 += 1;
			str1 = str1 + 1;
		} while (uVar4 < uVar3 - 1);
		return NULL;
	}
	return NULL;
}



char * __cdecl lego::lw::stringAlloc(char *str)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	uVar3 = 0xffffffff;
	pcVar6 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	uVar4 = ~uVar3 + (~uVar3 & 1);
	puVar2 = (undefined4 *)std::malloc(uVar4);
	puVar5 = puVar2;
	for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 -= 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar5 = 0;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
	}
	uVar3 = 0xffffffff;
	do {
		pcVar6 = str;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar6 = str + 1;
		cVar1 = *str;
		str = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



// Defaults to "PLANAR" on failure to parse

uint __cdecl lego::lw::texMapType(char *shapeName)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	char **ppcVar5;
	char *pcVar6;
	char *tTypes [3];
	
	tTypes[0] = "PLANAR";
	tTypes[1] = "CYLINDRICAL";
	tTypes[2] = "SPHERICAL";
	uVar4 = 0;
	ppcVar5 = tTypes;
	do {
		uVar3 = 0xffffffff;
		pcVar6 = *ppcVar5;
		do {
			if (uVar3 == 0) break;
			uVar3 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		iVar2 = std::_strnicmp(shapeName,*ppcVar5,~uVar3 - 1);
		if (iVar2 == 0) break;
		uVar4 += 1;
		ppcVar5 = ppcVar5 + 1;
	} while (uVar4 < 3);
	if (uVar4 == 3) {
		uVar4 = 0;
	}
	return uVar4;
}



void __cdecl lego::lw::surfFree(LWSURFACE *srf,BOOL flag)
{
	if (srf->srfName != NULL) {
		std::free(srf->srfName);
	}
	if (srf->srfPath != NULL) {
		std::free(srf->srfPath);
	}
	if (srf->srfNextSurf != NULL) {
		surfFree(srf->srfNextSurf,1);
	}
	if (flag != 0) {
		std::free(srf);
	}
	return;
}



BOOL __cdecl lego::lw::LWD3D(byte **p,float *f)
{
	byte *pbVar1;
	
	*(byte *)((int)f + 3) = **p;
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)((int)f + 2) = pbVar1[1];
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)((int)f + 1) = pbVar1[1];
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)f = pbVar1[1];
	*p = *p + 1;
	return TRUE;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::lw::PNTSprc(File *file,LWSIZE *sizeData,int csize,float **verts,BOOL dflag)
{
	float *pfVar1;
	int iVar2;
	float local_120;
	float fStack284;
	undefined uStack280;
	undefined local_117;
	undefined2 uStack278;
	byte *local_114;
	byte *local_110;
	uint local_10c;
	char local_108 [260];
	
	iVar2 = 0;
	local_120 = (float)(uint)local_120._0_1_;
	fStack284 = 0.0;
	uStack280 = 0;
	local_117 = 0;
	local_114 = (byte *)std::malloc(csize + 0x10);
	local_110 = local_114;
	lego::file::File_Read(local_114,csize,1,file);
	sizeData->lwVertCount = csize / 0xc;
	if (verts != NULL) {
		pfVar1 = (float *)std::malloc(csize + 4);
		*verts = pfVar1;
		if (0 < csize) {
			local_10c = (csize + 0xbU) / 0xc;
			do {
				LWD3D(&local_114,&local_120);
				LWD3D(&local_114,&fStack284);
				LWD3D(&local_114,(float *)&uStack280);
				*pfVar1 = local_120;
				pfVar1[1] = fStack284;
				pfVar1[2] = (float)CONCAT22(uStack278,CONCAT11(local_117,uStack280));
				pfVar1 = pfVar1 + 3;
				if (dflag != 0) {
					std::sprintf(local_108,"Point %d > %f %f %f\n",iVar2,(double)local_120,(double)fStack284);
				}
				iVar2 += 1;
				local_10c -= 1;
			} while (local_10c != 0);
		}
	}
	std::free(local_110);
	return TRUE;
}



BOOL __cdecl lego::lw::CRVSprc(File *file,int csize,BOOL dflag)
{
	ushort uVar1;
	ushort *out_buffer;
	uint uVar2;
	ushort *puVar3;
	int iVar4;
	
	out_buffer = (ushort *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	puVar3 = out_buffer;
	if (0 < csize) {
		do {
			uVar1 = *puVar3 * 0x100 + (*puVar3 >> 8);
			puVar3 = puVar3 + 1;
			iVar4 = csize + -2;
			if (uVar1 != 0) {
				uVar2 = (uint)uVar1;
				puVar3 = puVar3 + uVar2;
				do {
					iVar4 += -2;
					uVar2 -= 1;
				} while (uVar2 != 0);
			}
			csize = iVar4 + -4;
			puVar3 = puVar3 + 2;
		} while (0 < csize);
	}
	std::free(out_buffer);
	return TRUE;
}



BOOL __cdecl lego::lw::POLSprc(File *file,LWSIZE *sizeData,LWPOLY **polys,int csize,BOOL dflag)
{
	char cVar1;
	ushort *out_buffer;
	LWPOLY *pLVar2;
	ushort *puVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	ushort uVar7;
	ushort uVar8;
	LWPOLY *pLVar9;
	undefined4 *puVar10;
	LWPOLY *pLVar11;
	char *pcVar12;
	char *pcVar13;
	char *pcVar14;
	undefined4 *puVar15;
	ushort *local_150;
	uint local_14c;
	char local_140 [64];
	char local_100 [256];
	
	out_buffer = (ushort *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	uVar8 = 0;
	local_150 = out_buffer;
	uVar7 = 0;
	if (0 < csize) {
		do {
			uVar7 = *local_150 * 0x100 + (*local_150 >> 8);
			local_150 = local_150 + 1;
			csize += -2;
			if (polys != NULL) {
				if (uVar8 == 0) {
					pLVar2 = (LWPOLY *)std::malloc(0xc);
					*polys = pLVar2;
				}
				else {
					uVar4 = (uint)uVar8;
					pLVar2 = (LWPOLY *)std::malloc((uVar4 + 1) * 0xc);
					pLVar9 = *polys;
					pLVar11 = pLVar2;
					for (iVar5 = uVar4 * 3; iVar5 != 0; iVar5 += -1) {
						pLVar11->plyCount = pLVar9->plyCount;
						pLVar9 = (LWPOLY *)&pLVar9->plySurface;
						pLVar11 = (LWPOLY *)&pLVar11->plySurface;
					}
					for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
						*(undefined *)&pLVar11->plyCount = *(undefined *)&pLVar9->plyCount;
						pLVar9 = (LWPOLY *)((int)&pLVar9->plyCount + 1);
						pLVar11 = (LWPOLY *)((int)&pLVar11->plyCount + 1);
					}
					std::free(*polys);
					*polys = pLVar2;
					pLVar2 = pLVar2 + uVar4;
				}
				local_14c = (uint)uVar7;
				puVar3 = (ushort *)std::malloc(local_14c * 2);
				if (dflag != 0) {
					std::sprintf(local_100,"Poly %d, Vertex Count %d > ",(uint)uVar8,local_14c);
				}
				pLVar2->plyCount = local_14c;
				pLVar2->plyData = puVar3;
				if (uVar7 != 0) {
					do {
						uVar7 = *local_150 * 0x100 + (*local_150 >> 8);
						if (dflag != 0) {
							std::sprintf(local_140,"%d ",(uint)uVar7);
							uVar4 = 0xffffffff;
							pcVar13 = local_140;
							do {
								pcVar12 = pcVar13;
								if (uVar4 == 0) break;
								uVar4 -= 1;
								pcVar12 = pcVar13 + 1;
								cVar1 = *pcVar13;
								pcVar13 = pcVar12;
							} while (cVar1 != '\0');
							uVar4 = ~uVar4;
							iVar5 = -1;
							pcVar13 = local_100;
							do {
								pcVar14 = pcVar13;
								if (iVar5 == 0) break;
								iVar5 += -1;
								pcVar14 = pcVar13 + 1;
								cVar1 = *pcVar13;
								pcVar13 = pcVar14;
							} while (cVar1 != '\0');
							puVar10 = (undefined4 *)(pcVar12 + -uVar4);
							puVar15 = (undefined4 *)(pcVar14 + -1);
							for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
								*puVar15 = *puVar10;
								puVar10 = puVar10 + 1;
								puVar15 = puVar15 + 1;
							}
							for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
								*(undefined *)puVar15 = *(undefined *)puVar10;
								puVar10 = (undefined4 *)((int)puVar10 + 1);
								puVar15 = (undefined4 *)((int)puVar15 + 1);
							}
						}
						*puVar3 = uVar7;
						puVar3 = puVar3 + 1;
						local_150 = local_150 + 1;
						csize += -2;
						local_14c -= 1;
					} while (local_14c != 0);
				}
				uVar4 = (uint)(byte)*local_150 * 0x100 + -1 + (uint)(*local_150 >> 8) & 0xffff;
				pLVar2->plySurface = uVar4;
				if (dflag != 0) {
					std::sprintf(local_140,"Surface :- %d\n",uVar4);
					uVar4 = 0xffffffff;
					pcVar13 = local_140;
					do {
						pcVar12 = pcVar13;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar12 = pcVar13 + 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar12;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar5 = -1;
					pcVar13 = local_100;
					do {
						pcVar14 = pcVar13;
						if (iVar5 == 0) break;
						iVar5 += -1;
						pcVar14 = pcVar13 + 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar14;
					} while (cVar1 != '\0');
					puVar10 = (undefined4 *)(pcVar12 + -uVar4);
					puVar15 = (undefined4 *)(pcVar14 + -1);
					for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
						*puVar15 = *puVar10;
						puVar10 = puVar10 + 1;
						puVar15 = puVar15 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar15 = *(undefined *)puVar10;
						puVar10 = (undefined4 *)((int)puVar10 + 1);
						puVar15 = (undefined4 *)((int)puVar15 + 1);
					}
				}
			}
			csize += -2;
			uVar8 += 1;
			local_150 = local_150 + 1;
			uVar7 = uVar8;
		} while (0 < csize);
	}
	sizeData->lwPolyCount = (uint)uVar7;
	std::free(out_buffer);
	return TRUE;
}



BOOL __cdecl
lego::lw::SRFSprc(File *file,LWSIZE *sizeData,LWSURFLIST **srfl,int csize,uint *srflCount,BOOL dflag
								 )
{
	char cVar1;
	undefined4 *out_buffer;
	undefined4 *puVar2;
	char **ppcVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	undefined4 *puVar8;
	char **ppcVar9;
	undefined4 *puVar10;
	undefined4 *puVar11;
	char **ppcVar12;
	uint local_224;
	LWSURFLIST *local_220;
	char local_200 [512];
	
	uVar7 = 0;
	local_224 = 0;
	out_buffer = (undefined4 *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	if (srfl != NULL) {
		local_220 = (LWSURFLIST *)std::malloc(8);
		local_220->srflCount = 0;
		local_220->srflName = NULL;
	}
	puVar10 = out_buffer;
	if (0 < csize) {
		do {
			if (dflag != 0) {
				std::sprintf(local_200,"Surface %d > %s\n",local_224,puVar10);
			}
			uVar4 = 0xffffffff;
			puVar8 = puVar10;
			do {
				if (uVar4 == 0) break;
				uVar4 -= 1;
				cVar1 = *(char *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			if ((uVar4 & 1) != 0) {
				uVar4 += 1;
			}
			if (srfl != NULL) {
				puVar2 = (undefined4 *)std::malloc(uVar4);
				ppcVar3 = (char **)std::malloc(uVar7 + 4);
				puVar8 = puVar10;
				puVar11 = puVar2;
				for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar11 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar5 = uVar4 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar11 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				if (uVar7 != 0) {
					ppcVar9 = local_220->srflName;
					ppcVar12 = ppcVar3;
					for (uVar5 = uVar7 >> 2; uVar5 != 0; uVar5 -= 1) {
						*ppcVar12 = *ppcVar9;
						ppcVar9 = ppcVar9 + 1;
						ppcVar12 = ppcVar12 + 1;
					}
					for (iVar6 = 0; iVar6 != 0; iVar6 += -1) {
						*(undefined *)ppcVar12 = *(undefined *)ppcVar9;
						ppcVar9 = (char **)((int)ppcVar9 + 1);
						ppcVar12 = (char **)((int)ppcVar12 + 1);
					}
					std::free(local_220->srflName);
				}
				*(undefined4 **)((int)ppcVar3 + uVar7) = puVar2;
				local_220->srflName = ppcVar3;
				*srfl = local_220;
				local_220->srflCount = local_224 + 1;
			}
			local_224 += 1;
			uVar7 += 4;
			*srflCount = local_224;
			puVar10 = (undefined4 *)((int)puVar10 + uVar4);
			csize -= uVar4;
		} while (0 < csize);
	}
	std::free(out_buffer);
	return TRUE;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::lw::SURFprc(File *file,LWSIZE *sizeData,LWSURFACE **surf,int csize,BOOL dflag)
{
	char cVar1;
	float fVar2;
	char *pcVar3;
	LWSURFACE *pLVar4;
	char *pcVar5;
	int iVar6;
	LWTEXMAPTYPE LVar7;
	LWSURFACE *pLVar8;
	int iVar9;
	uint uVar10;
	uint uVar11;
	LWTEXFLAGS LVar12;
	LWSRFFLAGS LVar13;
	char **shapeName;
	undefined4 *puVar14;
	int iVar15;
	LWSURFACE *pLVar16;
	char **ppcVar17;
	char **ppcVar18;
	char *pcVar19;
	char *pcVar20;
	undefined4 *puVar21;
	char **local_50c;
	LWSURFACE *local_508;
	uint local_504;
	char local_500;
	undefined4 local_4ff;
	undefined4 local_4fb;
	undefined local_4f7;
	char **local_4f4;
	int local_4f0;
	char *local_4ec;
	char *local_4e8;
	char *local_4e4;
	char *local_4e0;
	char *local_4dc;
	char *local_4d8;
	char *local_4d4;
	uint local_4d0;
	int local_4cc;
	char *local_4c8 [4];
	char *local_4b8;
	char *local_4b4;
	char *local_4b0;
	char *local_4ac [4];
	char *local_49c;
	char *local_498;
	char *local_494;
	char *local_490;
	char *local_48c;
	char *local_488;
	uint local_484;
	char local_480 [511];
	undefined uStack641;
	undefined4 local_280 [32];
	char local_200 [512];
	
	local_4ff = 0;
	local_4fb = 0;
	local_500 = '\0';
	local_4f7 = 0;
	pcVar3 = (char *)std::malloc(csize + 0x10);
	local_4ec = pcVar3;
	lego::file::File_Read(pcVar3,csize,1,file);
	uVar10 = sizeData->lwSurfaceCount;
	pLVar4 = local_508;
	local_504 = uVar10;
	if (surf != NULL) {
		if (uVar10 == 0) {
			pLVar4 = (LWSURFACE *)std::malloc(0x54);
			*surf = pLVar4;
			pLVar8 = pLVar4;
			for (iVar9 = 0x15; iVar9 != 0; iVar9 += -1) {
				pLVar8->srfName = NULL;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
			}
			local_508 = pLVar4;
			pcVar5 = stringAlloc(pcVar3);
			pLVar4->srfName = pcVar5;
		}
		else {
			pLVar4 = (LWSURFACE *)std::malloc((uVar10 + 1) * 0x54);
			pLVar8 = *surf;
			pLVar16 = pLVar4;
			for (uVar11 = uVar10 * 0x15 & 0x3fffffff; uVar11 != 0; uVar11 -= 1) {
				pLVar16->srfName = pLVar8->srfName;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
				pLVar16 = (LWSURFACE *)&pLVar16->srfNextSurf;
			}
			for (iVar9 = 0; iVar9 != 0; iVar9 += -1) {
				*(undefined *)&pLVar16->srfName = *(undefined *)&pLVar8->srfName;
				pLVar8 = (LWSURFACE *)((int)&pLVar8->srfName + 1);
				pLVar16 = (LWSURFACE *)((int)&pLVar16->srfName + 1);
			}
			std::free(*surf);
			*surf = pLVar4;
			pLVar4 = pLVar4 + uVar10;
			pLVar8 = pLVar4;
			for (iVar9 = 0x15; iVar9 != 0; iVar9 += -1) {
				pLVar8->srfName = NULL;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
			}
			local_508 = pLVar4;
			pcVar3 = stringAlloc(local_4ec);
			pLVar4->srfName = pcVar3;
			pcVar3 = local_4ec;
		}
	}
	if (dflag != 0) {
		std::sprintf(local_200,"Surface %d :- %s");
	}
	uVar10 = 0xffffffff;
	pcVar5 = pcVar3;
	do {
		if (uVar10 == 0) break;
		uVar10 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar10 = ~uVar10;
	if ((uVar10 & 1) != 0) {
		uVar10 += 1;
	}
	iVar9 = csize - uVar10;
	pcVar3 = pcVar3 + uVar10;
	do {
		if (iVar9 < 1) {
			sizeData->lwSurfaceCount = sizeData->lwSurfaceCount + 1;
			std::free(local_4ec);
			return TRUE;
		}
		std::strncpy(&local_500,pcVar3,4);
		local_4cc = (*(ushort *)(pcVar3 + 4) & 0xff) * 0x100 + (uint)(*(ushort *)(pcVar3 + 4) >> 8);
		std::sprintf(local_200," %s (%d)");
		shapeName = (char **)(pcVar3 + 6);
		iVar6 = std::_strnicmp(&local_500,"TIMG",4);
		if (iVar6 == 0) {
			uVar10 = 0xffffffff;
			ppcVar17 = shapeName;
			do {
				ppcVar18 = ppcVar17;
				if (uVar10 == 0) break;
				uVar10 -= 1;
				ppcVar18 = (char **)((int)ppcVar17 + 1);
				cVar1 = *(char *)ppcVar17;
				ppcVar17 = ppcVar18;
			} while (cVar1 != '\0');
			uVar10 = ~uVar10;
			iVar6 = -1;
			pcVar3 = local_200;
			do {
				pcVar5 = pcVar3;
				if (iVar6 == 0) break;
				iVar6 += -1;
				pcVar5 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar5;
			} while (cVar1 != '\0');
			puVar14 = (undefined4 *)((int)ppcVar18 - uVar10);
			puVar21 = (undefined4 *)(pcVar5 + -1);
			for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
				*puVar21 = *puVar14;
				puVar14 = puVar14 + 1;
				puVar21 = puVar21 + 1;
			}
			for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
				*(undefined *)puVar21 = *(undefined *)puVar14;
				puVar14 = (undefined4 *)((int)puVar14 + 1);
				puVar21 = (undefined4 *)((int)puVar21 + 1);
			}
			if (surf != NULL) {
				uVar10 = 0xffffffff;
				ppcVar17 = shapeName;
				do {
					ppcVar18 = ppcVar17;
					if (uVar10 == 0) break;
					uVar10 -= 1;
					ppcVar18 = (char **)((int)ppcVar17 + 1);
					cVar1 = *(char *)ppcVar17;
					ppcVar17 = ppcVar18;
				} while (cVar1 != '\0');
				uVar10 = ~uVar10;
				puVar14 = (undefined4 *)((int)ppcVar18 - uVar10);
				puVar21 = local_280;
				for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
					*puVar21 = *puVar14;
					puVar14 = puVar14 + 1;
					puVar21 = puVar21 + 1;
				}
				for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
					*(undefined *)puVar21 = *(undefined *)puVar14;
					puVar14 = (undefined4 *)((int)puVar14 + 1);
					puVar21 = (undefined4 *)((int)puVar21 + 1);
				}
				pcVar3 = lwExtractString((char *)local_280,"(sequence)",&local_4d0,&local_484);
				if (pcVar3 != NULL) {
					LVar12 = pLVar4->srfTexFlags;
					*(undefined *)((int)local_280 + (local_4d0 - 1)) = 0;
					pLVar4->srfTexFlags = LVar12 | TFM_SEQUENCE;
				}
				pcVar3 = stringAlloc((char *)local_280);
				pLVar4->srfPath = pcVar3;
			}
		}
		else {
			iVar6 = std::_strnicmp(&local_500,"COLR",4);
			if (iVar6 == 0) {
				std::sprintf(local_480," RGBA %d,%d,%d,%d");
				uVar10 = 0xffffffff;
				pcVar5 = local_480;
				do {
					pcVar20 = pcVar5;
					if (uVar10 == 0) break;
					uVar10 -= 1;
					pcVar20 = pcVar5 + 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar20;
				} while (cVar1 != '\0');
				uVar10 = ~uVar10;
				iVar6 = -1;
				pcVar5 = local_200;
				do {
					pcVar19 = pcVar5;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar19 = pcVar5 + 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar19;
				} while (cVar1 != '\0');
				puVar14 = (undefined4 *)(pcVar20 + -uVar10);
				puVar21 = (undefined4 *)(pcVar19 + -1);
				for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
					*puVar21 = *puVar14;
					puVar14 = puVar14 + 1;
					puVar21 = puVar21 + 1;
				}
				for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
					*(undefined *)puVar21 = *(undefined *)puVar14;
					puVar14 = (undefined4 *)((int)puVar14 + 1);
					puVar21 = (undefined4 *)((int)puVar21 + 1);
				}
				if (surf != NULL) {
					(pLVar4->srfCol).colRed = *(byte *)shapeName;
					(pLVar4->srfCol).colGreen = pcVar3[7];
					(pLVar4->srfCol).colBlue = pcVar3[8];
					(pLVar4->srfCol).colAlpha = pcVar3[9];
				}
			}
			else {
				iVar6 = std::_strnicmp(&local_500,"CTEX",4);
				if (iVar6 == 0) {
					uVar10 = 0xffffffff;
					ppcVar17 = shapeName;
					do {
						ppcVar18 = ppcVar17;
						if (uVar10 == 0) break;
						uVar10 -= 1;
						ppcVar18 = (char **)((int)ppcVar17 + 1);
						cVar1 = *(char *)ppcVar17;
						ppcVar17 = ppcVar18;
					} while (cVar1 != '\0');
					uVar10 = ~uVar10;
					iVar6 = -1;
					pcVar3 = local_200;
					do {
						pcVar5 = pcVar3;
						if (iVar6 == 0) break;
						iVar6 += -1;
						pcVar5 = pcVar3 + 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar5;
					} while (cVar1 != '\0');
					puVar14 = (undefined4 *)((int)ppcVar18 - uVar10);
					puVar21 = (undefined4 *)(pcVar5 + -1);
					for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
						*puVar21 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar21 = puVar21 + 1;
					}
					for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
						*(undefined *)puVar21 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar21 = (undefined4 *)((int)puVar21 + 1);
					}
					if (surf != NULL) {
						LVar7 = texMapType((char *)shapeName);
						pLVar4->srfTexType = LVar7;
					}
				}
				else {
					iVar6 = std::_strnicmp(&local_500,"TTEX",4);
					if (iVar6 == 0) {
						uVar10 = 0xffffffff;
						ppcVar17 = shapeName;
						do {
							ppcVar18 = ppcVar17;
							if (uVar10 == 0) break;
							uVar10 -= 1;
							ppcVar18 = (char **)((int)ppcVar17 + 1);
							cVar1 = *(char *)ppcVar17;
							ppcVar17 = ppcVar18;
						} while (cVar1 != '\0');
						uVar10 = ~uVar10;
						iVar6 = -1;
						pcVar3 = local_200;
						do {
							pcVar5 = pcVar3;
							if (iVar6 == 0) break;
							iVar6 += -1;
							pcVar5 = pcVar3 + 1;
							cVar1 = *pcVar3;
							pcVar3 = pcVar5;
						} while (cVar1 != '\0');
						puVar14 = (undefined4 *)((int)ppcVar18 - uVar10);
						puVar21 = (undefined4 *)(pcVar5 + -1);
						for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
							*puVar21 = *puVar14;
							puVar14 = puVar14 + 1;
							puVar21 = puVar21 + 1;
						}
						for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
							*(undefined *)puVar21 = *(undefined *)puVar14;
							puVar14 = (undefined4 *)((int)puVar14 + 1);
							puVar21 = (undefined4 *)((int)puVar21 + 1);
						}
						if (surf != NULL) {
							pLVar8 = (LWSURFACE *)std::malloc(0x54);
							pLVar4->srfNextSurf = pLVar8;
							pLVar4 = pLVar8;
							for (iVar6 = 0x15; iVar6 != 0; iVar6 += -1) {
								pLVar4->srfName = NULL;
								pLVar4 = (LWSURFACE *)&pLVar4->srfNextSurf;
							}
							local_508 = pLVar8;
							LVar7 = texMapType((char *)shapeName);
							pLVar8->srfTexType = LVar7;
							pLVar4 = pLVar8;
						}
					}
					else {
						iVar6 = std::_strnicmp(&local_500,"TFLG",4);
						if (iVar6 == 0) {
							local_4f4 = NULL;
							if (surf != NULL) {
								LVar12 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100 &
												 0xffff;
								local_4c8[0] = "Axis_x";
								local_508->srfTexFlags = local_508->srfTexFlags | LVar12;
								local_4c8[1] = "Axis_y";
								local_4c8[2] = "Axis_z";
								local_4c8[3] = "World Coord";
								local_4b8 = "Negative Image";
								local_4b4 = "Pixel Blending";
								local_4b0 = "Anti Aliasing";
								std::sprintf(local_480,"%xH - ");
								local_50c = local_4c8;
								local_4f0 = 0;
								local_504 = 8;
								do {
									if ((LVar12 & 1 << ((byte)local_4f0 & 0x1f)) != 0) {
										if ((short)local_4f4 != 0) {
											uVar10 = 0xffffffff;
											pcVar3 = ",";
											do {
												pcVar5 = pcVar3;
												if (uVar10 == 0) break;
												uVar10 -= 1;
												pcVar5 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar5;
											} while (cVar1 != '\0');
											uVar10 = ~uVar10;
											iVar6 = -1;
											pcVar3 = local_480;
											do {
												pcVar20 = pcVar3;
												if (iVar6 == 0) break;
												iVar6 += -1;
												pcVar20 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar20;
											} while (cVar1 != '\0');
											puVar14 = (undefined4 *)(pcVar5 + -uVar10);
											puVar21 = (undefined4 *)(pcVar20 + -1);
											for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
												*puVar21 = *puVar14;
												puVar14 = puVar14 + 1;
												puVar21 = puVar21 + 1;
											}
											for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
												*(undefined *)puVar21 = *(undefined *)puVar14;
												puVar14 = (undefined4 *)((int)puVar14 + 1);
												puVar21 = (undefined4 *)((int)puVar21 + 1);
											}
										}
										local_4f4 = (char **)((int)local_4f4 + 1);
										uVar10 = 0xffffffff;
										pcVar3 = *local_50c;
										do {
											pcVar5 = pcVar3;
											if (uVar10 == 0) break;
											uVar10 -= 1;
											pcVar5 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar5;
										} while (cVar1 != '\0');
										uVar10 = ~uVar10;
										iVar6 = -1;
										pcVar3 = local_480;
										do {
											pcVar20 = pcVar3;
											if (iVar6 == 0) break;
											iVar6 += -1;
											pcVar20 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar20;
										} while (cVar1 != '\0');
										puVar14 = (undefined4 *)(pcVar5 + -uVar10);
										puVar21 = (undefined4 *)(pcVar20 + -1);
										for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
											*puVar21 = *puVar14;
											puVar14 = puVar14 + 1;
											puVar21 = puVar21 + 1;
										}
										for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
											*(undefined *)puVar21 = *(undefined *)puVar14;
											puVar14 = (undefined4 *)((int)puVar14 + 1);
											puVar21 = (undefined4 *)((int)puVar21 + 1);
										}
									}
									local_4f0 += 1;
									local_50c = local_50c + 1;
									local_504 -= 1;
								} while (local_504 != 0);
LAB_0048d1d2:
								uVar10 = 0xffffffff;
								pcVar3 = local_480;
								do {
									pcVar5 = pcVar3;
									if (uVar10 == 0) break;
									uVar10 -= 1;
									pcVar5 = pcVar3 + 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar5;
								} while (cVar1 != '\0');
								uVar10 = ~uVar10;
								iVar6 = -1;
								pcVar3 = local_200;
								do {
									pcVar20 = pcVar3;
									if (iVar6 == 0) break;
									iVar6 += -1;
									pcVar20 = pcVar3 + 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar20;
								} while (cVar1 != '\0');
								puVar14 = (undefined4 *)(pcVar5 + -uVar10);
								puVar21 = (undefined4 *)(pcVar20 + -1);
								for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
									*puVar21 = *puVar14;
									puVar14 = puVar14 + 1;
									puVar21 = puVar21 + 1;
								}
								for (uVar10 &= 3; pLVar4 = local_508, uVar10 != 0; uVar10 -= 1) {
									*(undefined *)puVar21 = *(undefined *)puVar14;
									puVar14 = (undefined4 *)((int)puVar14 + 1);
									puVar21 = (undefined4 *)((int)puVar21 + 1);
								}
							}
						}
						else {
							iVar6 = std::_strnicmp(&local_500,"FLAG",4);
							if (iVar6 == 0) {
								local_50c = NULL;
								if (surf != NULL) {
									local_4ac[0] = "Luminous";
									LVar13 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100
													 & 0xffff;
									local_4ac[1] = "Outline";
									local_4ac[2] = "Smoothing";
									local_4ac[3] = "Color Highlights";
									local_49c = "Color Filter";
									local_498 = "Opaque Edge";
									local_494 = "Transparent Edge";
									local_490 = "Sharp Terminator";
									local_48c = "Double Sided";
									local_488 = "Additive";
									local_508->srfFlags = LVar13;
									std::sprintf(local_480,"%xH - ");
									local_4f4 = local_4ac;
									local_504 = 0;
									local_4f0 = 10;
									do {
										if ((LVar13 & 1 << ((byte)local_504 & 0x1f)) != 0) {
											if ((short)local_50c != 0) {
												uVar10 = 0xffffffff;
												pcVar3 = ",";
												do {
													pcVar5 = pcVar3;
													if (uVar10 == 0) break;
													uVar10 -= 1;
													pcVar5 = pcVar3 + 1;
													cVar1 = *pcVar3;
													pcVar3 = pcVar5;
												} while (cVar1 != '\0');
												uVar10 = ~uVar10;
												iVar6 = -1;
												pcVar3 = local_480;
												do {
													pcVar20 = pcVar3;
													if (iVar6 == 0) break;
													iVar6 += -1;
													pcVar20 = pcVar3 + 1;
													cVar1 = *pcVar3;
													pcVar3 = pcVar20;
												} while (cVar1 != '\0');
												puVar14 = (undefined4 *)(pcVar5 + -uVar10);
												puVar21 = (undefined4 *)(pcVar20 + -1);
												for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
													*puVar21 = *puVar14;
													puVar14 = puVar14 + 1;
													puVar21 = puVar21 + 1;
												}
												for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
													*(undefined *)puVar21 = *(undefined *)puVar14;
													puVar14 = (undefined4 *)((int)puVar14 + 1);
													puVar21 = (undefined4 *)((int)puVar21 + 1);
												}
											}
											local_50c = (char **)((int)local_50c + 1);
											uVar10 = 0xffffffff;
											pcVar3 = *local_4f4;
											do {
												pcVar5 = pcVar3;
												if (uVar10 == 0) break;
												uVar10 -= 1;
												pcVar5 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar5;
											} while (cVar1 != '\0');
											uVar10 = ~uVar10;
											iVar6 = -1;
											pcVar3 = local_480;
											do {
												pcVar20 = pcVar3;
												if (iVar6 == 0) break;
												iVar6 += -1;
												pcVar20 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar20;
											} while (cVar1 != '\0');
											puVar14 = (undefined4 *)(pcVar5 + -uVar10);
											puVar21 = (undefined4 *)(pcVar20 + -1);
											for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
												*puVar21 = *puVar14;
												puVar14 = puVar14 + 1;
												puVar21 = puVar21 + 1;
											}
											for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
												*(undefined *)puVar21 = *(undefined *)puVar14;
												puVar14 = (undefined4 *)((int)puVar14 + 1);
												puVar21 = (undefined4 *)((int)puVar21 + 1);
											}
										}
										local_504 += 1;
										local_4f4 = local_4f4 + 1;
										local_4f0 += -1;
									} while (local_4f0 != 0);
									goto LAB_0048d1d2;
								}
							}
							else {
								iVar6 = std::_strnicmp(&local_500,"TSIZ",4);
								if (iVar6 == 0) {
									if (surf != NULL) {
										local_50c = shapeName;
										LWD3D((byte **)&local_50c,(float *)&local_4dc);
										LWD3D((byte **)&local_50c,(float *)&local_4d8);
										LWD3D((byte **)&local_50c,(float *)&local_4d4);
										std::sprintf(local_480," (%f,%f,%f)");
										(pLVar4->srfTexSize).tdX = (float)local_4dc;
										(pLVar4->srfTexSize).tdY = (float)local_4d8;
										(pLVar4->srfTexSize).tdZ = (float)local_4d4;
LAB_0048d369:
										uVar10 = 0xffffffff;
										pcVar3 = local_480;
										do {
											pcVar5 = pcVar3;
											if (uVar10 == 0) break;
											uVar10 -= 1;
											pcVar5 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar5;
										} while (cVar1 != '\0');
										uVar10 = ~uVar10;
										iVar6 = -1;
										pcVar3 = local_200;
										do {
											pcVar20 = pcVar3;
											if (iVar6 == 0) break;
											iVar6 += -1;
											pcVar20 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar20;
										} while (cVar1 != '\0');
										puVar14 = (undefined4 *)(pcVar5 + -uVar10);
										puVar21 = (undefined4 *)(pcVar20 + -1);
										for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
											*puVar21 = *puVar14;
											puVar14 = puVar14 + 1;
											puVar21 = puVar21 + 1;
										}
										for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
											*(undefined *)puVar21 = *(undefined *)puVar14;
											puVar14 = (undefined4 *)((int)puVar14 + 1);
											puVar21 = (undefined4 *)((int)puVar21 + 1);
										}
									}
								}
								else {
									iVar6 = std::_strnicmp(&local_500,"TCTR",4);
									if ((iVar6 == 0) && (surf != NULL)) {
										local_50c = shapeName;
										LWD3D((byte **)&local_50c,(float *)&local_4e8);
										LWD3D((byte **)&local_50c,(float *)&local_4e4);
										LWD3D((byte **)&local_50c,(float *)&local_4e0);
										std::sprintf(local_480," (%f,%f,%f)");
										(pLVar4->srfTexCentre).tdX = (float)local_4e8;
										(pLVar4->srfTexCentre).tdY = (float)local_4e4;
										(pLVar4->srfTexCentre).tdZ = (float)local_4e0;
										goto LAB_0048d369;
									}
								}
							}
						}
					}
				}
			}
		}
		iVar15 = 0;
		iVar6 = std::_strnicmp(&local_500,"TRAN",4);
		if (iVar6 == 0) {
			iVar15 = 1;
		}
		else {
			iVar6 = std::_strnicmp(&local_500,"DIFF",4);
			if (iVar6 == 0) {
				iVar15 = 2;
			}
			else {
				iVar6 = std::_strnicmp(&local_500,"LUMI",4);
				if (iVar6 == 0) {
					iVar15 = 3;
				}
				else {
					iVar6 = std::_strnicmp(&local_500,"REFL",4);
					if (iVar6 == 0) {
						iVar15 = 4;
					}
					else {
						iVar6 = std::_strnicmp(&local_500,"SPEC",4);
						if (iVar6 == 0) {
							iVar15 = 5;
						}
						else {
							iVar6 = std::_strnicmp(&local_500,"GLOS",4);
							if (iVar6 == 0) {
								iVar15 = 6;
							}
						}
					}
				}
			}
		}
		if ((iVar15 != 0) && (surf != NULL)) {
			local_504 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100 & 0xffff
			;
			fVar2 = (float)local_504 * 0.00390625;
			switch(iVar15) {
			case 1:
				pLVar4->srfTransparent = fVar2;
				break;
			case 2:
				pLVar4->srfDiffuse = fVar2;
				break;
			case 3:
				pLVar4->srfLuminous = fVar2;
				break;
			case 4:
				pLVar4->srfReflect = fVar2;
				break;
			case 5:
				pLVar4->srfSpecular = fVar2;
				break;
			case 6:
				pLVar4->srfSpecPower = fVar2;
			}
			std::sprintf(local_480,"%f");
			uVar10 = 0xffffffff;
			pcVar3 = local_480;
			do {
				pcVar5 = pcVar3;
				if (uVar10 == 0) break;
				uVar10 -= 1;
				pcVar5 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar5;
			} while (cVar1 != '\0');
			uVar10 = ~uVar10;
			iVar6 = -1;
			pcVar3 = local_200;
			do {
				pcVar20 = pcVar3;
				if (iVar6 == 0) break;
				iVar6 += -1;
				pcVar20 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar20;
			} while (cVar1 != '\0');
			puVar14 = (undefined4 *)(pcVar5 + -uVar10);
			puVar21 = (undefined4 *)(pcVar20 + -1);
			for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
				*puVar21 = *puVar14;
				puVar14 = puVar14 + 1;
				puVar21 = puVar21 + 1;
			}
			for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
				*(undefined *)puVar21 = *(undefined *)puVar14;
				puVar14 = (undefined4 *)((int)puVar14 + 1);
				puVar21 = (undefined4 *)((int)puVar21 + 1);
			}
		}
		pcVar3 = (char *)((int)shapeName + local_4cc);
		iVar9 += -6 - local_4cc;
	} while( true );
}



BOOL __cdecl
lego::lw::LoadLWOB(char *fn,LWSIZE *sd,float **verts,LWPOLY **polys,LWSURFACE **surfs,
									File **out_fileUV,BOOL dflag)
{
	File *f;
	LWSIZE *sizeData;
	BOOL BVar1;
	File *pFVar2;
	int iVar3;
	int iVar4;
	char *pcVar5;
	uint uVar6;
	byte *pbVar7;
	LWSURFACE *pLVar8;
	char **ppcVar9;
	uint local_534;
	uint local_530;
	LWSURFLIST *local_52c;
	uint local_528;
	char local_524;
	undefined4 local_523;
	undefined4 local_51f;
	undefined local_51b;
	uint local_518;
	uint local_514;
	char *local_510;
	File *local_50c;
	LWSIZE *local_508;
	LWSURFACE *local_504;
	char filenameLwo [256];
	char buff [1024];
	
	local_523 = 0;
	local_51f = 0;
	local_524 = '\0';
	local_51b = 0;
	local_530 = 0;
	std::sprintf(filenameLwo,"%s.lwo",fn);
	f = lego::file::File_Open(filenameLwo,"rb");
	if (f == NULL) {
		return 0;
	}
	local_50c = f;
	sizeData = (LWSIZE *)std::malloc(0xc);
	sizeData->lwSurfaceCount = 0;
	sizeData->lwPolyCount = 0;
	sizeData->lwVertCount = 0;
	local_508 = sizeData;
	if (out_fileUV != NULL) {
		std::sprintf(filenameLwo,"%s.uv",fn);
		BVar1 = lego::file::File_Exists(filenameLwo);
		if (BVar1 == 0) {
			*out_fileUV = NULL;
		}
		else {
			pFVar2 = lego::file::File_Open(filenameLwo,"rb");
			*out_fileUV = pFVar2;
		}
	}
	lego::file::File_Read(&local_524,4,1,f);
	iVar3 = std::_stricmp(&local_524,"FORM");
	if (iVar3 == 0) {
		lego::file::File_Read(&local_518,4,1,f);
		local_518 = ((local_518 & 0xff00) + (local_518 & 0xff) * 0x10000) * 0x100 +
								(local_518 >> 0x10 & 0xff) * 0x100 + (local_518 >> 0x18);
		lego::file::File_Read(&local_524,4,1,f);
		iVar3 = std::_stricmp(&local_524,"LWOB");
		if (iVar3 == 0) {
			for (iVar3 = local_518 - 4; 0 < iVar3; iVar3 += -8 - local_534) {
				lego::file::File_Read(&local_524,4,1,f);
				lego::file::File_Read(&local_534,4,1,f);
				local_534 = ((local_534 & 0xff00) + (local_534 & 0xff) * 0x10000) * 0x100 +
										(local_534 >> 0x10 & 0xff) * 0x100 + (local_534 >> 0x18);
				if (dflag != 0) {
					std::sprintf(buff,"LW OBJECT %s %d\n",&local_524,local_534);
				}
				iVar4 = std::_stricmp(&local_524,"PNTS");
				if (iVar4 == 0) {
					PNTSprc(f,sizeData,local_534,verts,dflag);
				}
				else {
					iVar4 = std::_stricmp(&local_524,"SRFS");
					if (iVar4 == 0) {
						SRFSprc(f,sizeData,&local_52c,local_534,&local_530,dflag);
					}
					else {
						iVar4 = std::_stricmp(&local_524,"SURF");
						if (iVar4 == 0) {
							SURFprc(f,sizeData,surfs,local_534,dflag);
						}
						else {
							iVar4 = std::_stricmp(&local_524,"CRVS");
							if (iVar4 == 0) {
								CRVSprc(f,local_534,dflag);
							}
							else {
								iVar4 = std::_stricmp(&local_524,"POLS");
								if (iVar4 == 0) {
									POLSprc(f,sizeData,polys,local_534,dflag);
								}
								else {
									lego::file::File_Seek(f,local_534,SEEK_CUR);
								}
							}
						}
					}
				}
			}
			local_528 = sizeData->lwSurfaceCount;
			if (((surfs != NULL) && (local_52c != NULL)) && (sizeData != NULL)) {
				local_504 = (LWSURFACE *)std::malloc(local_530 * 0x54);
				pLVar8 = local_504;
				for (uVar6 = local_530 * 0x15 & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
					pLVar8->srfName = NULL;
					pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
				}
				for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
					*(undefined *)&pLVar8->srfName = 0;
					pLVar8 = (LWSURFACE *)((int)&pLVar8->srfName + 1);
				}
				local_514 = 0;
				if (local_530 != 0) {
					pbVar7 = &(local_504->srfCol).colGreen;
					do {
						uVar6 = 0;
						local_510 = local_52c->srflName[local_514];
						if (local_528 != 0) {
							iVar3 = 0;
LAB_0048d940:
							iVar4 = std::_stricmp(*(char **)((*surfs)->srfTCLR + iVar3 + -0x10),local_510);
							if (iVar4 != 0) goto code_r0x0048d95e;
							pLVar8 = *surfs + uVar6;
							ppcVar9 = (char **)(pbVar7 + -0xd);
							for (iVar3 = 0x15; f = local_50c, iVar3 != 0; iVar3 += -1) {
								*ppcVar9 = pLVar8->srfName;
								pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
								ppcVar9 = ppcVar9 + 1;
							}
						}
LAB_0048d990:
						if (uVar6 == local_528) {
							pcVar5 = stringAlloc("Default");
							*(char **)(pbVar7 + -0xd) = pcVar5;
							pbVar7[-1] = 0xff;
							*pbVar7 = 0xff;
							pbVar7[1] = 0xff;
							local_528 = local_530;
						}
						pbVar7 = pbVar7 + 0x54;
						local_514 += 1;
						sizeData = local_508;
					} while (local_514 < local_530);
				}
				pLVar8 = local_504;
				std::free(*surfs);
				*surfs = pLVar8;
			}
			sizeData->lwSurfaceCount = local_528;
			if (sd != NULL) {
				sd->lwVertCount = sizeData->lwVertCount;
				sd->lwPolyCount = sizeData->lwPolyCount;
				sd->lwSurfaceCount = sizeData->lwSurfaceCount;
			}
			std::free(sizeData);
			if (local_530 != 0) {
				uVar6 = 0;
				if (local_530 != 0) {
					do {
						std::free(local_52c->srflName[uVar6]);
						uVar6 += 1;
					} while (uVar6 < local_530);
				}
				std::free(local_52c->srflName);
				std::free(local_52c);
			}
			lego::file::File_Close(f);
			return TRUE;
		}
	}
	std::free(sizeData);
	lego::file::File_Close(f);
	std::sprintf(buff,"Error in Lightwave file %s",fn);
	return 0;
code_r0x0048d95e:
	uVar6 += 1;
	iVar3 += 0x54;
	if (local_528 <= uVar6) goto LAB_0048d990;
	goto LAB_0048d940;
}



BOOL __cdecl lego::lw::LoadAppObj(char *fn,APPOBJ **out_ao,BOOL flag)
{
	APPOBJ *pAVar1;
	char *pcVar2;
	BOOL BVar3;
	int iVar4;
	char path [128];
	
	pAVar1 = (APPOBJ *)std::malloc(0x20);
	*out_ao = pAVar1;
	for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
		pAVar1->aoPath = NULL;
		pAVar1 = (APPOBJ *)&pAVar1->aoSize;
	}
	std::_splitpath(fn,NULL,path,NULL,NULL);
	pcVar2 = stringAlloc(path);
	(*out_ao)->aoPath = pcVar2;
	pAVar1 = *out_ao;
	BVar3 = LoadLWOB(fn,&pAVar1->aoSize,&pAVar1->aoVerts,&pAVar1->aoPoly,&pAVar1->aoSurface,
									 &pAVar1->aoFileUV,flag);
	if (BVar3 != 0) {
		return TRUE;
	}
	std::free((*out_ao)->aoPath);
	std::free(*out_ao);
	return 0;
}



BOOL __cdecl lego::lw::FreeLWOB(APPOBJ *ao)
{
	uint uVar1;
	LWSURFACE *srf;
	int iVar2;
	
	if (ao != NULL) {
		if (ao->aoFileUV != NULL) {
			lego::file::File_Close(ao->aoFileUV);
		}
		srf = ao->aoSurface;
		if (srf != NULL) {
			for (uVar1 = (ao->aoSize).lwSurfaceCount; uVar1 != 0; uVar1 -= 1) {
				surfFree(srf,0);
				srf = srf + 1;
			}
			std::free(ao->aoSurface);
		}
		if (ao->aoPoly != NULL) {
			uVar1 = (ao->aoSize).lwPolyCount;
			if (uVar1 != 0) {
				iVar2 = 0;
				do {
					std::free(*(void **)((int)&ao->aoPoly->plyData + iVar2));
					iVar2 += 0xc;
					uVar1 -= 1;
				} while (uVar1 != 0);
			}
			std::free(ao->aoPoly);
		}
		std::free(ao->aoVerts);
		std::free(ao->aoPath);
		std::free(ao);
		return TRUE;
	}
	return 0;
}



float10 __cdecl std::atof(char *str)
{
	byte bVar1;
	uint uVar2;
	undefined *puVar3;
	int iVar4;
	byte *pbVar5;
	
	while( true ) {
						// int std::isspace(int c)
		if (globals::_pcharwidth < 2) {
			uVar2 = *(byte *)(globals::_pctype + (byte)*str) & C1_SPACE;
		}
		else {
			uVar2 = _isctype((uint)(byte)*str,C1_SPACE);
		}
		if (uVar2 == 0) break;
		str = (char *)((byte *)str + 1);
	}
	iVar4 = -1;
	pbVar5 = (byte *)str;
	do {
		if (iVar4 == 0) break;
		iVar4 += -1;
		bVar1 = *pbVar5;
		pbVar5 = pbVar5 + 1;
	} while (bVar1 != 0);
	puVar3 = internal::__atof_internal(str);
	return (float10)*(double *)(puVar3 + 0x10);
}



int __cdecl std::sprintf(char *out_buffer,char *format,...)
{
	int iVar1;
	FILE dummyFile;
	
	dummyFile._base = out_buffer;
	dummyFile._ptr = out_buffer;
	dummyFile._flag = 0x42;
	dummyFile._cnt = 0x7fffffff;
	iVar1 = internal::__vfprintf_internal(&dummyFile,format,&stack0x0000000c);
	dummyFile._cnt += -1;
	if (-1 < dummyFile._cnt) {
		*dummyFile._ptr = '\0';
		return iVar1;
	}
	internal::__fafterwrite_00490b60(0,&dummyFile._ptr);
	return iVar1;
}



char * __cdecl std::strstr(char *str,char *strSearch)
{
	char *pcVar1;
	char *pcVar2;
	char cVar3;
	uint uVar4;
	char cVar5;
	uint uVar6;
	char *pcVar7;
	uint uVar8;
	uint *puVar9;
	char *pcVar10;
	
	cVar3 = *strSearch;
	if (cVar3 == '\0') {
		return (char *)(uint *)str;
	}
	if (strSearch[1] == '\0') {
		uVar4 = (uint)str & 3;
		while (uVar4 != 0) {
			if (*str == cVar3) {
				return (char *)(uint *)str;
			}
			if (*str == '\0') {
				return (char *)NULL;
			}
			uVar4 = (uint)(uint *)((int)str + 1) & 3;
			str = (char *)(uint *)((int)str + 1);
		}
		while( true ) {
			while( true ) {
				uVar4 = *(uint *)str;
				uVar8 = uVar4 ^ CONCAT22(CONCAT11(cVar3,cVar3),CONCAT11(cVar3,cVar3));
				uVar6 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;
				puVar9 = (uint *)((int)str + 4);
				if (((uVar8 ^ 0xffffffff ^ uVar8 + 0x7efefeff) & 0x81010100) != 0) break;
				str = (char *)puVar9;
				if ((uVar6 & 0x81010100) != 0) {
					if ((uVar6 & 0x1010100) != 0) {
						return (char *)NULL;
					}
					if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {
						return (char *)NULL;
					}
				}
			}
			uVar4 = *(uint *)str;
			if ((char)uVar4 == cVar3) {
				return (char *)(uint *)str;
			}
			if ((char)uVar4 == '\0') {
				return (char *)NULL;
			}
			cVar5 = (char)(uVar4 >> 8);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 1);
			}
			if (cVar5 == '\0') break;
			cVar5 = (char)(uVar4 >> 0x10);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 2);
			}
			if (cVar5 == '\0') {
				return (char *)NULL;
			}
			cVar5 = (char)(uVar4 >> 0x18);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 3);
			}
			str = (char *)puVar9;
			if (cVar5 == '\0') {
				return (char *)NULL;
			}
		}
		return (char *)NULL;
	}
	do {
		cVar5 = *str;
		do {
			while (str = str + 1, cVar5 != cVar3) {
				if (cVar5 == '\0') {
					return (char *)NULL;
				}
				cVar5 = *str;
			}
			cVar5 = *str;
			pcVar10 = str + 1;
			pcVar7 = strSearch;
		} while (cVar5 != strSearch[1]);
		do {
			if (pcVar7[2] == '\0') {
LAB_0048dd83:
				return (char *)(uint *)(str + -1);
			}
			if (*pcVar10 != pcVar7[2]) break;
			pcVar1 = pcVar7 + 3;
			if (*pcVar1 == '\0') goto LAB_0048dd83;
			pcVar2 = pcVar10 + 1;
			pcVar7 = pcVar7 + 2;
			pcVar10 = pcVar10 + 2;
		} while (*pcVar1 == *pcVar2);
	} while( true );
}



int __cdecl std::atoi(char *str)
{
	int iVar1;
	
	iVar1 = internal::__atoi_internal(str);
	return iVar1;
}



void __cdecl std::free(void *buffer)
{
	void *lpMem;
	byte *pbVar1;
	int *local_4;
	
	lpMem = buffer;
	if (buffer != NULL) {
		pbVar1 = (byte *)internal::__realloc_free__00491b00
															 ((undefined *)buffer,&local_4,(uint *)&buffer);
		if (pbVar1 != NULL) {
			internal::__free_realloc__00491b60((int)local_4,(int)buffer,pbVar1);
			return;
		}
		HeapFree(globs::_crt2._heap,0,lpMem);
	}
	return;
}



void * __cdecl std::malloc(uint size)
{
	void *buffer;
	
	buffer = internal::__malloc_handlermode(size,globs::_crt1._handlermode);
	return buffer;
}



void * __cdecl std::realloc(void *memblock,uint size)
{
	int *piVar1;
	int **ppiVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int *piVar7;
	int *piVar8;
	int **local_8;
	int *local_4;
	
	if (memblock == NULL) {
		piVar1 = (int *)malloc(size);
		return piVar1;
	}
	if (size == 0) {
		free(memblock);
		return NULL;
	}
	if (size < 0xffffffe1) {
		if (size == 0) {
			size = 0x10;
		}
		else {
			size = size + 0xf & 0xfffffff0;
		}
	}
	do {
		piVar1 = NULL;
		if (size < 0xffffffe1) {
			ppiVar2 = (int **)internal::__realloc_free__00491b00
																	((undefined *)memblock,&local_4,(uint *)&local_8);
			if (ppiVar2 == NULL) {
				piVar1 = (int *)HeapReAlloc(globs::_crt2._heap,0,memblock,size);
				goto LAB_0048e0aa;
			}
			if (size < globs::_ctr3.field_0x2038) {
				iVar3 = internal::__realloc__00491f80((int)local_4,local_8,ppiVar2,(uint)(int *)(size >> 4))
				;
				piVar1 = (int *)memblock;
				if (iVar3 != 0) goto LAB_0048e03f;
				piVar1 = internal::__malloc__00491bc0((int *)(size >> 4));
				if (piVar1 != NULL) {
					uVar6 = (uint)*(byte *)ppiVar2 << 4;
					if (size <= (uint)*(byte *)ppiVar2 << 4) {
						uVar6 = size;
					}
					piVar7 = (int *)memblock;
					piVar8 = piVar1;
					for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 -= 1) {
						*piVar8 = *piVar7;
						piVar7 = piVar7 + 1;
						piVar8 = piVar8 + 1;
					}
					for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
						*(undefined *)piVar8 = *(undefined *)piVar7;
						piVar7 = (int *)((int)piVar7 + 1);
						piVar8 = (int *)((int)piVar8 + 1);
					}
					internal::__free_realloc__00491b60((int)local_4,(int)local_8,(byte *)ppiVar2);
					goto LAB_0048e03f;
				}
			}
			else {
LAB_0048e03f:
				if (piVar1 != NULL) {
					return piVar1;
				}
			}
			piVar1 = (int *)HeapAlloc(globs::_crt2._heap,0,size);
			if (piVar1 != NULL) {
				uVar6 = (uint)*(byte *)ppiVar2 << 4;
				if (size <= (uint)*(byte *)ppiVar2 << 4) {
					uVar6 = size;
				}
				piVar7 = (int *)memblock;
				piVar8 = piVar1;
				for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 -= 1) {
					*piVar8 = *piVar7;
					piVar7 = piVar7 + 1;
					piVar8 = piVar8 + 1;
				}
				for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
					*(undefined *)piVar8 = *(undefined *)piVar7;
					piVar7 = (int *)((int)piVar7 + 1);
					piVar8 = (int *)((int)piVar8 + 1);
				}
				internal::__free_realloc__00491b60((int)local_4,(int)local_8,(byte *)ppiVar2);
				goto LAB_0048e0aa;
			}
		}
		else {
LAB_0048e0aa:
			if (piVar1 != NULL) {
				return piVar1;
			}
		}
		if (globs::_crt1._handlermode == 0) {
			return piVar1;
		}
		BVar4 = internal::__call_new_handler(size);
		if (BVar4 == 0) {
			return NULL;
		}
	} while( true );
}



void __cdecl std::qsort(void *base,uint number,uint width,QsortCompare compare)
{
	uint uVar1;
	int iVar2;
	byte *a;
	byte *b;
	byte *local_100;
	byte **local_fc;
	byte **local_f8;
	int local_f4;
	byte *local_f0 [30];
	byte *local_78 [30];
	
	if ((number < 2) || (width == 0)) {
		return;
	}
	local_100 = (byte *)((number - 1) * width + (int)base);
	local_fc = local_f0;
	local_f8 = local_78;
	local_f4 = 0;
LAB_0048e134:
	uVar1 = (uint)((int)local_100 - (int)base) / width + 1;
	if (8 < uVar1) {
		internal::__memswap((byte *)((int)base + (uVar1 >> 1) * width),(byte *)base,width);
		b = local_100 + width;
		a = (byte *)base;
LAB_0048e1ae:
		a = a + width;
		if (a <= local_100) goto code_r0x0048e1b8;
		goto LAB_0048e1c8;
	}
	internal::__qsort((byte *)base,local_100,width,compare);
	goto LAB_0048e155;
code_r0x0048e1b8:
	iVar2 = (*compare)(a,base);
	if (iVar2 < 1) goto LAB_0048e1ae;
LAB_0048e1c8:
	do {
		b = b + -width;
		if (b <= base) break;
		iVar2 = (*compare)(b,base);
	} while (-1 < iVar2);
	if (a <= b) {
		internal::__memswap(a,b,width);
		goto LAB_0048e1ae;
	}
	internal::__memswap((byte *)base,b,width);
	if ((int)(b + (-1 - (int)base)) < (int)local_100 - (int)a) {
		if (a < local_100) {
			*local_f8 = a;
			*local_fc = local_100;
			local_f4 += 1;
			local_f8 = local_f8 + 1;
			local_fc = local_fc + 1;
		}
		if ((byte *)((int)base + width) < b) {
			local_100 = b + -width;
			goto LAB_0048e134;
		}
	}
	else {
		if ((byte *)((int)base + width) < b) {
			*local_f8 = (byte *)base;
			*local_fc = b + -width;
			local_f4 += 1;
			local_f8 = local_f8 + 1;
			local_fc = local_fc + 1;
		}
		base = a;
		if (a < local_100) goto LAB_0048e134;
	}
LAB_0048e155:
	local_f4 += -1;
	local_f8 = local_f8 + -1;
	local_fc = local_fc + -1;
	if (local_f4 < 0) {
		return;
	}
	local_100 = *local_fc;
	base = *local_f8;
	goto LAB_0048e134;
}



// Library Function - Single Match
// Name: __ftol
// Library: Visual Studio

longlong __ftol(float10 param_1)
{
	return (longlong)ROUND(param_1);
}



float10 __cdecl std::acos(float10 x)
{
	float10 fVar1;
	double dVar2;
	
	dVar2 = (double)x;
	internal::__fpmath_FUN_00492328(dVar2);
	fVar1 = internal::__fpmath_acos_FUN_0048e36d(dVar2);
	return fVar1;
}



void __cdecl std::srand(uint seed)
{
	globals::g_rand = seed;
	return;
}



int __cdecl std::rand(void)
{
	globals::g_rand = globals::g_rand * 0x343fd + 0x269ec3;
	return (int)globals::g_rand >> 0x10 & 0x7fff;
}



float10 __cdecl std::fmod(float10 x,float10 y)
{
	float10 fVar1;
	
	fVar1 = internal::__cintrindisp2(x,y);
	return fVar1;
}



int __cdecl std::vsprintf(char *buffer,char *format,va_list argptr)
{
	int iVar1;
	FILE dummyFile;
	
	dummyFile._base = buffer;
	dummyFile._ptr = buffer;
	dummyFile._flag = 0x42;
	dummyFile._cnt = 0x7fffffff;
	iVar1 = internal::__vfprintf_internal(&dummyFile,format,argptr);
	dummyFile._cnt += -1;
	if (-1 < dummyFile._cnt) {
		*dummyFile._ptr = '\0';
		return iVar1;
	}
	internal::__fafterwrite_00490b60(0,&dummyFile._ptr);
	return iVar1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack

void * std::_alloca4k(uint size)
{
	undefined *puVar1;
	void *unaff_retaddr;
	
	puVar1 = &stack0x00000004;
	if (0xfff < size) {
		do {
			puVar1 = puVar1 + -0x1000;
			size -= 0x1000;
		} while (0xfff < size);
	}
	*(void **)(puVar1 + (-4 - size)) = unaff_retaddr;
	return unaff_retaddr;
}



// This function appears implicitly in a few locations.

float10 __cdecl std::floor(double x)
{
	double dVar1;
	uint new;
	int iVar2;
	float10 fVar3;
	
	new = _control87(null_ARRAY_004b0d20[0],0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		fVar3 = internal::__std_unk_round_internal__00493410(x);
		dVar1 = (double)fVar3;
		if ((dVar1 != x) && ((new & 0x20) == 0)) {
			fVar3 = internal::__fpmath_enum2_FUN_00493480(0x10,_FPMATH_floor,x,dVar1,new);
			return fVar3;
		}
		_control87(new,0xffff);
		return (float10)dVar1;
	}
	iVar2 = internal::__fpmath_FUN_00493d40(x);
	if (0 < iVar2) {
		if (iVar2 < 3) {
			_control87(new,0xffff);
			return (float10)x;
		}
		if (iVar2 == 3) {
			fVar3 = internal::__fpmath_enum1_FUN_00493430(_FPMATH_floor,x,new);
			return fVar3;
		}
	}
	fVar3 = internal::__fpmath_enum2_FUN_00493480(8,_FPMATH_floor,x,x - -1.0,new);
	return fVar3;
}



int __cdecl std::toupper(int c)
{
	int iVar1;
	uint uVar2;
	LPCWSTR pWVar3;
	int iVar4;
	uint local_8 [2];
	
	iVar1 = c;
	if (globs::_crt1.DAT_0054a180 == 0) {
		if ((0x60 < c) && (c < 0x7b)) {
			return c - 0x20;
		}
	}
	else {
		if (c < 0x100) {
						// int std::islower(int c)
			if (globals::_pcharwidth < 2) {
				uVar2 = *(byte *)(globals::_pctype + c) & C1_LOWER;
			}
			else {
				uVar2 = _isctype(c,C1_LOWER);
			}
			if (uVar2 == 0) {
				return iVar1;
			}
		}
		if ((*(byte *)((int)globals::_pctype + (iVar1 >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
			c = c & 0xffff0000U | iVar1 & 0xffU;
			pWVar3 = (LPCWSTR)0x1;
		}
		else {
			c = c & 0xff000000U | (uint)CONCAT11((char)iVar1,(char)((uint)iVar1 >> 8));
			pWVar3 = (LPCWSTR)0x2;
		}
		iVar4 = internal::__uprlwr__00493f60
											(globs::_crt1.DAT_0054a180,0x200,(char *)&c,pWVar3,(LPWSTR)local_8,3,0);
		if (iVar4 == 0) {
			return iVar1;
		}
		if (iVar4 == 1) {
			return local_8[0] & 0xff;
		}
		c = (local_8[0] >> 8 & 0xff) << 8 | local_8[0] & 0xff;
	}
	return c;
}



void __cdecl std::exit(int status)
{
	internal::__std_exit_FUN_0048e7b0(status,0,0);
	return;
}



float10 __cdecl std::sqrt(double x)
{
	uint uVar1;
	undefined4 in_ECX;
	uint extraout_EDX;
	undefined in_ZF;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 fVar2;
	float10 extraout_ST0_01;
	float10 fVar3;
	ushort in_FPUControlWord;
	ushort in_FPUStatusWord;
	uint uVar4;
	
	internal::__fload_withFB(in_ECX,(int)&x);
	uVar4 = extraout_EDX & 0xffff0000 | (uint)in_FPUControlWord;
	fVar2 = extraout_ST0;
	if ((bool)in_ZF) {
		if ((((ulonglong)x & 0xfffff00000000) == 0) && (x._0_4_ == 0)) {
			fVar3 = globs::_ctr3.field_0x203c;
			if (((ulonglong)x & 0x8000000000000000) == 0) goto LAB_0048e8be;
		}
		else {
			internal::__fpmath_FUN_004922cc(x._4_4_);
			fVar3 = extraout_ST0_01;
		}
LAB_0048e91b:
		if (globs::_crt1.DAT_0054a0c8 == 0) {
			fVar2 = internal::__startOneArgErrorHandling("sqrt",_FPMATH_sqrt,uVar4);
			return fVar2;
		}
	}
	else {
		uVar1 = x._4_4_;
		if (in_FPUControlWord != 0x27f) {
			uVar1 = internal::__fpmath_FUN_004922b5(uVar4);
			fVar2 = extraout_ST0_00;
		}
		if ((uVar1 & 0x80000000) == 0) {
			fVar2 = SQRT(fVar2);
		}
		else {
			fVar3 = globs::_ctr3.field_0x203c;
			if ((((uVar1 & 0x7ff00000) != 0) || ((uVar1 & 0xfffff) != 0)) || (x._0_4_ != 0))
			goto LAB_0048e91b;
		}
LAB_0048e8be:
		fVar3 = fVar2;
		if (globs::_crt1.DAT_0054a0c8 == 0) {
			if ((((short)uVar4 != 0x27f) && ((uVar4 & 0x20) != 0)) && ((in_FPUStatusWord & 0x20) != 0)) {
				fVar2 = internal::__startOneArgErrorHandling("sqrt",_FPMATH_sqrt,uVar4);
				return fVar2;
			}
			return fVar2;
		}
	}
	return fVar3;
}



float10 __cdecl std::fabs(double x)
{
	uint new;
	int iVar1;
	float10 fVar2;
	
	new = _control87(0x133f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		_control87(new,0xffff);
		return (float10)(double)((ulonglong)x & 0x7fffffffffffffff);
	}
	iVar1 = internal::__fpmath_FUN_00493d40(x);
	if (iVar1 == 1) {
		_control87(new,0xffff);
		return (float10)x;
	}
	if (iVar1 == 2) {
		_control87(new,0xffff);
		return -(float10)x;
	}
	if (iVar1 != 3) {
		fVar2 = internal::__fpmath_enum2_FUN_00493480(8,_FPMATH_fabs,x,x - -1.0,new);
		return fVar2;
	}
	fVar2 = internal::__fpmath_enum1_FUN_00493430(_FPMATH_fabs,x,new);
	return fVar2;
}



// Library Function - Single Match
// Name: _strncpy
// Library: Visual Studio 1998 Release

char * __cdecl std::strncpy(char *_Dest,char *_Source,size_t _Count)
{
	uint uVar1;
	uint uVar2;
	char cVar3;
	uint uVar4;
	uint *puVar5;
	
	if (_Count == 0) {
		return _Dest;
	}
	puVar5 = (uint *)_Dest;
	if (((uint)_Source & 3) != 0) {
		while( true ) {
			cVar3 = *_Source;
			_Source = (char *)((int)_Source + 1);
			*(char *)puVar5 = cVar3;
			puVar5 = (uint *)((int)puVar5 + 1);
			_Count -= 1;
			if (_Count == 0) {
				return _Dest;
			}
			if (cVar3 == '\0') break;
			if (((uint)_Source & 3) == 0) {
				uVar4 = _Count >> 2;
				goto joined_r0x0048ea6e;
			}
		}
		do {
			if (((uint)puVar5 & 3) == 0) {
				uVar4 = _Count >> 2;
				if (uVar4 == 0) goto LAB_0048eaab;
				goto LAB_0048eb19;
			}
			*(undefined *)puVar5 = 0;
			puVar5 = (uint *)((int)puVar5 + 1);
			_Count -= 1;
		} while (_Count != 0);
		return _Dest;
	}
	uVar4 = _Count >> 2;
	if (uVar4 != 0) {
		do {
			uVar1 = *(uint *)_Source;
			uVar2 = *(uint *)_Source;
			_Source = (char *)((int)_Source + 4);
			if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {
				if ((char)uVar2 == '\0') {
					*puVar5 = 0;
joined_r0x0048eb15:
					while( true ) {
						uVar4 -= 1;
						puVar5 = puVar5 + 1;
						if (uVar4 == 0) break;
LAB_0048eb19:
						*puVar5 = 0;
					}
					cVar3 = '\0';
					_Count &= 3;
					if (_Count != 0) goto LAB_0048eaab;
					return _Dest;
				}
				if ((char)(uVar2 >> 8) == '\0') {
					*puVar5 = uVar2 & 0xff;
					goto joined_r0x0048eb15;
				}
				if ((uVar2 & 0xff0000) == 0) {
					*puVar5 = uVar2 & 0xffff;
					goto joined_r0x0048eb15;
				}
				if ((uVar2 & 0xff000000) == 0) {
					*puVar5 = uVar2;
					goto joined_r0x0048eb15;
				}
			}
			*puVar5 = uVar2;
			puVar5 = puVar5 + 1;
			uVar4 -= 1;
joined_r0x0048ea6e:
		} while (uVar4 != 0);
		_Count &= 3;
		if (_Count == 0) {
			return _Dest;
		}
	}
	do {
		cVar3 = *_Source;
		_Source = (char *)((int)_Source + 1);
		*(char *)puVar5 = cVar3;
		puVar5 = (uint *)((int)puVar5 + 1);
		if (cVar3 == '\0') {
			while (_Count -= 1, _Count != 0) {
LAB_0048eaab:
				*(char *)puVar5 = cVar3;
				puVar5 = (uint *)((int)puVar5 + 1);
			}
			return _Dest;
		}
		_Count -= 1;
	} while (_Count != 0);
	return _Dest;
}



int __cdecl std::_finite(double x)
{
	return (uint)((x._6_2_ & 0x7ff0) != 0x7ff0);
}



void __cdecl std::sscanf(char *buffer,char *format,...)
{
	char cVar1;
	uint uVar2;
	FILE file;
	
	uVar2 = 0xffffffff;
	file._base = buffer;
	file._ptr = buffer;
	do {
		if (uVar2 == 0) break;
		uVar2 -= 1;
		cVar1 = *buffer;
		buffer = buffer + 1;
	} while (cVar1 != '\0');
	file._cnt = ~uVar2 - 1;
	file._flag = 0x49;
	vfscanf(&file,format,&stack0x0000000c);
	return;
}



// (probably)

float10 __cdecl std::ceil(double x)
{
	double dVar1;
	uint new;
	int iVar2;
	float10 fVar3;
	
	new = _control87(null_ARRAY_004b0d38[2],0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		fVar3 = internal::__std_unk_round_internal__00493410(x);
		dVar1 = (double)fVar3;
		if ((dVar1 != x) && ((new & 0x20) == 0)) {
			fVar3 = internal::__fpmath_enum2_FUN_00493480(0x10,_FPMATH_ceil,x,dVar1,new);
			return fVar3;
		}
		_control87(new,0xffff);
		return (float10)dVar1;
	}
	iVar2 = internal::__fpmath_FUN_00493d40(x);
	if (0 < iVar2) {
		if (iVar2 < 3) {
			_control87(new,0xffff);
			return (float10)x;
		}
		if (iVar2 == 3) {
			fVar3 = internal::__fpmath_enum1_FUN_00493430(_FPMATH_ceil,x,new);
			return fVar3;
		}
	}
	fVar3 = internal::__fpmath_enum2_FUN_00493480(8,_FPMATH_ceil,x,x - -1.0,new);
	return fVar3;
}



// Library Function - Single Match
// Name: __alldiv
// Library: Visual Studio

undefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	bool bVar10;
	char cVar11;
	uint uVar9;
	
	cVar11 = (int)param_2 < 0;
	if ((bool)cVar11) {
		bVar10 = param_1 != 0;
		param_1 = -param_1;
		param_2 = -(uint)bVar10 - param_2;
	}
	if ((int)param_4 < 0) {
		cVar11 += '\x01';
		bVar10 = param_3 != 0;
		param_3 = -param_3;
		param_4 = -(uint)bVar10 - param_4;
	}
	uVar3 = param_1;
	uVar5 = param_3;
	uVar6 = param_2;
	uVar9 = param_4;
	if (param_4 == 0) {
		uVar3 = param_2 / param_3;
		iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
								 (ulonglong)param_3);
	}
	else {
		do {
			uVar8 = uVar9 >> 1;
			uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
			uVar7 = uVar6 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
			uVar6 = uVar7;
			uVar9 = uVar8;
		} while (uVar8 != 0);
		uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
		iVar4 = (int)uVar1;
		lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
		uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar5 = uVar3 + iVar4 * param_4;
		if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
			 ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
			iVar4 += -1;
		}
		uVar3 = 0;
	}
	if (cVar11 == '\x01') {
		bVar10 = iVar4 != 0;
		iVar4 = -iVar4;
		uVar3 = -(uint)bVar10 - uVar3;
	}
	return CONCAT44(uVar3,iVar4);
}



void * __cdecl std::operator_new(uint size)
{
	void *pvVar1;
	
	pvVar1 = internal::__malloc_handlermode(size,1);
	return pvVar1;
}



int __cdecl std::fclose(FILE *stream)
{
	int iVar1;
	int iVar2;
	
	iVar2 = -1;
	if ((stream->_flag & 0x40U) != 0) {
		stream->_flag = 0;
		return -1;
	}
	if ((stream->_flag & 0x83U) != 0) {
		iVar2 = internal::fflush(stream);
		internal::__ffree__004950b0(stream);
		iVar1 = internal::__fdclose__00494fd0(stream->_file);
		if (iVar1 < 0) {
			stream->_flag = 0;
			return -1;
		}
		if (stream->_tmpfname != NULL) {
			free(stream->_tmpfname);
			stream->_tmpfname = NULL;
		}
	}
	stream->_flag = 0;
	return iVar2;
}



FILE * __cdecl std::fopen(LPCSTR filename,char *mode)
{
	FILE *pFVar1;
	
	pFVar1 = _fsopen(filename,mode,SH_DENYNO);
	return pFVar1;
}



BOOL __cdecl std::_isctype(int c,uint desc)
{
	int iVar1;
	LCID LVar2;
	uint local_4;
	
	if (c + 1U < 0x101) {
		return globals::_pctype[c] & desc;
	}
	if ((*(byte *)((int)globals::_pctype + (c >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
		c &= 0xffff00ff;
		iVar1 = 1;
	}
	else {
		c = c & 0xff000000U | (uint)CONCAT11((char)c,(char)((uint)c >> 8));
		iVar1 = 2;
	}
	LVar2 = internal::__ctype_internal(1,(LPCSTR)&c,iVar1,(LPWORD)&local_4,0,0);
	if (LVar2 == 0) {
		return 0;
	}
	return local_4 & 0xffff & desc;
}



// Library Function - Single Match
// Name: _strncmp
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::strncmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	size_t sVar4;
	int iVar5;
	uint uVar6;
	char *pcVar7;
	char *pcVar8;
	bool bVar9;
	
	sVar4 = _MaxCount;
	pcVar7 = _Str1;
	if (_MaxCount != 0) {
		do {
			if (sVar4 == 0) break;
			sVar4 -= 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		iVar5 = _MaxCount - sVar4;
		do {
			pcVar7 = _Str2;
			pcVar8 = _Str1;
			if (iVar5 == 0) break;
			iVar5 += -1;
			pcVar8 = _Str1 + 1;
			pcVar7 = _Str2 + 1;
			cVar1 = *_Str2;
			cVar2 = *_Str1;
			_Str2 = pcVar7;
			_Str1 = pcVar8;
		} while (cVar1 == cVar2);
		bVar3 = pcVar7[-1];
		uVar6 = 0;
		bVar9 = bVar3 == pcVar8[-1];
		if (bVar3 < (byte)pcVar8[-1] || bVar9) {
			if (bVar9) {
				return 0;
			}
			uVar6 = 0xfffffffe;
		}
		_MaxCount = ~uVar6;
	}
	return _MaxCount;
}



long __cdecl std::ftell(FILE *stream)
{
	uint uVar1;
	uint uVar2;
	char *pcVar3;
	int iVar4;
	DWORD DVar5;
	char *pcVar6;
	int iVar7;
	char *pcVar8;
	DWORD local_8;
	DWORD local_4;
	
	uVar1 = stream->_file;
	if (stream->_cnt < 0) {
		stream->_cnt = 0;
	}
	local_4 = internal::__fdread__00496ec0(uVar1,0,1);
	if ((int)local_4 < 0) {
		return 0xffffffff;
	}
	uVar2 = stream->_flag;
	if ((uVar2 & 0x108) == 0) {
		return local_4 - stream->_cnt;
	}
	pcVar8 = stream->_ptr;
	pcVar3 = stream->_base;
	local_8 = (int)pcVar8 - (int)pcVar3;
	iVar4 = (int)uVar1 >> 5;
	if ((uVar2 & 3) == 0) {
		if ((uVar2 & 0x80) == 0) {
			globs::_crt1.errno = 0x16;
			return 0xffffffff;
		}
	}
	else {
		pcVar6 = pcVar3;
		if ((*(byte *)((int)globs::_crt2._handlesTable_0076edc0[iVar4] + (uVar1 & 0x1f) * 8 + 4) & 0x80)
				!= 0) {
			for (; pcVar6 < pcVar8; pcVar6 = pcVar6 + 1) {
				if (*pcVar6 == '\n') {
					local_8 += 1;
				}
			}
		}
	}
	if (local_4 == 0) {
		return local_8;
	}
	if ((*(byte *)&stream->_flag & 1) == 0) goto LAB_0048f6e5;
	if (stream->_cnt == 0) {
		return local_4;
	}
	pcVar8 = pcVar8 + (stream->_cnt - (int)pcVar3);
	iVar7 = (uVar1 & 0x1f) * 8;
	if ((*(byte *)(iVar7 + 4 + (int)globs::_crt2._handlesTable_0076edc0[iVar4]) & 0x80) != 0) {
		DVar5 = internal::__fdread__00496ec0(uVar1,0,2);
		if (DVar5 == local_4) {
			pcVar6 = stream->_base;
			pcVar3 = pcVar6 + (int)pcVar8;
			for (; pcVar6 < pcVar3; pcVar6 = pcVar6 + 1) {
				if (*pcVar6 == '\n') {
					pcVar8 = pcVar8 + 1;
				}
			}
			if ((stream->_flag & 0x2000U) != 0) {
LAB_0048f6dc:
				pcVar8 = pcVar8 + 1;
			}
		}
		else {
			internal::__fdread__00496ec0(uVar1,local_4,0);
			if (((pcVar8 < (char *)0x201) && ((stream->_flag & 8U) != 0)) &&
				 ((stream->_flag & 0x400U) == 0)) {
				pcVar8 = (char *)0x200;
			}
			else {
				pcVar8 = (char *)stream->_bufsiz;
			}
			if ((*(byte *)(iVar7 + 4 + (int)globs::_crt2._handlesTable_0076edc0[iVar4]) & 4) != 0)
			goto LAB_0048f6dc;
		}
	}
	local_4 -= (int)pcVar8;
LAB_0048f6e5:
	return local_4 + local_8;
}



int __cdecl std::fseek(FILE *stream,long offset,int origin)
{
	uint uVar1;
	long lVar2;
	DWORD DVar3;
	
	if (((stream->_flag & 0x83U) != 0) && (((origin == 0 || (origin == 1)) || (origin == 2)))) {
		stream->_flag = stream->_flag & 0xffffffef;
		if (origin == 1) {
			lVar2 = ftell(stream);
			offset += lVar2;
			origin = 0;
		}
		internal::fflush(stream);
		uVar1 = stream->_flag;
		if ((uVar1 & 0x80) == 0) {
			if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
				stream->_bufsiz = 0x200;
			}
		}
		else {
			stream->_flag = uVar1 & 0xfffffffc;
		}
		DVar3 = internal::__fdread__00496ec0(stream->_file,offset,origin);
		return (DVar3 != 0xffffffff) - 1;
	}
	globs::_crt1.errno = EINVAL;
	return -1;
}



size_t __cdecl std::fwrite(void *out_buffer,size_t size,size_t count,FILE *stream)
{
	FILE *stream_00;
	FILE *pFVar1;
	int iVar2;
	FILE *pFVar3;
	uint uVar4;
	FILE *pFVar5;
	FILE *pFVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	
	stream_00 = stream;
	pFVar5 = (FILE *)(count * size);
	if (pFVar5 == NULL) {
		return 0;
	}
	pFVar6 = pFVar5;
	if ((stream->_flag & 0x10cU) == 0) {
		stream = (FILE *)0x1000;
	}
	else {
		stream = (FILE *)stream->_bufsiz;
	}
	do {
		uVar4 = stream_00->_flag & 0x108;
		if ((uVar4 == 0) || (pFVar1 = (FILE *)stream_00->_cnt, pFVar1 == NULL)) {
			if (pFVar6 < stream) {
						// WARNING: Load size is inaccurate
				uVar4 = internal::__fafterwrite_00490b60((int)*out_buffer,&stream_00->_ptr);
				if (uVar4 == 0xffffffff) goto LAB_0048f8f4;
				stream = (FILE *)stream_00->_bufsiz;
				out_buffer = (void *)((int)out_buffer + 1);
				pFVar6 = (FILE *)((int)&pFVar6[-1]._tmpfname + 3);
				if ((int)stream < 1) {
					stream = (FILE *)0x1;
				}
			}
			else {
				if ((uVar4 != 0) && (iVar2 = internal::fflush(stream_00), iVar2 != 0)) {
LAB_0048f8f4:
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				pFVar1 = pFVar6;
				if (stream != NULL) {
					pFVar1 = (FILE *)((int)pFVar6 - (uint)pFVar6 % (uint)stream);
				}
				pFVar3 = (FILE *)internal::__fdwrite__00496f80
																	 (stream_00->_file,(char *)out_buffer,(char *)pFVar1);
				if (pFVar3 == (FILE *)0xffffffff) {
LAB_0048f8d9:
					stream_00->_flag = stream_00->_flag | 0x20;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				pFVar6 = (FILE *)((int)pFVar6 - (int)pFVar3);
				out_buffer = (void *)((int)out_buffer + (int)pFVar3);
				if (pFVar3 < pFVar1) goto LAB_0048f8d9;
			}
		}
		else {
			if (pFVar6 < pFVar1) {
				pFVar1 = pFVar6;
			}
			pFVar6 = (FILE *)((int)pFVar6 - (int)pFVar1);
			puVar7 = (undefined4 *)out_buffer;
			puVar8 = (undefined4 *)stream_00->_ptr;
			for (uVar4 = (uint)pFVar1 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar8 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar8 = puVar8 + 1;
			}
			for (uVar4 = (uint)pFVar1 & 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar8 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			out_buffer = (void *)((int)out_buffer + (int)pFVar1);
			stream_00->_cnt = stream_00->_cnt - (int)pFVar1;
			stream_00->_ptr = (char *)((int)&pFVar1->_ptr + (int)stream_00->_ptr);
		}
		if (pFVar6 == NULL) {
			return count;
		}
	} while( true );
}



int __cdecl std::remove(LPCSTR filename)
{
	BOOL BVar1;
	uint error_value;
	
	BVar1 = DeleteFileA(filename);
	if (BVar1 == 0) {
		error_value = GetLastError();
	}
	else {
		error_value = 0;
	}
	if (error_value != 0) {
		internal::__set_doserrno(error_value);
		return -1;
	}
	return 0;
}



int __cdecl std::_chmod(LPCSTR filename,int pmode)
{
	DWORD DVar1;
	BOOL BVar2;
	
	DVar1 = GetFileAttributesA(filename);
	if (DVar1 != INVALID_FILE_ATTRIBUTES) {
		if ((pmode & FILE_ATTRIBUTE_NORMAL) == 0) {
			DVar1 |= 1;
		}
		else {
			DVar1 &= 0xfffffffe;
		}
		BVar2 = SetFileAttributesA(filename,DVar1);
		if (BVar2 != 0) {
			return 0;
		}
	}
	DVar1 = GetLastError();
	internal::__set_doserrno(DVar1);
	return -1;
}



int __cdecl std::_mkdir(LPCSTR dirname)
{
	BOOL BVar1;
	uint error_value;
	
	BVar1 = CreateDirectoryA(dirname,NULL);
	if (BVar1 == 0) {
		error_value = GetLastError();
	}
	else {
		error_value = 0;
	}
	if (error_value != 0) {
		internal::__set_doserrno(error_value);
		return -1;
	}
	return 0;
}



HANDLE __cdecl std::_findfirst32(LPCSTR filename,_finddata32_t *fileinfo)
{
	char cVar1;
	HANDLE pvVar2;
	DWORD DVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	_WIN32_FIND_DATAA local_140;
	
	pvVar2 = FindFirstFileA(filename,(LPWIN32_FIND_DATAA)&local_140);
	if (pvVar2 == (HANDLE)0xffffffff) {
		DVar3 = GetLastError();
		if (true) {
			switch(DVar3) {
			case 2:
			case 3:
			case 0x12:
				globs::_crt1.errno = 2;
				return (HANDLE)0xffffffff;
			case 8:
				globs::_crt1.errno = 0xc;
				return (HANDLE)0xffffffff;
			}
		}
		globs::_crt1.errno = 0x16;
		return (HANDLE)0xffffffff;
	}
	fileinfo->attrib = -(uint)(local_140.dwFileAttributes != 0x80) & local_140.dwFileAttributes;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftCreationTime);
	fileinfo->time_create = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastAccessTime);
	fileinfo->time_access = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastWriteTime);
	fileinfo->time_write = iVar4;
	uVar5 = 0xffffffff;
	pcVar8 = local_140.cFileName;
	do {
		pcVar9 = pcVar8;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar9 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar9;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	fileinfo->size = local_140.nFileSizeLow;
	puVar7 = (undefined4 *)(pcVar9 + -uVar5);
	puVar10 = (undefined4 *)fileinfo->name;
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
		*puVar10 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return pvVar2;
}



int __cdecl std::_findnext32(HANDLE handle,_finddata32_t *fileinfo)
{
	char cVar1;
	BOOL BVar2;
	DWORD DVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	_WIN32_FIND_DATAA local_140;
	
	BVar2 = FindNextFileA(handle,(LPWIN32_FIND_DATAA)&local_140);
	if (BVar2 == 0) {
		DVar3 = GetLastError();
		if (true) {
			switch(DVar3) {
			case 2:
			case 3:
			case 0x12:
				globs::_crt1.errno = ENOENT;
				return -1;
			case 8:
				globs::_crt1.errno = ENOMEM;
				return -1;
			}
		}
		globs::_crt1.errno = EINVAL;
		return -1;
	}
	fileinfo->attrib = -(uint)(local_140.dwFileAttributes != 0x80) & local_140.dwFileAttributes;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftCreationTime);
	fileinfo->time_create = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastAccessTime);
	fileinfo->time_access = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastWriteTime);
	fileinfo->time_write = iVar4;
	uVar5 = 0xffffffff;
	pcVar8 = local_140.cFileName;
	do {
		pcVar9 = pcVar8;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar9 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar9;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	fileinfo->size = local_140.nFileSizeLow;
	puVar7 = (undefined4 *)(pcVar9 + -uVar5);
	puVar10 = (undefined4 *)fileinfo->name;
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
		*puVar10 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return 0;
}



int __cdecl std::_findclose(HANDLE handle)
{
	BOOL BVar1;
	
	BVar1 = FindClose(handle);
	if (BVar1 == 0) {
		globs::_crt1.errno = 0x16;
		return -1;
	}
	return 0;
}



char * __cdecl std::_getcwd(char *out_buffer,int maxlen)
{
	char *pcVar1;
	
	pcVar1 = _getdcwd(0,out_buffer,maxlen);
	return pcVar1;
}



size_t __cdecl std::fread(void *out_buffer,size_t size,size_t count,FILE *stream)
{
	FILE *file;
	FILE *pFVar1;
	char *pcVar2;
	int iVar3;
	uint uVar4;
	FILE *pFVar5;
	FILE *pFVar6;
	undefined4 *puVar7;
	FILE *pFVar8;
	undefined4 *puVar9;
	
	file = stream;
	pFVar5 = (FILE *)(count * size);
	if (pFVar5 == NULL) {
		return 0;
	}
	pFVar6 = pFVar5;
	if ((stream->_flag & 0x10cU) == 0) {
		stream = (FILE *)0x1000;
		pFVar8 = (FILE *)0x1000;
	}
	else {
		pFVar8 = (FILE *)stream->_bufsiz;
		stream = pFVar8;
	}
	do {
		if (((file->_flag & 0x10cU) == 0) || (pFVar1 = (FILE *)file->_cnt, pFVar1 == NULL)) {
			if (pFVar6 < pFVar8) {
				iVar3 = internal::__fpeekc(file);
				if (iVar3 == -1) {
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				*(char *)out_buffer = (char)iVar3;
				pFVar8 = (FILE *)file->_bufsiz;
				out_buffer = (void *)((int)out_buffer + 1);
				iVar3 = -1;
				stream = pFVar8;
			}
			else {
				pFVar1 = pFVar6;
				if (pFVar8 != NULL) {
					pFVar1 = (FILE *)((int)pFVar6 - (uint)pFVar6 % (uint)pFVar8);
				}
				pcVar2 = internal::__fdread(file->_file,(char *)out_buffer,(DWORD)pFVar1);
				if (pcVar2 == NULL) {
					file->_flag = file->_flag | 0x10;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				if (pcVar2 == (char *)0xffffffff) {
					file->_flag = file->_flag | 0x20;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				iVar3 = -(int)pcVar2;
				out_buffer = (void *)((int)out_buffer + (int)pcVar2);
			}
		}
		else {
			if (pFVar6 < pFVar1) {
				pFVar1 = pFVar6;
			}
			iVar3 = -(int)pFVar1;
			puVar7 = (undefined4 *)file->_ptr;
			puVar9 = (undefined4 *)out_buffer;
			for (uVar4 = (uint)pFVar1 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar4 = (uint)pFVar1 & 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			out_buffer = (void *)((int)out_buffer + (int)pFVar1);
			file->_cnt = file->_cnt - (int)pFVar1;
			file->_ptr = (char *)((int)&pFVar1->_ptr + (int)file->_ptr);
			pFVar8 = stream;
		}
		pFVar6 = (FILE *)((int)&pFVar6->_ptr + iVar3);
		if (pFVar6 == NULL) {
			return count;
		}
	} while( true );
}



int __cdecl std::fgetc(FILE *stream)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	
	iVar2 = stream->_cnt + -1;
	stream->_cnt = iVar2;
	if (-1 < iVar2) {
		bVar1 = *stream->_ptr;
		stream->_ptr = stream->_ptr + 1;
		return (uint)bVar1;
	}
	uVar3 = internal::__fpeekc(stream);
	return uVar3;
}



char * __cdecl std::fgets(char *str,int numChars,FILE *stream)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	
	if (numChars < 1) {
		return NULL;
	}
	iVar3 = numChars + -1;
	pcVar4 = str;
	if (iVar3 != 0) {
		while( true ) {
			iVar1 = stream->_cnt + -1;
			stream->_cnt = iVar1;
			if (iVar1 < 0) {
				uVar2 = internal::__fpeekc(stream);
			}
			else {
				uVar2 = (uint)(byte)*stream->_ptr;
				stream->_ptr = stream->_ptr + 1;
			}
			if (uVar2 == 0xffffffff) break;
			*pcVar4 = (char)uVar2;
			pcVar4 = pcVar4 + 1;
			if ((char)uVar2 == '\n') goto LAB_00490176;
			iVar3 += -1;
			if (iVar3 == 0) {
				*pcVar4 = '\0';
				return str;
			}
		}
		if (pcVar4 == str) {
			return NULL;
		}
	}
LAB_00490176:
	*pcVar4 = '\0';
	return str;
}



int __cdecl std::vfprintf(FILE *stream,char *format,va_list argptr)
{
	BOOL BVar1;
	int iVar2;
	
	BVar1 = internal::__vfprintf__00497790(stream);
	iVar2 = internal::__vfprintf_internal(stream,format,argptr);
	internal::__vfprintf__00497830(BVar1,stream);
	return iVar2;
}



// Library Function - Single Match
// Name: __strcmpi
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::_stricmp(char *_Str1,char *_Str2)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	byte bVar5;
	uint uVar4;
	uint c;
	
	if (globs::_crt1.DAT_0054a180 == 0) {
		uVar4 = 0xff;
		do {
			do {
				cVar2 = (char)uVar4;
				if (cVar2 == '\0') goto LAB_0049021e;
				cVar2 = *_Str2;
				_Str2 = _Str2 + 1;
				cVar1 = *_Str1;
				uVar4 = (uint)CONCAT11(cVar1,cVar2);
				_Str1 = _Str1 + 1;
			} while ((char)(uVar4 >> 8) == cVar2);
			bVar3 = cVar1 + 0xbf;
			bVar3 = bVar3 + (-(bVar3 < 0x1a) & 0x20U) + 0x41;
			uVar4 = (uint)CONCAT11(cVar2 + 0xbfU + (-((byte)(cVar2 + 0xbfU) < 0x1a) & 0x20U) + 'A',bVar3);
			bVar5 = (byte)(uVar4 >> 8);
		} while (bVar3 == bVar5);
		cVar2 = (bVar3 < bVar5) * -2 + '\x01';
LAB_0049021e:
		uVar4 = SEXT14(cVar2);
	}
	else {
		c = 0;
		uVar4 = 0xff;
		do {
			do {
				if ((char)uVar4 == '\0') {
					return uVar4;
				}
				bVar3 = *_Str2;
				uVar4 = uVar4 & 0xffffff00 | (uint)bVar3;
				_Str2 = (char *)((byte *)_Str2 + 1);
				bVar5 = *_Str1;
				c = c & 0xffffff00 | (uint)bVar5;
				_Str1 = (char *)((byte *)_Str1 + 1);
			} while (bVar3 == bVar5);
			c = tolower(c);
			uVar4 = tolower(uVar4);
		} while ((byte)c == (byte)uVar4);
		uVar4 = (uint)((byte)c < (byte)uVar4);
		uVar4 = (1 - uVar4) - (uint)(uVar4 != 0);
	}
	return uVar4;
}



char * __cdecl std::_fullpath(char *out_absPath,LPCSTR relPath,uint maxLength)
{
	LPSTR lpBuffer;
	LPSTR pCVar1;
	DWORD error_value;
	char *pcVar2;
	LPSTR nBufferLength;
	
	if ((relPath == NULL) || (*relPath == '\0')) {
		pcVar2 = _getcwd(out_absPath,maxLength);
		return pcVar2;
	}
	lpBuffer = out_absPath;
	nBufferLength = (LPSTR)maxLength;
	if (out_absPath == NULL) {
		lpBuffer = (LPSTR)malloc(MAX_PATH);
		if (lpBuffer == NULL) {
			globs::_crt1.errno = ENOMEM;
			return NULL;
		}
		nBufferLength = (LPSTR)MAX_PATH;
	}
	pCVar1 = (LPSTR)GetFullPathNameA(relPath,(DWORD)nBufferLength,lpBuffer,(LPSTR *)&maxLength);
	if (pCVar1 < nBufferLength) {
		if (pCVar1 != NULL) {
			return lpBuffer;
		}
		if (out_absPath == NULL) {
			free(lpBuffer);
		}
		error_value = GetLastError();
		internal::__set_doserrno(error_value);
		return NULL;
	}
	if (out_absPath == NULL) {
		free(lpBuffer);
	}
	globs::_crt1.errno = ERANGE;
	return NULL;
}



int __cdecl std::fscanf(FILE *stream,char *format,...)
{
	int iVar1;
	
	iVar1 = vfscanf(stream,format,&stack0x0000000c);
	return iVar1;
}



void __cdecl std::_splitpath(char *path,char *drive,char *dir,char *fname,char *ext)
{
	byte *pbVar1;
	char cVar2;
	byte bVar3;
	uint uVar4;
	int iVar5;
	byte *pbVar6;
	size_t sVar7;
	char *pcVar8;
	byte *local_4;
	
	iVar5 = -1;
	pcVar8 = path;
	do {
		if (iVar5 == 0) break;
		iVar5 += -1;
		cVar2 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar2 != '\0');
	local_4 = NULL;
	if ((iVar5 == -2) || (path[1] != ':')) {
		if (drive != NULL) {
			*drive = '\0';
		}
	}
	else {
		if (drive != NULL) {
			internal::__strncpy(drive,path,2);
			drive[2] = '\0';
		}
		path = path + 2;
	}
	bVar3 = *path;
	drive = NULL;
	pbVar6 = (byte *)path;
	while (bVar3 != 0) {
		bVar3 = *pbVar6;
		if ((globs::_crt1.CHAR_ARRAY_0054a2b8[bVar3 + 1] & 4U) == 0) {
			if ((bVar3 == '/') || (bVar3 == '\\')) {
				drive = (char *)(pbVar6 + 1);
			}
			else {
				if (bVar3 == '.') {
					local_4 = pbVar6;
				}
			}
		}
		else {
			pbVar6 = pbVar6 + 1;
		}
		pbVar1 = pbVar6 + 1;
		pbVar6 = pbVar6 + 1;
		bVar3 = *pbVar1;
	}
	if ((byte *)drive == NULL) {
		drive = path;
		if (dir != NULL) {
			*dir = '\0';
		}
	}
	else {
		if (dir != NULL) {
			uVar4 = (int)drive - (int)path;
			if (0xfe < uVar4) {
				uVar4 = 0xff;
			}
			internal::__strncpy(dir,path,uVar4);
			dir[uVar4] = '\0';
		}
	}
	if ((local_4 == NULL) || (local_4 < drive)) {
		if (fname != NULL) {
			sVar7 = (int)pbVar6 - (int)drive;
			if (0xfe < sVar7) {
				sVar7 = 0xff;
			}
			internal::__strncpy(fname,drive,sVar7);
			fname[sVar7] = '\0';
		}
		if (ext != NULL) {
			*ext = '\0';
		}
	}
	else {
		if (fname != NULL) {
			uVar4 = (int)local_4 - (int)drive;
			if (0xfe < uVar4) {
				uVar4 = 0xff;
			}
			internal::__strncpy(fname,drive,uVar4);
			fname[uVar4] = '\0';
		}
		if (ext != NULL) {
			sVar7 = (int)pbVar6 - (int)local_4;
			if (0xfe < sVar7) {
				sVar7 = 0xff;
			}
			internal::__strncpy(ext,(char *)local_4,sVar7);
			ext[sVar7] = '\0';
			return;
		}
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl std::vfscanf(FILE *stream,char *format,va_list argptr)
{
	byte bVar1;
	int **ppiVar2;
	va_list *ppcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	int **c;
	uint uVar7;
	byte bVar8;
	byte *pbVar9;
	byte *pbVar10;
	va_list *ppcVar11;
	char *pcVar12;
	char *pcVar13;
	int iVar14;
	undefined4 *puVar15;
	va_list *ppcVar16;
	va_list pcVar17;
	bool bVar18;
	ulonglong uVar19;
	FILE *file;
	char local_1cd;
	va_list local_1cc;
	char local_1c7;
	char local_1c6;
	char local_1c5;
	int local_1c4;
	char local_1c0;
	char local_1bf;
	char local_1be;
	byte local_1bd;
	uint local_1bc;
	va_list *local_1b8;
	undefined4 local_1b4;
	int local_1b0;
	int local_1ac;
	int local_1a8;
	va_list local_1a4;
	byte local_19e;
	undefined local_19d;
	undefined8 local_19c;
	uint local_194;
	ushort local_18e;
	int **local_18c;
	int local_188;
	uint local_184;
	undefined4 local_180 [2];
	undefined local_175;
	char local_160;
	char local_15f [351];
	
	local_1bf = '\0';
	local_1cc = NULL;
	local_1ac = 0;
	bVar1 = *format;
	c = local_18c;
	do {
		if (bVar1 == 0) {
LAB_00494e06:
			if ((c == (int **)0xffffffff) && ((local_1ac == 0 && (local_1bf == '\0')))) {
				local_1ac = -1;
			}
			return local_1ac;
		}
		iVar14 = 0;
		if (globals::_pcharwidth < 2) {
			uVar4 = *(byte *)(globals::_pctype + bVar1) & 8;
		}
		else {
			uVar4 = _isctype((uint)bVar1,8);
		}
		if (uVar4 != 0) {
			local_1cc = local_1cc + -1;
			file = stream;
			iVar5 = internal::__vfscanf__fgetc_skipws((int *)&local_1cc,stream);
			internal::__vfscanf__00494f60(iVar5,file);
			format = format + 1;
			iVar5 = isspace((uint)(byte)*format);
			while (iVar5 != 0) {
				format = (char *)((byte *)format + 1);
				iVar5 = isspace((uint)(byte)*format);
			}
		}
		if (*format != '%') {
			local_1cc = local_1cc + 1;
			c = (int **)internal::__vfscanf__fgetc(stream);
			if ((int **)(uint)(byte)*format != c) goto LAB_00494ded;
			pbVar9 = (byte *)(format + 1);
			if ((*(byte *)((int)globals::_pctype + ((uint)c & 0xff) * 2 + 1) & 0x80) != 0) {
				local_1cc = local_1cc + 1;
				uVar4 = internal::__vfscanf__fgetc(stream);
				if ((byte)format[1] != uVar4) {
					local_1cc = local_1cc + -1;
					internal::__vfscanf__00494f60(uVar4,stream);
					goto LAB_00494ded;
				}
				local_1cc = local_1cc + -1;
				pbVar9 = (byte *)(format + 2);
			}
			goto LAB_00494db3;
		}
		local_1a4 = NULL;
		local_1b4 &= 0xffffff00;
		local_1a8 = 0;
		local_1b0 = 0;
		local_1c4 = 0;
		local_1bd = 0;
		local_1be = '\0';
		local_1c5 = '\0';
		local_1cd = '\0';
		local_1c0 = '\0';
		local_1c7 = '\0';
		local_1c6 = '\x01';
		local_188 = 0;
		do {
			pbVar9 = (byte *)(format + 1);
			uVar4 = (uint)*pbVar9;
			if (globals::_pcharwidth < 2) {
				uVar6 = *(byte *)(globals::_pctype + uVar4) & 4;
			}
			else {
				uVar6 = _isctype(uVar4,4);
			}
			if (uVar6 != 0) {
				local_1b0 += 1;
				local_1c4 = (uVar4 - 0x30) + local_1c4 * 10;
				goto switchD_00494330_caseD_46;
			}
			if (false) {
switchD_00494330_caseD_2b:
				local_1cd += '\x01';
			}
			else {
				switch(uVar4) {
				case 0x2a:
					local_1c5 += '\x01';
					break;
				default:
					goto switchD_00494330_caseD_2b;
				case 0x46:
				case 0x4e:
					break;
				case 0x49:
					if ((format[2] != '6') || (format[3] != '4')) goto switchD_00494330_caseD_2b;
					iVar14 += 1;
					local_19c = 0;
					pbVar9 = (byte *)(format + 3);
					break;
				case 0x4c:
					local_1c6 += '\x01';
					break;
				case 0x68:
					local_1c6 += -1;
					local_1c7 += -1;
					break;
				case 0x6c:
					local_1c6 += '\x01';
				case 0x77:
					local_1c7 += '\x01';
				}
			}
switchD_00494330_caseD_46:
			format = (char *)pbVar9;
		} while (local_1cd == '\0');
		ppiVar2 = (int **)argptr;
		if (local_1c5 == '\0') {
			local_1b8 = *(va_list **)argptr;
			ppiVar2 = (int **)((int)argptr + 4);
			local_18c = (int **)argptr;
		}
		argptr = (va_list)ppiVar2;
		bVar18 = false;
		if ((local_1c7 == '\0') && ((*format == 'S' || (local_1c7 = -1, *format == 'C')))) {
			local_1c7 = '\x01';
		}
		local_1bc = (byte)*format | 0x20;
		local_188 = iVar14;
		uVar19 = local_19c;
		if (local_1bc != 0x6e) {
			if ((local_1bc == 99) || (local_1bc == 0x7b)) {
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				uVar19 = local_19c;
			}
			else {
				c = (int **)internal::__vfscanf__fgetc_skipws((int *)&local_1cc,stream);
				uVar19 = local_19c;
			}
		}
		ppcVar11 = local_1b8;
		uVar4 = local_1bc;
		local_19c = uVar19;
		if ((local_1b0 != 0) && (local_1c4 == 0)) {
LAB_00494ded:
			local_1cc = local_1cc + -1;
			internal::__vfscanf__00494f60((int)c,stream);
			goto LAB_00494e06;
		}
		if (false) {
switchD_00494448_caseD_68:
			if ((int **)(uint)(byte)*format != c) goto LAB_00494ded;
			local_1bf += -1;
			if (local_1c5 == '\0') {
				argptr = (va_list)local_18c;
			}
			goto LAB_00494d38;
		}
		switch(local_1bc) {
		case 99:
			if (local_1b0 == 0) {
				local_1b0 = 1;
				local_1c4 += 1;
			}
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pbVar9 = (byte *)globs::_crt4.field_0x3c;
			break;
		case 100:
		case 0x6f:
		case 0x75:
			goto switchD_00494448_caseD_64;
		case 0x65:
		case 0x66:
		case 0x67:
			pcVar12 = &local_160;
			if (c == (int **)0x2d) {
				local_160 = '-';
				pcVar12 = local_15f;
LAB_00494af3:
				local_1c4 += -1;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				uVar19 = local_19c;
			}
			else {
				if (c == (int **)0x2b) goto LAB_00494af3;
			}
			iVar14 = local_1a8;
			if ((local_1b0 == 0) || (0x15d < local_1c4)) {
				local_1c4 = 0x15d;
			}
			while( true ) {
				if (globals::_pcharwidth < 2) {
					uVar4 = *(byte *)(globals::_pctype + (int)c) & 4;
				}
				else {
					local_19c = uVar19;
					uVar4 = _isctype((int)c,4);
					uVar19 = local_19c;
				}
				local_19c = uVar19;
				if ((uVar4 == 0) ||
					 (iVar5 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar5, bVar18)) break;
				*pcVar12 = (char)c;
				pcVar12 = pcVar12 + 1;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				iVar14 = iVar14 + 1;
				uVar19 = local_19c;
			}
			if ((CHAR___004b0f78 == (char)c) &&
				 (iVar5 = local_1c4 + -1, bVar18 = local_1c4 != 0, local_1c4 = iVar5, bVar18)) {
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				*pcVar12 = CHAR___004b0f78;
				while( true ) {
					pcVar12 = pcVar12 + 1;
					if (globals::_pcharwidth < 2) {
						uVar4 = *(byte *)(globals::_pctype + (int)c) & 4;
						uVar19 = local_19c;
					}
					else {
						uVar4 = _isctype((int)c,4);
						uVar19 = local_19c;
					}
					if ((uVar4 == 0) ||
						 (iVar5 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar5, bVar18)) break;
					*pcVar12 = (char)c;
					iVar14 += 1;
					local_1cc = local_1cc + 1;
					local_19c = uVar19;
					c = (int **)internal::__vfscanf__fgetc(stream);
				}
			}
			pcVar13 = pcVar12;
			if ((iVar14 != 0) &&
				 (((c == (int **)0x65 || (c == (int **)0x45)) &&
					(iVar5 = local_1c4 + -1, bVar18 = local_1c4 != 0, local_1c4 = iVar5, bVar18)))) {
				*pcVar12 = 'e';
				pcVar13 = pcVar12 + 1;
				local_1cc = local_1cc + 1;
				local_19c = uVar19;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if (c == (int **)0x2d) {
					*pcVar13 = '-';
					pcVar13 = pcVar12 + 2;
LAB_00494c4e:
					iVar5 = local_1c4 + -1;
					uVar19 = local_19c;
					if (local_1c4 != 0) goto LAB_00494c63;
				}
				else {
					if (c == (int **)0x2b) goto LAB_00494c4e;
				}
				while( true ) {
					if (globals::_pcharwidth < 2) {
						uVar4 = *(byte *)(globals::_pctype + (int)c) & 4;
						uVar19 = local_19c;
					}
					else {
						uVar4 = _isctype((int)c,4);
						uVar19 = local_19c;
					}
					if ((uVar4 == 0) ||
						 (iVar5 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar5, bVar18)) break;
					iVar14 += 1;
					*pcVar13 = (char)c;
					pcVar13 = pcVar13 + 1;
LAB_00494c63:
					local_1c4 = iVar5;
					local_1cc = local_1cc + 1;
					local_19c = uVar19;
					c = (int **)internal::__vfscanf__fgetc(stream);
				}
			}
			local_1cc = local_1cc + -1;
			local_19c = uVar19;
			internal::__vfscanf__00494f60((int)c,stream);
			if (iVar14 != 0) {
				uVar19 = local_19c;
				if (local_1c5 == '\0') {
					local_1ac += 1;
					*pcVar13 = '\0';
					(*(code *)PTR___std_FUN_004b0f88)(local_1c6 + -1,local_1b8,&local_160);
					uVar19 = local_19c;
				}
				goto LAB_00494d38;
			}
			goto LAB_00494e06;
		default:
			goto switchD_00494448_caseD_68;
		case 0x69:
			local_1bc = 100;
		case 0x78:
			uVar4 = local_1bc;
			if (c == (int **)0x2d) {
				local_1be = '\x01';
LAB_00494702:
				local_1c4 += -1;
				if ((local_1c4 == 0) && (local_1b0 != 0)) {
					bVar18 = true;
				}
				else {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar19 = local_19c;
				}
			}
			else {
				if (c == (int **)0x2b) goto LAB_00494702;
			}
			if (c == (int **)0x30) {
				local_1cc = local_1cc + 1;
				local_19c = uVar19;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if (((char)c == 'x') || ((char)c == 'X')) {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar4 = 0x78;
					local_1bc = 0x78;
					uVar19 = local_19c;
				}
				else {
					local_1a8 = 1;
					if (uVar4 == 0x78) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
						c = (int **)0x30;
						uVar19 = local_19c;
					}
					else {
						uVar4 = 0x6f;
						local_1bc = 0x6f;
						uVar19 = local_19c;
					}
				}
			}
			goto LAB_004947e4;
		case 0x6e:
			pcVar17 = local_1cc;
			if (local_1c5 != '\0') goto LAB_00494d38;
			goto LAB_00494aa5;
		case 0x70:
			local_1c6 = '\x01';
switchD_00494448_caseD_64:
			if (c == (int **)0x2d) {
				local_1be = '\x01';
LAB_004947ba:
				local_1c4 += -1;
				if ((local_1c4 == 0) && (local_1b0 != 0)) {
					bVar18 = true;
				}
				else {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar19 = local_19c;
				}
			}
			else {
				if (c == (int **)0x2b) goto LAB_004947ba;
			}
LAB_004947e4:
			pcVar17 = local_1a4;
			local_19c = uVar19;
			if (iVar14 == 0) {
				while (!bVar18) {
					local_19c = uVar19;
					if ((uVar4 == 0x78) || (uVar4 == 0x70)) {
						if (globals::_pcharwidth < 2) {
						// C1_XDIGIT (0x80)
							uVar6 = *(byte *)(globals::_pctype + (int)c) & C1_XDIGIT;
						}
						else {
						// C1_XDIGIT (0x80)
							uVar6 = _isctype((int)c,C1_XDIGIT);
							uVar19 = local_19c;
						}
						if (uVar6 != 0) {
							pcVar17 = (va_list)((int)pcVar17 << 4);
							local_19c = uVar19;
							c = (int **)internal::__hexdigit_subtractalpha((int)c);
							goto LAB_004949da;
						}
LAB_004949d6:
						bVar18 = true;
						local_19c = uVar19;
					}
					else {
						if (globals::_pcharwidth < 2) {
							uVar6 = *(byte *)(globals::_pctype + (int)c) & 4;
						}
						else {
							uVar6 = _isctype((int)c,4);
							uVar19 = local_19c;
						}
						if (uVar6 == 0) goto LAB_004949d6;
						local_19c = uVar19;
						if (uVar4 == 0x6f) {
							if (0x37 < (int)c) goto LAB_004949d6;
							pcVar17 = (va_list)((int)pcVar17 << 3);
						}
						else {
							pcVar17 = (va_list)((int)pcVar17 * 10);
						}
					}
LAB_004949da:
					if (bVar18) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
						uVar19 = local_19c;
					}
					else {
						local_1a8 += 1;
						pcVar17 = pcVar17 + -0x30 + (int)c;
						if ((local_1b0 == 0) || (local_1c4 += -1, local_1c4 != 0)) {
							local_1cc = local_1cc + 1;
							c = (int **)internal::__vfscanf__fgetc(stream);
							uVar19 = local_19c;
						}
						else {
							bVar18 = true;
							uVar19 = local_19c;
						}
					}
				}
				local_1a4 = pcVar17;
				if (local_1be != '\0') {
					local_1a4 = (va_list)-(int)pcVar17;
				}
			}
			else {
				while( true ) {
					uVar4 = (uint)uVar19;
					uVar6 = (uint)(uVar19 >> 0x20);
					if (bVar18) break;
					if (local_1bc == 0x78) {
						if (globals::_pcharwidth < 2) {
							uVar4 = *(byte *)(globals::_pctype + (int)c) & 0x80;
						}
						else {
							uVar4 = _isctype((int)c,0x80);
						}
						if (uVar4 != 0) {
							uVar19 = internal::__allshl();
							c = (int **)internal::__hexdigit_subtractalpha((int)c);
							goto LAB_004948b1;
						}
LAB_004948ad:
						bVar18 = true;
					}
					else {
						if (globals::_pcharwidth < 2) {
							uVar7 = *(byte *)(globals::_pctype + (int)c) & 4;
						}
						else {
							uVar7 = _isctype((int)c,4);
						}
						if (uVar7 == 0) goto LAB_004948ad;
						if (local_1bc == 0x6f) {
							if (0x37 < (int)c) goto LAB_004948ad;
							uVar19 = internal::__allshl();
						}
						else {
							uVar19 = __allmul(uVar4,uVar6,10,0);
						}
					}
LAB_004948b1:
					if (bVar18) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
					}
					else {
						ppiVar2 = c + -0xc;
						local_1a8 += 1;
						if ((local_1b0 == 0) || (local_1c4 += -1, local_1c4 != 0)) {
							local_1cc = local_1cc + 1;
							c = (int **)internal::__vfscanf__fgetc(stream);
							uVar19 = uVar19 + (longlong)(int)ppiVar2;
						}
						else {
							bVar18 = true;
							uVar19 = uVar19 + (longlong)(int)ppiVar2;
						}
					}
				}
				if (local_1be != '\0') {
					uVar19 = CONCAT44(-(uVar6 + (uVar4 != 0)),-uVar4);
				}
			}
			iVar14 = local_1a8;
			if (local_1bc == 0x46) {
				iVar14 = 0;
			}
			if (iVar14 != 0) {
				if (local_1c5 == '\0') {
					local_1ac += 1;
					pcVar17 = local_1a4;
					iVar14 = local_188;
LAB_00494aa5:
					local_19c._4_4_ = (va_list)(uVar19 >> 0x20);
					local_19c._0_4_ = (va_list)uVar19;
					if (iVar14 == 0) {
						if (local_1c6 == '\0') {
							*(short *)local_1b8 = (short)pcVar17;
						}
						else {
							*local_1b8 = pcVar17;
						}
					}
					else {
						*local_1b8 = (va_list)local_19c;
						local_1b8[1] = local_19c._4_4_;
					}
				}
				goto LAB_00494d38;
			}
			goto LAB_00494e06;
		case 0x73:
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pbVar9 = (byte *)globs::_crt4.field_0x34;
			break;
		case 0x7b:
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pbVar10 = (byte *)(format + 1);
			pbVar9 = pbVar10;
			if (*pbVar10 == 0x5e) {
				pbVar9 = (byte *)(format + 2);
				format = (char *)pbVar10;
				break;
			}
			goto LAB_004944b3;
		}
		local_1bd = 0xff;
		pbVar10 = (byte *)format;
LAB_004944b3:
		format = (char *)pbVar10;
		puVar15 = local_180;
		for (iVar14 = 8; iVar14 != 0; iVar14 += -1) {
			*puVar15 = 0;
			puVar15 = puVar15 + 1;
		}
		if ((local_1bc == 0x7b) && (*pbVar9 == 0x5d)) {
			local_1b4 = CONCAT31(local_1b4._1_3_,0x5d);
			pbVar9 = pbVar9 + 1;
			local_175 = 0x20;
		}
		bVar1 = *pbVar9;
		while (bVar1 != 0x5d) {
			pbVar10 = pbVar9 + 1;
			local_184 = local_184 & 0xffffff00 | (uint)bVar1;
			if (((bVar1 == 0x2d) && ((byte)local_1b4 != 0)) && (bVar8 = *pbVar10, bVar8 != 0x5d)) {
				pbVar10 = pbVar9 + 2;
				if ((byte)local_1b4 < bVar8) {
					local_194 = local_194 & 0xffffff00 | (uint)bVar8;
					bVar8 = (byte)local_1b4;
				}
				else {
					local_194 = local_194 & 0xffffff00 | local_1b4 & 0xff;
					local_1b4 = local_1b4 & 0xffffff00 | (uint)bVar8;
				}
				if (bVar8 <= (byte)local_194) {
					uVar4 = local_1b4 & 0xff;
					iVar14 = ((local_194 & 0xff) - uVar4) + 1;
					do {
						bVar1 = (byte)uVar4;
						pbVar9 = (byte *)((int)local_180 + (uVar4 >> 3));
						uVar4 += 1;
						iVar14 += -1;
						*pbVar9 = *pbVar9 | '\x01' << (bVar1 & 7);
					} while (iVar14 != 0);
				}
				local_1b4 &= 0xffffff00;
			}
			else {
				local_1b4 = local_1b4 & 0xffffff00 | (uint)bVar1;
				pbVar9 = (byte *)((int)local_180 + (uint)(bVar1 >> 3));
				*pbVar9 = *pbVar9 | '\x01' << (bVar1 & 7);
			}
			pbVar9 = pbVar10;
			bVar1 = *pbVar10;
		}
		if (*pbVar9 == 0) goto LAB_00494e06;
		if (local_1bc == 0x7b) {
			format = (char *)pbVar9;
		}
		local_1cc = local_1cc + -1;
		internal::__vfscanf__00494f60((int)c,stream);
		ppcVar16 = ppcVar11;
		while( true ) {
			if ((local_1b0 != 0) &&
				 (iVar14 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar14, ppcVar3 = ppcVar16,
				 bVar18)) goto LAB_0049469c;
			local_1cc = local_1cc + 1;
			c = (int **)internal::__vfscanf__fgetc(stream);
			if ((c == (int **)0xffffffff) ||
				 (bVar1 = (byte)c,
				 ((int)(char)(*(byte *)((int)local_180 + ((int)c >> 3)) ^ local_1bd) & 1 << (bVar1 & 7)) ==
				 0)) break;
			if (local_1c5 == '\0') {
				if (local_1c0 == '\0') {
					*(byte *)ppcVar16 = bVar1;
					ppcVar16 = (va_list *)((int)ppcVar16 + 1);
				}
				else {
					local_19e = bVar1;
					if ((*(byte *)((int)globals::_pctype + ((uint)c & 0xff) * 2 + 1) & 0x80) != 0) {
						local_1cc = local_1cc + 1;
						iVar14 = internal::__vfscanf__fgetc(stream);
						local_19d = (undefined)iVar14;
					}
					internal::__vfscanf__004990c0(&local_18e,&local_19e,globals::_pcharwidth);
					*(ushort *)ppcVar16 = local_18e;
					ppcVar16 = (va_list *)((int)ppcVar16 + 2);
				}
			}
			else {
				ppcVar11 = (va_list *)((int)ppcVar11 + 1);
			}
		}
		local_1cc = local_1cc + -1;
		local_1b8 = ppcVar16;
		internal::__vfscanf__00494f60((int)c,stream);
		ppcVar3 = local_1b8;
LAB_0049469c:
		local_1b8 = ppcVar3;
		if (ppcVar11 == ppcVar16) goto LAB_00494e06;
		uVar19 = local_19c;
		if ((local_1c5 == '\0') && (local_1ac += 1, local_1bc != 99)) {
			if (local_1c0 == '\0') {
				*(undefined *)local_1b8 = 0;
			}
			else {
				*(undefined2 *)local_1b8 = 0;
			}
		}
LAB_00494d38:
		local_1bf += '\x01';
		pbVar9 = (byte *)(format + 1);
		local_19c = uVar19;
LAB_00494db3:
		format = (char *)pbVar9;
		if ((c == (int **)0xffffffff) && ((*format != '%' || (format[1] != 'n')))) goto LAB_00494e06;
		bVar1 = *format;
	} while( true );
}



int __cdecl std::tolower(int c)
{
	int iVar1;
	uint uVar2;
	LPCWSTR pWVar3;
	int iVar4;
	uint local_8 [2];
	
	iVar1 = c;
	if (globs::_crt1.DAT_0054a180 == 0) {
		if ((0x40 < c) && (c < 0x5b)) {
			return c + 0x20;
		}
	}
	else {
		if (c < 0x100) {
						// int std::isupper(int c)
			if (globals::_pcharwidth < 2) {
				uVar2 = *(byte *)(globals::_pctype + c) & C1_UPPER;
			}
			else {
				uVar2 = _isctype(c,C1_UPPER);
			}
			if (uVar2 == 0) {
				return iVar1;
			}
		}
		if ((*(byte *)((int)globals::_pctype + (iVar1 >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
			c = c & 0xffff0000U | iVar1 & 0xffU;
			pWVar3 = (LPCWSTR)0x1;
		}
		else {
			c = c & 0xff000000U | (uint)CONCAT11((char)iVar1,(char)((uint)iVar1 >> 8));
			pWVar3 = (LPCWSTR)0x2;
		}
		iVar4 = internal::__uprlwr__00493f60
											(globs::_crt1.DAT_0054a180,0x100,(char *)&c,pWVar3,(LPWSTR)local_8,3,0);
		if (iVar4 == 0) {
			return iVar1;
		}
		if (iVar4 == 1) {
			return local_8[0] & 0xff;
		}
		c = (local_8[0] >> 8 & 0xff) << 8 | local_8[0] & 0xff;
	}
	return c;
}



int __cdecl std::isspace(int c)
{
	uint uVar1;
	
	if (1 < globals::_pcharwidth) {
						// C1_SPACE (0x8)
		uVar1 = _isctype(c,C1_SPACE);
		return uVar1;
	}
						// C1_SPACE (0x8)
	return *(byte *)(globals::_pctype + c) & C1_SPACE;
}



HRESULT Direct3DRMCreate(IUnknown **lplpIDirect3DRM)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b970. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = Direct3DRMCreate(lplpIDirect3DRM);
	return HVar1;
}



Vector3F * D3DRMVectorRandom(Vector3F *d)
{
	Vector3F *pVVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b976. Too many branches
						// WARNING: Treating indirect jump as call
	pVVar1 = D3DRMVectorRandom(d);
	return pVVar1;
}



Vector3F * D3DRMVectorRotate(Vector3F *r,Vector3F *v,Vector3F *axis,float theta)
{
	Vector3F *pVVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b97c. Too many branches
						// WARNING: Treating indirect jump as call
	pVVar1 = D3DRMVectorRotate(r,v,axis,theta);
	return pVVar1;
}



HRESULT DirectDrawEnumerateA(DDENUMCALLBACKA *lpCallback,LPVOID lpContext)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b982. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = DirectDrawEnumerateA(lpCallback,lpContext);
	return HVar1;
}



HRESULT DirectDrawCreate(LPGUID lpGUID,IDirectDraw **lplpIDirectDraw,LPUNKNOWN pUnkOuter)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b988. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = DirectDrawCreate(lpGUID,lplpIDirectDraw,pUnkOuter);
	return HVar1;
}



HRESULT AVIStreamInfoA(IAVIStream *pIAVIStream,AVISTREAMINFOA *pAVIStreamInfoA,LONG lSize)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b98e. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = AVIStreamInfoA(pIAVIStream,pAVIStreamInfoA,lSize);
	return HVar1;
}



IGetFrame * AVIStreamGetFrameOpen(IAVIStream *pIAVIStream,BITMAPINFOHEADER *lpbiWanted)
{
	IGetFrame *pIVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b994. Too many branches
						// WARNING: Treating indirect jump as call
	pIVar1 = AVIStreamGetFrameOpen(pIAVIStream,lpbiWanted);
	return pIVar1;
}



HRESULT AVIStreamOpenFromFileA
									(IAVIStream **lplpIAVIStream,LPCSTR szFile,DWORD fccType,LONG lParam,UINT mode,
									CLSID *pclsidHandler)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b99a. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = AVIStreamOpenFromFileA(lplpIAVIStream,szFile,fccType,lParam,mode,pclsidHandler);
	return HVar1;
}



ULONG AVIStreamRelease(IAVIStream *pIAVIStream)
{
	ULONG UVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b9a0. Too many branches
						// WARNING: Treating indirect jump as call
	UVar1 = AVIStreamRelease(pIAVIStream);
	return UVar1;
}



LPVOID AVIStreamGetFrame(IGetFrame *pIGetFrame,LONG lPos)
{
	LPVOID pvVar1;
	
						// WARNING: Could not recover jumptable at 0x0049b9a6. Too many branches
						// WARNING: Treating indirect jump as call
	pvVar1 = AVIStreamGetFrame(pIGetFrame,lPos);
	return pvVar1;
}



void AVIFileInit(void)
{
						// WARNING: Could not recover jumptable at 0x0049b9ac. Too many branches
						// WARNING: Treating indirect jump as call
	AVIFileInit();
	return;
}



HRESULT DirectInputCreateA(HINSTANCE hInst,DWORD dwVersion,IUnknown **lplpIDirectInput,
													IUnknown *pUnkOuter)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049ca68. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = DirectInputCreateA(hInst,dwVersion,lplpIDirectInput,pUnkOuter);
	return HVar1;
}



HRESULT DirectSoundCreate(LPGUID lpGuid,IDirectSound **lplpIDirectSound,IUnknown *pUnkOuter)
{
	HRESULT HVar1;
	
						// WARNING: Could not recover jumptable at 0x0049ca6e. Too many branches
						// WARNING: Treating indirect jump as call
	HVar1 = DirectSoundCreate(lpGuid,lplpIDirectSound,pUnkOuter);
	return HVar1;
}



// RNC (Rob Northern Compression)
// https://moddingwiki.shikadi.net/wiki/Rob_Northern_Compression

uint __cdecl lego::rnc::RNC_Uncompress(void *bufferIn,void **out_bufferOut)
{
	RNCError result;
	byte *newBufferOut;
	uint origSize;
	uint beOrigSize;
	
	beOrigSize = *(uint *)((int)bufferIn + 4);
	origSize = ((beOrigSize & 0xff00) + beOrigSize * 0x10000) * 0x100 +
						 (beOrigSize >> 0x10 & 0xff) * 0x100 + (beOrigSize >> 0x18);
	if (out_bufferOut == NULL) {
		return origSize;
	}
	newBufferOut = (byte *)std::malloc(origSize);
	if (newBufferOut != NULL) {
		result = _RNC_Uncompress((RNC_HeaderInfo *)bufferIn,newBufferOut);
		if (result != RNC_OK) {
			std::free(newBufferOut);
			return 0;
		}
		*out_bufferOut = newBufferOut;
		return origSize;
	}
	return 0;
}



RNCError __cdecl lego::rnc::_RNC_Uncompress(RNC_HeaderInfo *bufferIn,byte *bufferOut)
{
	RNCError result;
	int cmp;
	uint origSize;
	undefined4 *puVar1;
	uint beOrigSize;
	RNCCompression compression;
	
	cmp = std::strncmp(bufferIn->signature,"RNC",3);
	if (cmp != 0) {
		return RNC_INVALIDFILE;
	}
	compression = bufferIn->compression;
	if (compression == RNC_COMPRESS_STORE) {
		beOrigSize = bufferIn->beOrigSize;
		origSize = (((beOrigSize >> 8 & 0xff) + beOrigSize * 0x100) * 0x100 +
							 (beOrigSize >> 0x10 & 0xff)) * 0x100 + (beOrigSize >> 0x18);
		puVar1 = (undefined4 *)bufferIn->data;
						// std::memcpy(bufferOut, bufferIn->data, origSize);
		for (beOrigSize = origSize >> 2; beOrigSize != 0; beOrigSize -= 1) {
			*(undefined4 *)bufferOut = *puVar1;
			puVar1 = puVar1 + 1;
			bufferOut = (byte *)((int)bufferOut + 4);
		}
		for (origSize &= 3; origSize != 0; origSize -= 1) {
			*bufferOut = *(undefined *)puVar1;
			puVar1 = (undefined4 *)((int)puVar1 + 1);
			bufferOut = (byte *)((int)bufferOut + 1);
		}
		return RNC_OK;
	}
	if (compression == RNC_COMPRESS_BEST) {
		result = RNC_M1_Uncompress(bufferIn,bufferOut);
		return result;
	}
	if (compression != RNC_COMPRESS_FAST) {
		return RNC_INVALIDCOMPRESSION;
	}
	result = RNC_M2_Uncompress(bufferIn,bufferOut);
	return result;
}



RNCError __cdecl lego::rnc::RNC_M1_Uncompress(RNC_HeaderInfo *bufferIn,byte *bufferOut)
{
	ushort runDataLength;
	ushort prevRunOffset;
	ushort runCopyLength;
	uint runCount;
	int i1;
	int i2;
	byte *prevOutput;
	
	RNC_BitStreamInit(bufferIn,bufferOut);
	RNC_M1_BitStreamAdvance(2);
	if (globs::rncGlobs.Output < globs::rncGlobs.OutputEnd) {
		do {
			RNC_M1_ReadHuffmanTable(globs::rncGlobs.HuffmanTable_Raw,0x10);
			RNC_M1_ReadHuffmanTable(globs::rncGlobs.HuffmanTable_Dst,0x10);
			RNC_M1_ReadHuffmanTable(globs::rncGlobs.HuffmanTable_Len,0x10);
			runCount = RNC_M1_BitStreamAdvance(0x10);
						// DECOMPILE FAIL: while (runCount)
						//  otherwise we end up reading a dataRun when there should be no more data!!!!!
			while( true ) {
						// DATA RUN
				runDataLength = RNC_M1_ReadHuffman(globs::rncGlobs.HuffmanTable_Raw);
				if (runDataLength != 0) {
					i1 = (ushort)(runDataLength - 1) + 1;
					do {
						*globs::rncGlobs.Output = *globs::rncGlobs.Input;
						globs::rncGlobs.Output = globs::rncGlobs.Output + 1;
						globs::rncGlobs.Input = globs::rncGlobs.Input + 1;
						i1 += -1;
					} while (i1 != 0);
				}
						// runCount--; // ushort
				runCount += 0xffff;
				globs::rncGlobs.BitBuffer =
						 (((uint)globs::rncGlobs.Input[1] + (uint)globs::rncGlobs.Input[2] * 0x100) * 0x100 +
							(uint)*globs::rncGlobs.Input << (globs::rncGlobs.BitCount & 0x1f)) +
						 ((1 << (globs::rncGlobs.BitCount & 0x1f)) - 1U & globs::rncGlobs.BitBuffer);
				if ((short)runCount == 0) break;
						// COPY RUN
				prevRunOffset = RNC_M1_ReadHuffman(globs::rncGlobs.HuffmanTable_Dst);
				prevOutput = globs::rncGlobs.Output + (-1 - (uint)prevRunOffset);
				runCopyLength = RNC_M1_ReadHuffman(globs::rncGlobs.HuffmanTable_Len);
				if (runCopyLength != 0xfffe) {
					i2 = (ushort)(runCopyLength + 1) + 1;
					do {
						*globs::rncGlobs.Output = *prevOutput;
						globs::rncGlobs.Output = globs::rncGlobs.Output + 1;
						prevOutput = prevOutput + 1;
						i2 += -1;
					} while (i2 != 0);
				}
			}
		} while (globs::rncGlobs.Output < globs::rncGlobs.OutputEnd);
	}
	return RNC_OK;
}



RNCError __cdecl lego::rnc::RNC_M2_Uncompress(RNC_HeaderInfo *bufferIn,byte *bufferOut)
{
	short sVar1;
	ushort uVar2;
	ushort uVar3;
	uint uVar4;
	byte *pbVar5;
	int iVar6;
	
	RNC_BitStreamInit(bufferIn,bufferOut);
	RNC_M2_BitStreamAdvance(2);
	if (globs::rncGlobs.Output < globs::rncGlobs.OutputEnd) {
		do {
			while( true ) {
				while( true ) {
					uVar4 = RNC_M2_BitStreamAdvance(1);
					sVar1 = (short)uVar4;
					while (sVar1 == 0) {
						*globs::rncGlobs.Output = *globs::rncGlobs.Input;
						globs::rncGlobs.Output = globs::rncGlobs.Output + 1;
						globs::rncGlobs.Input = globs::rncGlobs.Input + 1;
						uVar4 = RNC_M2_BitStreamAdvance(1);
						sVar1 = (short)uVar4;
					}
					uVar4 = RNC_M2_BitStreamAdvance(1);
					if ((short)uVar4 != 0) break;
					uVar2 = RNC_M2_ReadLengthCode();
					if (uVar2 == 9) {
						uVar4 = RNC_M2_BitStreamAdvance(4);
						if ((short)(uVar4 * 4) != -0xc) {
							iVar6 = (uVar4 * 4 + 0x1000b & 0xffff) + 1;
							do {
								*globs::rncGlobs.Output = *globs::rncGlobs.Input;
								globs::rncGlobs.Output = globs::rncGlobs.Output + 1;
								globs::rncGlobs.Input = globs::rncGlobs.Input + 1;
								iVar6 += -1;
							} while (iVar6 != 0);
						}
					}
					else {
						uVar3 = RNC_M2_ReadOffsetCode();
						pbVar5 = globs::rncGlobs.Output + -(uint)uVar3;
						if (uVar2 != 0) {
							iVar6 = (ushort)(uVar2 - 1) + 1;
							do {
								*globs::rncGlobs.Output = *pbVar5;
								globs::rncGlobs.Output = globs::rncGlobs.Output + 1;
								pbVar5 = pbVar5 + 1;
								iVar6 += -1;
							} while (iVar6 != 0);
						}
					}
				}
				uVar4 = RNC_M2_BitStreamAdvance(1);
				if ((short)uVar4 != 0) break;
				sVar1 = 2;
				uVar4 = *globs::rncGlobs.Input + 1;
				globs::rncGlobs.Input = globs::rncGlobs.Input + 1;
LAB_0049ce07:
				pbVar5 = globs::rncGlobs.Output + -uVar4;
				if (sVar1 != 0) {
					iVar6 = (ushort)(sVar1 - 1) + 1;
					do {
						*globs::rncGlobs.Output = *pbVar5;
						globs::rncGlobs.Output = globs::rncGlobs.Output + 1;
						pbVar5 = pbVar5 + 1;
						iVar6 += -1;
					} while (iVar6 != 0);
				}
			}
			uVar4 = RNC_M2_BitStreamAdvance(1);
			if ((short)uVar4 == 0) {
				sVar1 = 3;
LAB_0049ce02:
				uVar2 = RNC_M2_ReadOffsetCode();
				uVar4 = (uint)uVar2;
				goto LAB_0049ce07;
			}
			sVar1 = *globs::rncGlobs.Input + 8;
			globs::rncGlobs.Input = globs::rncGlobs.Input + 1;
			if (sVar1 != 8) goto LAB_0049ce02;
			RNC_M2_BitStreamAdvance(1);
		} while (globs::rncGlobs.Output < globs::rncGlobs.OutputEnd);
	}
	return RNC_OK;
}



void __cdecl lego::rnc::RNC_BitStreamInit(RNC_HeaderInfo *bufferIn,byte *bufferOut)
{
	uint beOrigSize;
	
	beOrigSize = bufferIn->beOrigSize;
	globs::rncGlobs.BitCount = 0;
	globs::rncGlobs.Input = bufferIn->data;
	globs::rncGlobs.Output = bufferOut;
	globs::rncGlobs.OutputEnd =
			 bufferOut +
			 (beOrigSize >> 0x18) +
			 (((beOrigSize >> 8 & 0xff) + beOrigSize * 0x100) * 0x100 + (beOrigSize >> 0x10 & 0xff)) *
			 0x100;
	return;
}



uint __cdecl lego::rnc::RNC_M1_BitStreamAdvance(byte bits)
{
	uint result;
	int k;
	uint *ptr;
	uint bitmask;
	
	result = 0;
	bitmask = 1;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		k = _bits + 1;
		ptr = (uint *)globs::rncGlobs.Input;
		do {
			if (globs::rncGlobs.BitCount == 0) {
				globs::rncGlobs.BitBuffer = *ptr;
				ptr = (uint *)((int)ptr + 2);
				globs::rncGlobs.BitCount = 0x10;
				globs::rncGlobs.Input = (byte *)ptr;
			}
			if ((globs::rncGlobs.BitBuffer & 1) != 0) {
				result |= bitmask;
			}
			bitmask <<= 1;
			globs::rncGlobs.BitBuffer >>= 1;
			globs::rncGlobs.BitCount -= 1;
			k += -1;
		} while (k != 0);
	}
	return result;
}



uint __cdecl lego::rnc::RNC_M2_BitStreamAdvance(byte bits)
{
	uint result;
	byte *ptr;
	int k;
	
	result = 0;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		k = _bits + 1;
		ptr = globs::rncGlobs.Input;
		do {
			if (globs::rncGlobs.BitCount == 0) {
				globs::rncGlobs.ByteBuffer = *ptr;
				ptr = ptr + 1;
				globs::rncGlobs.BitCount = 8;
				globs::rncGlobs.Input = ptr;
			}
			result *= 2;
			if ((globs::rncGlobs.ByteBuffer & 0x80) != 0) {
				result += 1;
			}
			globs::rncGlobs.ByteBuffer <<= 1;
			globs::rncGlobs.BitCount -= 1;
			k += -1;
		} while (k != 0);
	}
	return result;
}



void __cdecl lego::rnc::RNC_M1_ReadHuffmanTable(HuffmanLeaf *table,byte bits)
{
	byte bits2;
	uint uVar1;
	ushort *pCount_2;
	uint k;
	
	RNC_M1_HuffmanReset(table,bits);
	uVar1 = RNC_M1_BitStreamAdvance(5);
	bits2 = (byte)uVar1;
	if (bits2 != 0) {
		if (0x10 < bits2) {
			bits2 = 0x10;
		}
		if (bits2 != 0) {
			pCount_2 = &table->count_2;
			k = (uint)bits2;
			do {
				uVar1 = RNC_M1_BitStreamAdvance(4);
				*pCount_2 = (ushort)uVar1;
				pCount_2 = pCount_2 + 8;
				k -= 1;
			} while (k != 0);
		}
		RNC_M1_HuffmanAssignValues(table,bits2);
	}
	return;
}



ushort __cdecl lego::rnc::RNC_M1_ReadHuffman(HuffmanLeaf *table)
{
	uint uVar1;
	byte k;
	
	k = 0;
	for (; (table->count_2 == 0 ||
				 (((1 << ((byte)table->count_2 & 0x1f)) - 1U & globs::rncGlobs.BitBuffer) != table->value_2)
				 ); table = table + 1) {
		k += 1;
	}
	RNC_M1_BitStreamAdvance(*(byte *)&table->count_2);
	if (k < 2) {
		return (ushort)k;
	}
	uVar1 = RNC_M1_BitStreamAdvance(k - 1);
	return (ushort)uVar1 | (ushort)(1 << (k - 1 & 0x1f));
}



ushort __cdecl lego::rnc::RNC_M2_ReadLengthCode(void)
{
	ushort uVar1;
	uint uVar2;
	
	uVar2 = RNC_M2_BitStreamAdvance(1);
	uVar1 = (short)uVar2 + 4;
	uVar2 = RNC_M2_BitStreamAdvance(1);
	if ((short)uVar2 == 0) {
		return uVar1;
	}
	uVar2 = RNC_M2_BitStreamAdvance(1);
	return (short)uVar2 + -2 + uVar1 * 2;
}



ushort __cdecl lego::rnc::RNC_M2_ReadOffsetCode(void)
{
	byte bVar1;
	ushort uVar2;
	uint uVar3;
	
	uVar2 = 0;
	uVar3 = RNC_M2_BitStreamAdvance(1);
	if ((short)uVar3 != 0) {
		uVar3 = RNC_M2_BitStreamAdvance(1);
		uVar2 = (ushort)uVar3;
		uVar3 = RNC_M2_BitStreamAdvance(1);
		if ((short)uVar3 == 0) {
			if (uVar2 == 0) {
				uVar3 = RNC_M2_BitStreamAdvance(1);
				uVar2 = (short)uVar3 + 2;
			}
		}
		else {
			uVar3 = RNC_M2_BitStreamAdvance(1);
			uVar2 = (short)uVar3 + uVar2 * 2 | 4;
			uVar3 = RNC_M2_BitStreamAdvance(1);
			if ((short)uVar3 == 0) {
				uVar3 = RNC_M2_BitStreamAdvance(1);
				uVar2 = (short)uVar3 + uVar2 * 2;
			}
		}
	}
	bVar1 = *globs::rncGlobs.Input;
	globs::rncGlobs.Input = globs::rncGlobs.Input + 1;
	return uVar2 * 0x100 + 1 + (ushort)bVar1;
}



void __cdecl lego::rnc::RNC_M1_HuffmanReset(HuffmanLeaf *table,byte bits)
{
	int k;
	
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		k = _bits + 1;
		do {
			table->value_1 = 0;
			table->count_1 = 0xffff;
			table->value_2 = 0;
			table->count_2 = 0;
			table = table + 1;
			k += -1;
		} while (k != 0);
	}
	return;
}



void __cdecl lego::rnc::RNC_M1_HuffmanAssignValues(HuffmanLeaf *table,byte bits)
{
	uint uVar1;
	ushort k;
	uint bitmask;
	uint *pValue_2;
	uint i;
	uint value;
	
	k = 1;
	value = 0;
	bitmask = 0x80000000;
	do {
		i = (uint)bits;
		if (bits != 0) {
			pValue_2 = &table->value_2;
			do {
				if (*(ushort *)(pValue_2 + 1) == k) {
					uVar1 = RNC_M1_MirrorBits(value / bitmask,(byte)k);
					*pValue_2 = uVar1;
					value += bitmask;
				}
				pValue_2 = pValue_2 + 4;
				i -= 1;
			} while (i != 0);
		}
		k += 1;
		bitmask >>= 1;
	} while (k < 17);
	return;
}



uint __cdecl lego::rnc::RNC_M1_MirrorBits(uint value,byte bits)
{
	uint result;
	int k;
	
	result = 0;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		k = _bits + 1;
		do {
			result <<= 1;
			if ((value & 1) != 0) {
				result |= 1;
			}
			value >>= 1;
			k += -1;
		} while (k != 0);
	}
	return result;
}



// (ChooseScreenMode)

BOOL __cdecl
lego::setup::Init_Initialise(BOOL setup,BOOL debug,BOOL best,BOOL window,char *noHALMsg)
{
	bool bVar1;
	BOOL BVar2;
	DirectDraw_DeviceFlags *pDVar3;
	int iVar4;
	int iVar5;
	uint modeIndex;
	DirectDraw_Driver *driver;
	INT_PTR local_4;
	
	local_4 = 1;
	globs::initGlobs.selDriver = NULL;
	globs::initGlobs.selDevice = NULL;
	globs::initGlobs.selMode = NULL;
	globs::initGlobs.wasFullScreen = 1;
	globs::initGlobs.selFullScreen = 1;
	globs::initGlobs.validModeCount = 0;
	Init_AddValidMode(640,480,0x10);
	if (debug != 0) {
		Init_AddValidMode(800,600,0x10);
		Init_AddValidMode(1024,768,0x10);
	}
	ddraw::DirectDraw_EnumDrivers(globs::initGlobs.drivers,&globs::initGlobs.driverCount);
	if (globs::initGlobs.driverCount != 0) {
		globs::initGlobs.selDriver = globs::initGlobs.drivers;
		if (best == 0) {
			if (setup != 0) {
				local_4 = DialogBoxParamA(globs::mainGlobs.hInst,(LPCSTR)LEGORR_MODESELECTION_DIALOG,
																	globs::mainGlobs.hWnd,Init_DialogProc,0);
			}
		}
		else {
			bVar1 = false;
			iVar5 = globs::initGlobs.driverCount - 1;
			local_4 = 1;
			globs::initGlobs.selFullScreen = ZEXT14(window == 0);
			if (-1 < iVar5) {
				driver = (DirectDraw_Driver *)((int)&globs::initGlobs + iVar5 * 0x114 + 0xc);
LAB_0049d3d2:
				BVar2 = ddraw::DirectDraw_EnumDevices
													(driver,globs::initGlobs.devices,&globs::initGlobs.deviceCount);
				if (BVar2 == 0) {
					MessageBoxA(NULL,"Please install DirectX version 6 or later","Error",0);
					return 0;
				}
				ddraw::DirectDraw_EnumModes
									(driver,globs::initGlobs.selFullScreen,globs::initGlobs.modes,
									 &globs::initGlobs.modeCount);
				modeIndex = 0;
				if (globs::initGlobs.modeCount != 0) {
					do {
						BVar2 = Init_IsValidMode(modeIndex);
						if (BVar2 != 0) {
							iVar4 = globs::initGlobs.deviceCount - 1;
							if (-1 < iVar4) {
								pDVar3 = &globs::initGlobs.devices[globs::initGlobs.deviceCount - 1].flags;
								goto LAB_0049d447;
							}
							break;
						}
						modeIndex += 1;
					} while (modeIndex < globs::initGlobs.modeCount);
				}
				goto LAB_0049d48f;
			}
LAB_0049d4a8:
			if (!bVar1) {
				MessageBoxA(NULL,noHALMsg,"Error",0);
				return 0;
			}
		}
		if (local_4 == 1) {
			if (globs::initGlobs.selFullScreen != 0) {
				BVar2 = ddraw::DirectDraw_Setup
													(1,globs::initGlobs.selDriver,globs::initGlobs.selDevice,
													 globs::initGlobs.selMode,0,0,320,200);
				return BVar2;
			}
			if (globs::initGlobs.selMode == NULL) {
				BVar2 = ddraw::DirectDraw_Setup(0,NULL,globs::initGlobs.selDevice,NULL,40,40,640,480);
				return BVar2;
			}
			BVar2 = ddraw::DirectDraw_Setup
												(0,NULL,globs::initGlobs.selDevice,NULL,100,100,
												 (globs::initGlobs.selMode)->width,(globs::initGlobs.selMode)->height);
			return BVar2;
		}
	}
	return 0;
	while( true ) {
		iVar4 += -1;
		pDVar3 = pDVar3 + -0x45;
		if (iVar4 < 0) break;
LAB_0049d447:
		if ((*pDVar3 & DIRECTDRAW_FLAG_DEVICE_HARDWARE) != DIRECTDRAW_FLAG_DEVICE_NONE) {
			globs::initGlobs.selMode = globs::initGlobs.modes + modeIndex;
			bVar1 = true;
			globs::initGlobs.selDevice = globs::initGlobs.devices + iVar4;
			globs::initGlobs.selDriver = driver;
			break;
		}
	}
LAB_0049d48f:
	if (bVar1) goto LAB_0049d4a8;
	iVar5 += -1;
	driver = driver + -1;
	if (iVar5 < 0) goto LAB_0049d4a8;
	goto LAB_0049d3d2;
}



INT_PTR lego::setup::Init_DialogProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
	short sVar1;
	HWND pHVar2;
	LRESULT LVar3;
	WPARAM wParam2;
	BOOL BVar4;
	short sVar5;
	uint uVar6;
	int iVar7;
	uint outIndex;
	tagRECT dlgRect;
	tagRECT desktopRect;
	char screenModeText [1024];
	
	if (message == WM_INITDIALOG) {
		pHVar2 = GetDesktopWindow();
		GetWindowRect(pHVar2,(LPRECT)&desktopRect);
		GetWindowRect(hDlg,(LPRECT)&dlgRect);
		MoveWindow(hDlg,desktopRect.right / 2 - (dlgRect.right - dlgRect.left) / 2,
							 desktopRect.bottom / 2 - (dlgRect.bottom - dlgRect.top) / 2,
							 dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,1);
		if (globs::initGlobs.selFullScreen == 0) {
			iVar7 = LEGORR_ID_WINDOW_RADIOBUTTON;
		}
		else {
			iVar7 = LEGORR_ID_FULLSCREEN_RADIOBUTTON;
		}
		pHVar2 = GetDlgItem(hDlg,iVar7);
		SendMessageA(pHVar2,BM_SETCHECK,BST_CHECKED,0);
		pHVar2 = GetDlgItem(hDlg,LEGORR_ID_DRIVER_LISTBOX);
		uVar6 = 0;
		if (globs::initGlobs.driverCount != 0) {
			iVar7 = 0x5590bc;
			do {
				SendMessageA(pHVar2,LB_ADDSTRING,0,iVar7);
				uVar6 += 1;
				iVar7 += 0x114;
			} while (uVar6 < globs::initGlobs.driverCount);
		}
		SendMessageA(pHVar2,LB_SETCURSEL,0,0);
		SetFocus(pHVar2);
		Init_HandleWindowButton(hDlg);
		Init_SetDeviceList(hDlg);
		Init_SetModeList(hDlg);
		return 0;
	}
	if (message != WM_COMMAND) {
		return 0;
	}
	sVar1 = (short)(wParam >> 0x10);
	sVar5 = (short)wParam;
	if (sVar1 == 1) {
		if (sVar5 == LEGORR_ID_DEVICE_LISTBOX) {
			LVar3 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
			globs::initGlobs.selDevice = globs::initGlobs.devices + LVar3;
			return 1;
		}
		if (sVar5 == LEGORR_ID_SCREENMODES_LISTBOX) {
			wParam2 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
			SendMessageA((HWND)lParam,LB_GETTEXT,wParam2,(LPARAM)screenModeText);
			BVar4 = Init_GetMode(screenModeText,&outIndex);
			if (BVar4 != 0) {
				globs::initGlobs.selMode = globs::initGlobs.modes + outIndex;
				return 1;
			}
		}
		else {
			if (sVar5 == LEGORR_ID_DRIVER_LISTBOX) {
				LVar3 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
				globs::initGlobs.selDriver = globs::initGlobs.drivers + LVar3;
				Init_HandleWindowButton(hDlg);
				Init_SetModeList(hDlg);
				Init_SetDeviceList(hDlg);
				return 1;
			}
		}
	}
	else {
		if (sVar1 == 0) {
			if (sVar5 == LEGORR_ID_WINDOW_RADIOBUTTON) {
				Init_SetFullScreen(hDlg,0);
			}
			if (sVar5 == LEGORR_ID_FULLSCREEN_RADIOBUTTON) {
				Init_SetFullScreen(hDlg,1);
				return 1;
			}
			if ((sVar5 == IDOK) || (sVar5 == IDCANCEL)) {
				EndDialog(hDlg,wParam);
			}
		}
	}
	return 1;
}



void __cdecl lego::setup::Init_SetFullScreen(HWND hDlg,BOOL on)
{
	HWND hWnd;
	
	globs::initGlobs.selFullScreen = on;
	Init_SetModeList(hDlg);
	hWnd = GetDlgItem(hDlg,LEGORR_ID_SCREENMODES_LABEL);
	if (on != 0) {
		SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)"Screen Mode");
		return;
	}
	SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)"Window Size");
	return;
}



void __cdecl lego::setup::Init_SetModeList(HWND hDlg)
{
	bool bVar1;
	HWND hCtrl_Screens;
	int iVar2;
	BOOL BVar3;
	HWND hCtrl_OK;
	DirectDraw_Mode *pDVar4;
	uint local_104;
	char unsupportedMessage [256];
	
	bVar1 = true;
	hCtrl_Screens = GetDlgItem(hDlg,LEGORR_ID_SCREENMODES_LISTBOX);
	iVar2 = SendMessageA(hCtrl_Screens,LB_DELETESTRING,0,0);
	while (iVar2 != -1) {
		iVar2 = SendMessageA(hCtrl_Screens,LB_DELETESTRING,0,0);
	}
	ddraw::DirectDraw_EnumModes
						(globs::initGlobs.selDriver,globs::initGlobs.selFullScreen,globs::initGlobs.modes,
						 &globs::initGlobs.modeCount);
	local_104 = 0;
	if (globs::initGlobs.modeCount != 0) {
		pDVar4 = globs::initGlobs.modes;
		do {
			BVar3 = Init_IsValidMode(local_104);
			if ((BVar3 != 0) && (SendMessageA(hCtrl_Screens,LB_ADDSTRING,0,(LPARAM)pDVar4->desc), bVar1))
			{
				bVar1 = false;
				globs::initGlobs.selMode = pDVar4;
			}
			local_104 += 1;
			pDVar4 = pDVar4 + 1;
		} while (local_104 < globs::initGlobs.modeCount);
	}
	hCtrl_OK = GetDlgItem(hDlg,IDOK);
	if (bVar1) {
		if (globs::initGlobs.selFullScreen == 0) {
			iVar2 = main::Main_GetWindowsBitDepth();
			std::sprintf(unsupportedMessage,"No supported %i bit modes found",iVar2);
		}
		else {
			std::sprintf(unsupportedMessage,"No supported screen modes found");
		}
		SendMessageA(hCtrl_Screens,LB_ADDSTRING,0,(LPARAM)unsupportedMessage);
		BVar3 = 0;
	}
	else {
		BVar3 = 1;
	}
	EnableWindow(hCtrl_OK,BVar3);
	SendMessageA(hCtrl_Screens,LB_SETCURSEL,0,0);
	return;
}



void __cdecl lego::setup::Init_SetDeviceList(HWND hDlg)
{
	HWND hWnd;
	int iVar1;
	BOOL BVar2;
	WPARAM wParam;
	WPARAM WVar3;
	WPARAM local_4;
	
	local_4 = 0;
	hWnd = GetDlgItem(hDlg,LEGORR_ID_DEVICE_LISTBOX);
	iVar1 = SendMessageA(hWnd,LB_DELETESTRING,0,0);
	while (iVar1 != -1) {
		iVar1 = SendMessageA(hWnd,LB_DELETESTRING,0,0);
	}
	BVar2 = ddraw::DirectDraw_EnumDevices
										(globs::initGlobs.selDriver,globs::initGlobs.devices,
										 &globs::initGlobs.deviceCount);
	if (BVar2 != 0) {
		WVar3 = 0;
		wParam = 0;
		if (globs::initGlobs.deviceCount != 0) {
			iVar1 = 0x55a64c;
			do {
				if ((*(uint *)(iVar1 + 0x100) & 0x2000) != 0) {
					local_4 = WVar3;
				}
				SendMessageA(hWnd,LB_ADDSTRING,0,iVar1);
				WVar3 += 1;
				iVar1 += 0x114;
				wParam = local_4;
			} while (WVar3 < globs::initGlobs.deviceCount);
		}
		globs::initGlobs.selDevice = globs::initGlobs.devices + wParam;
		SendMessageA(hWnd,LB_SETCURSEL,wParam,0);
		return;
	}
	SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)"Error: DirectX6 not installed.");
	SendMessageA(hWnd,LB_SETCURSEL,0,0);
	return;
}



void __cdecl lego::setup::Init_AddValidMode(uint width,uint height,uint depth)
{
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].width = width;
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].height = height;
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].bitDepth = depth;
	globs::initGlobs.validModeCount = globs::initGlobs.validModeCount + 1;
	return;
}



BOOL __cdecl lego::setup::Init_IsValidMode(uint modeIndex)
{
	uint *puVar1;
	uint uVar2;
	
	if (globs::initGlobs.validModeCount == 0) {
		return 1;
	}
	uVar2 = 0;
	if (globs::initGlobs.validModeCount != 0) {
		puVar1 = &globs::initGlobs.validModes[0].height;
		do {
			if (((puVar1[-1] == 0) || (puVar1[-1] == globs::initGlobs.modes[modeIndex].width)) &&
				 ((*puVar1 == 0 || (*puVar1 == globs::initGlobs.modes[modeIndex].height)))) {
				if (puVar1[1] == 0) {
					return 1;
				}
				if (puVar1[1] == globs::initGlobs.modes[modeIndex].bitDepth) {
					return 1;
				}
			}
			uVar2 += 1;
			puVar1 = puVar1 + 0x44;
		} while (uVar2 < globs::initGlobs.validModeCount);
	}
	return 0;
}



BOOL __cdecl lego::setup::Init_GetMode(char *name,uint *out_modeIndex)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	byte *pbVar6;
	bool bVar7;
	
	uVar4 = 0;
	if (globs::initGlobs.modeCount == 0) {
		return 0;
	}
	pbVar2 = (byte *)globs::initGlobs.modes[0].desc;
	pbVar5 = (byte *)name;
	pbVar6 = pbVar2;
LAB_0049dc2b:
	do {
		bVar1 = *pbVar2;
		bVar7 = bVar1 < *pbVar5;
		if (bVar1 == *pbVar5) {
			if (bVar1 != 0) {
				bVar1 = pbVar2[1];
				bVar7 = bVar1 < pbVar5[1];
				if (bVar1 != pbVar5[1]) goto LAB_0049dc4f;
				pbVar2 = pbVar2 + 2;
				pbVar5 = pbVar5 + 2;
				if (bVar1 != 0) goto LAB_0049dc2b;
			}
			iVar3 = 0;
		}
		else {
LAB_0049dc4f:
			iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
		}
		if (iVar3 == 0) {
			*out_modeIndex = uVar4;
			return 1;
		}
		uVar4 += 1;
		pbVar2 = pbVar6 + 0x110;
		pbVar5 = (byte *)name;
		pbVar6 = pbVar2;
		if (globs::initGlobs.modeCount <= uVar4) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::setup::Init_HandleWindowButton(HWND hDlg)
{
	HWND pHVar1;
	
	if ((*(byte *)&(globs::initGlobs.selDriver)->flags & DIRECTDRAW_FLAG_DRIVER_WINDOWOK) == 0) {
		globs::initGlobs.wasFullScreen = globs::initGlobs.selFullScreen;
		Init_SetFullScreen(hDlg,1);
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
		SendMessageA(pHVar1,BM_SETCHECK,0,0);
		EnableWindow(pHVar1,0);
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_FULLSCREEN_RADIOBUTTON);
		SendMessageA(pHVar1,BM_SETCHECK,1,0);
	}
	else {
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
		EnableWindow(pHVar1,1);
		if (globs::initGlobs.wasFullScreen == 0) {
			Init_SetFullScreen(hDlg,0);
			pHVar1 = GetDlgItem(hDlg,LEGORR_ID_FULLSCREEN_RADIOBUTTON);
			SendMessageA(pHVar1,BM_SETCHECK,0,0);
			pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
			SendMessageA(pHVar1,BM_SETCHECK,1,0);
			return;
		}
	}
	return;
}



// Library Function - Single Match
// Name: __strnicmp
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
	byte bVar1;
	byte bVar2;
	uint c;
	uint c_00;
	bool bVar3;
	
	if (_MaxCount != 0) {
		if (globs::_crt1.DAT_0054a180 == 0) {
			do {
				bVar2 = *_Str1;
				bVar1 = *_Str2;
				if ((bVar2 == 0) || (bVar1 == 0)) break;
				_Str1 = (char *)((byte *)_Str1 + 1);
				_Str2 = (char *)((byte *)_Str2 + 1);
				if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
					bVar2 += 0x20;
				}
				if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
					bVar1 += 0x20;
				}
				bVar3 = bVar2 < bVar1;
				if (bVar2 != bVar1) goto LAB_0049ddcb;
				_MaxCount -= 1;
			} while (_MaxCount != 0);
			_MaxCount = 0;
			bVar3 = bVar2 < bVar1;
			if (bVar2 != bVar1) {
LAB_0049ddcb:
				_MaxCount = 0xffffffff;
				if (!bVar3) {
					_MaxCount = 1;
				}
			}
		}
		else {
			c_00 = 0;
			c = 0;
			do {
				c = c & 0xffffff00 | (uint)(byte)*_Str1;
				c_00 = c_00 & 0xffffff00 | (uint)(byte)*_Str2;
				if ((c == 0) || (c_00 == 0)) break;
				_Str1 = (char *)((byte *)_Str1 + 1);
				_Str2 = (char *)((byte *)_Str2 + 1);
				c_00 = tolower(c_00);
				c = tolower(c);
				bVar3 = c < c_00;
				if (c != c_00) goto LAB_0049de0d;
				_MaxCount -= 1;
			} while (_MaxCount != 0);
			_MaxCount = 0;
			bVar3 = c < c_00;
			if (c != c_00) {
LAB_0049de0d:
				_MaxCount = 0xffffffff;
				if (!bVar3) {
					_MaxCount = 1;
				}
			}
		}
	}
	return _MaxCount;
}



char * __cdecl std::itoa(int value,char *buffer,int radix)
{
	if ((radix == 10) && (value < 0)) {
		internal::__itoa__internal(value,buffer,10,1);
		return buffer;
	}
	internal::__itoa__internal(value,buffer,radix,0);
	return buffer;
}



char * __cdecl std::_strlwr(char *str)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	LPWSTR buffer;
	undefined4 *puVar7;
	LPWSTR pWVar8;
	LPWSTR pWVar9;
	undefined4 *puVar10;
	
	buffer = NULL;
	if (globs::_crt1.DAT_0054a180 == 0) {
		pcVar3 = str;
		if (*str != '\0') {
			do {
				cVar2 = *str;
				if (('@' < cVar2) && (cVar2 < '[')) {
					*str = cVar2 + ' ';
				}
				pcVar1 = str + 1;
				str = str + 1;
			} while (*pcVar1 != '\0');
			return pcVar3;
		}
	}
	else {
		uVar4 = internal::__uprlwr__00493f60
											(globs::_crt1.DAT_0054a180,0x100,str,(LPCWSTR)0xffffffff,NULL,0,0);
		if (((uVar4 != 0) && (buffer = (LPWSTR)malloc(uVar4), buffer != NULL)) &&
			 (iVar5 = internal::__uprlwr__00493f60
													(globs::_crt1.DAT_0054a180,0x100,str,(LPCWSTR)0xffffffff,buffer,uVar4,0),
			 iVar5 != 0)) {
			uVar4 = 0xffffffff;
			pWVar8 = buffer;
			do {
				pWVar9 = pWVar8;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pWVar9 = (LPWSTR)((int)pWVar8 + 1);
				cVar2 = *(char *)pWVar8;
				pWVar8 = pWVar9;
			} while (cVar2 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)((int)pWVar9 - uVar4);
			puVar10 = (undefined4 *)str;
			for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
		}
		free(buffer);
	}
	return str;
}



char * __cdecl std::_strupr(char *str)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	LPWSTR buffer;
	undefined4 *puVar7;
	LPWSTR pWVar8;
	LPWSTR pWVar9;
	undefined4 *puVar10;
	
	buffer = NULL;
	if (globs::_crt1.DAT_0054a180 == 0) {
		pcVar3 = str;
		if (*str != '\0') {
			do {
				cVar2 = *str;
				if (('`' < cVar2) && (cVar2 < '{')) {
					*str = cVar2 + -0x20;
				}
				pcVar1 = str + 1;
				str = str + 1;
			} while (*pcVar1 != '\0');
			return pcVar3;
		}
	}
	else {
		uVar4 = internal::__uprlwr__00493f60
											(globs::_crt1.DAT_0054a180,0x200,str,(LPCWSTR)0xffffffff,NULL,0,0);
		if (((uVar4 != 0) && (buffer = (LPWSTR)malloc(uVar4), buffer != NULL)) &&
			 (iVar5 = internal::__uprlwr__00493f60
													(globs::_crt1.DAT_0054a180,0x200,str,(LPCWSTR)0xffffffff,buffer,uVar4,0),
			 iVar5 != 0)) {
			uVar4 = 0xffffffff;
			pWVar8 = buffer;
			do {
				pWVar9 = pWVar8;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pWVar9 = (LPWSTR)((int)pWVar8 + 1);
				cVar2 = *(char *)pWVar8;
				pWVar8 = pWVar9;
			} while (cVar2 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)((int)pWVar9 - uVar4);
			puVar10 = (undefined4 *)str;
			for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
		}
		free(buffer);
	}
	return str;
}


